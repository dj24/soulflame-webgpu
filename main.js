(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};e.d({},{nS:()=>v,JQ:()=>d,sL:()=>p,Uh:()=>u,ZU:()=>m});const t=(e,t)=>{const r=new Uint32Array(t);u.queue.writeBuffer(e,0,r.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},r=(e,r)=>{const n=new Uint32Array(e),i=u.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:r});return t(i,e),i},n=(e,t)=>{const r=new Float32Array(e),n=u.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return((e,t)=>{const r=new Float32Array(t);u.queue.writeBuffer(e,0,r.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)})(n,e),n};class i{x;y;constructor(e,t){this.x=e,this.y=t}get uniformBuffer(){return r([this.x,this.y])}static zero=new i(0,0);static one=new i(1,1);static up=new i(0,1);static down=new i(0,-1);static left=new i(-1,0);static right=new i(1,1);toArray(){return[this.x,this.y]}mul(e){if(e instanceof i)return new i(this.x*e.x,this.y*e.y);if("number"==typeof e)return new i(this.x*e,this.y*e);throw new Error("Can only multiply Vector2 by Vector2 or Number")}add(e){return new i(this.x+e.x,this.y+e.y)}subtract(e){return new i(this.x-e.x,this.y-e.y)}normalize(){const e=Math.sqrt(this.x**2+this.y**2);return new i(this.x/e,this.y/e)}negate(){return new i(-this.x,-this.y)}}class o{x;y;z;constructor(e,t,r){this.x=e,this.y=t,this.z=r}get uniformBuffer(){return r([this.x,this.y,this.z])}static zero=new o(0,0,0);static one=new o(1,1,1);static up=new o(0,1,0);static down=new o(0,-1,0);static left=new o(-1,0,0);static right=new o(1,0,0);toArray(){return[this.x,this.y,this.z]}toString(){return`Vector3(${this.x.toFixed(2)},${this.y.toFixed(2)},${this.z.toFixed(2)})`}mul(e){if(e instanceof o)return new o(this.x*e.x,this.y*e.y,this.z*e.z);if("number"==typeof e)return new o(this.x*e,this.y*e,this.z*e);throw new Error("Can only multiply Vector3 by Vector3 or Number")}add(e){return new o(this.x+e.x,this.y+e.y,this.z+e.z)}subtract(e){return new o(this.x-e.x,this.y-e.y,this.z-e.z)}cross(e){return new o(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}normalize(){const e=Math.sqrt(this.x**2+this.y**2+this.z**2);return new o(0!==this.x?this.x/e:0,0!==this.y?this.y/e:0,0!==this.z?this.z/e:0)}negate(){return new o(-this.x,-this.y,-this.z)}rotateAroundAxis(e,t){const r=Math.cos(t),n=Math.sin(t),i=this.x*(r+(1-r)*e.x*e.x)+this.y*((1-r)*e.x*e.y-n*e.z)+this.z*((1-r)*e.x*e.z+n*e.y),s=this.x*((1-r)*e.y*e.x+n*e.z)+this.y*(r+(1-r)*e.y*e.y)+this.z*((1-r)*e.y*e.z-n*e.x),a=this.x*((1-r)*e.z*e.x-n*e.y)+this.y*((1-r)*e.z*e.y+n*e.x)+this.z*(r+(1-r)*e.z*e.z);return new o(i,s,a)}}class s{position;targetPosition;velocity;constructor(e){this.position=e.position,this.targetPosition=this.position,this.velocity=o.zero}update(){v.velocity=v.velocity.mul(1-.015*p),this.position=this.position.add(this.velocity.mul(p))}}const a=new class{pressed={w:!1,a:!1,s:!1,d:!1," ":!1,Control:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1}))}},c=new class{velocity=i.zero;animationFrame;constructor(){window.addEventListener("mousemove",(e=>{cancelAnimationFrame(this.animationFrame),this.velocity=new i(e.movementX,e.movementY),this.animationFrame=requestAnimationFrame((()=>{this.velocity=i.zero}))}))}};let u,l,d,m=new i(0,0),f=1;const x=performance.now();let h=x,p=0,v=new class extends s{fieldOfView;direction;constructor(e){super({position:e.position}),this.fieldOfView=e.fieldOfView,this.direction=new o(0,0,1)}reset(e){this.position=new o(16,16,-16),this.targetPosition=this.position,this.fieldOfView=e.fieldOfView,this.direction=new o(0,0,1)}get right(){return o.up.cross(this.direction).normalize()}get left(){return this.direction.cross(o.up).normalize()}get up(){return this.direction.cross(this.right).normalize()}get down(){return this.up.negate()}rotateX(e){this.direction=this.direction.rotateAroundAxis(this.right,e)}rotateY(e){this.direction=this.direction.rotateAroundAxis(o.up,e)}}({fieldOfView:90,position:new o(16,16,-16)});const y=new class{logElement;constructor(){document.getElementById("reset").addEventListener("click",(e=>{v.reset({fieldOfView:90}),document.getElementById("captures").innerHTML=""})),document.getElementById("capture").addEventListener("click",(e=>{const t=new Image;t.id=performance.now().toString(),t.src=d.toDataURL(),document.getElementById("captures").appendChild(t).addEventListener("click",(e=>{e.target,console.log(e.target)}))})),document.getElementById("downscale").addEventListener("input",(e=>{const t=e.target;window.dispatchEvent(new CustomEvent("changeDownscale",{detail:t.value}))})),this.logElement=document.getElementById("log")}log(e){this.logElement.innerText=e}};let g;void 0!==navigator.gpu?navigator.gpu.requestAdapter().then((e=>{e.requestDevice().then((e=>{u=e;const s=(()=>{let e;return{start:()=>{e=u.createComputePipeline({layout:"auto",compute:{module:u.createShaderModule({code:"\n          // Function to mimic the ease_out_expo function\r\nfn ease_out_expo(x: f32) -> f32 {\r\n    let t: f32 = x;\r\n    let b: f32 = 0.0;\r\n    let c: f32 = 1.0;\r\n    let d: f32 = 1.0; // Set the duration within the function\r\n\r\n    let intermediate_result: f32 = c * (-pow(2.0, -10.0 * t / d) + 1.0) + b;\r\n\r\n    return select(intermediate_result, b + c, t == d);\r\n\r\n}\r\n\r\nfn sample_sky(rayDirection: vec3<f32>) -> vec3<f32> {\r\n    //TODO: add this to uniforms\r\n    let lightDirection = normalize(vec3(1.0,1.0,0.));\r\n    let y = clamp(ease_out_expo(rayDirection.y * 0.66), 0.0, 1.0);\r\n//    let y = rayDirection.y;\r\n    let sunHeight = clamp(lightDirection.y, 0.0, 1.0);\r\n    let horizon = mix(vec3<f32>(0.95, 0.5, 0.4), vec3<f32>(0.6, 0.8, 1.0), sunHeight);\r\n    let sky = mix(vec3<f32>(0.55, 0.7, 0.7), vec3<f32>(0.3, 0.6, 0.95), sunHeight);\r\n    let sunFalloff = 0.8;\r\n    let sunAmount = 1.0 - ease_out_expo(length(lightDirection - rayDirection) * sunFalloff);\r\n//    let sunAmount = 1.0 - length(lightDirection - rayDirection) * sunFalloff;\r\n    let skyColour = mix(horizon, sky, y);\r\n    let sunColour = mix(vec3<f32>(1.8, 1.6, 1.1), vec3<f32>(1.6, 1.6, 1.4), sunHeight);\r\n\r\n    let intensity = clamp(sunHeight, 0.75, 1.0);\r\n    return mix(skyColour, sunColour, clamp(sunAmount, 0.0, 1.0)) * intensity;\r\n}struct FrustumCornerDirections {\r\n  topLeft : vec3<f32>,\r\n  topRight : vec3<f32>,\r\n  bottomLeft : vec3<f32>,\r\n  bottomRight : vec3<f32>\r\n}\r\n\r\nfn calculateRayDirection(uv: vec2<f32>, directions: FrustumCornerDirections) -> vec3<f32> {\r\n  let topInterpolated = mix(directions.topLeft, directions.topRight, uv.x);\r\n  let bottomInterpolated = mix(directions.bottomLeft, directions.bottomRight, uv.x);\r\n  let finalInterpolated = mix(bottomInterpolated, topInterpolated, uv.y);\r\n  return normalize(finalInterpolated);\r\n}\r\n\r\nstruct BoxIntersectionResult {\r\n    tNear: f32,\r\n    tFar: f32,\r\n    normal: vec3<f32>\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n\r\n    if (tN > tF || tF < 0.0) {\r\n        result.tNear = -1.0;\r\n        result.tFar = -1.0;\r\n        result.normal = vec3(0.0);\r\n\r\n        return result;\r\n    }\r\n\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n\r\n    normal *= -sign(rd);\r\n\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n\r\n    return result;\r\n}\r\n\r\n@group(0) @binding(0) var outputTex : texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> time : u32;\r\n@group(0) @binding(2) var<uniform> resolution : vec2<u32>;\r\n@group(0) @binding(3) var<uniform> frustumCornerDirections : FrustumCornerDirections;\r\n@group(0) @binding(4) var<uniform> cameraPosition : vec3<f32>;\r\n\r\nconst EPSILON = 0.0001;\r\nconst BORDER_WIDTH = 0.025;\r\nconst BOUNDS_SIZE = 64.0;\r\nconst MAX_RAY_STEPS = 128;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\nlet timeOffset = (sin(f32(time) * 0.001) * 0.5 + 0.5) * 2.0;\r\n  let pixel = vec2<f32>(f32(GlobalInvocationID.x), f32(resolution.y - GlobalInvocationID.y));\r\n  let uv = pixel / vec2<f32>(resolution);\r\n  let rayOrigin = cameraPosition;\r\n  var rayDirection = calculateRayDirection(uv,frustumCornerDirections);\r\n  var boxSize = vec3<f32>(BOUNDS_SIZE);\r\n  let intersect = boxIntersection(rayOrigin, rayDirection, boxSize * 0.5);\r\n  var colour = sample_sky(rayDirection);\r\n  let tNear = intersect.tNear;\r\n  let startingPos = rayOrigin + (tNear + EPSILON)  * rayDirection;\r\n  if(tNear > 0.0){\r\n  }\r\n      var pos = startingPos;\r\n      var normal = vec3(0.0);\r\n      var stepsTaken = 0;\r\n      var voxelSize = 1.0;\r\n      var voxelStep = sign(rayDirection);\r\n      var tIntersection = 0.0;\r\n      var tDelta = vec3(voxelSize / abs(rayDirection));\r\n      var scaledStartingPoint = pos / voxelSize;\r\n      var scaledRayOrigin = vec3<f32>(rayOrigin) / voxelSize;\r\n      var currentIndex = floor(scaledStartingPoint);\r\n      var voxelOriginDifference = vec3<f32>(currentIndex) - scaledRayOrigin;\r\n      var clampedVoxelBoundary = (voxelStep * 0.5) + 0.5; // 0 if <= 0, 1 if > 0\r\n      var tMax = (voxelStep * voxelOriginDifference + clampedVoxelBoundary) * tDelta + EPSILON;\r\n      var occlusion = false;\r\n      \r\n      while(stepsTaken <= MAX_RAY_STEPS)\r\n      {\r\n        tIntersection = min(min(tMax.x, tMax.y), tMax.z);\r\n        let mask = vec3(\r\n            select(0.0, 1.0, tMax.x == tIntersection),\r\n            select(0.0, 1.0, tMax.y == tIntersection), \r\n            select(0.0, 1.0, tMax.z == tIntersection)\r\n        );\r\n        tMax += mask * tDelta;\r\n        currentIndex += mask * voxelStep;\r\n        normal = vec3(mask * -voxelStep);\r\n        pos = rayOrigin + rayDirection * tIntersection;\r\n        stepsTaken ++;\r\n        let isInBounds = all(currentIndex > vec3(0.0)) && all(currentIndex < vec3(BOUNDS_SIZE));\r\n        if(!isInBounds){\r\n            break;\r\n        }\r\n        let isSolidVoxel = sin(currentIndex.x * 0.25) - sin(currentIndex.z * 0.25) > (currentIndex.y - 8) * 0.4;\r\n        if(isSolidVoxel){\r\n            occlusion = true;\r\n            break;\r\n        }\r\n      }\r\n        \r\n      // Voxel borders\r\n      let positionInVoxel = fract(pos);\r\n      let positionInBounds = fract(startingPos / BOUNDS_SIZE);\r\n      let voxelBorder = step(positionInVoxel, vec3(1 - BORDER_WIDTH)) - step(positionInVoxel, vec3(BORDER_WIDTH));\r\n      let boundsBorderWidth = BORDER_WIDTH / BOUNDS_SIZE * 2.0;\r\n      let boundsBorder = step(positionInBounds, vec3(1 - boundsBorderWidth)) - step(positionInBounds, vec3(boundsBorderWidth));\r\n      let isVoxelBorder = step(length(voxelBorder), 1.0);\r\n      let isBoundsBorder = step(length(boundsBorder), 1.0);\r\n      let baseColour = normal;\r\n      occlusion = true;\r\n      if(occlusion){    \r\n        colour = mix(baseColour,baseColour * 0.8,isVoxelBorder);\r\n      }\r\n      colour = mix(colour,vec3(0.0,1.0,0.0),isBoundsBorder);\r\n     \r\n \r\n\r\n  textureStore(outputTex, GlobalInvocationID.xy, vec4(colour,1));\r\n}\r\n"}),entryPoint:"main"}})},render:({commandEncoder:t,timeBuffer:r,resolutionBuffer:i,outputTextureView:s})=>{const a=(e=>{const t=m.x/m.y,r=e.fieldOfView/2,n=Math.tan(r),i=o.up.cross(e.direction).normalize(),s=e.direction.cross(i).normalize().mul(n);return[e.direction.add(s).add(i.mul(-t*n)),e.direction.add(s).add(i.mul(t*n)),e.direction.subtract(s).add(i.mul(-t*n)),e.direction.subtract(s).add(i.mul(t*n))]})(v).flatMap((e=>[...e.toArray(),0])),c=n(a,"frustum corner directions"),l=n(v.position.toArray(),"camera position"),d=t.beginComputePass();d.setPipeline(e);const f=u.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:s},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:c}},{binding:4,resource:{buffer:l}}]});d.setBindGroup(0,f),d.dispatchWorkgroups(Math.ceil(m.x/8),Math.ceil(m.y/8)),d.end()}}})();((e,n)=>{let s,u,w,b,I,z,E;d=document.getElementById("webgpu-canvas"),d.addEventListener("click",(async()=>{d.requestPointerLock()})),document.addEventListener("pointerlockchange",(()=>{z=null!==document.pointerLockElement})),l=d.getContext("webgpu");const B=navigator.gpu.getPreferredCanvasFormat();l.configure({device:e,format:B,usage:GPUTextureUsage.RENDER_ATTACHMENT});const D=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n//    return vec4(sin(f32(time) * 0.001), 0, 0, 1);\r\n    return textureSample(myTexture, mySampler, fragUV);\r\n}\r\n"}),S=e.createRenderPipeline({layout:"auto",vertex:{module:D,entryPoint:"vertex_main"},fragment:{module:D,entryPoint:"fragment_main",targets:[{format:B}]}}),O=()=>{cancelAnimationFrame(w),P()},P=()=>{const{clientWidth:e,clientHeight:t}=d.parentElement;m=new i(e*window.devicePixelRatio,t*window.devicePixelRatio),E=m.mul(1/f),d.width=m.x,d.height=m.y,d.style.transform=`scale(${1/window.devicePixelRatio})`,n.forEach((e=>{e.start()})),w=requestAnimationFrame(_)},_=async()=>{const i=performance.now()-x;p=i-h,h=i,z&&(()=>{if(v.rotateY(.001*c.velocity.x),v.rotateX(.001*c.velocity.y),!document.hasFocus())return;let e=o.zero;a.pressed.a&&(e=e.add(v.left)),a.pressed.d&&(e=e.add(v.right)),a.pressed.w&&(e=e.add(v.direction)),a.pressed.s&&(e=e.subtract(v.direction)),a.pressed[" "]&&(e=e.add(v.up)),a.pressed.Control&&(e=e.add(v.down)),e=e.normalize(),v.velocity=v.velocity.add(e.mul(.01))})(),v.update(),y.log(`Position: ${v.position.toString()}\n    Resolution: ${E.x.toFixed(0)}x${E.y.toFixed(0)}\n    FPS: ${(1e3/p).toFixed(1)}\n    `);const d=e.createCommandEncoder();b?t(b,[h]):b=r([h]),I?t(I,[E.x,E.y]):I=r([E.x,E.y]);const m=(u&&u.destroy(),u=e.createTexture({size:[E.x,E.y,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING}),u.createView());n.forEach((e=>{e.render({commandEncoder:d,timeBuffer:b,resolutionBuffer:I,outputTextureView:m})})),(({commandEncoder:t,outputTextureView:r})=>{const n=t.beginRenderPass({colorAttachments:[{view:l.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]});s=e.createBindGroup({layout:S.getBindGroupLayout(0),entries:[{binding:0,resource:e.createSampler({magFilter:"linear",minFilter:"linear"})},{binding:1,resource:r}]}),n.setPipeline(S),n.setBindGroup(0,s),n.draw(6),n.end()})({commandEncoder:d,outputTextureView:m}),e.queue.submit([d.finish()]),w=requestAnimationFrame(_)},R=new ResizeObserver(O);g=e=>{f=e.detail,O()},window.addEventListener("changeDownscale",g),R.observe(d.parentElement)})(u,[s])}))})):console.error("WebGPU not supported")})();