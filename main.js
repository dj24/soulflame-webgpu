/*! For license information please see main.js.LICENSE.txt */
(()=>{"use strict";class e{}class t{ecs}class n{map=new Map;add(e){this.map.set(e.constructor,e)}get(e){return this.map.get(e)}has(e){return this.map.has(e)}hasAll(e){for(let t of e)if(!this.map.has(t))return!1;return!0}delete(e){this.map.delete(e)}}let i=1e-6,s=Float32Array;function r(e=0,t=0){const n=new s(2);return void 0!==e&&(n[0]=e,void 0!==t&&(n[1]=t)),n}let o=Float32Array;function a(e,t,n){const i=new o(3);return void 0!==e&&(i[0]=e,void 0!==t&&(i[1]=t,void 0!==n&&(i[2]=n))),i}const l=r;function c(e,t,n){return(n=n||new s(2))[0]=e[0]-t[0],n[1]=e[1]-t[1],n}const u=c;function h(e,t,n){return(n=n||new s(2))[0]=e[0]*t,n[1]=e[1]*t,n}const d=h;function p(e,t){return(t=t||new s(2))[0]=1/e[0],t[1]=1/e[1],t}const f=p;function m(e,t){return e[0]*t[0]+e[1]*t[1]}function g(e){const t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}const v=g;function y(e){const t=e[0],n=e[1];return t*t+n*n}const x=y;function w(e,t){const n=e[0]-t[0],i=e[1]-t[1];return Math.sqrt(n*n+i*i)}const _=w;function b(e,t){const n=e[0]-t[0],i=e[1]-t[1];return n*n+i*i}const k=b;function A(e,t){return(t=t||new s(2))[0]=e[0],t[1]=e[1],t}const E=A;function S(e,t,n){return(n=n||new s(2))[0]=e[0]*t[0],n[1]=e[1]*t[1],n}const T=S;function M(e,t,n){return(n=n||new s(2))[0]=e[0]/t[0],n[1]=e[1]/t[1],n}const P=M;var z=Object.freeze({__proto__:null,create:r,setDefaultType:function(e){const t=s;return s=e,t},fromValues:l,set:function(e,t,n){return(n=n||new s(2))[0]=e,n[1]=t,n},ceil:function(e,t){return(t=t||new s(2))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},floor:function(e,t){return(t=t||new s(2))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},round:function(e,t){return(t=t||new s(2))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},clamp:function(e,t=0,n=1,i){return(i=i||new s(2))[0]=Math.min(n,Math.max(t,e[0])),i[1]=Math.min(n,Math.max(t,e[1])),i},add:function(e,t,n){return(n=n||new s(2))[0]=e[0]+t[0],n[1]=e[1]+t[1],n},addScaled:function(e,t,n,i){return(i=i||new s(2))[0]=e[0]+t[0]*n,i[1]=e[1]+t[1]*n,i},angle:function(e,t){const n=e[0],i=e[1],s=e[0],r=e[1],o=Math.sqrt(n*n+i*i)*Math.sqrt(s*s+r*r),a=o&&m(e,t)/o;return Math.acos(a)},subtract:c,sub:u,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<i&&Math.abs(e[1]-t[1])<i},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:function(e,t,n,i){return(i=i||new s(2))[0]=e[0]+n*(t[0]-e[0]),i[1]=e[1]+n*(t[1]-e[1]),i},lerpV:function(e,t,n,i){return(i=i||new s(2))[0]=e[0]+n[0]*(t[0]-e[0]),i[1]=e[1]+n[1]*(t[1]-e[1]),i},max:function(e,t,n){return(n=n||new s(2))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n},min:function(e,t,n){return(n=n||new s(2))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n},mulScalar:h,scale:d,divScalar:function(e,t,n){return(n=n||new s(2))[0]=e[0]/t,n[1]=e[1]/t,n},inverse:p,invert:f,cross:function(e,t,n){n=n||new o(3);const i=e[0]*t[1]-e[1]*t[0];return n[0]=0,n[1]=0,n[2]=i,n},dot:m,length:g,len:v,lengthSq:y,lenSq:x,distance:w,dist:_,distanceSq:b,distSq:k,normalize:function(e,t){t=t||new s(2);const n=e[0],i=e[1],r=Math.sqrt(n*n+i*i);return r>1e-5?(t[0]=n/r,t[1]=i/r):(t[0]=0,t[1]=0),t},negate:function(e,t){return(t=t||new s(2))[0]=-e[0],t[1]=-e[1],t},copy:A,clone:E,multiply:S,mul:T,divide:M,div:P,random:function(e=1,t){t=t||new s(2);const n=2*Math.random()*Math.PI;return t[0]=Math.cos(n)*e,t[1]=Math.sin(n)*e,t},zero:function(e){return(e=e||new s(2))[0]=0,e[1]=0,e},transformMat4:function(e,t,n){n=n||new s(2);const i=e[0],r=e[1];return n[0]=i*t[0]+r*t[4]+t[12],n[1]=i*t[1]+r*t[5]+t[13],n},transformMat3:function(e,t,n){n=n||new s(2);const i=e[0],r=e[1];return n[0]=t[0]*i+t[4]*r+t[8],n[1]=t[1]*i+t[5]*r+t[9],n}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);const C=a;function I(e,t,n){return(n=n||new o(3))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}const B=I;function O(e,t,n){return(n=n||new o(3))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n}const N=O;function R(e,t){return(t=t||new o(3))[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}const U=R;function F(e,t,n){n=n||new o(3);const i=e[2]*t[0]-e[0]*t[2],s=e[0]*t[1]-e[1]*t[0];return n[0]=e[1]*t[2]-e[2]*t[1],n[1]=i,n[2]=s,n}function D(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function L(e){const t=e[0],n=e[1],i=e[2];return Math.sqrt(t*t+n*n+i*i)}const q=L;function j(e){const t=e[0],n=e[1],i=e[2];return t*t+n*n+i*i}const V=j;function G(e,t){const n=e[0]-t[0],i=e[1]-t[1],s=e[2]-t[2];return Math.sqrt(n*n+i*i+s*s)}const $=G;function H(e,t){const n=e[0]-t[0],i=e[1]-t[1],s=e[2]-t[2];return n*n+i*i+s*s}const W=H;function Y(e,t){t=t||new o(3);const n=e[0],i=e[1],s=e[2],r=Math.sqrt(n*n+i*i+s*s);return r>1e-5?(t[0]=n/r,t[1]=i/r,t[2]=s/r):(t[0]=0,t[1]=0,t[2]=0),t}function X(e,t){return(t=t||new o(3))[0]=e[0],t[1]=e[1],t[2]=e[2],t}const Z=X;function K(e,t,n){return(n=n||new o(3))[0]=e[0]*t[0],n[1]=e[1]*t[1],n[2]=e[2]*t[2],n}const Q=K;function J(e,t,n){return(n=n||new o(3))[0]=e[0]/t[0],n[1]=e[1]/t[1],n[2]=e[2]/t[2],n}const ee=J;var te=Object.freeze({__proto__:null,create:a,setDefaultType:function(e){const t=o;return o=e,t},fromValues:C,set:function(e,t,n,i){return(i=i||new o(3))[0]=e,i[1]=t,i[2]=n,i},ceil:function(e,t){return(t=t||new o(3))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},floor:function(e,t){return(t=t||new o(3))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},round:function(e,t){return(t=t||new o(3))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},clamp:function(e,t=0,n=1,i){return(i=i||new o(3))[0]=Math.min(n,Math.max(t,e[0])),i[1]=Math.min(n,Math.max(t,e[1])),i[2]=Math.min(n,Math.max(t,e[2])),i},add:function(e,t,n){return(n=n||new o(3))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n},addScaled:function(e,t,n,i){return(i=i||new o(3))[0]=e[0]+t[0]*n,i[1]=e[1]+t[1]*n,i[2]=e[2]+t[2]*n,i},angle:function(e,t){const n=e[0],i=e[1],s=e[2],r=e[0],o=e[1],a=e[2],l=Math.sqrt(n*n+i*i+s*s)*Math.sqrt(r*r+o*o+a*a),c=l&&D(e,t)/l;return Math.acos(c)},subtract:I,sub:B,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<i&&Math.abs(e[1]-t[1])<i&&Math.abs(e[2]-t[2])<i},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:function(e,t,n,i){return(i=i||new o(3))[0]=e[0]+n*(t[0]-e[0]),i[1]=e[1]+n*(t[1]-e[1]),i[2]=e[2]+n*(t[2]-e[2]),i},lerpV:function(e,t,n,i){return(i=i||new o(3))[0]=e[0]+n[0]*(t[0]-e[0]),i[1]=e[1]+n[1]*(t[1]-e[1]),i[2]=e[2]+n[2]*(t[2]-e[2]),i},max:function(e,t,n){return(n=n||new o(3))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n[2]=Math.max(e[2],t[2]),n},min:function(e,t,n){return(n=n||new o(3))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n},mulScalar:O,scale:N,divScalar:function(e,t,n){return(n=n||new o(3))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n},inverse:R,invert:U,cross:F,dot:D,length:L,len:q,lengthSq:j,lenSq:V,distance:G,dist:$,distanceSq:H,distSq:W,normalize:Y,negate:function(e,t){return(t=t||new o(3))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},copy:X,clone:Z,multiply:K,mul:Q,divide:J,div:ee,random:function(e=1,t){t=t||new o(3);const n=2*Math.random()*Math.PI,i=2*Math.random()-1,s=Math.sqrt(1-i*i)*e;return t[0]=Math.cos(n)*s,t[1]=Math.sin(n)*s,t[2]=i*e,t},zero:function(e){return(e=e||new o(3))[0]=0,e[1]=0,e[2]=0,e},transformMat4:function(e,t,n){n=n||new o(3);const i=e[0],s=e[1],r=e[2],a=t[3]*i+t[7]*s+t[11]*r+t[15]||1;return n[0]=(t[0]*i+t[4]*s+t[8]*r+t[12])/a,n[1]=(t[1]*i+t[5]*s+t[9]*r+t[13])/a,n[2]=(t[2]*i+t[6]*s+t[10]*r+t[14])/a,n},transformMat4Upper3x3:function(e,t,n){n=n||new o(3);const i=e[0],s=e[1],r=e[2];return n[0]=i*t[0]+s*t[4]+r*t[8],n[1]=i*t[1]+s*t[5]+r*t[9],n[2]=i*t[2]+s*t[6]+r*t[10],n},transformMat3:function(e,t,n){n=n||new o(3);const i=e[0],s=e[1],r=e[2];return n[0]=i*t[0]+s*t[4]+r*t[8],n[1]=i*t[1]+s*t[5]+r*t[9],n[2]=i*t[2]+s*t[6]+r*t[10],n},transformQuat:function(e,t,n){n=n||new o(3);const i=t[0],s=t[1],r=t[2],a=2*t[3],l=e[0],c=e[1],u=e[2],h=s*u-r*c,d=r*l-i*u,p=i*c-s*l;return n[0]=l+h*a+2*(s*p-r*d),n[1]=c+d*a+2*(r*h-i*p),n[2]=u+p*a+2*(i*d-s*h),n},getTranslation:function(e,t){return(t=t||new o(3))[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const i=4*t;return(n=n||new o(3))[0]=e[i+0],n[1]=e[i+1],n[2]=e[i+2],n},getScaling:function(e,t){t=t||new o(3);const n=e[0],i=e[1],s=e[2],r=e[4],a=e[5],l=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+i*i+s*s),t[1]=Math.sqrt(r*r+a*a+l*l),t[2]=Math.sqrt(c*c+u*u+h*h),t}});let ne=Float32Array;function ie(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}const se=ie;function re(e){return(e=e||new ne(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function oe(e,t){t=t||new ne(16);const n=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15],y=d*v,x=g*p,w=l*v,_=g*c,b=l*p,k=d*c,A=s*v,E=g*r,S=s*p,T=d*r,M=s*c,P=l*r,z=u*m,C=f*h,I=o*m,B=f*a,O=o*h,N=u*a,R=n*m,U=f*i,F=n*h,D=u*i,L=n*a,q=o*i,j=y*a+_*h+b*m-(x*a+w*h+k*m),V=x*i+A*h+T*m-(y*i+E*h+S*m),G=w*i+E*a+M*m-(_*i+A*a+P*m),$=k*i+S*a+P*h-(b*i+T*a+M*h),H=1/(n*j+o*V+u*G+f*$);return t[0]=H*j,t[1]=H*V,t[2]=H*G,t[3]=H*$,t[4]=H*(x*o+w*u+k*f-(y*o+_*u+b*f)),t[5]=H*(y*n+E*u+S*f-(x*n+A*u+T*f)),t[6]=H*(_*n+A*o+P*f-(w*n+E*o+M*f)),t[7]=H*(b*n+T*o+M*u-(k*n+S*o+P*u)),t[8]=H*(z*c+B*p+O*v-(C*c+I*p+N*v)),t[9]=H*(C*r+R*p+D*v-(z*r+U*p+F*v)),t[10]=H*(I*r+U*c+L*v-(B*r+R*c+q*v)),t[11]=H*(N*r+F*c+q*p-(O*r+D*c+L*p)),t[12]=H*(I*d+N*g+C*l-(O*g+z*l+B*d)),t[13]=H*(F*g+z*s+U*d-(R*d+D*g+C*s)),t[14]=H*(R*l+q*g+B*s-(L*g+I*s+U*l)),t[15]=H*(L*d+O*s+D*l-(F*l+q*d+N*s)),t}const ae=oe;function le(e,t,n){n=n||new ne(16);const i=e[0],s=e[1],r=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=e[8],d=e[9],p=e[10],f=e[11],m=e[12],g=e[13],v=e[14],y=e[15],x=t[0],w=t[1],_=t[2],b=t[3],k=t[4],A=t[5],E=t[6],S=t[7],T=t[8],M=t[9],P=t[10],z=t[11],C=t[12],I=t[13],B=t[14],O=t[15];return n[0]=i*x+a*w+h*_+m*b,n[1]=s*x+l*w+d*_+g*b,n[2]=r*x+c*w+p*_+v*b,n[3]=o*x+u*w+f*_+y*b,n[4]=i*k+a*A+h*E+m*S,n[5]=s*k+l*A+d*E+g*S,n[6]=r*k+c*A+p*E+v*S,n[7]=o*k+u*A+f*E+y*S,n[8]=i*T+a*M+h*P+m*z,n[9]=s*T+l*M+d*P+g*z,n[10]=r*T+c*M+p*P+v*z,n[11]=o*T+u*M+f*P+y*z,n[12]=i*C+a*I+h*B+m*O,n[13]=s*C+l*I+d*B+g*O,n[14]=r*C+c*I+p*B+v*O,n[15]=o*C+u*I+f*B+y*O,n}const ce=le;let ue,he,de;function pe(e,t,n){n=n||new ne(16);let i=e[0],s=e[1],r=e[2];const o=Math.sqrt(i*i+s*s+r*r);i/=o,s/=o,r/=o;const a=i*i,l=s*s,c=r*r,u=Math.cos(t),h=Math.sin(t),d=1-u;return n[0]=a+(1-a)*u,n[1]=i*s*d+r*h,n[2]=i*r*d-s*h,n[3]=0,n[4]=i*s*d-r*h,n[5]=l+(1-l)*u,n[6]=s*r*d+i*h,n[7]=0,n[8]=i*r*d+s*h,n[9]=s*r*d-i*h,n[10]=c+(1-c)*u,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}const fe=pe;function me(e,t,n,i){i=i||new ne(16);let s=t[0],r=t[1],o=t[2];const a=Math.sqrt(s*s+r*r+o*o);s/=a,r/=a,o/=a;const l=s*s,c=r*r,u=o*o,h=Math.cos(n),d=Math.sin(n),p=1-h,f=l+(1-l)*h,m=s*r*p+o*d,g=s*o*p-r*d,v=s*r*p-o*d,y=c+(1-c)*h,x=r*o*p+s*d,w=s*o*p+r*d,_=r*o*p-s*d,b=u+(1-u)*h,k=e[0],A=e[1],E=e[2],S=e[3],T=e[4],M=e[5],P=e[6],z=e[7],C=e[8],I=e[9],B=e[10],O=e[11];return i[0]=f*k+m*T+g*C,i[1]=f*A+m*M+g*I,i[2]=f*E+m*P+g*B,i[3]=f*S+m*z+g*O,i[4]=v*k+y*T+x*C,i[5]=v*A+y*M+x*I,i[6]=v*E+y*P+x*B,i[7]=v*S+y*z+x*O,i[8]=w*k+_*T+b*C,i[9]=w*A+_*M+b*I,i[10]=w*E+_*P+b*B,i[11]=w*S+_*z+b*O,e!==i&&(i[12]=e[12],i[13]=e[13],i[14]=e[14],i[15]=e[15]),i}const ge=me;var ve=Object.freeze({__proto__:null,setDefaultType:function(e){const t=ne;return ne=e,t},create:function(e,t,n,i,s,r,o,a,l,c,u,h,d,p,f,m){const g=new ne(16);return void 0!==e&&(g[0]=e,void 0!==t&&(g[1]=t,void 0!==n&&(g[2]=n,void 0!==i&&(g[3]=i,void 0!==s&&(g[4]=s,void 0!==r&&(g[5]=r,void 0!==o&&(g[6]=o,void 0!==a&&(g[7]=a,void 0!==l&&(g[8]=l,void 0!==c&&(g[9]=c,void 0!==u&&(g[10]=u,void 0!==h&&(g[11]=h,void 0!==d&&(g[12]=d,void 0!==p&&(g[13]=p,void 0!==f&&(g[14]=f,void 0!==m&&(g[15]=m)))))))))))))))),g},set:function(e,t,n,i,s,r,o,a,l,c,u,h,d,p,f,m,g){return(g=g||new ne(16))[0]=e,g[1]=t,g[2]=n,g[3]=i,g[4]=s,g[5]=r,g[6]=o,g[7]=a,g[8]=l,g[9]=c,g[10]=u,g[11]=h,g[12]=d,g[13]=p,g[14]=f,g[15]=m,g},fromMat3:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=0,t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=0,t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromQuat:function(e,t){t=t||new ne(16);const n=e[0],i=e[1],s=e[2],r=e[3],o=n+n,a=i+i,l=s+s,c=n*o,u=i*o,h=i*a,d=s*o,p=s*a,f=s*l,m=r*o,g=r*a,v=r*l;return t[0]=1-h-f,t[1]=u+v,t[2]=d-g,t[3]=0,t[4]=u-v,t[5]=1-c-f,t[6]=p+m,t[7]=0,t[8]=d+g,t[9]=p-m,t[10]=1-c-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},negate:function(e,t){return(t=t||new ne(16))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t[9]=-e[9],t[10]=-e[10],t[11]=-e[11],t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=-e[15],t},copy:ie,clone:se,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<i&&Math.abs(e[1]-t[1])<i&&Math.abs(e[2]-t[2])<i&&Math.abs(e[3]-t[3])<i&&Math.abs(e[4]-t[4])<i&&Math.abs(e[5]-t[5])<i&&Math.abs(e[6]-t[6])<i&&Math.abs(e[7]-t[7])<i&&Math.abs(e[8]-t[8])<i&&Math.abs(e[9]-t[9])<i&&Math.abs(e[10]-t[10])<i&&Math.abs(e[11]-t[11])<i&&Math.abs(e[12]-t[12])<i&&Math.abs(e[13]-t[13])<i&&Math.abs(e[14]-t[14])<i&&Math.abs(e[15]-t[15])<i},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},identity:re,transpose:function(e,t){if((t=t||new ne(16))===e){let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,t}const n=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15];return t[0]=n,t[1]=o,t[2]=u,t[3]=f,t[4]=i,t[5]=a,t[6]=h,t[7]=m,t[8]=s,t[9]=l,t[10]=d,t[11]=g,t[12]=r,t[13]=c,t[14]=p,t[15]=v,t},inverse:oe,determinant:function(e){const t=e[0],n=e[1],i=e[2],s=e[3],r=e[4],o=e[5],a=e[6],l=e[7],c=e[8],u=e[9],h=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],v=h*g,y=m*d,x=a*g,w=m*l,_=a*d,b=h*l,k=i*g,A=m*s,E=i*d,S=h*s,T=i*l,M=a*s;return t*(v*o+w*u+_*f-(y*o+x*u+b*f))+r*(y*n+k*u+S*f-(v*n+A*u+E*f))+c*(x*n+A*o+T*f-(w*n+k*o+M*f))+p*(b*n+E*o+M*u-(_*n+S*o+T*u))},invert:ae,multiply:le,mul:ce,setTranslation:function(e,t,n){return e!==(n=n||re())&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11]),n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},getTranslation:function(e,t){return(t=t||a())[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const i=4*t;return(n=n||a())[0]=e[i+0],n[1]=e[i+1],n[2]=e[i+2],n},setAxis:function(e,t,n,i){i!==e&&(i=ie(e,i));const s=4*n;return i[s+0]=t[0],i[s+1]=t[1],i[s+2]=t[2],i},getScaling:function(e,t){t=t||a();const n=e[0],i=e[1],s=e[2],r=e[4],o=e[5],l=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+i*i+s*s),t[1]=Math.sqrt(r*r+o*o+l*l),t[2]=Math.sqrt(c*c+u*u+h*h),t},perspective:function(e,t,n,i,s){s=s||new ne(16);const r=Math.tan(.5*Math.PI-.5*e);if(s[0]=r/t,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=r,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[11]=-1,s[12]=0,s[13]=0,s[15]=0,i===1/0)s[10]=-1,s[14]=-n;else{const e=1/(n-i);s[10]=i*e,s[14]=i*n*e}return s},ortho:function(e,t,n,i,s,r,o){return(o=o||new ne(16))[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(i-n),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(s-r),o[11]=0,o[12]=(t+e)/(e-t),o[13]=(i+n)/(n-i),o[14]=s/(s-r),o[15]=1,o},frustum:function(e,t,n,i,s,r,o){const a=t-e,l=i-n,c=s-r;return(o=o||new ne(16))[0]=2*s/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*s/l,o[6]=0,o[7]=0,o[8]=(e+t)/a,o[9]=(i+n)/l,o[10]=r/c,o[11]=-1,o[12]=0,o[13]=0,o[14]=s*r/c,o[15]=0,o},aim:function(e,t,n,i){return i=i||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(t,e,de),de),Y(F(n,de,ue),ue),Y(F(de,ue,he),he),i[0]=ue[0],i[1]=ue[1],i[2]=ue[2],i[3]=0,i[4]=he[0],i[5]=he[1],i[6]=he[2],i[7]=0,i[8]=de[0],i[9]=de[1],i[10]=de[2],i[11]=0,i[12]=e[0],i[13]=e[1],i[14]=e[2],i[15]=1,i},cameraAim:function(e,t,n,i){return i=i||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(e,t,de),de),Y(F(n,de,ue),ue),Y(F(de,ue,he),he),i[0]=ue[0],i[1]=ue[1],i[2]=ue[2],i[3]=0,i[4]=he[0],i[5]=he[1],i[6]=he[2],i[7]=0,i[8]=de[0],i[9]=de[1],i[10]=de[2],i[11]=0,i[12]=e[0],i[13]=e[1],i[14]=e[2],i[15]=1,i},lookAt:function(e,t,n,i){return i=i||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(e,t,de),de),Y(F(n,de,ue),ue),Y(F(de,ue,he),he),i[0]=ue[0],i[1]=he[0],i[2]=de[0],i[3]=0,i[4]=ue[1],i[5]=he[1],i[6]=de[1],i[7]=0,i[8]=ue[2],i[9]=he[2],i[10]=de[2],i[11]=0,i[12]=-(ue[0]*e[0]+ue[1]*e[1]+ue[2]*e[2]),i[13]=-(he[0]*e[0]+he[1]*e[1]+he[2]*e[2]),i[14]=-(de[0]*e[0]+de[1]*e[1]+de[2]*e[2]),i[15]=1,i},translation:function(e,t){return(t=t||new ne(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},translate:function(e,t,n){n=n||new ne(16);const i=t[0],s=t[1],r=t[2],o=e[0],a=e[1],l=e[2],c=e[3],u=e[4],h=e[5],d=e[6],p=e[7],f=e[8],m=e[9],g=e[10],v=e[11],y=e[12],x=e[13],w=e[14],_=e[15];return e!==n&&(n[0]=o,n[1]=a,n[2]=l,n[3]=c,n[4]=u,n[5]=h,n[6]=d,n[7]=p,n[8]=f,n[9]=m,n[10]=g,n[11]=v),n[12]=o*i+u*s+f*r+y,n[13]=a*i+h*s+m*r+x,n[14]=l*i+d*s+g*r+w,n[15]=c*i+p*s+v*r+_,n},rotationX:function(e,t){t=t||new ne(16);const n=Math.cos(e),i=Math.sin(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=i,t[7]=0,t[8]=0,t[9]=-i,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateX:function(e,t,n){n=n||new ne(16);const i=e[4],s=e[5],r=e[6],o=e[7],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[4]=h*i+d*a,n[5]=h*s+d*l,n[6]=h*r+d*c,n[7]=h*o+d*u,n[8]=h*a-d*i,n[9]=h*l-d*s,n[10]=h*c-d*r,n[11]=h*u-d*o,e!==n&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationY:function(e,t){t=t||new ne(16);const n=Math.cos(e),i=Math.sin(e);return t[0]=n,t[1]=0,t[2]=-i,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=i,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateY:function(e,t,n){n=n||new ne(16);const i=e[0],s=e[1],r=e[2],o=e[3],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[0]=h*i-d*a,n[1]=h*s-d*l,n[2]=h*r-d*c,n[3]=h*o-d*u,n[8]=h*a+d*i,n[9]=h*l+d*s,n[10]=h*c+d*r,n[11]=h*u+d*o,e!==n&&(n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationZ:function(e,t){t=t||new ne(16);const n=Math.cos(e),i=Math.sin(e);return t[0]=n,t[1]=i,t[2]=0,t[3]=0,t[4]=-i,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateZ:function(e,t,n){n=n||new ne(16);const i=e[0],s=e[1],r=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=Math.cos(t),d=Math.sin(t);return n[0]=h*i+d*a,n[1]=h*s+d*l,n[2]=h*r+d*c,n[3]=h*o+d*u,n[4]=h*a-d*i,n[5]=h*l-d*s,n[6]=h*c-d*r,n[7]=h*u-d*o,e!==n&&(n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},axisRotation:pe,rotation:fe,axisRotate:me,rotate:ge,scaling:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},scale:function(e,t,n){n=n||new ne(16);const i=t[0],s=t[1],r=t[2];return n[0]=i*e[0],n[1]=i*e[1],n[2]=i*e[2],n[3]=i*e[3],n[4]=s*e[4],n[5]=s*e[5],n[6]=s*e[6],n[7]=s*e[7],n[8]=r*e[8],n[9]=r*e[9],n[10]=r*e[10],n[11]=r*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},uniformScaling:function(e,t){return(t=t||new ne(16))[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},uniformScale:function(e,t,n){return(n=n||new ne(16))[0]=t*e[0],n[1]=t*e[1],n[2]=t*e[2],n[3]=t*e[3],n[4]=t*e[4],n[5]=t*e[5],n[6]=t*e[6],n[7]=t*e[7],n[8]=t*e[8],n[9]=t*e[9],n[10]=t*e[10],n[11]=t*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n}});let ye=Float32Array;function xe(e,t,n,i){const s=new ye(4);return void 0!==e&&(s[0]=e,void 0!==t&&(s[1]=t,void 0!==n&&(s[2]=n,void 0!==i&&(s[3]=i)))),s}const we=xe;function _e(e,t,n){n=n||new ye(4);const i=.5*t,s=Math.sin(i);return n[0]=s*e[0],n[1]=s*e[1],n[2]=s*e[2],n[3]=Math.cos(i),n}function be(e,t,n){n=n||new ye(4);const i=e[0],s=e[1],r=e[2],o=e[3],a=t[0],l=t[1],c=t[2],u=t[3];return n[0]=i*u+o*a+s*c-r*l,n[1]=s*u+o*l+r*a-i*c,n[2]=r*u+o*c+i*l-s*a,n[3]=o*u-i*a-s*l-r*c,n}const ke=be;function Ae(e,t,n,s){s=s||new ye(4);const r=e[0],o=e[1],a=e[2],l=e[3];let c,u,h=t[0],d=t[1],p=t[2],f=t[3],m=r*h+o*d+a*p+l*f;if(m<0&&(m=-m,h=-h,d=-d,p=-p,f=-f),1-m>i){const e=Math.acos(m),t=Math.sin(e);c=Math.sin((1-n)*e)/t,u=Math.sin(n*e)/t}else c=1-n,u=n;return s[0]=c*r+u*h,s[1]=c*o+u*d,s[2]=c*a+u*p,s[3]=c*l+u*f,s}function Ee(e,t){return(t=t||new ye(4))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}const Se=Ee;function Te(e,t,n){return(n=n||new ye(4))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n}const Me=Te;function Pe(e,t,n){return(n=n||new ye(4))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n}const ze=Pe;function Ce(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Ie(e){const t=e[0],n=e[1],i=e[2],s=e[3];return Math.sqrt(t*t+n*n+i*i+s*s)}const Be=Ie;function Oe(e){const t=e[0],n=e[1],i=e[2],s=e[3];return t*t+n*n+i*i+s*s}const Ne=Oe;function Re(e,t){t=t||new ye(4);const n=e[0],i=e[1],s=e[2],r=e[3],o=Math.sqrt(n*n+i*i+s*s+r*r);return o>1e-5?(t[0]=n/o,t[1]=i/o,t[2]=s/o,t[3]=r/o):(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}let Ue,Fe,De,Le,qe;var je=Object.freeze({__proto__:null,create:xe,setDefaultType:function(e){const t=ye;return ye=e,t},fromValues:we,set:function(e,t,n,i,s){return(s=s||new ye(4))[0]=e,s[1]=t,s[2]=n,s[3]=i,s},fromAxisAngle:_e,toAxisAngle:function(e,t){t=t||a(4);const n=2*Math.acos(e[3]),s=Math.sin(.5*n);return s>i?(t[0]=e[0]/s,t[1]=e[1]/s,t[2]=e[2]/s):(t[0]=1,t[1]=0,t[2]=0),{angle:n,axis:t}},angle:function(e,t){const n=Ce(e,t);return Math.acos(2*n*n-1)},multiply:be,mul:ke,rotateX:function(e,t,n){n=n||new ye(4);const i=.5*t,s=e[0],r=e[1],o=e[2],a=e[3],l=Math.sin(i),c=Math.cos(i);return n[0]=s*c+a*l,n[1]=r*c+o*l,n[2]=o*c-r*l,n[3]=a*c-s*l,n},rotateY:function(e,t,n){n=n||new ye(4);const i=.5*t,s=e[0],r=e[1],o=e[2],a=e[3],l=Math.sin(i),c=Math.cos(i);return n[0]=s*c-o*l,n[1]=r*c+a*l,n[2]=o*c+s*l,n[3]=a*c-r*l,n},rotateZ:function(e,t,n){n=n||new ye(4);const i=.5*t,s=e[0],r=e[1],o=e[2],a=e[3],l=Math.sin(i),c=Math.cos(i);return n[0]=s*c+r*l,n[1]=r*c-s*l,n[2]=o*c+a*l,n[3]=a*c-o*l,n},slerp:Ae,inverse:function(e,t){t=t||new ye(4);const n=e[0],i=e[1],s=e[2],r=e[3],o=n*n+i*i+s*s+r*r,a=o?1/o:0;return t[0]=-n*a,t[1]=-i*a,t[2]=-s*a,t[3]=r*a,t},conjugate:function(e,t){return(t=t||new ye(4))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},fromMat:function(e,t){t=t||new ye(4);const n=e[0]+e[5]+e[10];if(n>0){const i=Math.sqrt(n+1);t[3]=.5*i;const s=.5/i;t[0]=(e[6]-e[9])*s,t[1]=(e[8]-e[2])*s,t[2]=(e[1]-e[4])*s}else{let n=0;e[5]>e[0]&&(n=1),e[10]>e[4*n+n]&&(n=2);const i=(n+1)%3,s=(n+2)%3,r=Math.sqrt(e[4*n+n]-e[4*i+i]-e[4*s+s]+1);t[n]=.5*r;const o=.5/r;t[3]=(e[4*i+s]-e[4*s+i])*o,t[i]=(e[4*i+n]+e[4*n+i])*o,t[s]=(e[4*s+n]+e[4*n+s])*o}return t},fromEuler:function(e,t,n,i,s){s=s||new ye(4);const r=.5*e,o=.5*t,a=.5*n,l=Math.sin(r),c=Math.cos(r),u=Math.sin(o),h=Math.cos(o),d=Math.sin(a),p=Math.cos(a);switch(i){case"xyz":s[0]=l*h*p+c*u*d,s[1]=c*u*p-l*h*d,s[2]=c*h*d+l*u*p,s[3]=c*h*p-l*u*d;break;case"xzy":s[0]=l*h*p-c*u*d,s[1]=c*u*p-l*h*d,s[2]=c*h*d+l*u*p,s[3]=c*h*p+l*u*d;break;case"yxz":s[0]=l*h*p+c*u*d,s[1]=c*u*p-l*h*d,s[2]=c*h*d-l*u*p,s[3]=c*h*p+l*u*d;break;case"yzx":s[0]=l*h*p+c*u*d,s[1]=c*u*p+l*h*d,s[2]=c*h*d-l*u*p,s[3]=c*h*p-l*u*d;break;case"zxy":s[0]=l*h*p-c*u*d,s[1]=c*u*p+l*h*d,s[2]=c*h*d+l*u*p,s[3]=c*h*p-l*u*d;break;case"zyx":s[0]=l*h*p-c*u*d,s[1]=c*u*p+l*h*d,s[2]=c*h*d-l*u*p,s[3]=c*h*p+l*u*d;break;default:throw new Error(`Unknown rotation order: ${i}`)}return s},copy:Ee,clone:Se,add:function(e,t,n){return(n=n||new ye(4))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n},subtract:Te,sub:Me,mulScalar:Pe,scale:ze,divScalar:function(e,t,n){return(n=n||new ye(4))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n[3]=e[3]/t,n},dot:Ce,lerp:function(e,t,n,i){return(i=i||new ye(4))[0]=e[0]+n*(t[0]-e[0]),i[1]=e[1]+n*(t[1]-e[1]),i[2]=e[2]+n*(t[2]-e[2]),i[3]=e[3]+n*(t[3]-e[3]),i},length:Ie,len:Be,lengthSq:Oe,lenSq:Ne,normalize:Re,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<i&&Math.abs(e[1]-t[1])<i&&Math.abs(e[2]-t[2])<i&&Math.abs(e[3]-t[3])<i},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(e){return(e=e||new ye(4))[0]=0,e[1]=0,e[2]=0,e[3]=1,e},rotationTo:function(e,t,n){n=n||new ye(4),Ue=Ue||a(),Fe=Fe||a(1,0,0),De=De||a(0,1,0);const i=D(e,t);return i<-.999999?(F(Fe,e,Ue),q(Ue)<1e-6&&F(De,e,Ue),Y(Ue,Ue),_e(Ue,Math.PI,n),n):i>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(F(e,t,Ue),n[0]=Ue[0],n[1]=Ue[1],n[2]=Ue[2],n[3]=1+i,Re(n,n))},sqlerp:function(e,t,n,i,s,r){return r=r||new ye(4),Le=Le||new ye(4),qe=qe||new ye(4),Ae(e,i,s,Le),Ae(t,n,s,qe),Ae(Le,qe,2*s*(1-s),r),r}});Float32Array;const Ve=(e,t)=>{const n=new Uint32Array(t);er.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},Ge=(e,t)=>{const n=new Uint32Array(e),i=er.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return Ve(i,e),i},$e=(e,t)=>{if(t instanceof Float32Array)er.queue.writeBuffer(e,0,t.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT);else{const n=new Float32Array(t);er.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)}},He="// Constants\nconst infinity : f32 = 99999999.0;\n\n// Utility functions\nfn degreesToRadians(degrees : f32) -> f32 {\n    return degrees * (3.1415926535897932385 / 180.0);\n}\n\nfn unitVector(v : vec3<f32>) -> vec3<f32> {\n    return v / length(v);\n}\n\nfn lengthSquared(v : vec3<f32>) -> f32 {\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nfn random(co : vec2<f32>) -> f32 {\n    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn randomMinMax(co : vec2<f32>, min : f32, max : f32) -> f32 {\n    return min + (max - min) * random(co);\n}\n\nfn randomFloat3(co : vec2<f32>) -> vec3<f32> {\n    return vec3<f32>(random(co), random(co * 2.0), random(co * 3.0));\n}\n\nfn randomFloat3MinMax(co : vec2<f32>, min : f32, max : f32) -> vec3<f32> {\n    return vec3<f32>(randomMinMax(co, min, max), randomMinMax(co * 2.0, min, max), randomMinMax(co * 3.0, min, max));\n}\n\nfn randomInUnitSphere(co : vec2<f32>) -> vec3<f32> {\n    var p : vec3<f32> = randomFloat3MinMax(co, -1.0, 1.0);\n    while (lengthSquared(p) < 1.0) {\n        p = randomFloat3MinMax(co, -1.0, 1.0);\n    }\n    return p;\n}\n\nfn randomInUnitDisk(seed : vec2<f32>) -> vec2<f32> {\n    let r = sqrt(random(seed));\n    let theta = 2.0 * 3.14159265359 * random(vec2<f32>(seed.y, seed.x));\n    return vec2<f32>(cos(theta), sin(theta)) * r;\n}\n\nfn randomInPlanarUnitDisk(seed : vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\n    let disk = randomInUnitDisk(seed);\n    var diskNormal = cross(normal, vec3<f32>(0.0, 1.0, 0.0));\n    if (length(diskNormal) < 0.01) {\n        diskNormal = cross(normal, vec3<f32>(1.0, 0.0, 0.0));\n    }\n    diskNormal = normalize(diskNormal);\n    let diskTangent = cross(diskNormal, normal);\n    return disk.x * diskTangent + disk.y * diskNormal;\n}\n\nfn reflect(v : vec3<f32>, n : vec3<f32>) -> vec3<f32> {\n    return v - 2.0 * dot(v, n) * n;\n}\n\nfn randomUnitVector(co : vec2<f32>) -> vec3<f32> {\n    return unitVector(randomInUnitSphere(co));\n}\n\nfn nearZero(e : vec3<f32>) -> bool {\n    const s : f32 = 1e-8;\n    return (abs(e.x) < s) && (abs(e.y) < s) && (abs(e.z) < s);\n}\n\nfn randomInHemisphere(co : vec2<f32>, normal : vec3<f32>) -> vec3<f32> {\n    let inUnitSphere = randomUnitVector(co);\n    if (dot(inUnitSphere, normal) > 0.0) {\n        return inUnitSphere;\n    }\n    return -inUnitSphere;\n}\n\nfn randomAlongVector(co : vec2<f32>, direction : vec3<f32>) -> vec3<f32> {\n    return normalize(direction) * random(co);\n}\n\n// Function to perturb the normal vector within the hemisphere\nfn perturbDirection(normal: vec3<f32>, scatterAmount: f32, co: vec2<f32>) -> vec3<f32> {\n    // Generate a random vector in a hemisphere\n    let hemisphereVector : vec3<f32> = randomInHemisphere(co, normal);\n\n    // Combine the perturbation with the original normal\n    let perturbedDir : vec3<f32> = normalize(normal + scatterAmount * hemisphereVector);\n\n    return perturbedDir;\n}\n\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\nfn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfn perlinNoise3(P: vec3<f32>) -> f32 {\n    var Pi0 : vec3<f32> = floor(P); // Integer part for indexing\n    var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1\n    Pi0 = Pi0 % vec3<f32>(289.);\n    Pi1 = Pi1 % vec3<f32>(289.);\n    let Pf0 = fract(P); // Fractional part for interpolation\n    let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.\n    let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy = vec4<f32>(Pi0.yy, Pi1.yy);\n    let iz0 = Pi0.zzzz;\n    let iz1 = Pi1.zzzz;\n\n    let ixy = permute4(permute4(ix) + iy);\n    let ixy0 = permute4(ixy + iz0);\n    let ixy1 = permute4(ixy + iz1);\n\n    var gx0: vec4<f32> = ixy0 / 7.;\n    var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;\n    gx0 = fract(gx0);\n    var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\n    var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));\n    gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);\n    gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);\n\n    var gx1: vec4<f32> = ixy1 / 7.;\n    var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;\n    gx1 = fract(gx1);\n    var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\n    var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));\n    gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);\n    gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);\n\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\n\n    let norm0 = taylorInvSqrt4(\n        vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 = g000 * norm0.x;\n    g010 = g010 * norm0.y;\n    g100 = g100 * norm0.z;\n    g110 = g110 * norm0.w;\n    let norm1 = taylorInvSqrt4(\n        vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 = g001 * norm1.x;\n    g011 = g011 * norm1.y;\n    g101 = g101 * norm1.z;\n    g111 = g111 * norm1.w;\n\n    let n000 = dot(g000, Pf0);\n    let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\n    let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\n    let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\n    let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\n    let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\n    let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\n    let n111 = dot(g111, Pf1);\n\n    var fade_xyz: vec3<f32> = fade3(Pf0);\n    let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix\n    let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);\n    let n_yz = mix(n_z.xy, n_z.zw, vec2f(f32(fade_xyz.y))); // simplify after chrome bug fix\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}",We="fn calculateRayDirection(uv: vec2<f32>, inverseProjection: mat4x4<f32>) -> vec3<f32> {\n  let clipSpace = vec2(1.0 - uv.x, 1.0 - uv.y) * 2.0 - 1.0;\n  let viewRay = vec3<f32>(clipSpace, 1.0);\n  let viewRayView = inverseProjection * vec4(viewRay, 1.0);\n  return normalize(viewRayView.xyz);\n}\n\nfn normaliseValue(min: f32, max: f32, value: f32) -> f32 {\n  return (value - min) / (max - min);\n}",Ye="struct BoxIntersectionResult {\n    tNear: f32,\n    tFar: f32,\n    normal: vec3<f32>,\n    isHit: bool,\n}\n\nfn boxIntersection(\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n    boxSize: vec3<f32>,\n) -> BoxIntersectionResult {\n    var result = BoxIntersectionResult();\n    result.isHit = false;\n    result.tNear = 0.0;\n    result.tFar = 0.0;\n\n    let offsetRayOrigin = ro - boxSize;\n    let m: vec3<f32> = 1.0 / rd;\n    let n: vec3<f32> = m * offsetRayOrigin;\n    let k: vec3<f32> = abs(m) * boxSize;\n    let t1: vec3<f32> = -n - k;\n    let t2: vec3<f32> = -n + k;\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) {\n        return result;\n    }\n    // Check if the ray starts inside the volume\n    let insideVolume = tN < 0.0;\n    var normal = select(\n        step(vec3<f32>(tN), t1),\n        step(t2, vec3<f32>(tF)),\n        tN < 0.0,\n    );\n    normal *= -sign(rd);\n    // Check if the intersection is in the correct direction, only if inside the volume\n    if (insideVolume && dot(normal, rd) < 0.0) {\n        return result;\n    }\n    result.tNear = tN;\n    result.tFar = tF;\n    result.normal = normal;\n    result.isHit = true;\n    return result;\n}\n\nfn get3x3From4x4(m: mat4x4<f32>) -> mat3x3<f32> {\n    return mat3x3<f32>(\n        m[0].xyz,\n        m[1].xyz,\n        m[2].xyz,\n    );\n}\n\n\nfn intersectOBB(\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n    boxSize: vec3<f32>,\n    boxOrientation: mat3x3<f32>,\n) -> BoxIntersectionResult {\n    var result = BoxIntersectionResult();\n    result.isHit = false;\n    result.tNear = -1.0;\n    result.tFar = -1.0;\n\n    let offsetRayOrigin = ro - boxSize;\n    let m: vec3<f32> = 1.0 / rd;\n    let n: vec3<f32> = m * offsetRayOrigin;\n    let k: vec3<f32> = abs(m) * boxSize;\n    let t1: vec3<f32> = -n - k;\n    let t2: vec3<f32> = -n + k;\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) {\n        return result;\n    }\n    // Check if the ray starts inside the volume\n    let insideVolume = tN < 0.0;\n    var normal = select(\n        step(vec3<f32>(tN), t1),\n        step(t2, vec3<f32>(tF)),\n        tN < 0.0,\n    );\n    normal *= -sign(rd);\n    // Check if the intersection is in the correct direction, only if inside the volume\n    if (insideVolume && dot(normal, rd) < 0.0) {\n        return result;\n    }\n    result.tNear = tN;\n    result.tFar = tF;\n    result.normal = normal;\n    result.isHit = true;\n    return result;\n}",Xe='const EPSILON = 0.001;\nconst MAX_RAY_STEPS = 256;\nconst FAR_PLANE = 10000.0;\nconst NEAR_PLANE = 0.5;\nconst STACK_LEN: u32 = 32u;\n\n// Function to transform a normal vector from object to world space\nfn transformNormal(inverseTransform: mat4x4<f32>, normal: vec3<f32>) -> vec3<f32> {\n    let worldNormal = normalize((vec4<f32>(normal, 0.0) * inverseTransform).xyz);\n    return worldNormal;\n}\n\n// Function to transform an object space position to world space\nfn transformPosition(transform: mat4x4<f32>, position: vec3<f32>) -> vec3<f32> {\n    let worldPosition = (transform * vec4<f32>(position, 1.0)).xyz;\n    return worldPosition;\n}\n\n\nstruct VoxelObject {\n  transform: mat4x4<f32>,\n  inverseTransform: mat4x4<f32>,\n  previousTransform: mat4x4<f32>,\n  previousInverseTransform: mat4x4<f32>,\n  size : vec3<f32>,\n  atlasLocation : vec3<f32>,\n  paletteIndex : f32,\n  octreeBufferIndex: u32\n}\n\nstruct RayMarchResult {\n  voxelObjectIndex: i32,\n  colour: vec3<f32>,\n  normal: vec3<f32>,\n  hit: bool,\n  t: f32,\n  iterations: u32,\n}\n\nfn isInBounds(position: vec3<i32>, size: vec3<i32>) -> bool {\n  return all(position >= vec3(0)) && all(position <= size - vec3(1));\n}\n\nfn getBit(value: u32, bitIndex: u32) -> bool {\n  return (value & (1u << bitIndex)) != 0;\n}\n\nfn getScaleFromMatrix(transform: mat4x4<f32>) -> vec3<f32> {\n  return vec3<f32>(length(transform[0].xyz), length(transform[1].xyz), length(transform[2].xyz));\n}\n\nstruct Stack {\n  arr: array<i32, STACK_LEN>,\n\thead: u32,\n}\n\nfn stack_new() -> Stack {\n    var arr: array<i32, STACK_LEN>;\n    return Stack(arr, 0u);\n}\n\nfn stack_push(stack: ptr<function, Stack>, val: i32) {\n    (*stack).arr[(*stack).head] = val;\n    (*stack).head += 1u;\n}\n\nfn stack_pop(stack: ptr<function, Stack>) -> i32 {\n    (*stack).head -= 1u;\n    return (*stack).arr[(*stack).head];\n}\n\nstruct StackU32 {\n  arr: array<u32, STACK_LEN>,\n  head: u32,\n}\n\nfn stacku32_new() -> StackU32 {\n    var arr: array<u32, STACK_LEN>;\n    return StackU32(arr, 0u);\n}\n\nfn stacku32_push(stack: ptr<function, StackU32>, val: u32) {\n    (*stack).arr[(*stack).head] = val;\n    (*stack).head += 1u;\n}\n\nfn stacku32_pop(stack: ptr<function, StackU32>) -> u32 {\n    (*stack).head -= 1u;\n    return (*stack).arr[(*stack).head];\n}\n\n\nstruct InternalNode {\n  firstChildOffset: u32,\n  childMask: u32,\n  position: vec3<u32>,\n  size: u32,\n}\n\nstruct LeafNode {\n  colour: vec3<u32>,\n  position: vec3<u32>,\n}\n\nconst mask8 = 0xFFu;\nconst mask16 = 0xFFFFu;\nconst mask24 = 0xFFFFFFu;\n\n// if first child offset is 0, then it is a leaf\nfn isLeaf(node:vec2<u32>) -> bool {\n  return (node[0] & mask16) == 0;\n}\n\n/**\n  * Unpacks a leaf node from a 32 bit integer\n  * First 16 bits are the leaf flag (0)\n  * The next 8 bits are the red component\n  * The next 8 bits are the green component\n  * The next 8 bits are the blue component\n  * The next 8 bits are the x position\n  * The next 8 bits are the y position\n  * The next 8 bits are the z position\n  */\nfn unpackLeaf(node: vec2<u32>) -> LeafNode {\n  var output = LeafNode();\n  let first4Bytes = node.x;\n  let second4Bytes = node.y;\n  let r = (first4Bytes >> 16u) & mask8;\n  let g = (first4Bytes >> 24u) & mask8;\n  let b = second4Bytes & mask8;\n  let x = (second4Bytes >> 8u) & mask8;\n  let y = (second4Bytes >> 16u) & mask8;\n  let z = (second4Bytes >> 24u) & mask8;\n  output.colour = vec3<u32>(r, g, b);\n  output.position = vec3<u32>(x, y, z);\n  return output;\n}\n\n/**\n  * Unpacks an internal node from a 32 bit integer\n  * First 24 bits are the firstChildOffset\n  * The next 8 bits are the child mask\n  * The next 8 bits are the x position\n  * The next 8 bits are the y position\n  * The next 8 bits are the z position\n  * The next 8 bits are the size\n  */\nfn unpackInternal(node: vec2<u32>) -> InternalNode {\n  var output = InternalNode();\n  let first4Bytes = node.x;\n  let second4Bytes = node.y;\n  output.firstChildOffset = first4Bytes & mask24;\n  output.childMask = (first4Bytes >> 24u) & mask8;\n  let x = second4Bytes & mask8;\n  let y = (second4Bytes >> 8u) & mask8;\n  let z = (second4Bytes >> 16u) & mask8;\n  output.position = vec3<u32>(x, y, z);\n  output.size = 1u << ((second4Bytes >> 24u) & mask8); // 2 raised to the power of the size\n  return output;\n}\n\nfn getNodeSizeAtDepth(rootSize: u32, depth: u32) -> u32 {\n  return rootSize >> depth;\n}\n\nfn octantIndexToOffset(index: u32) -> vec3<u32> {\n  return vec3<u32>(\n    select(0u, 1u, (index & 1u) != 0u),\n    select(0u, 1u, (index & 2u) != 0u),\n    select(0u, 1u, (index & 4u) != 0u)\n  );\n}\n\nfn octantOffsetToIndex(offset: vec3<u32>) -> u32 {\n  return offset.x + offset.y * 2u + offset.z * 4u;\n}\n\nfn ceilToPowerOfTwo(value: f32) -> f32 {\n  return pow(2.0, ceil(log2(value)));\n}\n\nfn max3(value: vec3<f32>) -> f32 {\n  return max(value.x, max(value.y, value.z));\n}\n\nfn planeIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, planeNormal: vec3<f32>, planeDistance: f32) -> f32 {\n  return -(dot(rayOrigin,planeNormal)+planeDistance)/dot(rayDirection,planeNormal);\n}\n\nstruct PlaneIntersection {\n  tNear: f32,\n  side: vec3<i32>\n}\n\n\nfn sort3Asc(a: f32, b: f32, c: f32) -> vec3<f32> {\n  return vec3<f32>(\n    min(a, min(b, c)),\n    min(max(a, b), max(min(a, b), c)),\n    max(a, max(b, c))\n  );\n}\n\nfn sort3Desc(a: f32, b: f32, c: f32) -> vec3<f32> {\n  return vec3<f32>(\n    max(a, max(b, c)),\n    max(min(a, b), min(max(a, b), c)),\n    min(a, min(b, c))\n  );\n}\n\nfn getPlaneIntersections(rayOrigin: vec3<f32>, rayDirection:vec3<f32>, nodeSize: f32) -> vec3<f32> {\n    let boxExtents = nodeSize * 0.5;\n\n    var yPlaneIntersectionTNear = planeIntersection(rayOrigin, rayDirection, vec3(0.0, -1, 0.0), boxExtents);\n    var xPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(-1, 0.0, 0.0), boxExtents);\n    var zPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(0.0, 0.0, -1), boxExtents);\n\n    // If the intersection is outside the bounds of the node, set it to a large value to ignore it\n    let yPlaneHitPosition = rayOrigin + rayDirection * yPlaneIntersectionTNear  - EPSILON;\n    if(any(yPlaneHitPosition < vec3(0.0)) || any(yPlaneHitPosition > vec3(f32(nodeSize)))){\n      yPlaneIntersectionTNear  = 10000.0;\n    }\n    let xPlaneHitPosition = rayOrigin + rayDirection * xPlaneIntersectionTNear  - EPSILON;\n    if(any(xPlaneHitPosition < vec3(0.0)) || any(xPlaneHitPosition > vec3(f32(nodeSize)))){\n      xPlaneIntersectionTNear  = 10000.0;\n    }\n    let zPlaneHitPosition = rayOrigin + rayDirection * zPlaneIntersectionTNear  - EPSILON;\n    if(any(zPlaneHitPosition < vec3(0.0)) || any(zPlaneHitPosition > vec3(f32(nodeSize)))){\n      zPlaneIntersectionTNear  = 10000.0;\n    }\n\n    return vec3(xPlaneIntersectionTNear, yPlaneIntersectionTNear, zPlaneIntersectionTNear);\n}\n\nconst DISTANCE_THRESHOLDS =\n  array<vec2<f32>, 4>(\n    vec2<f32>(2.0, 500),\n    vec2<f32>(4.0, 1000),\n    vec2<f32>(8.0, 1500),\n    vec2<f32>(16.0, 2000)\n  );\n\nfn rayMarchOctree(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>, minNodeSize: f32) -> RayMarchResult {\n    let halfExtents = voxelObject.size * 0.5;\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz + halfExtents;\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\n    var output = RayMarchResult();\n\n    let distanceToRoot = boxIntersection(objectRayOrigin, objectRayDirection, voxelObject.size * 0.5).tNear;\n    if(distanceToRoot > FAR_PLANE){\n      return output;\n    }\n\n    // Set the initial t value to the far plane - essentially an out of bounds value\n    output.t = FAR_PLANE;\n\n    // Create a stack to hold the indices of the nodes we need to check\n    var stack = stacku32_new();\n\n    // Push the root node index onto the stack\n//    stacku32_push(&stack, 84688 + 1u);\n    stacku32_push(&stack, voxelObject.octreeBufferIndex);\n\n    // Main loop\n    while (stack.head > 0u && output.iterations < MAX_STEPS) {\n      output.colour += vec3(0.02);\n      output.iterations += 1u;\n      let nodeIndex = stacku32_pop(&stack);\n      let node = octreeBuffer[nodeIndex];\n\n      if(isLeaf(node)){\n        // TODO: find out how to get normal without extra intersection\n        let leafNode = unpackLeaf(node);\n        let nodeOrigin = vec3(f32(leafNode.position.x), f32(leafNode.position.y), f32(leafNode.position.z));\n        let nodeRayOrigin = objectRayOrigin - nodeOrigin;\n        let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(0.5));\n        output.hit = true;\n        output.t = nodeIntersection.tNear;\n        output.normal = nodeIntersection.normal;\n//          output.colour = vec3<f32>(leafNode.colour) / 255.0;\n        return output;\n      }\n\n      // Get the current nodes data\n      let internalNode = unpackInternal(node);\n\n      // Get the size of the node to get the center for plane intersections\n      let nodeSize = f32(internalNode.size);\n\n      // Check if the ray intersects the node, if not, skip it\n      let nodeOrigin = vec3<f32>(internalNode.position);\n      let nodeRayOrigin = objectRayOrigin - nodeOrigin;\n      let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(nodeSize * 0.5));\n      let isOriginInside = all(nodeRayOrigin >= vec3(0.0)) && all(nodeRayOrigin <= vec3(nodeSize));\n\n      let distanceToNode = nodeIntersection.tNear;\n//      output.colour = distanceToNode * vec3(0.001);\n\n      if(distanceToNode < 0.0){\n        continue;\n      }\n\n      if(!nodeIntersection.isHit && !isOriginInside){\n        continue;\n      }\n\n//      if(f32(internalNode.size) <= minNodeSize){\n//        output.hit = true;\n//        output.t = nodeIntersection.tNear;\n//        output.normal = nodeIntersection.normal;\n//        output.colour = vec3(1,0,0);\n//        return output;\n//      }\n\n//      for(var i = 0u; i < 4u; i++){\n//        if(f32(internalNode.size) <= DISTANCE_THRESHOLDS[i].x && distanceToRoot > DISTANCE_THRESHOLDS[i].y){\n//          output.hit = true;\n//          output.t = nodeIntersection.tNear;\n//          output.normal = nodeIntersection.normal;\n//          output.colour = vec3(1);\n//          return output;\n//        }\n//      }\n\n      let centerOfChild = vec3(nodeSize* 0.5);\n\n      // Use planes to find the "inner" intersections\n      let planeIntersections = getPlaneIntersections(nodeRayOrigin, objectRayDirection, nodeSize);\n\n      // Get the closest plane intersection\n      let sortedIntersections = sort3Desc(planeIntersections[0], planeIntersections[1], planeIntersections[2]);\n\n      // Get the side of the planes that the ray is on\n      let sideOfPlanes = vec3<f32>(sign(nodeRayOrigin - centerOfChild));\n\n      // Push the children onto the stack, furthest first\n      for(var i = 0u; i < 3u; i++){\n        if(sortedIntersections[i] > 9999.0){\n          continue;\n        }\n\n        var hitPosition = nodeRayOrigin + objectRayDirection * sortedIntersections[i] - sideOfPlanes * EPSILON;\n        let hitOctant = vec3<u32>(hitPosition >= centerOfChild);\n        let hitIndex = octantOffsetToIndex(hitOctant);\n\n        // If the child is present, push it onto the stack\n        if(getBit(internalNode.childMask, hitIndex)){\n           let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\n           stacku32_push(&stack, childIndex);\n        }\n      }\n\n      // Get octant hit on the surface of the nodes bounding box\n      let intersectionPoint = nodeRayOrigin + objectRayDirection * nodeIntersection.tNear;\n      let hitOctant = vec3<u32>(intersectionPoint >= centerOfChild);\n      let hitIndex = octantOffsetToIndex(vec3<u32>(hitOctant));\n\n      // If the child is present, push it onto the stack\n      if(getBit(internalNode.childMask, hitIndex)){\n        let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\n        stacku32_push(&stack, childIndex);\n      }\n    }\n\n    return output;\n}\n\n\nconst colours = array<vec3<f32>, 8>(\n  vec3<f32>(0.5),\n  vec3<f32>(1.0, 0.0, 0.0),\n  vec3<f32>(0.0, 1.0, 0.0),\n  vec3<f32>(1.0, 1.0, 0.0),\n  vec3<f32>(0.0, 0.0, 1.0),\n  vec3<f32>(1.0, 0.0, 1.0),\n  vec3<f32>(0.0, 1.0, 1.0),\n  vec3<f32>(1.0, 1.0, 1.0)\n);\n\nfn debugColourFromIndex(index: i32) -> vec3<f32> {\n  return colours[index % 8];\n}\n',Ze="const BRICK_SIZE = 8;\nconst MAX_BVH_STEPS = 64;\nconst MAX_STEPS = 256;\n\n\nstruct BVHNode {\n  leftIndex: i32,\n  rightIndex: i32,\n  objectCount: u32,\n  AABBMin: vec3<f32>,\n  AABBMax: vec3<f32>\n}\n\nfn getDistanceToNode(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, node: BVHNode) -> f32 {\n  if(all(rayOrigin >= node.AABBMin) && all(rayOrigin <= node.AABBMax)){\n    return 0.0;\n  }\n  let boxSize = (node.AABBMax - node.AABBMin) / 2;\n  let intersection = boxIntersection(rayOrigin - node.AABBMin, rayDirection, boxSize);\n  if(intersection.isHit){\n    return intersection.tNear;\n  }\n  return -1.0;\n\n}\n\n// Stack-based BVH traversal\nfn rayMarchBVH(rayOrigin: vec3<f32>, rayDirection: vec3<f32>) -> RayMarchResult {\n  var closestIntersection = RayMarchResult();\n closestIntersection.t = FAR_PLANE;\n\n  // Create a stack to store the nodes to visit\n  var stack = stack_new();\n  stack_push(&stack, 0);\n\n  var iterations = 0;\n  var closestRayMarchDistance = FAR_PLANE;\n\n  while (stack.head > 0u && iterations < MAX_BVH_STEPS) {\n    let nodeIndex = stack_pop(&stack);\n    let node = bvhNodes[nodeIndex];\n    if(node.objectCount > 1){\n      let leftNode = bvhNodes[node.leftIndex];\n      let rightNode = bvhNodes[node.rightIndex];\n      let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\n      let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\n      let hitLeft = leftDist >= 0.0 && leftDist < closestIntersection.t;\n      let hitRight = rightDist >= 0.0 && rightDist < closestIntersection.t;\n      if(hitLeft && hitRight){\n        if(leftDist < rightDist){\n          // left is closer, push right to stack\n          stack_push(&stack, node.rightIndex);\n          stack_push(&stack, node.leftIndex);\n        } else {\n          // right is closer, push left to stack\n          stack_push(&stack, node.leftIndex);\n          stack_push(&stack, node.rightIndex);\n        }\n      }\n      // We only hit the right Node\n      else if(hitRight){\n        stack_push(&stack, node.rightIndex);\n      }\n      else if(hitLeft){\n        stack_push(&stack, node.leftIndex);\n      }\n    }\n    // valid leaf, raymarch it\n    else if(node.objectCount == 1){\n        let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\n        if(distanceToLeaf > closestIntersection.t){\n          continue;\n        }\n        let voxelObject = voxelObjects[node.leftIndex];\n        var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, rayOrigin, 0.0);\n//        if(rayMarchResult.hit && rayMarchResult.t < closestIntersection.t){\n           closestIntersection = rayMarchResult;\n//        }\n    }\n    iterations += 1;\n//    closestIntersection.colour += vec3<f32>(0.05);\n  }\n\n  return closestIntersection;\n}\n\nconst MAX_SHADOW_BVH_VISITS = 32;\n\nfn rayMarchBVHShadows(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, mipLevel: u32) -> RayMarchResult {\n   var closestIntersection = RayMarchResult();\n   closestIntersection.t = FAR_PLANE;\n\n   // Create a stack to store the nodes to visit\n   var stack = stack_new();\n   stack_push(&stack, 0);\n\n   var iterations = 0;\n   var nodeIndex = 0;\n\n   while (stack.head > 0u && iterations < MAX_SHADOW_BVH_VISITS) {\n     let node = bvhNodes[nodeIndex];\n     if(node.objectCount > 1){\n       let leftNode = bvhNodes[node.leftIndex];\n       let rightNode = bvhNodes[node.rightIndex];\n       let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\n       let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\n       let hitLeft = leftDist >= 0.0;\n       let hitRight = rightDist >= 0.0;\n       if(hitLeft){\n         var nearIndex = node.leftIndex;\n         // We hit both left and right, choose the closest one\n         if(hitRight){\n           if(leftDist < rightDist){\n             // left is closer, push right to stack\n             stack_push(&stack, node.rightIndex);\n           } else {\n             // right is closer, push left to stack\n             stack_push(&stack, node.leftIndex);\n             nearIndex = node.rightIndex;\n           }\n         }\n         nodeIndex = nearIndex;\n       }\n       // We only hit the right Node\n       else if(hitRight){\n         nodeIndex = node.rightIndex;\n       }\n       // We didn't hit any node, pop the stack\n       else{\n         nodeIndex = stack_pop(&stack);\n       }\n     }\n     // valid leaf, raymarch it\n     else if(node.objectCount == 1){\n         let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\n         if(distanceToLeaf < 0.0){\n           nodeIndex = stack_pop(&stack);\n           continue;\n         }\n         let worldPos = rayOrigin + rayDirection * distanceToLeaf;\n         let voxelObject = voxelObjects[node.leftIndex];\n         var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, worldPos, 1.0);\n         let totalDistance = rayMarchResult.t + distanceToLeaf;\n         if(rayMarchResult.hit){\n           return rayMarchResult;\n         }\n\n         nodeIndex = stack_pop(&stack);\n     }\n\n     iterations += 1;\n   }\n\n   return closestIntersection;\n }",Ke=Symbol(),Qe=e=>new Proxy(e,{construct:(e,t,n)=>e.prototype!==n.prototype?Reflect.construct(e,t,n):(e[Ke]||(e[Ke]=Reflect.construct(e,t,n)),e[Ke])}),Je="rgba16float";const et=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,tt=(e,t,n=et)=>{let i=class{#e;#t;#n;#i;#s=t;#r=n;#o=e;constructor(i,s,r){this.#e=i.createTexture({label:e,size:[s,r,1],format:t,usage:n}),this.#t=this.#e.createView({label:e}),this.#n=s,this.#i=r}get texture(){return this.#e}get view(){return this.#t}get width(){return this.#n}get height(){return this.#i}get format(){return this.#s}get usage(){return this.#r}get label(){return this.#o}};return i=function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o}([Qe],i),i},nt=tt("albedo","rgba16float"),it=tt("normal","rgba16float"),st=tt("depth","r32float",GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST),rt=tt("velocity","rgba16float"),ot=tt("world position","rgba32float"),at=tt("output",Je),lt=async()=>{const e=await(async()=>{const e={binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},t={binding:9,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},n={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},i={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},s={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},r={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba32float",viewDimension:"2d"}},a={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},l=(GPUShaderStage.COMPUTE,{binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),c=er.createBindGroupLayout({label:"raymarch g-buffer",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},e,{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},a,n,i,s,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},r,l,o,t]}),u=await er.createComputePipelineAsync({label:"raymarch g-buffer",layout:er.createPipelineLayout({bindGroupLayouts:[c]}),compute:{module:er.createShaderModule({code:`\n          struct Time {\n            frame: u32,\n            deltaTime: f32\n          };\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> time : Time;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(6) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(9) var blueNoiseTex : texture_2d<f32>;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${He}\n          ${We}\n          ${Ye}\n          ${Xe}\n          ${Ze}\n          // TODO: actually make linear\nfn distanceToReversedLinearDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\n  return (far - cameraDistance) / (far - near);//Reversed\n}\n\nfn reversedLinearDepthToDistance(linearDepth: f32, near: f32, far: f32) -> f32 {\n    return far - linearDepth * (far - near); //Reversed\n}\n\nfn distanceToLogarithmicDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\n    return log2(cameraDistance / near + 1.0) / log2(far / near + 1.0);\n}\n\nfn logarithmicDepthToDistance(logDepth: f32, near: f32, far: f32) -> f32 {\n    let base = far / near + 1.0;\n    return near * (pow(base, logDepth) - 1.0);\n}\n          struct ViewProjectionMatrices {\n  viewProjection : mat4x4<f32>,\n  previousViewProjection : mat4x4<f32>,\n  inverseViewProjection : mat4x4<f32>,\n  previousInverseViewProjection : mat4x4<f32>,\n  projection : mat4x4<f32>,\n  inverseProjection: mat4x4<f32>,\n  viewMatrix : mat4x4<f32>,\n};\n\n\nfn plainIntersect(ro: vec3<f32>, rd: vec3<f32>, p: vec4<f32>) -> f32 {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\nfn getVelocityStatic(worldPos: vec3<f32>, viewProjections:ViewProjectionMatrices) -> vec2<f32>{\n  let vp = viewProjections.viewProjection;\n  let previousVp = viewProjections.previousViewProjection;\n\n  let clipSpace = vp * vec4(worldPos.xyz, 1.0);\n  let previousClipSpace = previousVp * vec4(worldPos.xyz, 1.0);\n\n  let ndc = clipSpace.xyz / clipSpace.w;\n  let previousNdc = previousClipSpace.xyz / previousClipSpace.w;\n\n  var uv = ndc.xy * 0.5 + 0.5;\n  var previousUv = previousNdc.xy * 0.5 + 0.5;\n\n  var velocity = previousUv - uv;\n  return velocity;\n}\n\nfn getVelocity(objectPos: vec3<f32>, modelMatrix: mat4x4<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec2<f32> {\n  let vp = viewProjections.viewProjection;\n  let previousVp = viewProjections.previousViewProjection;\n\n  // Get current object space position of the current pixel\n  let objectClipSpace = vp * modelMatrix * vec4(objectPos.xyz, 1.0);\n  let objectNDC = objectClipSpace.xyz / objectClipSpace.w;\n\n  // Get previous position of the current object space position\n  let previousObjectClipSpace = previousVp * previousModelMatrix * vec4(objectPos.xyz, 1.0);\n  let previousObjectNDC = previousObjectClipSpace.xyz / previousObjectClipSpace.w;\n\n  // UV\n  var uv = objectNDC.xy * 0.5 + 0.5;\n  var previousUv = previousObjectNDC.xy * 0.5 + 0.5;\n  uv.y = 1.0 - uv.y;\n  previousUv.y = 1.0 - previousUv.y;\n\n  // Get velocity based on the difference between the current and previous positions\n  var velocity = previousUv - uv;\n  return velocity;\n}\n\nfn getLeftChildIndex(index: i32) -> i32 {\n  return index * 2 + 1;\n}\n\nfn getRightChildIndex(index: i32) -> i32 {\n  return index * 2 + 2;\n}\n\nfn getParentIndex(index: i32) -> i32 {\n  return (index - 1) / 2;\n}\n\n\nfn dirIsNegative(dir: vec3<f32>, axis: i32) -> bool {\n  return dir[axis] < 0.0;\n}\n\nfn getDebugColour(index: i32) -> vec3<f32> {\n  let colours = array<vec3<f32>, 6>(\n    vec3<f32>(1.0, 0.0, 0.0),\n    vec3<f32>(0.0, 1.0, 0.0),\n    vec3<f32>(0.0, 0.0, 1.0),\n    vec3<f32>(1.0, 1.0, 0.0),\n    vec3<f32>(1.0, 0.0, 1.0),\n    vec3<f32>(0.0, 1.0, 1.0)\n  );\n  return colours[index % 6];\n}\n\n\nfn customNormalize(value: f32, min: f32, max: f32) -> f32 {\n    return (value - min) / (max - min);\n}\n\nconst IDENTITY_MATRIX = mat4x4<f32>(\n  vec4<f32>(1.0, 0.0, 0.0, 0.0),\n  vec4<f32>(0.0, 1.0, 0.0, 0.0),\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0)\n);\n\nfn intersectSphere(origin: vec3<f32>, dir: vec3<f32>, spherePos: vec3<f32>, sphereRad: f32) -> f32\n{\n\tlet oc = origin - spherePos;\n\tlet b = 2.0 * dot(dir, oc);\n\tlet c = dot(oc, oc) - sphereRad*sphereRad;\n\tlet disc = b * b - 4.0 * c;\n\tif (disc < 0.0)\n\t{\n\t  return -1.0;\n\t}\n\n//    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\n  let q = (-b + select(sqrt(disc), -sqrt(disc), b < 0.0)) / 2.0;\n\tvar t0 = q;\n\tvar t1 = c / q;\n\tif (t0 > t1) {\n\t\tvar temp = t0;\n\t\tt0 = t1;\n\t\tt1 = temp;\n\t}\n\tif (t1 < 0.0){\n\t  return -1.0;\n\t}\n\n  return select(t0, t1, t0 < 0.0);\n}\n\nfn skyDomeIntersection(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\n    return intersectSphere(ro, rd, vec3<f32>(0.0, 0.0, 0.0), FAR_PLANE);\n}\n\nconst BLUE_NOISE_SIZE = 511;\n\nfn tracePixel(pixel: vec2<u32>){\n   let resolution = textureDimensions(albedoTex);\n   var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\n   var rayDirection = calculateRayDirection(uv,viewProjections.inverseViewProjection);\n\n    // DOF\n    let blueNoiseOffset = vec2<u32>(0);\n    var blueNoisePixel = pixel;\n    blueNoisePixel.x += time.frame * 32;\n    blueNoisePixel.y += time.frame * 16;\n    blueNoisePixel = (blueNoisePixel + blueNoiseOffset) % BLUE_NOISE_SIZE;\n    if(time.frame % 2 == 0){\n      blueNoisePixel.y = BLUE_NOISE_SIZE - blueNoisePixel.y;\n    }\n    if(time.frame % 3 == 0){\n      blueNoisePixel.x = BLUE_NOISE_SIZE - blueNoisePixel.x;\n    }\n    var r = textureLoad(blueNoiseTex, blueNoisePixel, 0).rg;\n    let aperture = 0.15;\n    let focalDistance = 100.0;\n    let randomOffset = randomInUnitDisk(r) * aperture;\n    let cameraRight = vec3(viewProjections.viewMatrix[0].x, viewProjections.viewMatrix[1].x, viewProjections.viewMatrix[2].x);\n    let cameraUp = vec3(viewProjections.viewMatrix[0].y, viewProjections.viewMatrix[1].y, viewProjections.viewMatrix[2].y);\n    let rayOrigin = cameraPosition + randomOffset.x * cameraRight + randomOffset.y * cameraUp;\n    let focalPoint = cameraPosition + normalize(rayDirection) * focalDistance;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\n    var closestIntersection = RayMarchResult();\n    var worldPos = vec3(0.0);\n    var normal = vec3(0.0);\n    var albedo = vec3(0.0);\n    var velocity = vec2(0.0);\n    let bvhResult = rayMarchBVH(rayOrigin, rayDirection);\n//    if(bvhResult.hit){\n      let voxelObject = voxelObjects[bvhResult.voxelObjectIndex];\n      albedo = bvhResult.colour;\n      normal = transformNormal(voxelObject.inverseTransform,vec3<f32>(bvhResult.normal));\n      worldPos = rayOrigin + rayDirection * bvhResult.t;\n//    }\n//    else{\n//      albedo = vec3(0.0);\n//      worldPos = rayOrigin + skyDomeIntersection(rayOrigin, rayDirection) * rayDirection;\n//    }\n    velocity = getVelocityStatic(worldPos, viewProjections);\n\n    textureStore(albedoTex, pixel, vec4(albedo, 1));\n    textureStore(normalTex, pixel, vec4(normal,1));\n    textureStore(velocityTex, pixel, vec4(velocity,0,f32(bvhResult.voxelObjectIndex)));\n    textureStore(worldPosTex, pixel, vec4(worldPos,0));\n}\n\n@compute @workgroup_size(16, 8, 1)\nfn main(\n   @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\n) {\n  let pixel = GlobalInvocationID.xy;\n  tracePixel(pixel);\n}\n\n@group(1) @binding(0) var<storage, read> screenRayBuffer : array<vec2<u32>>;\n\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\n  vec2<u32>(0,1),\n  vec2<u32>(1,0),\n  vec2<u32>(1,1),\n  vec2<u32>(2,0),\n  vec2<u32>(2,1),\n  vec2<u32>(0,2),\n  vec2<u32>(1,2),\n  vec2<u32>(2,2)\n);\n\n@compute @workgroup_size(64, 1, 1)\nfn bufferMarch(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n) {\n  let bufferIndex = GlobalInvocationID.x / 8;\n  let localRayIndex = GlobalInvocationID.x % 8;\n  let pixel = screenRayBuffer[bufferIndex];\n  let offsetPixel = pixel + REMAINING_RAY_OFFSETS[localRayIndex];\n\n  tracePixel(offsetPixel);\n//  textureStore(depthWrite, offsetPixel, vec4(0,0,0,0));\n//   textureStore(albedoTex, offsetPixel, vec4(1,0,0,1));\n}`}),entryPoint:"main"}});let h;return(e,t)=>{h=(e=>er.createBindGroup({layout:c,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:1,resource:{buffer:e.timeBuffer}},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.worldPositionTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:9,resource:e.blueNoiseTextureView},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),e.setPipeline(u),e.setBindGroup(0,h),e.dispatchWorkgroups(Math.ceil(tr[0]/16),Math.ceil(tr[1]/8))}})();let t,n,i,s={albedoTexture:null,velocityTexture:null,depthTexture:null,normalTexture:null};return{render:r=>{if(!n){n=er.createBuffer({size:12,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),t=er.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const e=new Uint32Array(3);e[0]=1,e[1]=1,e[2]=1,er.queue.writeBuffer(n,0,e,0,e.length);const{width:s,height:a}=r.outputTextures.finalTexture,l=(o=s/3*(a/3)*4,4,4*Math.ceil(o/4));i=er.createBuffer({size:l,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}var o;Object.keys(s).forEach((e=>{const t=r.outputTextures[e];null===s[e]&&(s[e]=((e,t)=>new(tt(`${t.label}-copy`,t.format,t.usage))(e,t.width,t.height))(er,t))}));const{commandEncoder:a,timestampWrites:l}=r;a.clearBuffer(n,0,4),a.clearBuffer(t,0,4),a.clearBuffer(i);let c=a.beginComputePass({timestampWrites:l});e(c,r),c.end()},label:"primary rays",timestampLabels:["full raymarch"]}};class ct{constructor(e,t,n,i,s="div"){this.parent=e,this.object=t,this.property=n,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(s),this.domElement.classList.add("controller"),this.domElement.classList.add(i),this.$name=document.createElement("div"),this.$name.classList.add("name"),ct.nextNameID=ct.nextNameID||0,this.$name.id="lil-gui-name-"+ ++ct.nextNameID,this.$widget=document.createElement("div"),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.domElement.addEventListener("keydown",(e=>e.stopPropagation())),this.domElement.addEventListener("keyup",(e=>e.stopPropagation())),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(n)}name(e){return this._name=e,this.$name.textContent=e,this}onChange(e){return this._onChange=e,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(e=!0){return this.disable(!e)}disable(e=!0){return e===this._disabled||(this._disabled=e,this.domElement.classList.toggle("disabled",e),this.$disable.toggleAttribute("disabled",e)),this}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(e){const t=this.parent.add(this.object,this.property,e);return t.name(this._name),this.destroy(),t}min(e){return this}max(e){return this}step(e){return this}decimals(e){return this}listen(e=!0){return this._listening=e,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const e=this.save();e!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=e}getValue(){return this.object[this.property]}setValue(e){return this.getValue()!==e&&(this.object[this.property]=e,this._callOnChange(),this.updateDisplay()),this}updateDisplay(){return this}load(e){return this.setValue(e),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class ut extends ct{constructor(e,t,n){super(e,t,n,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",(()=>{this.setValue(this.$input.checked),this._callOnFinishChange()})),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function ht(e){let t,n;return(t=e.match(/(#|0x)?([a-f0-9]{6})/i))?n=t[2]:(t=e.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?n=parseInt(t[1]).toString(16).padStart(2,0)+parseInt(t[2]).toString(16).padStart(2,0)+parseInt(t[3]).toString(16).padStart(2,0):(t=e.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(n=t[1]+t[1]+t[2]+t[2]+t[3]+t[3]),!!n&&"#"+n}const dt={isPrimitive:!0,match:e=>"number"==typeof e,fromHexString:e=>parseInt(e.substring(1),16),toHexString:e=>"#"+e.toString(16).padStart(6,0)},pt={isPrimitive:!1,match:e=>Array.isArray(e),fromHexString(e,t,n=1){const i=dt.fromHexString(e);t[0]=(i>>16&255)/255*n,t[1]=(i>>8&255)/255*n,t[2]=(255&i)/255*n},toHexString:([e,t,n],i=1)=>dt.toHexString(e*(i=255/i)<<16^t*i<<8^n*i<<0)},ft={isPrimitive:!1,match:e=>Object(e)===e,fromHexString(e,t,n=1){const i=dt.fromHexString(e);t.r=(i>>16&255)/255*n,t.g=(i>>8&255)/255*n,t.b=(255&i)/255*n},toHexString:({r:e,g:t,b:n},i=1)=>dt.toHexString(e*(i=255/i)<<16^t*i<<8^n*i<<0)},mt=[{isPrimitive:!0,match:e=>"string"==typeof e,fromHexString:ht,toHexString:ht},dt,pt,ft];class gt extends ct{constructor(e,t,n,i){var s;super(e,t,n,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(s=this.initialValue,mt.find((e=>e.match(s)))),this._rgbScale=i,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",(()=>{this._setValueFromHexString(this.$input.value)})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$text.addEventListener("input",(()=>{const e=ht(this.$text.value);e&&this._setValueFromHexString(e)})),this.$text.addEventListener("focus",(()=>{this._textFocused=!0,this.$text.select()})),this.$text.addEventListener("blur",(()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()})),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(e){if(this._format.isPrimitive){const t=this._format.fromHexString(e);this.setValue(t)}else this._format.fromHexString(e,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(e){return this._setValueFromHexString(e),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class vt extends ct{constructor(e,t,n){super(e,t,n,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",(e=>{e.preventDefault(),this.getValue().call(this.object),this._callOnChange()})),this.$button.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$disable=this.$button}}class yt extends ct{constructor(e,t,n,i,s,r){super(e,t,n,"number"),this._initInput(),this.min(i),this.max(s);const o=void 0!==r;this.step(o?r:this._getImplicitStep(),o),this.updateDisplay()}decimals(e){return this._decimals=e,this.updateDisplay(),this}min(e){return this._min=e,this._onUpdateMinMax(),this}max(e){return this._max=e,this._onUpdateMinMax(),this}step(e,t=!0){return this._step=e,this._stepExplicit=t,this}updateDisplay(){const e=this.getValue();if(this._hasSlider){let t=(e-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=100*t+"%"}return this._inputFocused||(this.$input.value=void 0===this._decimals?e:e.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),window.matchMedia("(pointer: coarse)").matches&&(this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any")),this.$widget.appendChild(this.$input),this.$disable=this.$input;const e=e=>{const t=parseFloat(this.$input.value);isNaN(t)||(this._snapClampSetValue(t+e),this.$input.value=this.getValue())};let t,n,i,s,r,o=!1;const a=e=>{if(o){const i=e.clientX-t,s=e.clientY-n;Math.abs(s)>5?(e.preventDefault(),this.$input.blur(),o=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(i)>5&&l()}if(!o){const t=e.clientY-i;r-=t*this._step*this._arrowKeyMultiplier(e),s+r>this._max?r=this._max-s:s+r<this._min&&(r=this._min-s),this._snapClampSetValue(s+r)}i=e.clientY},l=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",a),window.removeEventListener("mouseup",l)};this.$input.addEventListener("input",(()=>{let e=parseFloat(this.$input.value);isNaN(e)||(this._stepExplicit&&(e=this._snap(e)),this.setValue(this._clamp(e)))})),this.$input.addEventListener("keydown",(t=>{"Enter"===t.key&&this.$input.blur(),"ArrowUp"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t))),"ArrowDown"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t)*-1))})),this.$input.addEventListener("wheel",(t=>{this._inputFocused&&(t.preventDefault(),e(this._step*this._normalizeMouseWheel(t)))}),{passive:!1}),this.$input.addEventListener("mousedown",(e=>{t=e.clientX,n=i=e.clientY,o=!0,s=this.getValue(),r=0,window.addEventListener("mousemove",a),window.addEventListener("mouseup",l)})),this.$input.addEventListener("focus",(()=>{this._inputFocused=!0})),this.$input.addEventListener("blur",(()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()}))}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const e=e=>{const t=this.$slider.getBoundingClientRect();let n=((e,t,n,i,s)=>(e-t)/(n-t)*(this._max-i)+i)(e,t.left,t.right,this._min);this._snapClampSetValue(n)},t=t=>{e(t.clientX)},n=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",t),window.removeEventListener("mouseup",n)};let i,s,r=!1;const o=t=>{t.preventDefault(),this._setDraggingStyle(!0),e(t.touches[0].clientX),r=!1},a=t=>{if(r){const e=t.touches[0].clientX-i,n=t.touches[0].clientY-s;Math.abs(e)>Math.abs(n)?o(t):(window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l))}else t.preventDefault(),e(t.touches[0].clientX)},l=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l)},c=this._callOnFinishChange.bind(this);let u;this.$slider.addEventListener("mousedown",(i=>{this._setDraggingStyle(!0),e(i.clientX),window.addEventListener("mousemove",t),window.addEventListener("mouseup",n)})),this.$slider.addEventListener("touchstart",(e=>{e.touches.length>1||(this._hasScrollBar?(i=e.touches[0].clientX,s=e.touches[0].clientY,r=!0):o(e),window.addEventListener("touchmove",a,{passive:!1}),window.addEventListener("touchend",l))}),{passive:!1}),this.$slider.addEventListener("wheel",(e=>{if(Math.abs(e.deltaX)<Math.abs(e.deltaY)&&this._hasScrollBar)return;e.preventDefault();const t=this._normalizeMouseWheel(e)*this._step;this._snapClampSetValue(this.getValue()+t),this.$input.value=this.getValue(),clearTimeout(u),u=setTimeout(c,400)}),{passive:!1})}_setDraggingStyle(e,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",e),document.body.classList.toggle("lil-gui-dragging",e),document.body.classList.toggle(`lil-gui-${t}`,e)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(e){let{deltaX:t,deltaY:n}=e;return Math.floor(e.deltaY)!==e.deltaY&&e.wheelDelta&&(t=0,n=-e.wheelDelta/120,n*=this._stepExplicit?1:10),t+-n}_arrowKeyMultiplier(e){let t=this._stepExplicit?1:10;return e.shiftKey?t*=10:e.altKey&&(t/=10),t}_snap(e){const t=Math.round(e/this._step)*this._step;return parseFloat(t.toPrecision(15))}_clamp(e){return e<this._min&&(e=this._min),e>this._max&&(e=this._max),e}_snapClampSetValue(e){this.setValue(this._clamp(this._snap(e)))}get _hasScrollBar(){const e=this.parent.root.$children;return e.scrollHeight>e.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class xt extends ct{constructor(e,t,n,i){super(e,t,n,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$select.addEventListener("change",(()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()})),this.$select.addEventListener("focus",(()=>{this.$display.classList.add("focus")})),this.$select.addEventListener("blur",(()=>{this.$display.classList.remove("focus")})),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.options(i)}options(e){return this._values=Array.isArray(e)?e:Object.values(e),this._names=Array.isArray(e)?e:Object.keys(e),this.$select.replaceChildren(),this._names.forEach((e=>{const t=document.createElement("option");t.textContent=e,this.$select.appendChild(t)})),this.updateDisplay(),this}updateDisplay(){const e=this.getValue(),t=this._values.indexOf(e);return this.$select.selectedIndex=t,this.$display.textContent=-1===t?e:this._names[t],this}}class wt extends ct{constructor(e,t,n){super(e,t,n,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("spellcheck","false"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",(()=>{this.setValue(this.$input.value)})),this.$input.addEventListener("keydown",(e=>{"Enter"===e.code&&this.$input.blur()})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let _t=!1;class bt{constructor({parent:e,autoPlace:t=void 0===e,container:n,width:i,title:s="Controls",closeFolders:r=!1,injectStyles:o=!0,touchStyles:a=!0}={}){if(this.parent=e,this.root=e?e.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",(()=>this.openAnimated(this._closed))),this.$title.addEventListener("keydown",(e=>{"Enter"!==e.code&&"Space"!==e.code||(e.preventDefault(),this.$title.click())})),this.$title.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(s),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add("root"),a&&this.domElement.classList.add("allow-touch-styles"),!_t&&o&&(function(e){const t=document.createElement("style");t.innerHTML='.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;\n  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n  background: var(--background-color);\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller > .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: " ";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: "lil-gui";\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-dragging .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-dragging * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui-dragging.lil-gui-vertical * {\n  cursor: ns-resize !important;\n}\n\n.lil-gui .title {\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: "lil-gui";\n  content: "";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  body:not(.lil-gui-dragging) .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: "";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: "Empty";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui label, .lil-gui input, .lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n}\n.lil-gui input {\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input:disabled {\n  opacity: 1;\n}\n.lil-gui input[type=text],\n.lil-gui input[type=number] {\n  padding: var(--widget-padding);\n  -moz-appearance: textfield;\n}\n.lil-gui input[type=text]:focus,\n.lil-gui input[type=number]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  width: var(--checkbox-size);\n  height: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n  cursor: pointer;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: "lil-gui";\n  content: "";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: none;\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: "lil-gui";\n  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");\n}';const n=document.querySelector("head link[rel=stylesheet], head style");n?document.head.insertBefore(t,n):document.head.appendChild(t)}(),_t=!0),n?n.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),i&&this.domElement.style.setProperty("--width",i+"px"),this._closeFolders=r}add(e,t,n,i,s){if(Object(n)===n)return new xt(this,e,t,n);const r=e[t];switch(typeof r){case"number":return new yt(this,e,t,n,i,s);case"boolean":return new ut(this,e,t);case"string":return new wt(this,e,t);case"function":return new vt(this,e,t)}console.error("gui.add failed\n\tproperty:",t,"\n\tobject:",e,"\n\tvalue:",r)}addColor(e,t,n=1){return new gt(this,e,t,n)}addFolder(e){const t=new bt({parent:this,title:e});return this.root._closeFolders&&t.close(),t}load(e,t=!0){return e.controllers&&this.controllers.forEach((t=>{t instanceof vt||t._name in e.controllers&&t.load(e.controllers[t._name])})),t&&e.folders&&this.folders.forEach((t=>{t._title in e.folders&&t.load(e.folders[t._title])})),this}save(e=!0){const t={controllers:{},folders:{}};return this.controllers.forEach((e=>{if(!(e instanceof vt)){if(e._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${e._name}"`);t.controllers[e._name]=e.save()}})),e&&this.folders.forEach((e=>{if(e._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${e._title}"`);t.folders[e._title]=e.save()})),t}open(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(e){this._closed!==e&&(this._closed=e,this._callOnOpenClose(this))}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame((()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const n=e=>{e.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",n))};this.$children.addEventListener("transitionend",n);const i=e?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!e),requestAnimationFrame((()=>{this.$children.style.height=i+"px"}))})),this}title(e){return this._title=e,this.$title.textContent=e,this}reset(e=!0){return(e?this.controllersRecursive():this.controllers).forEach((e=>e.reset())),this}onChange(e){return this._onChange=e,this}_callOnChange(e){this.parent&&this.parent._callOnChange(e),void 0!==this._onChange&&this._onChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(e){this.parent&&this.parent._callOnFinishChange(e),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onOpenClose(e){return this._onOpenClose=e,this}_callOnOpenClose(e){this.parent&&this.parent._callOnOpenClose(e),void 0!==this._onOpenClose&&this._onOpenClose.call(this,e)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach((e=>e.destroy()))}controllersRecursive(){let e=Array.from(this.controllers);return this.folders.forEach((t=>{e=e.concat(t.controllersRecursive())})),e}foldersRecursive(){let e=Array.from(this.folders);return this.folders.forEach((t=>{e=e.concat(t.foldersRecursive())})),e}}const kt=bt,At=async e=>{const t=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\n//@group(0) @binding(2) var debugTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n}\n\n@vertex\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}\n\nfn get_debug_colour(index : i32) -> vec4<f32> {\n  if(index < 0){\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n  }\n\n  let colours = array(\n    vec4<f32>(1.0, 0.0, 0.0, 1.0),\n    vec4<f32>(0.0, 1.0, 0.0, 1.0),\n    vec4<f32>(0.0, 0.0, 1.0, 1.0),\n    vec4<f32>(1.0, 1.0, 0.0, 1.0),\n    vec4<f32>(1.0, 0.0, 1.0, 1.0),\n    vec4<f32>(0.0, 1.0, 1.0, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  );\n  return colours[index % 8];\n}\n\n@fragment\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\n    let pixel = fragUV * vec2<f32>(textureDimensions(myTexture));\n    var colour = textureLoad(myTexture, vec2<u32>(pixel),0);\n    return colour;\n//    return colour;\n//    return abs(colour) % 8.0 * 0.125;\n//    return colour.gggg * 0.5;\n//    return (colour.rrrr * 500.0 % 1.0);\n//    return get_debug_colour(i32(colour.a));\n}\n"}),n=e.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vertex_main"},fragment:{module:t,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]}});return{render:t=>{const i=t.commandEncoder.beginRenderPass({timestampWrites:t.timestampWrites,colorAttachments:[{view:Ks.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]}),s=e.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:1,resource:t.outputTextures.finalTexture.view}]});i.setPipeline(n),i.setBindGroup(0,s),i.draw(6),i.end()},label:"fullscreen quad"}};var Et;!function(e){const t=[];e.updateAll=e=>{for(const n of t)n.update(e)},e.register=e=>class extends e{constructor(...e){super(...e),t.push(this)}}}(Et||(Et={}));const St={duration:.3,delay:0,endDelay:0,repeat:0,easing:"ease"},Tt=e=>1e3*e,Mt=e=>e/1e3,Pt=()=>{},zt=e=>e;function Ct(e,t=!0){if(e&&"finished"!==e.playState)try{e.stop?e.stop():(t&&e.commitStyles(),e.cancel())}catch(e){}}const It=e=>e(),Bt=(e,t,n=St.duration)=>new Proxy({animations:e.map(It).filter(Boolean),duration:n,options:t},Ot),Ot={get:(e,t)=>{const n=e.animations[0];switch(t){case"duration":return e.duration;case"currentTime":return Mt((null==n?void 0:n[t])||0);case"playbackRate":case"playState":return null==n?void 0:n[t];case"finished":return e.finished||(e.finished=Promise.all(e.animations.map(Nt)).catch(Pt)),e.finished;case"stop":return()=>{e.animations.forEach((e=>Ct(e)))};case"forEachNative":return t=>{e.animations.forEach((n=>t(n,e)))};default:return void 0===(null==n?void 0:n[t])?void 0:()=>e.animations.forEach((e=>e[t]()))}},set:(e,t,n)=>{switch(t){case"currentTime":n=Tt(n);case"playbackRate":for(let i=0;i<e.animations.length;i++)e.animations[i][t]=n;return!0}return!1}},Nt=e=>e.finished,Rt=e=>"object"==typeof e&&Boolean(e.createAnimation),Ut=e=>"number"==typeof e,Ft=e=>Array.isArray(e)&&!Ut(e[0]),Dt=(e,t,n)=>-n*e+n*t+e,Lt=(e,t,n)=>t-e==0?1:(n-e)/(t-e);function qt(e,t){const n=e[e.length-1];for(let i=1;i<=t;i++){const s=Lt(0,t,i);e.push(Dt(n,1,s))}}const jt=(e,t,n)=>Math.min(Math.max(n,e),t);const Vt=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e,Gt=1e-7,$t=12;function Ht(e,t,n,i){if(e===t&&n===i)return zt;return s=>0===s||1===s?s:Vt(function(e,t,n,i,s){let r,o,a=0;do{o=t+(n-t)/2,r=Vt(o,i,s)-e,r>0?n=o:t=o}while(Math.abs(r)>Gt&&++a<$t);return o}(s,0,1,e,n),t,i)}const Wt=e=>"function"==typeof e,Yt=e=>Array.isArray(e)&&Ut(e[0]),Xt={ease:Ht(.25,.1,.25,1),"ease-in":Ht(.42,0,1,1),"ease-in-out":Ht(.42,0,.58,1),"ease-out":Ht(0,0,.58,1)},Zt=/\((.*?)\)/;function Kt(e){if(Wt(e))return e;if(Yt(e))return Ht(...e);if(Xt[e])return Xt[e];if(e.startsWith("steps")){const t=Zt.exec(e);if(t){const e=t[1].split(",");return((e,t="end")=>n=>{const i=(n="end"===t?Math.min(n,.999):Math.max(n,.001))*e,s="end"===t?Math.floor(i):Math.ceil(i);return jt(0,1,s/e)})(parseFloat(e[0]),e[1].trim())}}return zt}class Qt{constructor(e,t=[0,1],{easing:n,duration:i=St.duration,delay:s=St.delay,endDelay:r=St.endDelay,repeat:o=St.repeat,offset:a,direction:l="normal",autoplay:c=!0}={}){if(this.startTime=null,this.rate=1,this.t=0,this.cancelTimestamp=null,this.easing=zt,this.duration=0,this.totalDuration=0,this.repeat=0,this.playState="idle",this.finished=new Promise(((e,t)=>{this.resolve=e,this.reject=t})),n=n||St.easing,Rt(n)){const e=n.createAnimation(t);n=e.easing,t=e.keyframes||t,i=e.duration||i}this.repeat=o,this.easing=Ft(n)?zt:Kt(n),this.updateDuration(i);const u=function(e,t=function(e){const t=[0];return qt(t,e-1),t}(e.length),n=zt){const i=e.length,s=i-t.length;return s>0&&qt(t,s),s=>{let r=0;for(;r<i-2&&!(s<t[r+1]);r++);let o=jt(0,1,Lt(t[r],t[r+1],s));const a=function(e,t){return Ft(e)?e[((e,t,n)=>{const i=t-e;return((n-e)%i+i)%i+e})(0,e.length,t)]:e}(n,r);return o=a(o),Dt(e[r],e[r+1],o)}}(t,a,Ft(n)?n.map(Kt):zt);this.tick=t=>{var n;let i=0;i=void 0!==this.pauseTime?this.pauseTime:(t-this.startTime)*this.rate,this.t=i,i/=1e3,i=Math.max(i-s,0),"finished"===this.playState&&void 0===this.pauseTime&&(i=this.totalDuration);const o=i/this.duration;let a=Math.floor(o),c=o%1;!c&&o>=1&&(c=1),1===c&&a--;const h=a%2;("reverse"===l||"alternate"===l&&h||"alternate-reverse"===l&&!h)&&(c=1-c);const d=i>=this.totalDuration?1:Math.min(c,1),p=u(this.easing(d));e(p),void 0===this.pauseTime&&("finished"===this.playState||i>=this.totalDuration+r)?(this.playState="finished",null===(n=this.resolve)||void 0===n||n.call(this,p)):"idle"!==this.playState&&(this.frameRequestId=requestAnimationFrame(this.tick))},c&&this.play()}play(){const e=performance.now();this.playState="running",void 0!==this.pauseTime?this.startTime=e-this.pauseTime:this.startTime||(this.startTime=e),this.cancelTimestamp=this.startTime,this.pauseTime=void 0,this.frameRequestId=requestAnimationFrame(this.tick)}pause(){this.playState="paused",this.pauseTime=this.t}finish(){this.playState="finished",this.tick(0)}stop(){var e;this.playState="idle",void 0!==this.frameRequestId&&cancelAnimationFrame(this.frameRequestId),null===(e=this.reject)||void 0===e||e.call(this,!1)}cancel(){this.stop(),this.tick(this.cancelTimestamp)}reverse(){this.rate*=-1}commitStyles(){}updateDuration(e){this.duration=e,this.totalDuration=e*(this.repeat+1)}get currentTime(){return this.t}set currentTime(e){void 0!==this.pauseTime||0===this.rate?this.pauseTime=e:this.startTime=performance.now()-e/this.rate}get playbackRate(){return this.rate}set playbackRate(e){this.rate=e}}class Jt{setAnimation(e){this.animation=e,null==e||e.finished.then((()=>this.clearAnimation())).catch((()=>{}))}clearAnimation(){this.animation=this.generator=void 0}}const en=new WeakMap;function tn(e){return en.has(e)||en.set(e,{transforms:[],values:new Map}),en.get(e)}const nn=["","X","Y","Z"],sn={x:"translateX",y:"translateY",z:"translateZ"},rn={syntax:"<angle>",initialValue:"0deg",toDefaultUnit:e=>e+"deg"},on={translate:{syntax:"<length-percentage>",initialValue:"0px",toDefaultUnit:e=>e+"px"},rotate:rn,scale:{syntax:"<number>",initialValue:1,toDefaultUnit:zt},skew:rn},an=new Map,ln=e=>`--motion-${e}`,cn=["x","y","z"];["translate","scale","rotate","skew"].forEach((e=>{nn.forEach((t=>{cn.push(e+t),an.set(ln(e+t),on[e])}))}));const un=(e,t)=>cn.indexOf(e)-cn.indexOf(t),hn=new Set(cn),dn=e=>hn.has(e),pn=e=>e.sort(un).reduce(fn,"").trim(),fn=(e,t)=>`${e} ${t}(var(${ln(t)}))`,mn=e=>e.startsWith("--"),gn=new Set,vn=(e,t)=>document.createElement("div").animate(e,t),yn={cssRegisterProperty:()=>"undefined"!=typeof CSS&&Object.hasOwnProperty.call(CSS,"registerProperty"),waapi:()=>Object.hasOwnProperty.call(Element.prototype,"animate"),partialKeyframes:()=>{try{vn({opacity:[1]})}catch(e){return!1}return!0},finished:()=>Boolean(vn({opacity:[0,1]},{duration:.001}).finished),linearEasing:()=>{try{vn({opacity:0},{easing:"linear(0, 1)"})}catch(e){return!1}return!0}},xn={},wn={};for(const e in yn)wn[e]=()=>(void 0===xn[e]&&(xn[e]=yn[e]()),xn[e]);const _n=(e,t)=>Wt(e)?wn.linearEasing()?`linear(${((e,t)=>{let n="";const i=Math.round(t/.015);for(let t=0;t<i;t++)n+=e(Lt(0,i-1,t))+", ";return n.substring(0,n.length-2)})(e,t)})`:St.easing:Yt(e)?bn(e):e,bn=([e,t,n,i])=>`cubic-bezier(${e}, ${t}, ${n}, ${i})`;function kn(e){return sn[e]&&(e=sn[e]),dn(e)?ln(e):e}const An=(e,t)=>{t=kn(t);let n=mn(t)?e.style.getPropertyValue(t):getComputedStyle(e)[t];if(!n&&0!==n){const e=an.get(t);e&&(n=e.initialValue)}return n},En=(e,t,n)=>{t=kn(t),mn(t)?e.style.setProperty(t,n):e.style[t]=n},Sn=e=>"string"==typeof e;function Tn(e,t){var n;let i=(null==t?void 0:t.toDefaultUnit)||zt;const s=e[e.length-1];if(Sn(s)){const e=(null===(n=s.match(/(-?[\d.]+)([a-z%]*)/))||void 0===n?void 0:n[2])||"";e&&(i=t=>t+e)}return i}function Mn(e,t,n,i={},s){const r=window.__MOTION_DEV_TOOLS_RECORD,o=!1!==i.record&&r;let a,{duration:l=St.duration,delay:c=St.delay,endDelay:u=St.endDelay,repeat:h=St.repeat,easing:d=St.easing,persist:p=!1,direction:f,offset:m,allowWebkitAcceleration:g=!1,autoplay:v=!0}=i;const y=tn(e),x=dn(t);let w=wn.waapi();x&&((e,t)=>{sn[t]&&(t=sn[t]);const{transforms:n}=tn(e);var i,s;s=t,-1===(i=n).indexOf(s)&&i.push(s),e.style.transform=pn(n)})(e,t);const _=kn(t),b=function(e,t){return e.has(t)||e.set(t,new Jt),e.get(t)}(y.values,_),k=an.get(_);return Ct(b.animation,!(Rt(d)&&b.generator)&&!1!==i.record),()=>{const y=()=>{var t,n;return null!==(n=null!==(t=An(e,_))&&void 0!==t?t:null==k?void 0:k.initialValue)&&void 0!==n?n:0};let A=function(e,t){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=n?e[n-1]:t());return e}((e=>Array.isArray(e)?e:[e])(n),y);const E=Tn(A,k);if(Rt(d)){const e=d.createAnimation(A,"opacity"!==t,y,_,b);d=e.easing,A=e.keyframes||A,l=e.duration||l}if(mn(_)&&(wn.cssRegisterProperty()?function(e){if(!gn.has(e)){gn.add(e);try{const{syntax:t,initialValue:n}=an.has(e)?an.get(e):{};CSS.registerProperty({name:e,inherits:!1,syntax:t,initialValue:n})}catch(e){}}}(_):w=!1),x&&!wn.linearEasing()&&(Wt(d)||Ft(d)&&d.some(Wt))&&(w=!1),w){k&&(A=A.map((e=>Ut(e)?k.toDefaultUnit(e):e))),1!==A.length||wn.partialKeyframes()&&!o||A.unshift(y());const t={delay:Tt(c),duration:Tt(l),endDelay:Tt(u),easing:Ft(d)?void 0:_n(d,l),direction:f,iterations:h+1,fill:"both"};a=e.animate({[_]:A,offset:m,easing:Ft(d)?d.map((e=>_n(e,l))):void 0},t),a.finished||(a.finished=new Promise(((e,t)=>{a.onfinish=e,a.oncancel=t})));const n=A[A.length-1];a.finished.then((()=>{p||(En(e,_,n),a.cancel())})).catch(Pt),g||(a.playbackRate=1.000001)}else if(s&&x)A=A.map((e=>"string"==typeof e?parseFloat(e):e)),1===A.length&&A.unshift(parseFloat(y())),a=new s((t=>{En(e,_,E?E(t):t)}),A,Object.assign(Object.assign({},i),{duration:l,easing:d}));else{const t=A[A.length-1];En(e,_,k&&Ut(t)?k.toDefaultUnit(t):t)}return o&&r(e,t,A,{duration:l,delay:c,easing:d,repeat:h,offset:m},"motion-one"),b.setAnimation(a),a&&!v&&a.pause(),a}}const Pn=(e,t)=>e[t]?Object.assign(Object.assign({},e),e[t]):Object.assign({},e);function zn(e,t,n){return Wt(e)?e(t,n):e}const Cn=(In=Qt,function(e,t,n={}){const i=(e=function(e,t){return"string"==typeof e?e=document.querySelectorAll(e):e instanceof Element&&(e=[e]),Array.from(e||[])}(e)).length;Boolean(i),Boolean(t);const s=[];for(let r=0;r<i;r++){const o=e[r];for(const e in t){const a=Pn(n,e);a.delay=zn(a.delay,r,i);const l=Mn(o,e,t[e],a,In);s.push(l)}}return Bt(s,n,n.duration)});var In;function Bn(e,t={}){return Bt([()=>{const n=new Qt(e,[0,1],t);return n.finished.catch((()=>{})),n}],t,t.duration)}function On(e,t,n){return(Wt(e)?Bn:Cn)(e,t,n)}function Nn(e,t,n){const i=Math.max(t-5,0);return s=n-e(i),(r=t-i)?s*(1e3/r):0;var s,r}function Rn(e){return Ut(e)&&!isNaN(e)}function Un(e){return Sn(e)?parseFloat(e):e}const Fn=function(e){const t=new WeakMap;return(e={})=>{const n=new Map,i=(t=0,i=100,s=0,r=!1)=>{const o=`${t}-${i}-${s}-${r}`;return n.has(o)||n.set(o,(({from:e=0,velocity:t=0,power:n=.8,decay:i=.325,bounceDamping:s,bounceStiffness:r,changeTarget:o,min:a,max:l,restDistance:c=.5,restSpeed:u})=>{i=Tt(i);const h={hasReachedTarget:!1,done:!1,current:e,target:e},d=e=>void 0===a?l:void 0===l||Math.abs(a-e)<Math.abs(l-e)?a:l;let p=n*t;const f=e+p,m=void 0===o?f:o(f);h.target=m,m!==f&&(p=m-e);const g=e=>-p*Math.exp(-e/i),v=e=>m+g(e),y=e=>{const t=g(e),n=v(e);h.done=Math.abs(t)<=c,h.current=h.done?m:n};let x,w;const _=e=>{var t;t=h.current,(void 0!==a&&t<a||void 0!==l&&t>l)&&(x=e,w=(({stiffness:e=100,damping:t=10,mass:n=1,from:i=0,to:s=1,velocity:r=0,restSpeed:o,restDistance:a}={})=>{r=r?Mt(r):0;const l={done:!1,hasReachedTarget:!1,current:i,target:s},c=s-i,u=Math.sqrt(e/n)/1e3,h=((e=100,t=10,n=1)=>t/(2*Math.sqrt(e*n)))(e,t,n),d=Math.abs(c)<5;let p;if(o||(o=d?.01:2),a||(a=d?.005:.5),h<1){const e=u*Math.sqrt(1-h*h);p=t=>s-Math.exp(-h*u*t)*((h*u*c-r)/e*Math.sin(e*t)+c*Math.cos(e*t))}else p=e=>s-Math.exp(-u*e)*(c+(u*c-r)*e);return e=>{l.current=p(e);const t=0===e?r:Nn(p,e,l.current),n=Math.abs(t)<=o,c=Math.abs(s-l.current)<=a;var u,h,d;return l.done=n&&c,l.hasReachedTarget=(u=i,h=s,d=l.current,u<h&&d>=h||u>h&&d<=h),l}})({from:h.current,to:d(h.current),velocity:Nn(v,e,h.current),damping:s,stiffness:r,restDistance:c,restSpeed:u}))};return _(0),e=>{let t=!1;return w||void 0!==x||(t=!0,y(e),_(e)),void 0!==x&&e>x?(h.hasReachedTarget=!0,w(e-x)):(h.hasReachedTarget=!1,!t&&y(e),h)}})(Object.assign({from:t,to:i,velocity:s},e))),n.get(o)},s=(e,n)=>(t.has(e)||t.set(e,function(e,t=zt){let n,i=10,s=e(0);const r=[t(s.current)];for(;!s.done&&i<1e4;)s=e(i),r.push(t(s.done?s.target:s.current)),void 0===n&&s.hasReachedTarget&&(n=i),i+=10;const o=i-10;return 1===r.length&&r.push(s.current),{keyframes:r,duration:o/1e3,overshootDuration:(null!=n?n:o)/1e3}}(e,n)),t.get(e));return{createAnimation:(e,t=!0,n,r,o)=>{let a,l,c,u=0,h=zt;const d=e.length;if(t)if(h=Tn(e,r?an.get(kn(r)):void 0),c=Un(e[d-1]),d>1&&null!==e[0])l=Un(e[0]);else{const e=null==o?void 0:o.generator;if(e){const{animation:t,generatorStartTime:n}=o,i=(null==t?void 0:t.startTime)||n||0,s=(null==t?void 0:t.currentTime)||performance.now()-i,r=e(s).current;l=r,u=Nn((t=>e(t).current),s,r)}else n&&(l=Un(n()))}if(Rn(l)&&Rn(c)){const e=i(l,c,u,null==r?void 0:r.includes("scale"));a=Object.assign(Object.assign({},s(e,h)),{easing:"linear"}),o&&(o.generator=e,o.generatorStartTime=performance.now())}return a||(a={easing:"ease",duration:s(i(0,100)).overshootDuration}),a}}}}();var Dn=function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};let Ln=class{value;target;constructor(e){this.value=e,this.target=e}update(){On((e=>{this.value=te.lerp(this.value,this.target,e)}),{easing:Fn({velocity:2e-4*sr})})}};Ln=Dn([Et.register],Ln);let qn=class{value;target;constructor(e){this.value=e,this.target=e}update(){On((e=>{this.value=this.value+(this.target-this.value)*e}),{easing:Fn({velocity:2e-4*sr})})}};qn=Dn([Et.register],qn);let jn=class{value;target;constructor(e){this.value=e,this.target=e}update(){On((e=>{this.value=je.slerp(this.value,this.target,e)}),{easing:Fn({velocity:2e-4*sr})})}};jn=Dn([Et.register],jn);const Vn=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength,Gn={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array},bool:{numElements:0,align:1,size:0,type:"bool",View:Uint32Array}},$n={...Gn,"atomic<i32>":Gn.i32,"atomic<u32>":Gn.u32,"vec2<i32>":Gn.vec2i,"vec2<u32>":Gn.vec2u,"vec2<f32>":Gn.vec2f,"vec2<f16>":Gn.vec2h,"vec3<i32>":Gn.vec3i,"vec3<u32>":Gn.vec3u,"vec3<f32>":Gn.vec3f,"vec3<f16>":Gn.vec3h,"vec4<i32>":Gn.vec4i,"vec4<u32>":Gn.vec4u,"vec4<f32>":Gn.vec4f,"vec4<f16>":Gn.vec4h,"mat2x2<f32>":Gn.mat2x2f,"mat2x2<f16>":Gn.mat2x2h,"mat3x2<f32>":Gn.mat3x2f,"mat3x2<f16>":Gn.mat3x2h,"mat4x2<f32>":Gn.mat4x2f,"mat4x2<f16>":Gn.mat4x2h,"mat2x3<f32>":Gn.mat2x3f,"mat2x3<f16>":Gn.mat2x3h,"mat3x3<f32>":Gn.mat3x3f,"mat3x3<f16>":Gn.mat3x3h,"mat4x3<f32>":Gn.mat4x3f,"mat4x3<f16>":Gn.mat4x3h,"mat2x4<f32>":Gn.mat2x4f,"mat2x4<f16>":Gn.mat2x4h,"mat3x4<f32>":Gn.mat3x4f,"mat3x4<f16>":Gn.mat3x4h,"mat4x4<f32>":Gn.mat4x4f,"mat4x4<f16>":Gn.mat4x4h},Hn=(Wn=$n,Object.keys(Wn));var Wn,Yn,Xn,Zn,Kn,Qn;!function(e=[],t){const n=new Set;for(const i of Hn){const s=$n[i];n.has(s)||(n.add(s),s.flatten=e.includes(i)?t:!t)}}(),new WeakMap;class Jn{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class ei{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(ti.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(ni.instance)}}}class ti extends ei{}ti.instance=new ti;class ni extends ei{}ni.instance=new ni;class ii extends ei{constructor(){super()}}class si extends ii{constructor(e,t,n,i){super(),this.name=e,this.args=t,this.returnType=n,this.body=i}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}}class ri extends ii{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class oi extends ii{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class ai extends ii{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class li extends ii{constructor(e,t,n,i){super(),this.init=e,this.condition=t,this.increment=n,this.body=i}get astNodeType(){return"for"}search(e){var t,n,i;null===(t=this.init)||void 0===t||t.search(e),null===(n=this.condition)||void 0===n||n.search(e),null===(i=this.increment)||void 0===i||i.search(e),this.searchBlock(this.body,e)}}class ci extends ii{constructor(e,t,n,i,s){super(),this.name=e,this.type=t,this.storage=n,this.access=i,this.value=s}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class ui extends ii{constructor(e,t,n){super(),this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class hi extends ii{constructor(e,t,n,i,s){super(),this.name=e,this.type=t,this.storage=n,this.access=i,this.value=s}get astNodeType(){return"let"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class di extends ii{constructor(e,t,n,i,s){super(),this.name=e,this.type=t,this.storage=n,this.access=i,this.value=s}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}!function(e){e.increment="++",e.decrement="--"}(Yn||(Yn={})),function(e){e.parse=function(t){const n=t;if("parse"==n)throw new Error("Invalid value for IncrementOperator");return e[n]}}(Yn||(Yn={}));class pi extends ii{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(Xn||(Xn={})),function(e){e.parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t}}(Xn||(Xn={}));class fi extends ii{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.value.search(e)}}class mi extends ii{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}}class gi extends ii{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class vi extends ii{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class yi extends ii{constructor(e,t,n,i){super(),this.condition=e,this.body=t,this.elseif=n,this.else=i}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class xi extends ii{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class wi extends ii{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class _i extends ii{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class bi extends ii{constructor(){super()}get astNodeType(){return"discard"}}class ki extends ii{constructor(){super()}get astNodeType(){return"break"}}class Ai extends ii{constructor(){super()}get astNodeType(){return"continue"}}class Ei extends ii{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class Si extends Ei{constructor(e,t){super(e),this.members=t}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class Ti extends Ei{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}}class Mi extends Ei{constructor(e,t,n,i){super(e),this.storage=t,this.type=n,this.access=i}get astNodeType(){return"pointer"}}class Pi extends Ei{constructor(e,t,n,i){super(e),this.attributes=t,this.format=n,this.count=i}get astNodeType(){return"array"}get isArray(){return!0}}class zi extends Ei{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}}class Ci extends ei{constructor(){super()}}class Ii extends Ci{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class Bi extends Ci{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}}class Oi extends Ci{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class Ni extends Ci{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this)}}class Ri extends Ci{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,n;if(this.initializer instanceof Bi){const i=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),s=null===(n=this.initializer.type)||void 0===n?void 0:n.name,r=e.structs.get(s),o=null==r?void 0:r.getMemberIndex(i);if(-1!=o)return this.initializer.args[o].evaluate(e);console.log(o)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class Ui extends Ci{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class Fi extends Ci{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class Di extends Ci{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}}class Li extends Ci{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class qi extends Ci{constructor(){super()}}class ji extends qi{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}}class Vi extends qi{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class Gi extends ei{constructor(){super()}}class $i extends Gi{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class Hi extends Gi{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class Wi extends ei{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}}class Yi extends ei{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Xi extends ei{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}}class Zi extends ei{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(Kn||(Kn={}));class Ki{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class Qi{}Zn=Qi,Qi.none=new Ki("",Kn.reserved,""),Qi.eof=new Ki("EOF",Kn.token,""),Qi.reserved={asm:new Ki("asm",Kn.reserved,"asm"),bf16:new Ki("bf16",Kn.reserved,"bf16"),do:new Ki("do",Kn.reserved,"do"),enum:new Ki("enum",Kn.reserved,"enum"),f16:new Ki("f16",Kn.reserved,"f16"),f64:new Ki("f64",Kn.reserved,"f64"),handle:new Ki("handle",Kn.reserved,"handle"),i8:new Ki("i8",Kn.reserved,"i8"),i16:new Ki("i16",Kn.reserved,"i16"),i64:new Ki("i64",Kn.reserved,"i64"),mat:new Ki("mat",Kn.reserved,"mat"),premerge:new Ki("premerge",Kn.reserved,"premerge"),regardless:new Ki("regardless",Kn.reserved,"regardless"),typedef:new Ki("typedef",Kn.reserved,"typedef"),u8:new Ki("u8",Kn.reserved,"u8"),u16:new Ki("u16",Kn.reserved,"u16"),u64:new Ki("u64",Kn.reserved,"u64"),unless:new Ki("unless",Kn.reserved,"unless"),using:new Ki("using",Kn.reserved,"using"),vec:new Ki("vec",Kn.reserved,"vec"),void:new Ki("void",Kn.reserved,"void")},Qi.keywords={array:new Ki("array",Kn.keyword,"array"),atomic:new Ki("atomic",Kn.keyword,"atomic"),bool:new Ki("bool",Kn.keyword,"bool"),f32:new Ki("f32",Kn.keyword,"f32"),i32:new Ki("i32",Kn.keyword,"i32"),mat2x2:new Ki("mat2x2",Kn.keyword,"mat2x2"),mat2x3:new Ki("mat2x3",Kn.keyword,"mat2x3"),mat2x4:new Ki("mat2x4",Kn.keyword,"mat2x4"),mat3x2:new Ki("mat3x2",Kn.keyword,"mat3x2"),mat3x3:new Ki("mat3x3",Kn.keyword,"mat3x3"),mat3x4:new Ki("mat3x4",Kn.keyword,"mat3x4"),mat4x2:new Ki("mat4x2",Kn.keyword,"mat4x2"),mat4x3:new Ki("mat4x3",Kn.keyword,"mat4x3"),mat4x4:new Ki("mat4x4",Kn.keyword,"mat4x4"),ptr:new Ki("ptr",Kn.keyword,"ptr"),sampler:new Ki("sampler",Kn.keyword,"sampler"),sampler_comparison:new Ki("sampler_comparison",Kn.keyword,"sampler_comparison"),struct:new Ki("struct",Kn.keyword,"struct"),texture_1d:new Ki("texture_1d",Kn.keyword,"texture_1d"),texture_2d:new Ki("texture_2d",Kn.keyword,"texture_2d"),texture_2d_array:new Ki("texture_2d_array",Kn.keyword,"texture_2d_array"),texture_3d:new Ki("texture_3d",Kn.keyword,"texture_3d"),texture_cube:new Ki("texture_cube",Kn.keyword,"texture_cube"),texture_cube_array:new Ki("texture_cube_array",Kn.keyword,"texture_cube_array"),texture_multisampled_2d:new Ki("texture_multisampled_2d",Kn.keyword,"texture_multisampled_2d"),texture_storage_1d:new Ki("texture_storage_1d",Kn.keyword,"texture_storage_1d"),texture_storage_2d:new Ki("texture_storage_2d",Kn.keyword,"texture_storage_2d"),texture_storage_2d_array:new Ki("texture_storage_2d_array",Kn.keyword,"texture_storage_2d_array"),texture_storage_3d:new Ki("texture_storage_3d",Kn.keyword,"texture_storage_3d"),texture_depth_2d:new Ki("texture_depth_2d",Kn.keyword,"texture_depth_2d"),texture_depth_2d_array:new Ki("texture_depth_2d_array",Kn.keyword,"texture_depth_2d_array"),texture_depth_cube:new Ki("texture_depth_cube",Kn.keyword,"texture_depth_cube"),texture_depth_cube_array:new Ki("texture_depth_cube_array",Kn.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new Ki("texture_depth_multisampled_2d",Kn.keyword,"texture_depth_multisampled_2d"),texture_external:new Ki("texture_external",Kn.keyword,"texture_external"),u32:new Ki("u32",Kn.keyword,"u32"),vec2:new Ki("vec2",Kn.keyword,"vec2"),vec3:new Ki("vec3",Kn.keyword,"vec3"),vec4:new Ki("vec4",Kn.keyword,"vec4"),bitcast:new Ki("bitcast",Kn.keyword,"bitcast"),block:new Ki("block",Kn.keyword,"block"),break:new Ki("break",Kn.keyword,"break"),case:new Ki("case",Kn.keyword,"case"),continue:new Ki("continue",Kn.keyword,"continue"),continuing:new Ki("continuing",Kn.keyword,"continuing"),default:new Ki("default",Kn.keyword,"default"),discard:new Ki("discard",Kn.keyword,"discard"),else:new Ki("else",Kn.keyword,"else"),enable:new Ki("enable",Kn.keyword,"enable"),fallthrough:new Ki("fallthrough",Kn.keyword,"fallthrough"),false:new Ki("false",Kn.keyword,"false"),fn:new Ki("fn",Kn.keyword,"fn"),for:new Ki("for",Kn.keyword,"for"),function:new Ki("function",Kn.keyword,"function"),if:new Ki("if",Kn.keyword,"if"),let:new Ki("let",Kn.keyword,"let"),const:new Ki("const",Kn.keyword,"const"),loop:new Ki("loop",Kn.keyword,"loop"),while:new Ki("while",Kn.keyword,"while"),private:new Ki("private",Kn.keyword,"private"),read:new Ki("read",Kn.keyword,"read"),read_write:new Ki("read_write",Kn.keyword,"read_write"),return:new Ki("return",Kn.keyword,"return"),storage:new Ki("storage",Kn.keyword,"storage"),switch:new Ki("switch",Kn.keyword,"switch"),true:new Ki("true",Kn.keyword,"true"),alias:new Ki("alias",Kn.keyword,"alias"),type:new Ki("type",Kn.keyword,"type"),uniform:new Ki("uniform",Kn.keyword,"uniform"),var:new Ki("var",Kn.keyword,"var"),override:new Ki("override",Kn.keyword,"override"),workgroup:new Ki("workgroup",Kn.keyword,"workgroup"),write:new Ki("write",Kn.keyword,"write"),r8unorm:new Ki("r8unorm",Kn.keyword,"r8unorm"),r8snorm:new Ki("r8snorm",Kn.keyword,"r8snorm"),r8uint:new Ki("r8uint",Kn.keyword,"r8uint"),r8sint:new Ki("r8sint",Kn.keyword,"r8sint"),r16uint:new Ki("r16uint",Kn.keyword,"r16uint"),r16sint:new Ki("r16sint",Kn.keyword,"r16sint"),r16float:new Ki("r16float",Kn.keyword,"r16float"),rg8unorm:new Ki("rg8unorm",Kn.keyword,"rg8unorm"),rg8snorm:new Ki("rg8snorm",Kn.keyword,"rg8snorm"),rg8uint:new Ki("rg8uint",Kn.keyword,"rg8uint"),rg8sint:new Ki("rg8sint",Kn.keyword,"rg8sint"),r32uint:new Ki("r32uint",Kn.keyword,"r32uint"),r32sint:new Ki("r32sint",Kn.keyword,"r32sint"),r32float:new Ki("r32float",Kn.keyword,"r32float"),rg16uint:new Ki("rg16uint",Kn.keyword,"rg16uint"),rg16sint:new Ki("rg16sint",Kn.keyword,"rg16sint"),rg16float:new Ki("rg16float",Kn.keyword,"rg16float"),rgba8unorm:new Ki("rgba8unorm",Kn.keyword,"rgba8unorm"),rgba8unorm_srgb:new Ki("rgba8unorm_srgb",Kn.keyword,"rgba8unorm_srgb"),rgba8snorm:new Ki("rgba8snorm",Kn.keyword,"rgba8snorm"),rgba8uint:new Ki("rgba8uint",Kn.keyword,"rgba8uint"),rgba8sint:new Ki("rgba8sint",Kn.keyword,"rgba8sint"),bgra8unorm:new Ki("bgra8unorm",Kn.keyword,"bgra8unorm"),bgra8unorm_srgb:new Ki("bgra8unorm_srgb",Kn.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new Ki("rgb10a2unorm",Kn.keyword,"rgb10a2unorm"),rg11b10float:new Ki("rg11b10float",Kn.keyword,"rg11b10float"),rg32uint:new Ki("rg32uint",Kn.keyword,"rg32uint"),rg32sint:new Ki("rg32sint",Kn.keyword,"rg32sint"),rg32float:new Ki("rg32float",Kn.keyword,"rg32float"),rgba16uint:new Ki("rgba16uint",Kn.keyword,"rgba16uint"),rgba16sint:new Ki("rgba16sint",Kn.keyword,"rgba16sint"),rgba16float:new Ki("rgba16float",Kn.keyword,"rgba16float"),rgba32uint:new Ki("rgba32uint",Kn.keyword,"rgba32uint"),rgba32sint:new Ki("rgba32sint",Kn.keyword,"rgba32sint"),rgba32float:new Ki("rgba32float",Kn.keyword,"rgba32float"),static_assert:new Ki("static_assert",Kn.keyword,"static_assert")},Qi.tokens={decimal_float_literal:new Ki("decimal_float_literal",Kn.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new Ki("hex_float_literal",Kn.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new Ki("int_literal",Kn.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new Ki("uint_literal",Kn.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new Ki("ident",Kn.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new Ki("and",Kn.token,"&"),and_and:new Ki("and_and",Kn.token,"&&"),arrow:new Ki("arrow ",Kn.token,"->"),attr:new Ki("attr",Kn.token,"@"),attr_left:new Ki("attr_left",Kn.token,"[["),attr_right:new Ki("attr_right",Kn.token,"]]"),forward_slash:new Ki("forward_slash",Kn.token,"/"),bang:new Ki("bang",Kn.token,"!"),bracket_left:new Ki("bracket_left",Kn.token,"["),bracket_right:new Ki("bracket_right",Kn.token,"]"),brace_left:new Ki("brace_left",Kn.token,"{"),brace_right:new Ki("brace_right",Kn.token,"}"),colon:new Ki("colon",Kn.token,":"),comma:new Ki("comma",Kn.token,","),equal:new Ki("equal",Kn.token,"="),equal_equal:new Ki("equal_equal",Kn.token,"=="),not_equal:new Ki("not_equal",Kn.token,"!="),greater_than:new Ki("greater_than",Kn.token,">"),greater_than_equal:new Ki("greater_than_equal",Kn.token,">="),shift_right:new Ki("shift_right",Kn.token,">>"),less_than:new Ki("less_than",Kn.token,"<"),less_than_equal:new Ki("less_than_equal",Kn.token,"<="),shift_left:new Ki("shift_left",Kn.token,"<<"),modulo:new Ki("modulo",Kn.token,"%"),minus:new Ki("minus",Kn.token,"-"),minus_minus:new Ki("minus_minus",Kn.token,"--"),period:new Ki("period",Kn.token,"."),plus:new Ki("plus",Kn.token,"+"),plus_plus:new Ki("plus_plus",Kn.token,"++"),or:new Ki("or",Kn.token,"|"),or_or:new Ki("or_or",Kn.token,"||"),paren_left:new Ki("paren_left",Kn.token,"("),paren_right:new Ki("paren_right",Kn.token,")"),semicolon:new Ki("semicolon",Kn.token,";"),star:new Ki("star",Kn.token,"*"),tilde:new Ki("tilde",Kn.token,"~"),underscore:new Ki("underscore",Kn.token,"_"),xor:new Ki("xor",Kn.token,"^"),plus_equal:new Ki("plus_equal",Kn.token,"+="),minus_equal:new Ki("minus_equal",Kn.token,"-="),times_equal:new Ki("times_equal",Kn.token,"*="),division_equal:new Ki("division_equal",Kn.token,"/="),modulo_equal:new Ki("modulo_equal",Kn.token,"%="),and_equal:new Ki("and_equal",Kn.token,"&="),or_equal:new Ki("or_equal",Kn.token,"|="),xor_equal:new Ki("xor_equal",Kn.token,"^="),shift_right_equal:new Ki("shift_right_equal",Kn.token,">>="),shift_left_equal:new Ki("shift_left_equal",Kn.token,"<<=")},Qi.storage_class=[Zn.keywords.function,Zn.keywords.private,Zn.keywords.workgroup,Zn.keywords.uniform,Zn.keywords.storage],Qi.access_mode=[Zn.keywords.read,Zn.keywords.write,Zn.keywords.read_write],Qi.sampler_type=[Zn.keywords.sampler,Zn.keywords.sampler_comparison],Qi.sampled_texture_type=[Zn.keywords.texture_1d,Zn.keywords.texture_2d,Zn.keywords.texture_2d_array,Zn.keywords.texture_3d,Zn.keywords.texture_cube,Zn.keywords.texture_cube_array],Qi.multisampled_texture_type=[Zn.keywords.texture_multisampled_2d],Qi.storage_texture_type=[Zn.keywords.texture_storage_1d,Zn.keywords.texture_storage_2d,Zn.keywords.texture_storage_2d_array,Zn.keywords.texture_storage_3d],Qi.depth_texture_type=[Zn.keywords.texture_depth_2d,Zn.keywords.texture_depth_2d_array,Zn.keywords.texture_depth_cube,Zn.keywords.texture_depth_cube_array,Zn.keywords.texture_depth_multisampled_2d],Qi.texture_external_type=[Zn.keywords.texture_external],Qi.any_texture_type=[...Zn.sampled_texture_type,...Zn.multisampled_texture_type,...Zn.storage_texture_type,...Zn.depth_texture_type,...Zn.texture_external_type],Qi.texel_format=[Zn.keywords.r8unorm,Zn.keywords.r8snorm,Zn.keywords.r8uint,Zn.keywords.r8sint,Zn.keywords.r16uint,Zn.keywords.r16sint,Zn.keywords.r16float,Zn.keywords.rg8unorm,Zn.keywords.rg8snorm,Zn.keywords.rg8uint,Zn.keywords.rg8sint,Zn.keywords.r32uint,Zn.keywords.r32sint,Zn.keywords.r32float,Zn.keywords.rg16uint,Zn.keywords.rg16sint,Zn.keywords.rg16float,Zn.keywords.rgba8unorm,Zn.keywords.rgba8unorm_srgb,Zn.keywords.rgba8snorm,Zn.keywords.rgba8uint,Zn.keywords.rgba8sint,Zn.keywords.bgra8unorm,Zn.keywords.bgra8unorm_srgb,Zn.keywords.rgb10a2unorm,Zn.keywords.rg11b10float,Zn.keywords.rg32uint,Zn.keywords.rg32sint,Zn.keywords.rg32float,Zn.keywords.rgba16uint,Zn.keywords.rgba16sint,Zn.keywords.rgba16float,Zn.keywords.rgba32uint,Zn.keywords.rgba32sint,Zn.keywords.rgba32float],Qi.const_literal=[Zn.tokens.int_literal,Zn.tokens.uint_literal,Zn.tokens.decimal_float_literal,Zn.tokens.hex_float_literal,Zn.keywords.true,Zn.keywords.false],Qi.literal_or_ident=[Zn.tokens.ident,Zn.tokens.int_literal,Zn.tokens.uint_literal,Zn.tokens.decimal_float_literal,Zn.tokens.hex_float_literal],Qi.element_count_expression=[Zn.tokens.int_literal,Zn.tokens.uint_literal,Zn.tokens.ident],Qi.template_types=[Zn.keywords.vec2,Zn.keywords.vec3,Zn.keywords.vec4,Zn.keywords.mat2x2,Zn.keywords.mat2x3,Zn.keywords.mat2x4,Zn.keywords.mat3x2,Zn.keywords.mat3x3,Zn.keywords.mat3x4,Zn.keywords.mat4x2,Zn.keywords.mat4x3,Zn.keywords.mat4x4,Zn.keywords.atomic,Zn.keywords.bitcast,...Zn.any_texture_type],Qi.attribute_name=[Zn.tokens.ident,Zn.keywords.block],Qi.assignment_operators=[Zn.tokens.equal,Zn.tokens.plus_equal,Zn.tokens.minus_equal,Zn.tokens.times_equal,Zn.tokens.division_equal,Zn.tokens.modulo_equal,Zn.tokens.and_equal,Zn.tokens.or_equal,Zn.tokens.xor_equal,Zn.tokens.shift_right_equal,Zn.tokens.shift_left_equal],Qi.increment_operators=[Zn.tokens.plus_plus,Zn.tokens.minus_minus];class Ji{constructor(e,t,n){this.type=e,this.lexeme=t,this.line=n}toString(){return this.lexeme}isTemplateType(){return-1!=Qi.template_types.indexOf(this.type)}isArrayType(){return this.type==Qi.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class es{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new Ji(Qi.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}let t=Qi.none;for(;;){let n=this._findType(e);const i=this._peekAhead();if(">"==e&&(">"==i||"="==i)){let e=!1,t=this._tokens.length-1;for(let n=0;n<5&&t>=0;++n,--t)if(this._tokens[t].type===Qi.tokens.less_than){t>0&&this._tokens[t-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(n),!0}if(n===Qi.none){let i=e,s=0;const r=2;for(let e=0;e<r;++e)if(i+=this._peekAhead(e),n=this._findType(i),n!==Qi.none){s=e;break}if(n===Qi.none)return t!==Qi.none&&(this._current--,this._addToken(t),!0);e=i,this._current+=s+1}if(t=n,this._isAtEnd())break;e+=this._advance()}return t!==Qi.none&&(this._addToken(t),!0)}_findType(e){for(const t in Qi.keywords){const n=Qi.keywords[t];if(this._match(e,n.rule))return n}for(const t in Qi.tokens){const n=Qi.tokens[t];if(this._match(e,n.rule))return n}return Qi.none}_match(e,t){if("string"==typeof t){if(t==e)return!0}else{const n=t.exec(e);if(n&&0==n.index&&n[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new Ji(e,t,this._line))}}class ts{constructor(){this._tokens=[],this._current=0,this._context=new Jn}parse(e){this._initialize(e);let t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}return t}_initialize(e){if(e)if("string"==typeof e){const t=new es(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return console.error(e,t),{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==Qi.eof}_match(e){if(e instanceof Ki)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const n=e[t];if(this._check(n))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){let n=t.type;return-1!=e.indexOf(n)}return t.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(Qi.tokens.semicolon)&&!this._isAtEnd(););if(this._match(Qi.keywords.alias)){const e=this._type_alias();return this._consume(Qi.tokens.semicolon,"Expected ';'"),e}if(this._match(Qi.keywords.enable)){const e=this._enable_directive();return this._consume(Qi.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(Qi.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(Qi.tokens.semicolon,"Expected ';'."),t}if(this._check(Qi.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(Qi.tokens.semicolon,"Expected ';'."),t}if(this._check(Qi.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(Qi.tokens.semicolon,"Expected ';'."),t}if(this._check(Qi.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(Qi.tokens.semicolon,"Expected ';'."),t}if(this._check(Qi.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(Qi.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(Qi.keywords.fn))return null;const e=this._consume(Qi.tokens.ident,"Expected function name.").toString();this._consume(Qi.tokens.paren_left,"Expected '(' for function arguments.");const t=[];if(!this._check(Qi.tokens.paren_right))do{if(this._check(Qi.tokens.paren_right))break;const e=this._attribute(),n=this._consume(Qi.tokens.ident,"Expected argument name.").toString();this._consume(Qi.tokens.colon,"Expected ':' for argument type.");const i=this._attribute(),s=this._type_decl();null!=s&&(s.attributes=i,t.push(new Wi(n,s,e)))}while(this._match(Qi.tokens.comma));this._consume(Qi.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(Qi.tokens.arrow)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}const i=this._compound_statement();return new si(e,t,n,i)}_compound_statement(){const e=[];for(this._consume(Qi.tokens.brace_left,"Expected '{' for block.");!this._check(Qi.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(Qi.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(Qi.tokens.semicolon)&&!this._isAtEnd(););if(this._check(Qi.keywords.if))return this._if_statement();if(this._check(Qi.keywords.switch))return this._switch_statement();if(this._check(Qi.keywords.loop))return this._loop_statement();if(this._check(Qi.keywords.for))return this._for_statement();if(this._check(Qi.keywords.while))return this._while_statement();if(this._check(Qi.keywords.continuing))return this._continuing_statement();if(this._check(Qi.keywords.static_assert))return this._static_assert_statement();if(this._check(Qi.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(Qi.keywords.return)?this._return_statement():this._check([Qi.keywords.var,Qi.keywords.let,Qi.keywords.const])?this._variable_statement():this._match(Qi.keywords.discard)?new bi:this._match(Qi.keywords.break)?new ki:this._match(Qi.keywords.continue)?new Ai:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(Qi.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(Qi.keywords.static_assert))return null;let e=this._optional_paren_expression();return new ri(e)}_while_statement(){if(!this._match(Qi.keywords.while))return null;let e=this._optional_paren_expression();const t=this._compound_statement();return new oi(e,t)}_continuing_statement(){if(!this._match(Qi.keywords.continuing))return null;const e=this._compound_statement();return new ai(e)}_for_statement(){if(!this._match(Qi.keywords.for))return null;this._consume(Qi.tokens.paren_left,"Expected '('.");const e=this._check(Qi.tokens.semicolon)?null:this._for_init();this._consume(Qi.tokens.semicolon,"Expected ';'.");const t=this._check(Qi.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(Qi.tokens.semicolon,"Expected ';'.");const n=this._check(Qi.tokens.paren_right)?null:this._for_increment();this._consume(Qi.tokens.paren_right,"Expected ')'.");const i=this._compound_statement();return new li(e,t,n,i)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(Qi.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(Qi.tokens.equal)&&(t=this._short_circuit_or_expression()),new ci(e.name,e.type,e.storage,e.access,t)}if(this._match(Qi.keywords.let)){const e=this._consume(Qi.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(Qi.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Qi.tokens.equal,"Expected '=' for let.");const n=this._short_circuit_or_expression();return new hi(e,t,null,null,n)}if(this._match(Qi.keywords.const)){const e=this._consume(Qi.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(Qi.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Qi.tokens.equal,"Expected '=' for const.");const n=this._short_circuit_or_expression();return new di(e,t,null,null,n)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(Qi.increment_operators))return this._current=e,null;const n=this._consume(Qi.increment_operators,"Expected increment operator");return new pi(n.type===Qi.tokens.plus_plus?Yn.increment:Yn.decrement,t)}_assignment_statement(){let e=null;if(this._check(Qi.tokens.brace_right))return null;let t=this._match(Qi.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const n=this._consume(Qi.assignment_operators,"Expected assignment operator."),i=this._short_circuit_or_expression();return new fi(Xn.parse(n.lexeme),e,i)}_func_call_statement(){if(!this._check(Qi.tokens.ident))return null;const e=this._current,t=this._consume(Qi.tokens.ident,"Expected function name."),n=this._argument_expression_list();return null===n?(this._current=e,null):new mi(t.lexeme,n)}_loop_statement(){if(!this._match(Qi.keywords.loop))return null;this._consume(Qi.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let n of t)e.push(n);else e.push(t);t=this._statement()}let n=null;return this._match(Qi.keywords.continuing)&&(n=this._compound_statement()),this._consume(Qi.tokens.brace_right,"Expected '}' for loop."),new gi(e,n)}_switch_statement(){if(!this._match(Qi.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(Qi.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(Qi.tokens.brace_right,"Expected '}' for switch."),new vi(e,t)}_switch_body(){const e=[];if(this._match(Qi.keywords.case)){const t=this._case_selectors();this._match(Qi.tokens.colon),this._consume(Qi.tokens.brace_left,"Exected '{' for switch case.");const n=this._case_body();this._consume(Qi.tokens.brace_right,"Exected '}' for switch case."),e.push(new $i(t,n))}if(this._match(Qi.keywords.default)){this._match(Qi.tokens.colon),this._consume(Qi.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(Qi.tokens.brace_right,"Exected '}' for switch default."),e.push(new Hi(t))}if(this._check([Qi.keywords.default,Qi.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){var e,t,n,i;const s=[null!==(t=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==t?t:""];for(;this._match(Qi.tokens.comma);)s.push(null!==(i=null===(n=this._shift_expression())||void 0===n?void 0:n.evaluate(this._context).toString())&&void 0!==i?i:"");return s}_case_body(){if(this._match(Qi.keywords.fallthrough))return this._consume(Qi.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(Qi.keywords.if))return null;const e=this._optional_paren_expression(),t=this._compound_statement();let n=[];this._match_elseif()&&(n=this._elseif_statement(n));let i=null;return this._match(Qi.keywords.else)&&(i=this._compound_statement()),new yi(e,t,n,i)}_match_elseif(){return this._tokens[this._current].type===Qi.keywords.else&&this._tokens[this._current+1].type===Qi.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(new Yi(t,n)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(Qi.keywords.return))return null;const e=this._short_circuit_or_expression();return new xi(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(Qi.tokens.or_or);)e=new Vi(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(Qi.tokens.and_and);)e=new Vi(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(Qi.tokens.or);)e=new Vi(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(Qi.tokens.xor);)e=new Vi(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(Qi.tokens.and);)e=new Vi(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([Qi.tokens.equal_equal,Qi.tokens.not_equal])?new Vi(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([Qi.tokens.less_than,Qi.tokens.greater_than,Qi.tokens.less_than_equal,Qi.tokens.greater_than_equal]);)e=new Vi(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([Qi.tokens.shift_left,Qi.tokens.shift_right]);)e=new Vi(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([Qi.tokens.plus,Qi.tokens.minus]);)e=new Vi(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([Qi.tokens.star,Qi.tokens.forward_slash,Qi.tokens.modulo]);)e=new Vi(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([Qi.tokens.minus,Qi.tokens.bang,Qi.tokens.tilde,Qi.tokens.star,Qi.tokens.and])?new ji(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(Qi.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(Qi.tokens.bracket_right,"Expected ']'.");const t=this._postfix_expression();return t&&(e.postfix=t),e}if(this._match(Qi.tokens.period)){const e=this._consume(Qi.tokens.ident,"Expected member name."),t=this._postfix_expression(),n=new Ii(e.lexeme);return t&&(n.postfix=t),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(Qi.tokens.ident)){const e=this._previous().toString();if(this._check(Qi.tokens.paren_left)){const t=this._argument_expression_list(),n=this._getStruct(e);return null!=n?new Bi(n,t):new Oi(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new Ri(e,t.value)}return new Ni(e)}if(this._match(Qi.const_literal))return new Ui(parseFloat(this._previous().toString()));if(this._check(Qi.tokens.paren_left))return this._paren_expression();if(this._match(Qi.keywords.bitcast)){this._consume(Qi.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(Qi.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new Fi(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new Di(e,t)}_argument_expression_list(){if(!this._match(Qi.tokens.paren_left))return null;const e=[];do{if(this._check(Qi.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(Qi.tokens.comma));return this._consume(Qi.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(Qi.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(Qi.tokens.paren_right),new Li([e])}_paren_expression(){this._consume(Qi.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(Qi.tokens.paren_right,"Expected ')'."),new Li([e])}_struct_decl(){if(!this._match(Qi.keywords.struct))return null;const e=this._consume(Qi.tokens.ident,"Expected name for struct.").toString();this._consume(Qi.tokens.brace_left,"Expected '{' for struct body.");const t=[];for(;!this._check(Qi.tokens.brace_right);){const e=this._attribute(),n=this._consume(Qi.tokens.ident,"Expected variable name.").toString();this._consume(Qi.tokens.colon,"Expected ':' for struct member type.");const i=this._attribute(),s=this._type_decl();null!=s&&(s.attributes=i),this._check(Qi.tokens.brace_right)?this._match(Qi.tokens.comma):this._consume(Qi.tokens.comma,"Expected ',' for struct member."),t.push(new Xi(n,s,e))}this._consume(Qi.tokens.brace_right,"Expected '}' after struct body.");const n=new Si(e,t);return this._context.structs.set(e,n),n}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(Qi.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(Qi.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(Qi.keywords.const))return null;const e=this._consume(Qi.tokens.ident,"Expected variable name");let t=null;if(this._match(Qi.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;if(this._match(Qi.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof Bi)n=e;else if(e instanceof Ri&&e.initializer instanceof Bi)n=e.initializer;else try{const t=e.evaluate(this._context);n=new Ui(t)}catch(t){n=e}}const i=new di(e.toString(),t,"","",n);return this._context.constants.set(i.name,i),i}_global_let_decl(){if(!this._match(Qi.keywords.let))return null;const e=this._consume(Qi.tokens.ident,"Expected variable name");let t=null;if(this._match(Qi.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;return this._match(Qi.tokens.equal)&&(n=this._const_expression()),new hi(e.toString(),t,"","",n)}_const_expression(){if(this._match(Qi.const_literal))return new Ii(this._previous().toString());const e=this._type_decl();this._consume(Qi.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(Qi.tokens.paren_right)&&(t.push(this._const_expression()),this._check(Qi.tokens.comma));)this._advance();return this._consume(Qi.tokens.paren_right,"Expected ')'."),new Bi(e,t)}_variable_decl(){if(!this._match(Qi.keywords.var))return null;let e="",t="";this._match(Qi.tokens.less_than)&&(e=this._consume(Qi.storage_class,"Expected storage_class.").toString(),this._match(Qi.tokens.comma)&&(t=this._consume(Qi.access_mode,"Expected access_mode.").toString()),this._consume(Qi.tokens.greater_than,"Expected '>'."));const n=this._consume(Qi.tokens.ident,"Expected variable name");let i=null;if(this._match(Qi.tokens.colon)){const e=this._attribute();i=this._type_decl(),null!=i&&(i.attributes=e)}return new ci(n.toString(),i,e,t,null)}_override_decl(){if(!this._match(Qi.keywords.override))return null;const e=this._consume(Qi.tokens.ident,"Expected variable name");let t=null;if(this._match(Qi.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new ui(e.toString(),t,null)}_enable_directive(){const e=this._consume(Qi.tokens.ident,"identity expected.");return new wi(e.toString())}_type_alias(){const e=this._consume(Qi.tokens.ident,"identity expected.");this._consume(Qi.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=new _i(e.toString(),t);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([Qi.tokens.ident,...Qi.texel_format,Qi.keywords.bool,Qi.keywords.f32,Qi.keywords.i32,Qi.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new Ei(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(Qi.template_types)){let e=this._advance().toString(),t=null,n=null;return this._match(Qi.tokens.less_than)&&(t=this._type_decl(),n=null,this._match(Qi.tokens.comma)&&(n=this._consume(Qi.access_mode,"Expected access_mode for pointer").toString()),this._consume(Qi.tokens.greater_than,"Expected '>' for type.")),new Ti(e,t,n)}if(this._match(Qi.keywords.ptr)){let e=this._previous().toString();this._consume(Qi.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(Qi.storage_class,"Expected storage_class for pointer");this._consume(Qi.tokens.comma,"Expected ',' for pointer.");const n=this._type_decl();let i=null;return this._match(Qi.tokens.comma)&&(i=this._consume(Qi.access_mode,"Expected access_mode for pointer").toString()),this._consume(Qi.tokens.greater_than,"Expected '>' for pointer."),new Mi(e,t.toString(),n,i)}const t=this._attribute();if(this._match(Qi.keywords.array)){let e=null,n=-1;const i=this._previous();if(this._match(Qi.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";this._match(Qi.tokens.comma)&&(t=this._shift_expression().evaluate(this._context).toString()),this._consume(Qi.tokens.greater_than,"Expected '>' for array."),n=t?parseInt(t):0}return new Pi(i.toString(),t,e,n)}return null}_texture_sampler_types(){if(this._match(Qi.sampler_type))return new zi(this._previous().toString(),null,null);if(this._match(Qi.depth_texture_type))return new zi(this._previous().toString(),null,null);if(this._match(Qi.sampled_texture_type)||this._match(Qi.multisampled_texture_type)){const e=this._previous();this._consume(Qi.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(Qi.tokens.greater_than,"Expected '>' for sampler type."),new zi(e.toString(),t,null)}if(this._match(Qi.storage_texture_type)){const e=this._previous();this._consume(Qi.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(Qi.texel_format,"Invalid texel format.").toString();this._consume(Qi.tokens.comma,"Expected ',' after texel format.");const n=this._consume(Qi.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(Qi.tokens.greater_than,"Expected '>' for sampler type."),new zi(e.toString(),t,n)}return null}_attribute(){let e=[];for(;this._match(Qi.tokens.attr);){const t=this._consume(Qi.attribute_name,"Expected attribute name"),n=new Zi(t.toString(),null);if(this._match(Qi.tokens.paren_left)){if(n.value=this._consume(Qi.literal_or_ident,"Expected attribute value").toString(),this._check(Qi.tokens.comma)){this._advance();do{const e=this._consume(Qi.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(e)}while(this._match(Qi.tokens.comma))}this._consume(Qi.tokens.paren_right,"Expected ')'")}e.push(n)}for(;this._match(Qi.tokens.attr_left);){if(!this._check(Qi.tokens.attr_right))do{const t=this._consume(Qi.attribute_name,"Expected attribute name"),n=new Zi(t.toString(),null);if(this._match(Qi.tokens.paren_left)){if(n.value=[this._consume(Qi.literal_or_ident,"Expected attribute value").toString()],this._check(Qi.tokens.comma)){this._advance();do{const e=this._consume(Qi.literal_or_ident,"Expected attribute value").toString();n.value.push(e)}while(this._match(Qi.tokens.comma))}this._consume(Qi.tokens.paren_right,"Expected ')'")}e.push(n)}while(this._match(Qi.tokens.comma));this._consume(Qi.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class ns{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class is{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class ss extends ns{constructor(e,t){super(e,t),this.members=[],this.align=0}get isStruct(){return!0}}class rs extends ns{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class os extends ns{constructor(e,t,n,i){super(e,n),this.format=t,this.access=i}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(Qn||(Qn={}));class as{constructor(e,t,n,i,s,r,o){this.name=e,this.type=t,this.group=n,this.binding=i,this.attributes=s,this.resourceType=r,this.access=o}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class ls{constructor(e,t){this.name=e,this.type=t}}class cs{constructor(e,t){this.align=e,this.size=t}}class us{constructor(e,t,n,i){this.name=e,this.type=t,this.locationType=n,this.location=i,this.interpolation=null}}class hs{constructor(e,t,n,i){this.name=e,this.type=t,this.locationType=n,this.location=i}}class ds{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.name=e,this.stage=t}}class ps{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class fs{constructor(e,t,n,i){this.name=e,this.type=t,this.attributes=n,this.id=i}}class ms{constructor(e){this.resources=null,this.node=e}}class gs{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new ps,this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new ts).parse(e);for(const e of t)e instanceof si&&this._functions.set(e.name,new ms(e));for(const e of t)if(e instanceof Si){const t=this._getTypeInfo(e,null);t instanceof ss&&this.structs.push(t)}else if(e instanceof _i)this.aliases.push(this._getAliasInfo(e));else if(e instanceof ui){const t=e,n=this._getAttributeNum(t.attributes,"id",0),i=null!=t.type?this._getTypeInfo(t.type,t.attributes):null;this.overrides.push(new fs(t.name,i,t.attributes,n))}else if(this._isUniformVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),s=this._getTypeInfo(t.type,t.attributes),r=new as(t.name,s,n,i,t.attributes,Qn.Uniform,t.access);this.uniforms.push(r)}else if(this._isStorageVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),s=this._getTypeInfo(t.type,t.attributes),r=this._isStorageTexture(s),o=new as(t.name,s,n,i,t.attributes,r?Qn.StorageTexture:Qn.Storage,t.access);this.storage.push(o)}else if(this._isTextureVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),s=this._getTypeInfo(t.type,t.attributes),r=this._isStorageTexture(s),o=new as(t.name,s,n,i,t.attributes,r?Qn.StorageTexture:Qn.Texture,t.access);r?this.storage.push(o):this.textures.push(o)}else if(this._isSamplerVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),s=this._getTypeInfo(t.type,t.attributes),r=new as(t.name,s,n,i,t.attributes,Qn.Sampler,t.access);this.samplers.push(r)}else if(e instanceof si){const t=this._getAttribute(e,"vertex"),n=this._getAttribute(e,"fragment"),i=this._getAttribute(e,"compute"),s=t||n||i;if(s){const t=new ds(e.name,null==s?void 0:s.name);t.inputs=this._getInputs(e.args),t.outputs=this._getOutputs(e.returnType),t.resources=this._findResources(e),this.entry[s.name].push(t)}}}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_findResources(e){const t=[],n=this,i=[];return e.search((e=>{if(e instanceof ti)i.push({});else if(e instanceof ni)i.pop();else if(e instanceof ci){if(i.length>0){const t=e;i[i.length-1][t.name]=t}}else if(e instanceof hi){if(i.length>0){const t=e;i[i.length-1][t.name]=t}}else if(e instanceof Ni){const s=e;if(i.length>0&&i[i.length-1][s.name])return;const r=n._findResource(s.name);r&&t.push(r)}else if(e instanceof Oi){const i=e,s=n._functions.get(i.name);s&&(null===s.resources&&(s.resources=n._findResources(s.node)),t.push(...s.resources))}})),[...new Map(t.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,n){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),n>=e[t].length&&(e[t].length=n+1)}for(const n of this.uniforms)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.storage)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.textures)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.samplers)t(n.group,n.binding),e[n.group][n.binding]=n;return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof Si)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);null!==n&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof Si)this._getStructOutputs(n.type,t);else{const e=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(null!==e){const i=this._getTypeInfo(n.type,n.type.attributes),s=this._parseInt(e.value),r=new hs(n.name,i,e.name,s);t.push(r)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getTypeInfo(e,e.attributes),i=this._parseInt(t.value);return new hs("",n,t.name,i)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const n of e)if(n.type instanceof Si)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof Si)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getAttribute(e,"interpolation"),i=this._getTypeInfo(e.type,e.attributes),s=this._parseInt(t.value),r=new us(e.name,i,t.name,s);return null!==n&&(r.interpolation=this._parseString(n.value)),r}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new ls(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof Pi){const n=e,i=this._getTypeInfo(n.format,n.attributes),s=new rs(n.name,t);return s.format=i,s.count=n.count,this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof Si){const n=e,i=new ss(n.name,t);for(const e of n.members){const t=this._getTypeInfo(e.type,e.attributes);i.members.push(new is(e.name,t,e.attributes))}return this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof zi){const n=e,i=n.format instanceof Ei,s=n.format?i?this._getTypeInfo(n.format,null):new ns(n.format,null):null,r=new os(n.name,s,t,n.access);return this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof Ti){const n=e,i=n.format?this._getTypeInfo(n.format,null):null,s=new os(n.name,i,t,n.access);return this._types.set(e,s),this._updateTypeInfo(s),s}const n=new ns(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n;const i=this._getTypeSize(e);if(e.size=null!==(t=null==i?void 0:i.size)&&void 0!==t?t:0,e instanceof rs){const t=this._getTypeSize(e.format);e.stride=null!==(n=null==t?void 0:t.size)&&void 0!==n?n:0,this._updateTypeInfo(e.format)}e instanceof ss&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,i=0,s=0,r=0;for(let o=0,a=e.members.length;o<a;++o){const a=e.members[o],l=this._getTypeSize(a);if(!l)continue;null!==(t=this._getAlias(a.type.name))&&void 0!==t||a.type;const c=l.align,u=l.size;n=this._roundUp(c,n+i),i=u,s=n,r=Math.max(r,c),a.offset=n,a.size=u,this._updateTypeInfo(a.type)}e.size=this._roundUp(r,s+i),e.align=r}_getTypeSize(e){var t;if(null==e)return null;const n=this._getAttributeNum(e.attributes,"size",0),i=this._getAttributeNum(e.attributes,"align",0);if(e instanceof is&&(e=e.type),e instanceof ns){const t=this._getAlias(e.name);null!==t&&(e=t)}{const t=gs._typeInfo[e.name];if(void 0!==t){const s="f16"===e.format?2:1;return new cs(Math.max(i,t.align/s),Math.max(n,t.size/s))}}{const t=gs._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const s="h"===e.name[e.name.length-1]?2:1;return new cs(Math.max(i,t.align/s),Math.max(n,t.size/s))}}if(e instanceof rs){let s=e,r=8,o=8;const a=this._getTypeSize(s.format);return null!==a&&(o=a.size,r=a.align),o=s.count*this._getAttributeNum(null!==(t=null==e?void 0:e.attributes)&&void 0!==t?t:null,"stride",this._roundUp(r,o)),n&&(o=n),new cs(Math.max(i,r),Math.max(n,o))}if(e instanceof ss){let t=0,s=0,r=0,o=0,a=0;for(const n of e.members){const e=this._getTypeSize(n.type);null!==e&&(t=Math.max(e.align,t),r=this._roundUp(e.align,r+o),o=e.size,a=r)}return s=this._roundUp(t,a+o),new cs(Math.max(i,t),Math.max(n,s))}return null}_isUniformVar(e){return e instanceof ci&&"uniform"==e.storage}_isStorageVar(e){return e instanceof ci&&"storage"==e.storage}_isTextureVar(e){return e instanceof ci&&null!==e.type&&-1!=gs._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof ci&&null!==e.type&&-1!=gs._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const i=n.attributes;for(let e of i)if(e.name==t)return e;return null}_getAttributeNum(e,t,n){if(null===e)return n;for(let i of e)if(i.name==t){let e=null!==i&&null!==i.value?i.value:n;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}function vs(e,t){const n=function(e){return Array.isArray(e)||Vn(e)?[...e,1,1].slice(0,3):function(e){return[e.width,e.height||1,e.depthOrArrayLayers||1]}(e)}(e),i=Math.max(...n.slice(0,"3d"===t?3:2));return 1+Math.log2(i)|0}gs._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},gs._textureTypes=Qi.any_texture_type.map((e=>e.name)),gs._samplerTypes=Qi.sampler_type.map((e=>e.name));const ys=new WeakMap;const xs=new Map([[Int8Array,{formats:["sint8","snorm8"],defaultForType:1}],[Uint8Array,{formats:["uint8","unorm8"],defaultForType:1}],[Int16Array,{formats:["sint16","snorm16"],defaultForType:1}],[Uint16Array,{formats:["uint16","unorm16"],defaultForType:1}],[Int32Array,{formats:["sint32","snorm32"],defaultForType:0}],[Uint32Array,{formats:["uint32","unorm32"],defaultForType:0}],[Float32Array,{formats:["float32","float32"],defaultForType:0}]]);function ws(e){return Vn(e)||Array.isArray(e)||function(e){const t=e;return Vn(t.data)||Array.isArray(t.data)}(e)}function _s(e){switch(e){case"1d":return"1d";case"3d":return"3d";default:return"2d"}}new Map([...xs.entries()].map((([e,{formats:[t,n]}])=>[[t,e],[n,e]])).flat());const bs={"8snorm":Int8Array,"8unorm":Uint8Array,"8sint":Int8Array,"8uint":Uint8Array,"16snorm":Int16Array,"16unorm":Uint16Array,"16sint":Int16Array,"16uint":Uint16Array,"32snorm":Int32Array,"32unorm":Uint32Array,"32sint":Int32Array,"32uint":Uint32Array,"16float":Uint16Array,"32float":Float32Array},ks=/([a-z]+)(\d+)([a-z]+)/;function As(e){const[,t,n,i]=ks.exec(e),s=t.length,r=parseInt(n)/8;return{channels:t,numChannels:s,bytesPerChannel:r,bytesPerElement:s*r,Type:bs[`${n}${i}`]}}function Es(e,t,n,i={}){n.forEach(((n,s)=>{const r=[0,0,s+(i.baseArrayLayer||0)];if(ws(n))!function(e,t,n,i){const s=function(e,t){if(Vn(e))return e;const{Type:n}=As(t);return new n(e)}(n.data||n,t.format),r=function(e,t){return[e.width,e.height,e.depthOrArrayLayers].map((e=>Math.max(1,Math.floor(e/1))))}(t),{bytesPerElement:o}=As(t.format),a=i.origin||[0,0,0];e.queue.writeTexture({texture:t,origin:a},s,{bytesPerRow:o*r[0],rowsPerImage:r[1]},r)}(e,t,n,{origin:r});else{const s=n,{flipY:o,premultipliedAlpha:a,colorSpace:l}=i;e.queue.copyExternalImageToTexture({source:s,flipY:o},{texture:t,premultipliedAlpha:a,colorSpace:l,origin:r},Ss(s,i))}})),t.mipLevelCount>1&&function(e,t,n){let i=ys.get(e);i||(i={pipelineByFormatAndView:{},moduleByViewType:{}},ys.set(e,i));let{sampler:s,uniformBuffer:r,uniformValues:o}=i;const{pipelineByFormatAndView:a,moduleByViewType:l}=i;n=n||function(e){switch(e.dimension){case"1d":return"1d";case"3d":return"3d";default:return e.depthOrArrayLayers>1?"2d-array":"2d"}}(t);let c=l[n];if(!c){const t=function(e){let t,n;switch(e){case"2d":t="texture_2d<f32>",n="textureSample(ourTexture, ourSampler, fsInput.texcoord)";break;case"2d-array":t="texture_2d_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              fsInput.texcoord,\n              uni.layer)";break;case"cube":t="texture_cube<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1))";break;case"cube-array":t="texture_cube_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1), uni.layer)";break;default:throw new Error(`unsupported view: ${e}`)}return`\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n          var pos = array<vec2f, 3>(\n            vec2f(-1.0, -1.0),\n            vec2f(-1.0,  3.0),\n            vec2f( 3.0, -1.0),\n          );\n\n          var vsOutput: VSOutput;\n          let xy = pos[vertexIndex];\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n          return vsOutput;\n        }\n\n        struct Uniforms {\n          layer: u32,\n        };\n\n        @group(0) @binding(0) var ourSampler: sampler;\n        @group(0) @binding(1) var ourTexture: ${t};\n        @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni.layer; // make sure this is used so all pipelines have the same bindings\n          return ${n};\n        }\n      `}(n);c=e.createShaderModule({label:`mip level generation for ${n}`,code:t}),l[n]=c}s||(s=e.createSampler({minFilter:"linear",magFilter:"linear"}),r=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=new Uint32Array(1),Object.assign(i,{sampler:s,uniformBuffer:r,uniformValues:o}));const u=`${t.format}.${n}`;a[u]||(a[u]=e.createRenderPipeline({label:`mip level generator pipeline for ${n}`,layout:"auto",vertex:{module:c,entryPoint:"vs"},fragment:{module:c,entryPoint:"fs",targets:[{format:t.format}]}}));const h=a[u];for(let i=1;i<t.mipLevelCount;++i)for(let a=0;a<t.depthOrArrayLayers;++a){o[0]=a,e.queue.writeBuffer(r,0,o);const l=e.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:s},{binding:1,resource:t.createView({dimension:n,baseMipLevel:i-1,mipLevelCount:1})},{binding:2,resource:{buffer:r}}]}),c={label:"mip gen renderPass",colorAttachments:[{view:t.createView({dimension:"2d",baseMipLevel:i,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},u=e.createCommandEncoder({label:"mip gen encoder"}),d=u.beginRenderPass(c);d.setPipeline(h),d.setBindGroup(0,l),d.draw(3),d.end();const p=u.finish();e.queue.submit([p])}}(e,t)}function Ss(e,t){if(e instanceof HTMLVideoElement)return[e.videoWidth,e.videoHeight,1];{const n=e,{width:i,height:s}=n;if(i>0&&s>0&&!ws(e))return[i,s,1];const r=t.format||"rgba8unorm",{bytesPerElement:o,bytesPerChannel:a}=As(r),l=Vn(e)||Array.isArray(e)?e:e.data;return function(e,t,n,i="2d"){if(n%1!=0)throw new Error("can't guess dimensions");if(e||t){if(t){if(!e&&(e=n/t)%1)throw new Error("can't guess dimensions")}else if((t=n/e)%1)throw new Error("can't guess dimensions")}else{const s=Math.sqrt(n/("cube"===i?6:1));s%1==0?(e=s,t=s):(e=n,t=1)}const s=n/e/t;if(s%1)throw new Error("can't guess dimensions");return[e,t,s]}(i,s,(Vn(l)?l.byteLength:l.length*a)/o)}}async function Ts(e,t,n={}){const i=await Promise.all(t.map((e=>async function(e,t={}){const n=await fetch(e),i=await n.blob(),s={...t,...void 0!==t.colorSpaceConversion&&{colorSpaceConversion:"none"}};return await createImageBitmap(i,s)}(e))));return function(e,t,n={}){const i=Ss(t[0],n);i[2]=i[2]>1?i[2]:t.length;const s=e.createTexture({dimension:_s(n.dimension),format:n.format||"rgba8unorm",mipLevelCount:n.mipLevelCount?n.mipLevelCount:n.mips?vs(i):1,size:i,usage:(n.usage??0)|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return Es(e,s,t,n),s}(e,i,n)}const Ms=e=>{let t=te.create(1/0,1/0,1/0),n=te.create(-1/0,-1/0,-1/0);for(const{AABB:i}of e)t=te.min(i.min,t),n=te.max(i.max,n);return{min:t,max:n}},Ps=e=>{const t=Ms(e),n=(t.max[0]-t.min[0])*(t.max[1]-t.min[1])*(t.max[2]-t.min[2]);return e.length*n},zs=(44,16,16*Math.ceil(2.75));class Cs{#a;#l;#c;#u;#h;constructor(e,t){this.#a=e,this.#c=t.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#l=[],this.#d(this.#c,0),this.#p()}get gpuBuffer(){if(!this.#h){const e=this.#a.createBuffer({size:this.#h.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),t=this.#a.createCommandEncoder();t.copyBufferToBuffer(this.#h,0,e,0,this.#h.size),this.#a.queue.submit([t.finish()]),e.mapAsync(GPUMapMode.READ).then((()=>{new Float32Array(e.getMappedRange())}))}return this.#h}update(e){this.#c=e.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#l=[],this.#d(this.#c,0),this.#p()}#d(e,t){if(0===this.#c.length)return;if(1===e.length)return void(this.#l[t]={leftChildIndex:this.#c.indexOf(e[0]),rightChildIndex:-1,objectCount:1,AABBMax:e[0].AABB.max,AABBMin:e[0].AABB.min});const n=Ms(e);let i=-1,s=-1;const{left:r,right:o}=(e=>{let t=1/0,n=-1;const i=Math.floor(e.length/2);for(let s=1;s<e.length;s++){const r=e.slice(0,s),o=e.slice(s),a=Ps(r)+Ps(o),l=1*Math.abs(s-i)+1*a;l<t&&(t=l,n=s)}return{left:e.slice(0,n),right:e.slice(n)}})(e);r.length>0&&(i=++this.#u,this.#d(r,i)),o.length>0&&(s=++this.#u,this.#d(o,s)),this.#l[t]={leftChildIndex:i,rightChildIndex:s,objectCount:e.length,AABBMax:n.max,AABBMin:n.min}}#p(){return this.#h=this.#a.createBuffer({size:Math.max(this.#l.length,1)*zs,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1,label:"bvh buffer"}),this.#l.forEach(((e,t)=>{const n=t*zs,i=new ArrayBuffer(zs),s=new DataView(i);s.setInt32(0,e.leftChildIndex,!0),s.setInt32(4,e.rightChildIndex,!0),s.setUint32(8,e.objectCount,!0),s.setFloat32(16,e.AABBMin[0],!0),s.setFloat32(20,e.AABBMin[1],!0),s.setFloat32(24,e.AABBMin[2],!0),s.setFloat32(32,e.AABBMax[0],!0),s.setFloat32(36,e.AABBMax[1],!0),s.setFloat32(40,e.AABBMax[2],!0),this.#a.queue.writeBuffer(this.#h,n,i,0,zs)})),this.#h}}const Is="clear",Bs=async()=>{const e=er.createShaderModule({code:"\n    struct VertexOutput {\n      @builtin(position) position : vec4f,\n    }\n    @vertex\n    fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n      var output : VertexOutput;\n      return output;\n    }\n    @fragment\n    fn fragment_main(@builtin(position) position : vec4f) -> @location(0) vec4<f32> {\n        return vec4(0.0);\n    }"}),t=er.createRenderPipeline({label:Is,layout:"auto",vertex:{module:e,entryPoint:"vertex_main"},fragment:{module:e,entryPoint:"fragment_main",targets:[{format:Je}]}});return{render:e=>{const n=e.commandEncoder.beginRenderPass({label:Is,timestampWrites:e.timestampWrites,colorAttachments:[{view:e.outputTextures.finalTexture.view,loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});n.setPipeline(t),n.draw(6),n.end()},label:Is}};function Os(e,t){let n=0,i=1/t,s=e;for(;s>0;)n+=i*(s%t),s=Math.floor(s/t),i/=t;return n}let Ns,Rs=!1;class Us extends e{position;rotation;scale;#f;constructor(e,t,n){super(),this.position=e,this.rotation=t,this.scale=n,this.#f=ve.identity()}get transform(){let e=ve.identity();return ve.translate(e,this.position,e),ve.multiply(e,ve.fromQuat(this.rotation),e),ve.scale(e,this.scale,e),e}get previousTransform(){return this.#f}set previousTransform(e){this.#f=e}get direction(){return te.transformQuat(te.create(0,0,1),this.rotation)}get right(){return te.transformQuat(te.create(1,0,0),this.rotation)}get left(){return te.transformQuat(te.create(-1,0,0),this.rotation)}get up(){return te.transformQuat(te.create(0,1,0),this.rotation)}get down(){return te.transformQuat(te.create(0,-1,0),this.rotation)}}class Fs extends e{size;atlasLocation;paletteIndex;octreeBufferIndex;name;constructor({size:e,atlasLocation:t,paletteIndex:n,octreeBufferIndex:i,name:s}){super(),this.size=e,this.atlasLocation=t,this.paletteIndex=n,this.octreeBufferIndex=i,this.name=s}}const Ds=async()=>{let e,t,n;const i=er.createComputePipeline({layout:"auto",compute:{module:er.createShaderModule({code:"// Helper function to compute luminance\nfn Luminance(color: vec3<f32>) -> f32 {\n    return dot(color, vec3<f32>(0.299, 0.587, 0.114));\n}\n\nfn rcp(x: f32) -> f32 {\n    return 1.0 / x;\n}\n\nstruct ViewProjectionMatrices {\n  viewProjection : mat4x4<f32>,\n  previousViewProjection : mat4x4<f32>,\n  inverseViewProjection : mat4x4<f32>,\n  projection : mat4x4<f32>,\n  inverseProjection: mat4x4<f32>\n};\n\n//fn calculateWorldDisplacementFromVelocity(velocity: vec2<f32>, depth: f32) -> vec3<f32> {\n//    let worldDisplacement = vec3<f32>(velocity, depth);\n//    return worldDisplacement;\n//}\n\nfn calculateUvFromWorldPostion(worldPos: vec3<f32>, matrices: ViewProjectionMatrices) -> vec2<f32> {\n  let clipPos = matrices.viewProjection * vec4<f32>(worldPos, 1.0);\n  let uv = (matrices.inverseProjection * clipPos).xy;\n  return uv * 0.5 + 0.5;\n}\n\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\n    vec2<i32>(-1, -1),\n    vec2<i32>(0, -1),\n    vec2<i32>(1, -1),\n    vec2<i32>(-1, 0),\n    vec2<i32>(1, 0),\n    vec2<i32>(-1, 1),\n    vec2<i32>(0, 1),\n    vec2<i32>(1, 1)\n);\n\n@group(0) @binding(0) var CurrentColor : texture_2d<f32>;\n@group(0) @binding(1) var Velocity : texture_2d<f32>;\n@group(0) @binding(2) var HistoryWrite : texture_storage_2d<rgba16float, write>;\n@group(0) @binding(3) var HistoryRead : texture_2d<f32>;\n@group(0) @binding(5) var Depth : texture_2d<f32>;\n@group(0) @binding(6) var linearSampler : sampler;\n@group(0) @binding(7) var nearestSampler : sampler;\n@group(0) @binding(8) var worldPosTex : texture_2d<f32>;\n//@group(0) @binding(9) var<uniform> viewProjectionMatrices : ViewProjectionMatrices;\n\nconst DEPTH_THRESHOLD : f32 = 4.0;\nconst MIN_SOURCE_BLEND = 0.075;\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n    @builtin(global_invocation_id) id : vec3<u32>\n) {\n    let texSize = vec2<f32>(textureDimensions(CurrentColor));\n    let uv = (vec2<f32>(id.xy) + vec2(0.5)) / texSize;\n    let depthSample: f32 = textureLoad(Depth, id.xy, 0).r;\n\n    // Get velocity from pixel with closest depth value in 3x3 neighborhood\n    var closestDepthPixel = vec2<i32>(id.xy);\n    var closestDepth = 999999999.0;\n    for (var i = 0; i < 8; i = i + 1) {\n        let neighbourPixel = clamp(vec2<i32>(id.xy) + NEIGHBORHOOD_SAMPLE_POSITIONS[i], vec2<i32>(0), vec2<i32>(texSize - 1));\n        let neighbourDepth = textureLoad(Depth, neighbourPixel, 0).r;\n        if (abs(neighbourDepth - depthSample) < abs(closestDepth - depthSample)) {\n            closestDepth = neighbourDepth;\n            closestDepthPixel = neighbourPixel;\n        }\n    }\n\n    let velocity = textureLoad(Velocity, closestDepthPixel, 0).xy;\n    let pixelVelocity: vec2<f32> = velocity * texSize;\n    let previousPixel: vec2<i32> = vec2<i32>(id.xy) -  vec2<i32>(pixelVelocity);\n    let previousUv = uv - velocity;\n\n    let worldPos = textureLoad(worldPosTex, id.xy, 0).xyz;\n    let worldPosPrev = textureLoad(worldPosTex, previousPixel, 0).xyz;\n\n    var depthAtPreviousPixel: f32 = textureLoad(Depth, previousPixel, 0).r;\n\n    var sourceSample: vec3<f32> = textureSampleLevel(CurrentColor, nearestSampler, uv, 0).rgb;\n    var historySample: vec3<f32> = textureSampleLevel(HistoryRead, linearSampler, previousUv, 0).rgb;\n\n    // Calculate depth difference between source and history samples\n    let depthDifference: f32 = abs(depthSample - depthAtPreviousPixel);\n\n    // Apply depth clamping\n    if (depthDifference > DEPTH_THRESHOLD) {\n        return;\n    }\n//\n    // Clamp the history sample to the min and max of the 3x3 neighborhood\n    var minCol: vec3<f32> = sourceSample;\n    var maxCol: vec3<f32> = sourceSample;\n    for (var x: i32 = -1; x <= 1; x = x + 1) {\n        for (var y: i32 = -1; y <= 1; y = y + 1) {\n            let neighbourPixel = clamp(vec2(i32(id.x) + x, i32(id.y) + y), vec2(0), vec2(i32(texSize.x - 1), i32(texSize.y - 1)));\n            let s: vec3<f32> = textureLoad(CurrentColor, neighbourPixel, 0).rgb;\n            minCol = min(minCol, s);\n            maxCol = max(maxCol, s);\n        }\n    }\n    historySample = clamp(historySample, minCol, maxCol);\n\n    var sourceWeight: f32 = clamp(length(velocity), MIN_SOURCE_BLEND, 1.0);\n    var historyWeight: f32 = 1.0 - sourceWeight;\n    let compressedSource: vec3<f32> = sourceSample * rcp(max(max(sourceSample.r, sourceSample.g), sourceSample.b) + 1.0);\n    let compressedHistory: vec3<f32> = historySample * rcp(max(max(historySample.r, historySample.g), historySample.b) + 1.0);\n    let luminanceSource: f32 = Luminance(compressedSource);\n    let luminanceHistory: f32 = Luminance(compressedHistory);\n    sourceWeight *= 1.0 / (1.0 + luminanceSource);\n    historyWeight *= 1.0 / (1.0 + luminanceHistory);\n    let result: vec3<f32> = (sourceSample * sourceWeight + historySample * historyWeight) / max(sourceWeight + historyWeight, 0.0001);\n\n    textureStore(HistoryWrite, id.xy, vec4<f32>(result, 1.0));\n}\n"}),entryPoint:"main"}});let s;return{render:({commandEncoder:r,timestampWrites:o,outputTextures:a,viewProjectionMatricesBuffer:l})=>{e||(e=er.createTexture({label:"TAA History Texture",size:[tr[0],tr[1],1],format:Je,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),s=e.createView()),t||(t=er.createTexture({size:[tr[0],tr[1],1],format:Je,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),n=t.createView()),r.copyTextureToTexture({texture:a.finalTexture.texture},{texture:t},{width:t.width,height:t.height,depthOrArrayLayers:1});const c=r.beginComputePass({timestampWrites:o});c.setPipeline(i);const u=er.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:a.velocityTexture.view},{binding:2,resource:a.finalTexture.view},{binding:3,resource:s},{binding:5,resource:a.depthTexture.view},{binding:6,resource:er.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})},{binding:7,resource:er.createSampler({magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest"})},{binding:8,resource:a.worldPositionTexture.view}]});c.setBindGroup(0,u),c.dispatchWorkgroups(tr[0]/8,tr[1]/8),c.end(),r.copyTextureToTexture({texture:a.finalTexture.texture},{texture:e},{width:e.width,height:e.height,depthOrArrayLayers:1})},label:"taa"}},Ls={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},qs={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},js={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Je}},Vs={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Gs={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},$s={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Hs={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},Ws={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Ys={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},Xs=(GPUShaderStage.COMPUTE,[Ls,qs,js,Vs,Gs,$s,Hs,Ws,Ys,{binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},{binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},{binding:19,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]),Zs=async()=>(async({shaderCode:e,entryPoint:t,label:n})=>{const i=er.createBindGroupLayout({entries:Xs}),s=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${Je}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\nstruct ViewProjectionMatrices {\n  viewProjection : mat4x4<f32>,\n  previousViewProjection : mat4x4<f32>,\n  inverseViewProjection : mat4x4<f32>,\n  previousInverseViewProjection : mat4x4<f32>,\n  projection : mat4x4<f32>,\n  inverseProjection: mat4x4<f32>\n};\n${He}\n${We}\n${Ye}\n${Xe}\n${Ze}\nconst MAX_COARSE_RAY_STEPS = 64;\n\nfn rayMarchCoarse(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>) -> bool {\n    let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\n    var voxelSize = vec3<f32>(1.0);\n    var objectPos = objectRayOrigin;\n    var currentIndex = vec3<i32>(round(objectPos));\n    var tDelta = voxelSize / abs(objectRayDirection);\n    var tIncrement = min(tDelta.x, min(tDelta.y, tDelta.z));\n\n    for(var i = 0; i < MAX_COARSE_RAY_STEPS; i++)\n    {\n      let samplePosition = objectPos + voxelObject.atlasLocation;\n      let uv = samplePosition / vec3<f32>(textureDimensions(voxels));\n      let mipSample0 = textureSampleLevel(voxels, nearestSampler, uv, 0.0);\n\n      if(mipSample0.a > 0.0){\n          return true;\n      }\n\n      objectPos += objectRayDirection * tIncrement;\n      currentIndex = vec3<i32>(round(objectPos));\n//      if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\n//          break;\n//      }\n    }\n    return false;\n}\n\nfn rayMarchTransformedCoarse(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> bool {\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz;\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\n    return rayMarchCoarse(voxelObject, objectRayDirection, objectRayOrigin);\n}\n\n// Used for shadows, return first hit\nfn rayMarchBVHCoarse(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxDistance: f32) -> bool {\n  // Create a stack to store the nodes to visit\n      var stack = stack_new();\n      stack_push(&stack, 0);\n\n      var iterations = 0;\n      var nodeIndex = 0;\n\n      while (stack.head > 0u && iterations < 32) {\n        let node = bvhNodes[nodeIndex];\n        if(node.objectCount == 0){\n          nodeIndex = stack_pop(&stack);\n        }\n        // valid leaf, raymarch it\n        else if(node.objectCount == 1){\n            // Raymarch the voxel object if it's a leaf node\n            let voxelObject = voxelObjects[node.leftIndex]; // left index represents the voxel object index for leaf nodes\n            let AABBDist = getDistanceToNode(rayOrigin, rayDirection, node);\n            if(rayMarchTransformedCoarse(voxelObject, rayDirection, rayOrigin + rayDirection * AABBDist)){\n              return true;\n            }\n            // Pop the stack and continue\n            nodeIndex = stack_pop(&stack);\n        }\n        else{\n          let leftDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.leftIndex]);\n          let rightDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.rightIndex]);\n          let hitLeft = leftDist >= 0.0 && leftDist < maxDistance;\n          let hitRight = rightDist >= 0.0 && rightDist < maxDistance;\n          if(hitLeft){\n            var nearIndex = node.leftIndex;\n            // We hit both left and right, choose the closest one\n            if(hitRight){\n              if(leftDist < rightDist){\n                // left is closer, push right to stack\n                stack_push(&stack, node.rightIndex);\n              } else {\n                // right is closer, push left to stack\n                stack_push(&stack, node.leftIndex);\n                nearIndex = node.rightIndex;\n              }\n            }\n            nodeIndex = nearIndex;\n          }\n          // We only hit the right Node\n          else if(hitRight){\n            nodeIndex = node.rightIndex;\n          }\n          // We didn't hit any node, pop the stack\n          else{\n            nodeIndex = stack_pop(&stack);\n          }\n        }\n\n        iterations += 1;\n      }\n\n      return false;\n}\n${e}`,r=er.createComputePipeline({layout:er.createPipelineLayout({bindGroupLayouts:[i]}),compute:{module:er.createShaderModule({code:s}),entryPoint:t}});let o,a,l,c=er.createSampler({magFilter:"nearest",minFilter:"nearest"}),u=er.createSampler({magFilter:"linear",minFilter:"linear"});return{render:({commandEncoder:e,outputTextures:t,timestampWrites:n,viewProjectionMatricesBuffer:s,volumeAtlas:h,cameraPositionBuffer:d,transformationMatrixBuffer:p,sunDirectionBuffer:f,blueNoiseTextureView:m,timeBuffer:g,bvhBuffer:v})=>{if(o||(o=er.createTexture({size:[t.finalTexture.width,t.finalTexture.height,1],format:t.finalTexture.format,usage:t.finalTexture.usage}),a=o.createView()),e.copyTextureToTexture({texture:t.finalTexture.texture},{texture:o},{width:t.finalTexture.width,height:t.finalTexture.height,depthOrArrayLayers:1}),!l){const e=[{binding:0,resource:t.depthTexture.view},{binding:1,resource:a},{binding:2,resource:t.finalTexture.view},{binding:3,resource:{buffer:s}},{binding:4,resource:h.atlasTextureView},{binding:5,resource:{buffer:d}},{binding:6,resource:{buffer:p}},{binding:7,resource:{buffer:f}},{binding:8,resource:u},{binding:10,resource:t.normalTexture.view},{binding:11,resource:m},{binding:12,resource:{buffer:g}},{binding:13,resource:c},{binding:14,resource:t.velocityTexture.view},{binding:15,resource:{buffer:v}},{binding:16,resource:t.worldPositionTexture.view},{binding:17,resource:t.albedoTexture.view},{binding:18,resource:t.skyTexture.createView({dimension:"cube"})},{binding:19,resource:{buffer:h.octreeBuffer}}],n={layout:i,entries:e};l=er.createBindGroup(n)}const y=e.beginComputePass({timestampWrites:n});y.setPipeline(r),y.setBindGroup(0,l),y.dispatchWorkgroups(Math.ceil(t.finalTexture.width/8),Math.ceil(t.finalTexture.height/8)),y.end()},label:n}})({shaderCode:"const TARGET_DELTA_TIME: f32 = 16.66;\nconst MAX_SAMPLES: i32 = 8;\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let pixel = GlobalInvocationID.xy;\n  var velocity = textureLoad(velocityAndWaterTex, pixel, 0).xy;\n  let resolution = textureDimensions(inputTex);\n  let centerOfPixel = vec2<f32>(GlobalInvocationID.xy) + vec2<f32>(0.5);\n  var uv = centerOfPixel / vec2<f32>(resolution);\n  let blurScale = (TARGET_DELTA_TIME / time.deltaTime); // less blur when framerate is high\n  let scaledVelocity = velocity * blurScale;\n  var samples = MAX_SAMPLES;\n  var validSamples = 0.0;\n  var result = vec4<f32>(0.0);\n  for (var i = 0; i < samples; i++) {\n    var offset = scaledVelocity * (f32(i) / f32(samples - 1) - 0.5);\n    let offsetUv = uv + offset;\n    let textureSample = textureSampleLevel(inputTex, nearestSampler, offsetUv, 0.0);\n    result += textureSample;\n    validSamples += 1.0;\n  }\n  result /= validSamples;\n  textureStore(outputTex, pixel, result);\n}",entryPoint:"main",label:"motion blur"});new class{#m;#g;#v;#y;constructor(){this.#m=new qn(1),this.#g=new qn(0),this.#v=new qn(0),this.#y=new qn(.8)}set targetScale(e){this.#m.target=e}set targetTranslateX(e){this.#g.target=e}set targetRotateY(e){this.#v.target=e}set targetSunRotateY(e){this.#y.target=e}get targetScale(){return this.#m.target}get targetTranslateX(){return this.#g.target}get targetRotateY(){return this.#v.target}get targetSunRotateY(){return this.#y.target}get sunRotateY(){return this.#y.value}get scale(){return this.#m.value}get translateX(){return this.#g.value}};let Ks,Qs,Js,er,tr=z.create(4,4),nr=0,ir=nr,sr=0,rr=0;const or=new class{gui;timingsFolder;passesFolder;constructor(){this.gui=new kt,this.timingsFolder=this.gui.addFolder("timings"),this.passesFolder=this.gui.addFolder("passes")}log(e){Object.keys(e).forEach((t=>{const n=this.timingsFolder.controllers.find((e=>e.property===t));n?n.setValue(e[t].toFixed(2)):this.timingsFolder.add(e,t)}))}setupDebugControls(e){const t=e.reduce(((e,t)=>(e[t.label]=!0,e)),{});e.forEach((e=>{this.passesFolder.add(t,e.label)}))}},ar=(()=>{let e={};const t=t=>{const n=e[t];return n?n.reduce(((e,t)=>e+t))/n.length:0};return{addSample:(t,n)=>{e[t]||(e[t]=[]),e[t].push(n)>50&&e[t].shift()},clearEntry:t=>{e[t]&&(e[t]=[0])},toString:()=>Object.keys(e).map((e=>`${e}: ${t(e).toFixed(2)}ms`)).join("\n"),toHTML:()=>Object.keys(e).map((e=>`<div class="debug-row">\n                    <div>\n                        ${e}\n                    </div>\n                   <div>${t(e).toFixed(2)}ms</div>\n                </div>`)).join("\n"),getAverages:()=>Object.keys(e).reduce(((e,n)=>(e[n]=t(n),e)),{})}})();ar.addSample("frame time",0);let lr,cr,ur,hr,dr,pr,fr,mr,gr,vr,yr,xr,wr,_r,br,kr,Ar,Er,Sr,Tr,Mr,Pr,zr,Cr=ve.create();cr=Array.from({length:200}).map((()=>({position:[-80*Math.random(),50*Math.random(),-200*Math.random()],size:4,color:te.normalize(te.create(Math.random(),Math.random(),Math.random()))})));const Ir=async(e,t,n,i)=>{if(er=e,Js=t,!navigator.gpu)throw new Error("WebGPU not supported");Or=((e,t,n)=>{const i=new Float32Array(t),s=e.createBuffer({size:i.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"camera position"});return $e(s,t),s})(er,[0,0,0,0]),Br(er),Er=new Cs(er,[]),lr=er.createTexture({label:"sky texture",dimension:"2d",size:[640,640,6],format:"rgba16float",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),ur=await Promise.all([Bs(),lt(),(async()=>({label:"copy albedo",render:e=>{((e,t,n)=>{if(t.width!==n.width||t.height!==n.height)throw new Error("Source and destination textures must have the same dimensions");e.copyTextureToTexture({texture:t.texture},{texture:n.texture},{width:t.texture.width,height:t.texture.height,depthOrArrayLayers:1})})(e.commandEncoder,e.outputTextures.albedoTexture,e.outputTextures.finalTexture)}}))(),Ds(),Zs(),At(er)]),zr=ur.reduce(((e,t)=>t.timestampLabels?e.concat(t.timestampLabels):e.concat(t.label)),[]),or.setupDebugControls(ur),Qs=document.getElementById("webgpu-canvas"),Qs.style.imageRendering="pixelated",Ks=Qs.getContext("webgpu"),Ks.configure({device:er,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT}),Mr=er.createSampler({magFilter:"linear",minFilter:"linear"}),Pr=er.createSampler({magFilter:"nearest",minFilter:"nearest"}),er.features.has("timestamp-query")&&(Sr=er.createQuerySet({type:"timestamp",count:1e3}),Tr=er.createBuffer({label:"timestamp query",size:8*Sr.count,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}));const{clientWidth:s,clientHeight:r}=Qs.parentElement,o=z.create(1*s,1*r);tr=z.mulScalar(o,1),Qs.width=o[0],Qs.height=o[1],Qs.style.transform="scale(1)"},Br=async e=>{const t=await async function(e,t,n={}){return Ts(e,[t],n)}(e,"blue-noise-rg.png",{usage:GPUTextureUsage.COPY_SRC});vr=t.createView()};let Or;setInterval((()=>{or.log(ar.getAverages())}),500);let Nr=0;const Rr=(e,t,n,i,s)=>{if(!er||!ur||!Js)return;const r=er.createCommandEncoder();0===nr&&(nr=e),r.pushDebugGroup("frame");const o=e-nr;sr=o-ir,ar.addSample("frame time",sr),ir=o,rr++,((e,t)=>{const n=function(e,t,n,i,s,r){const o=2*Math.tan(i/2)*r,a=o*s,l=1/t,c=1/n;return[(Os(e,2)-.5)*l*a,(Os(e,3)-.5)*c*o]}(rr,tr[0],tr[1],"fieldOfView"in e.config?e.config.fieldOfView:90,tr[0]/tr[1],"near"in e.config?e.config.near:.1),i=function(e,t){const n=new Float32Array(e);return n[8]+=t[0],n[9]+=t[1],n}(e.projectionMatrix,n),s=(e=>{const t=e.position;return ve.lookAt(t,te.add(t,e.direction),e.up)})(t),r=ve.mul(i,s);kr=new Float32Array([...r,...Cr,...ve.invert(r),...ve.invert(Cr),...i,...ve.invert(i),...s]),_r||(_r=er.createBuffer({size:kr.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"view matrices buffer"})),er.queue.writeBuffer(_r,0,kr.buffer,0,kr.length*Float32Array.BYTES_PER_ELEMENT);const o=ve.mul((a=i,ve.invert(a)),r);var a;const l=ve.invert(o);Ar=new Float32Array(ve.getTranslation(l)),er.queue.writeBuffer(Or,0,Ar.buffer,0,Ar.length*Float32Array.BYTES_PER_ELEMENT),Cr=r})(n,i),((e,t,n)=>{const i=76*n.length;wr&&i===wr.size||(wr=e.createBuffer({size:i*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"voxel objects buffer"})),n.forEach(((n,i)=>{const s=((e,t)=>{const n=((e,t)=>[...t.transform,...ve.invert(t.transform),...t.previousTransform,...ve.invert(t.previousTransform),...e.size,0,...e.atlasLocation,e.paletteIndex])(e,t),i=4*(n.length+1),s=new DataView(new ArrayBuffer(i));for(let e=0;e<n.length-1;e++)s.setFloat32(4*e,n[e],!0);return s.setUint32(i-4,e.octreeBufferIndex,!0),s})(t.getComponents(n).get(Fs),t.getComponents(n).get(Us)).buffer;e.queue.writeBuffer(wr,76*i*Float32Array.BYTES_PER_ELEMENT,s,0,s.byteLength)}))})(er,t,s),yr||(yr=Ge([rr,0,0],"time buffer")),er.queue.writeBuffer(yr,4,new Float32Array([sr])),er.queue.writeBuffer(yr,0,new Uint32Array([rr])),er.queue.writeBuffer(yr,8,new Float32Array([ir/1e3])),xr?Ve(xr,[tr[0],tr[1]]):xr=Ge([tr[0],tr[1]]),(()=>{let e=Math.cos(ir/5e3),t=Math.sin(ir/5e3);const n=te.create(e,1,t);br?$e(br,[n[0],n[1],n[2]]):br=Ge([n[0],n[1],n[2]],"sun buffer")})(),Er.update(s.map((e=>((e,t)=>{const n=te.create(e.size[0]/2,e.size[1]/2,e.size[2]/2);return(e=>{let t=te.create(1/0,1/0,1/0),n=te.create(-1/0,-1/0,-1/0);for(const i of e)t=te.min(t,i),n=te.max(n,i);return{min:t,max:n}})([te.create(-n[0],-n[1],-n[2]),te.create(-n[0],-n[1],n[2]),te.create(-n[0],n[1],-n[2]),te.create(-n[0],n[1],n[2]),te.create(n[0],-n[1],-n[2]),te.create(n[0],-n[1],n[2]),te.create(n[0],n[1],-n[2]),te.create(n[0],n[1],n[2])].map((e=>te.transformMat4(e,t.transform))))})(t.getComponents(e).get(Fs),t.getComponents(e).get(Us))))),Nr=s.length,dr=new nt(er,tr[0],tr[1]),hr=new it(er,tr[0],tr[1]),fr=new st(er,tr[0],tr[1]),mr=new rt(er,tr[0],tr[1]),pr=new at(er,tr[0],tr[1]),gr=new ot(er,tr[0],tr[1]);let a=0;ur.forEach(((e,o)=>{const{render:l,label:c}=e;if(!1===or.passesFolder.controllers.find((e=>e.property===c))?.getValue())return;let u;er.features.has("timestamp-query")&&r.clearBuffer(Tr),er.features.has("timestamp-query")&&(u={querySet:Sr,beginningOfPassWriteIndex:a,endOfPassWriteIndex:a+1}),c&&r.pushDebugGroup(c),l({enabled:document.getElementById(`flag-${c}`)?.checked,commandEncoder:r,resolutionBuffer:xr,timeBuffer:yr,outputTextures:{finalTexture:pr,albedoTexture:dr,normalTexture:hr,depthTexture:fr,skyTexture:lr,velocityTexture:mr,worldPositionTexture:gr},cameraPositionBuffer:Or,volumeAtlas:Js,transformationMatrixBuffer:wr,viewProjectionMatricesArray:kr,viewProjectionMatricesBuffer:_r,timestampWrites:u,sunDirectionBuffer:br,blueNoiseTextureView:vr,bvhBuffer:Er.gpuBuffer,lights:cr,linearSampler:Mr,nearestSampler:Pr,camera:n,cameraTransform:i,renderableEntities:s,ecs:t,device:er}),e.timestampLabels?.length>0?a+=2*e.timestampLabels.length:a+=2,c&&r.popDebugGroup()})),r.popDebugGroup(),er.features.has("timestamp-query")&&(async(e,t,n)=>{const i=n.size;Ns||(Ns=er.createBuffer({size:i,label:"gpu read buffer",usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}));const s=er.createCommandEncoder();if(Rs)return;Rs=!0,s.resolveQuerySet(t,0,t.count,n,0),s.copyBufferToBuffer(n,0,Ns,0,i),er.queue.submit([s.finish()]),await er.queue.onSubmittedWorkDone(),await Ns.mapAsync(GPUMapMode.READ).finally((()=>{Rs=!1}));const r=Ns.getMappedRange(),o=new BigInt64Array(r),a=[];o.forEach((e=>{a.push(Number(e)/1e6)})),a.reduce(((e,t,n)=>(n%2==0&&e.push(a[n+1]-t),e)),[]).forEach(((t,n)=>{ar.addSample(e[n],t)})),Ns.unmap()})(zr,Sr,Tr),er.queue.submit([r.finish()])};class Ur extends e{config;constructor(e){super(),this.config=e}get projectionMatrix(){return"size"in this.config?ve.ortho(-tr[0]/this.config.size,tr[0]/this.config.size,-tr[1]/this.config.size,tr[1]/this.config.size,this.config.size,-this.config.size):ve.perspective(this.config.fieldOfView,tr[0]/tr[1],this.config.near,this.config.far)}}class Fr{index;dataView;constructor(e){this.dataView=new DataView(e),this.index=0}readUint8(){const e=this.dataView.getUint8(this.index);return this.index++,e}readUint32(){const e=this.dataView.getUint32(this.index,!0);return this.index+=4,e}readFloat32(){const e=this.dataView.getFloat32(this.index,!0);return this.index+=4,e}skip(e){this.index+=e}}const Dr=e=>0===e,Lr=e=>[1&e?1:0,2&e?1:0,4&e?1:0];let qr=0;class jr{nodes;#x;#w;constructor(e){var t;this.nodes=[],this.#x=0,this.#w=(t=e.SIZE,Math.ceil(Math.log2(Math.max(...t)))),this.#d(e,0,[0,0,0],0),qr/=this.nodes.length,console.log(`Average first child index: ${qr}`),console.log(this.nodes.slice(0,10))}#_(e=8){return this.#x+=e,this.#x-(e-1)}#d(e,t,n,i){if(1===e.SIZE[0]){const i=e.XYZI[0].c;return void(this.nodes[t]={red:e.RGBA[i].r,green:e.RGBA[i].g,blue:e.RGBA[i].b,x:n[0],y:n[1],z:n[2]})}const s=Array.from({length:8},(()=>null)),r=i+1,o=(e=>Math.pow(2,Math.ceil(Math.log2(e))))(Math.max(...e.SIZE)),a=o/2;for(let t=0;t<8;t++){const i=Lr(t),r=n[0]+i[0]*a,o=n[1]+i[1]*a,l=n[2]+i[2]*a,c=e.XYZI.filter((e=>e.x>=r&&e.x<r+a&&e.y>=o&&e.y<o+a&&e.z>=l&&e.z<l+a));c.length>0&&(s[t]={SIZE:[a,a,a],XYZI:c,RGBA:e.RGBA,VOX:c.length})}let l=0;const c=s.reduce(((e,t,n)=>t?(l=n+1,e|1<<n):e),0),u=this.#_(l),h=u-t;s.forEach(((e,t)=>{if(e){const i=u+t,s=Lr(t),o=n[0]+s[0]*a,l=n[1]+s[1]*a,c=n[2]+s[2]*a;this.#d(e,i,[o,l,c],r)}})),qr+=u,this.nodes[t]={firstChildIndex:h,childMask:c,voxels:{...e,SIZE:[o,o,o]},x:n[0],y:n[1],z:n[2],size:o,leafMask:0}}get totalSize(){return 8*this.nodes.length}}const Vr=async(e,t,n)=>{console.time(`Fetch ${e}`);const i=await fetch(e);console.timeEnd(`Fetch ${e}`);const s=(e=>{console.time("convert vxm");const t=new Fr(e);let n,i=[],s="",r=[];if(s=String.fromCodePoint(t.readUint8(),t.readUint8(),t.readUint8(),t.readUint8()),"VXMC"!==s&&"VXMA"!==s)throw new Error(`Incorrect magic: ${s}`);if(s[3].charCodeAt(0)>="0".charCodeAt(0)&&s[3].charCodeAt(0)<="9".charCodeAt(0))n=s[3].charCodeAt(0)-"0".charCodeAt(0);else{if(!(s[3].charCodeAt(0)>="A".charCodeAt(0)&&s[3].charCodeAt(0)<="C".charCodeAt(0)))throw new Error("Unsupported version found");n=10+s[3].charCodeAt(0)-"A".charCodeAt(0)}if(n<11||n>12)throw new Error(`Could not load vxm file: Unsupported version found (${n})`);let o=[0,0,0];o[0]=t.readUint32(),o[1]=t.readUint32(),o[2]=t.readUint32();let a=[.5,0,.5];if(a[0]=t.readFloat32(),a[1]=t.readFloat32(),a[2]=t.readFloat32(),t.readUint8()>0){let e=0,n=0;t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),e=t.readUint32(),n=t.readUint32();let i=e*n;t.skip(4*i)}n>=8&&t.skip(16);let l=t.readUint32();for(let e=0;e<l;++e){let e=t.readUint32(),n=t.readUint32();if(e>2048||n>2048)throw new Error("Size of texture exceeds the max allowed value");let i=t.readUint32();t.skip(i);for(let e=0;e<6;++e){let e=t.readUint32();e>262144&&console.warn(`Size of quads exceeds the max allowed value: ${e}`);let n=4*e*20;t.skip(n)}}t.skip(1024),t.skip(1024);let c=t.readUint8();for(let e=0;e<c;++e)t.skip(1024),t.readUint8(),t.readUint8();let u=t.readUint8();for(let e=0;e<u;++e){let n=t.readUint8(),s=t.readUint8(),r=t.readUint8(),o=t.readUint8();o=1===t.readUint8()?2:255,i[e]={r,g:s,b:n,a:o}}let h=1;n>=12&&(h=t.readUint8());let d={min:te.create(9999,9999,9999),max:te.create(0,0,0)};for(let e=0;e<h;++e){let i=0,s=!0,a="";if(n>=12){for(;;){const e=t.readUint8();if(Dr(e))break;a=`${a}${String.fromCharCode(e)}`}s=t.readUint8()>0}else a=`Layer ${e}`;for(;;){let e=t.readUint8();if(0===e)break;let n=t.readUint8();if(255!==n)if(n>=u)i+=e;else{for(let t=i;t<i+e;t++){let e=Math.floor(t/(o[1]*o[2])),i=Math.floor(t/o[2]%o[1]),s=Math.floor(t%o[2]);d.min=te.min(d.min,[e,i,s]),d.max=te.max(d.max,[e,i,s]),r.push({x:e,y:i,z:s,c:n})}i+=e}else i+=e}}r=r.map((({x:e,y:t,z:n,c:i})=>({x:e-d.min[0],y:t-d.min[1],z:n-d.min[2],c:i})));const p=te.sub(d.max,d.min);return console.timeEnd("convert vxm"),{VOX:r.length,SIZE:[p[0]+1,p[1]+1,p[2]+1],XYZI:r,RGBA:i}})(await i.arrayBuffer());console.time(`Create octree for ${e}`);const r=(e=>{const t=new ArrayBuffer(e.totalSize+8),n=new DataView(t);return e.nodes.forEach(((e,t)=>{"red"in e?((e,t,n)=>{e.setUint16(8*t,0,!0),e.setUint8(8*t+2,n.red),e.setUint8(8*t+3,n.green),e.setUint8(8*t+4,n.blue),e.setUint8(8*t+5,n.x),e.setUint8(8*t+6,n.y),e.setUint8(8*t+7,n.z)})(n,t,e):((e,t,n)=>{console.assert(n.firstChildIndex<2**24-1,`First child index of ${n.firstChildIndex} is too large to fit in 3 bytes`),e.setUint32(8*t,n.firstChildIndex,!0),e.setUint8(8*t+3,n.childMask),e.setUint8(8*t+4,n.x),e.setUint8(8*t+5,n.y),e.setUint8(8*t+6,n.z),e.setUint8(8*t+7,Math.log2(n.size))})(n,t,e)})),console.debug(`Created ${e.nodes.length} node octree of size ${(e.totalSize/1048576).toFixed(3)} MB`),t})(new jr(s));console.timeEnd(`Create octree for ${e}`),await n.addVolume(e,s.SIZE,r)},Gr=async(e,t,n)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const i=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const n=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:t.mipLevelCount}),i=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let s=0;s<t.depthOrArrayLayers>>e;s++)i.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:s}},{texture:n,mipLevel:e,origin:{x:0,y:0,z:s}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([i.finish()]),await e.queue.onSubmittedWorkDone(),n})(e,t),s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),r=e.createBuffer({size:256*t.depthOrArrayLayers,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.UNIFORM,label:"z indices buffer"}),o=Array.from({length:t.depthOrArrayLayers},((e,t)=>t));for(let t=0;t<o.length;t++)e.queue.writeBuffer(r,256*t,new Uint32Array([o[t]]).buffer);const a=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[s]}),vertex:{module:e.createShaderModule({code:"\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n          }\n          const pos = array(\n              vec2( 1.0,  1.0),\n              vec2( 1.0, -1.0),\n              vec2(-1.0, -1.0),\n              vec2( 1.0,  1.0),\n              vec2(-1.0, -1.0),\n              vec2(-1.0,  1.0),\n            );\n          @vertex\n          fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            var output : VertexOutput;\n            output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n            return output;\n          }"}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:"\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> zIndex: u32;\n          @fragment\nfn fragment_main(@builtin(position) position : vec4<f32>) -> @location(0) vec4<f32> {\n  let srcTexel = vec3(vec2<u32>(position.xy),zIndex);\n  var colours = array<f32, 8>();\n  var isOctantEmpty = true;\n  for(var x = u32(0); x < 2; x++){\n    for(var y = u32(0); y < 2; y++){\n      for(var z = u32(0); z < 2; z++){\n        let voxelX = srcTexel.x * 2 + x;\n        let voxelY = srcTexel.y * 2 + y;\n        let voxelZ = srcTexel.z * 2 + z;\n        var voxelId = vec3<u32>(voxelX,voxelY,voxelZ);\n        var voxel = textureLoad(voxels,voxelId,0).r;\n        if(voxel > 0){\n          var index = x + y * 2 + z * 4;\n          colours[index] = voxel;\n          isOctantEmpty = false;\n        }\n      }\n    }\n  }\n\n  // If all voxels in the octant are empty, keep it blank\n  if(isOctantEmpty){\n    discard;\n  }\n\n  // Get the most common colour in the octant\n  var mostCommonColour = f32(0);\n  var mostCommonColourCount = u32(0);\n  for(var i = u32(0); i < 8; i = i + 1u){\n    var colour = colours[i];\n    var count = u32(0);\n    for(var j = u32(0); j < 8; j = j + 1u){\n      if(colour > 0 && colour == colours[j]){\n        count++;\n      }\n    }\n    if(count > mostCommonColourCount){\n      mostCommonColour = colour;\n      mostCommonColourCount = count;\n    }\n  }\n\n  return vec4(mostCommonColour, 0,0,0);\n}\n\n\n        "}),entryPoint:"fragment_main",targets:[{format:t.format}]}}),l=e.createCommandEncoder(),c=Math.max(1,t.depthOrArrayLayers>>n);for(let o=0;o<c;o++){const c=e.createBindGroup({layout:s,entries:[{binding:0,resource:t.createView({label:`${n} mip level of volume texture`,dimension:"3d",baseMipLevel:n-1,mipLevelCount:1})},{binding:1,resource:{buffer:r,offset:256*o,size:4}}]}),u=l.beginRenderPass({colorAttachments:[{view:i.createView({label:"volume slice for rendering mips",baseArrayLayer:o,arrayLayerCount:1,baseMipLevel:n,mipLevelCount:1,dimension:"2d-array"}),loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});u.setPipeline(a),u.setBindGroup(0,c),u.draw(6),u.end()}return e.queue.submit([l.finish()]),await e.queue.onSubmittedWorkDone(),await(async(e,t)=>{if("2d"!==t.dimension)throw new Error("Input texture should be a 2D texture");const n=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d",mipLevelCount:t.mipLevelCount}),i=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let s=0;s<t.depthOrArrayLayers>>e;s++)i.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:s}},{texture:n,mipLevel:e,origin:{x:0,y:0,z:s}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([i.finish()]),await e.queue.onSubmittedWorkDone(),n})(e,i)},$r={format:"r8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d"},Hr=Math.pow(2,3),Wr=(e,t)=>{if(4!==t.length)throw new Error("Sequence must be exactly 4 characters long");const n=new Uint8Array(4);for(let e=0;e<4;e++)n[e]=t.charCodeAt(e);const i=[];for(let t=0;t<=e.length-4;t++)e[t]===n[0]&&e[t+1]===n[1]&&e[t+2]===n[2]&&e[t+3]===n[3]&&i.push(t);return i};class Yr{#b={};#k;#A;#a;#E;#S;#T;constructor(e){this.#a=e,this.#k=e.createTexture({size:{width:Hr,height:Hr,depthOrArrayLayers:Hr},...$r,label:"Volume atlas containing ",mipLevelCount:4}),this.#A=e.createTexture({size:{width:256,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1}),this.#E=this.#k.createView(),this.#S=this.#A.createView(),this.#T=e.createBuffer({size:0,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,label:"Octree buffer"})}get dictionary(){return this.#b}addVolume=async(e,t,n)=>{if(this.#b[e])throw new Error(`Error adding volume to atlas: volume with label ${e} already exists`);const i=this.#a.createCommandEncoder(),[s,r,o]=t,a=this.#T.size/8;this.#b[e]={location:[0,0,0],size:[s,r,o],paletteIndex:0,octreeOffset:a,octreeSizeBytes:n.byteLength,textureSizeBytes:s*r*o};const l=this.#a.createBuffer({label:"Octree buffer",size:this.#T.size+n.byteLength,usage:this.#T.usage});i.copyBufferToBuffer(this.#T,0,l,0,this.#T.size),this.#a.queue.submit([i.finish()]),console.log(`writing ${e} at byte offset ${this.#T.size}, index ${a}`),this.#a.queue.writeBuffer(l,this.#T.size,n),await this.#a.queue.onSubmittedWorkDone();const c=this.#a.createCommandEncoder(),u=this.#a.createBuffer({size:l.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1});c.copyBufferToBuffer(l,0,u,0,l.size),this.#a.queue.submit([c.finish()]),u.mapAsync(GPUMapMode.READ).then((()=>{const e=new Uint8Array(u.getMappedRange());console.log({magicIndices:Wr(e,"OCTR")}),console.log({length:e.length/4})})),this.#T=l,this.#T.unmap(),this.#k=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");let n=t;for(let i=1;i<t.mipLevelCount;i++)n=await Gr(e,n,i);return n})(this.#a,this.#k),this.#E=this.#k.createView(),this.#S=this.#A.createView()};get atlasTextureView(){return this.#E}get paletteTextureView(){return this.#S}get octreeBuffer(){return this.#T}}class Xr extends e{device;volumeAtlas}class Zr{pressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1," ":!1,shift:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1})),window.addEventListener("blur",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))})),window.addEventListener("contextmenu",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))}))}}class Kr extends e{speed=.05;rotationSpeed=.002}class Qr{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new eo);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new eo);const n=this.elements,i=e.x,s=e.y,r=e.z;return t.x=n[0]*i+n[1]*s+n[2]*r,t.y=n[3]*i+n[4]*s+n[5]*r,t.z=n[6]*i+n[7]*s+n[8]*r,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new Qr);const n=this.elements,i=e.elements,s=t.elements,r=n[0],o=n[1],a=n[2],l=n[3],c=n[4],u=n[5],h=n[6],d=n[7],p=n[8],f=i[0],m=i[1],g=i[2],v=i[3],y=i[4],x=i[5],w=i[6],_=i[7],b=i[8];return s[0]=r*f+o*v+a*w,s[1]=r*m+o*y+a*_,s[2]=r*g+o*x+a*b,s[3]=l*f+c*v+u*w,s[4]=l*m+c*y+u*_,s[5]=l*g+c*x+u*b,s[6]=h*f+d*v+p*w,s[7]=h*m+d*y+p*_,s[8]=h*g+d*x+p*b,t}scale(e,t){void 0===t&&(t=new Qr);const n=this.elements,i=t.elements;for(let t=0;3!==t;t++)i[3*t+0]=e.x*n[3*t+0],i[3*t+1]=e.y*n[3*t+1],i[3*t+2]=e.z*n[3*t+2];return t}solve(e,t){void 0===t&&(t=new eo);const n=[];let i,s;for(i=0;i<12;i++)n.push(0);for(i=0;i<3;i++)for(s=0;s<3;s++)n[i+4*s]=this.elements[i+3*s];n[3]=e.x,n[7]=e.y,n[11]=e.z;let r=3;const o=r;let a,l;do{if(i=o-r,0===n[i+4*i])for(s=i+1;s<o;s++)if(0!==n[i+4*s]){a=4;do{l=4-a,n[l+4*i]+=n[l+4*s]}while(--a);break}if(0!==n[i+4*i])for(s=i+1;s<o;s++){const e=n[i+4*s]/n[i+4*i];a=4;do{l=4-a,n[l+4*s]=l<=i?0:n[l+4*s]-n[l+4*i]*e}while(--a)}}while(--r);if(t.z=n[11]/n[10],t.y=(n[7]-n[6]*t.z)/n[5],t.x=(n[3]-n[2]*t.z-n[1]*t.y)/n[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(void 0===n)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new Qr);const t=Jr;let n,i;for(n=0;n<3;n++)for(i=0;i<3;i++)t[n+6*i]=this.elements[n+3*i];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let s=3;const r=s;let o,a;do{if(n=r-s,0===t[n+6*n])for(i=n+1;i<r;i++)if(0!==t[n+6*i]){o=6;do{a=6-o,t[a+6*n]+=t[a+6*i]}while(--o);break}if(0!==t[n+6*n])for(i=n+1;i<r;i++){const e=t[n+6*i]/t[n+6*n];o=6;do{a=6-o,t[a+6*i]=a<=n?0:t[a+6*i]-t[a+6*n]*e}while(--o)}}while(--s);n=2;do{i=n-1;do{const e=t[n+6*i]/t[n+6*n];o=6;do{a=6-o,t[a+6*i]=t[a+6*i]-t[a+6*n]*e}while(--o)}while(i--)}while(--n);n=2;do{const e=1/t[n+6*n];o=6;do{a=6-o,t[a+6*n]=t[a+6*n]*e}while(--o)}while(n--);n=2;do{i=2;do{if(a=t[3+i+6*n],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(n,i,a)}while(i--)}while(n--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,i=e.z,s=e.w,r=t+t,o=n+n,a=i+i,l=t*r,c=t*o,u=t*a,h=n*o,d=n*a,p=i*a,f=s*r,m=s*o,g=s*a,v=this.elements;return v[0]=1-(h+p),v[1]=c-g,v[2]=u+m,v[3]=c+g,v[4]=1-(l+p),v[5]=d-f,v[6]=u-m,v[7]=d+f,v[8]=1-(l+h),this}transpose(e){void 0===e&&(e=new Qr);const t=this.elements,n=e.elements;let i;return n[0]=t[0],n[4]=t[4],n[8]=t[8],i=t[1],n[1]=t[3],n[3]=i,i=t[2],n[2]=t[6],n[6]=i,i=t[5],n[5]=t[7],n[7]=i,e}}const Jr=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class eo{constructor(e,t,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){void 0===t&&(t=new eo);const n=e.x,i=e.y,s=e.z,r=this.x,o=this.y,a=this.z;return t.x=o*s-a*i,t.y=a*n-r*s,t.z=r*i-o*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new eo(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new eo(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new Qr([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,i=Math.sqrt(e*e+t*t+n*n);if(i>0){const e=1/i;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return i}unit(e){void 0===e&&(e=new eo);const t=this.x,n=this.y,i=this.z;let s=Math.sqrt(t*t+n*n+i*i);return s>0?(s=1/s,e.x=t*s,e.y=n*s,e.z=i*s):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,i=this.z,s=e.x,r=e.y,o=e.z;return Math.sqrt((s-t)*(s-t)+(r-n)*(r-n)+(o-i)*(o-i))}distanceSquared(e){const t=this.x,n=this.y,i=this.z,s=e.x,r=e.y,o=e.z;return(s-t)*(s-t)+(r-n)*(r-n)+(o-i)*(o-i)}scale(e,t){void 0===t&&(t=new eo);const n=this.x,i=this.y,s=this.z;return t.x=e*n,t.y=e*i,t.z=e*s,t}vmul(e,t){return void 0===t&&(t=new eo),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return void 0===n&&(n=new eo),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new eo),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const i=to,s=1/n;i.set(this.x*s,this.y*s,this.z*s);const r=no;Math.abs(i.x)<.9?(r.set(1,0,0),i.cross(r,e)):(r.set(0,1,0),i.cross(r,e)),i.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const i=this.x,s=this.y,r=this.z;n.x=i+(e.x-i)*t,n.y=s+(e.y-s)*t,n.z=r+(e.z-r)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(io),io.almostEquals(e,t)}clone(){return new eo(this.x,this.y,this.z)}}eo.ZERO=new eo(0,0,0),eo.UNIT_X=new eo(1,0,0),eo.UNIT_Y=new eo(0,1,0),eo.UNIT_Z=new eo(0,0,1);const to=new eo,no=new eo,io=new eo;class so{constructor(e){void 0===e&&(e={}),this.lowerBound=new eo,this.upperBound=new eo,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,i){const s=this.lowerBound,r=this.upperBound,o=n;s.copy(e[0]),o&&o.vmult(s,s),r.copy(s);for(let t=1;t<e.length;t++){let n=e[t];o&&(o.vmult(n,ro),n=ro),n.x>r.x&&(r.x=n.x),n.x<s.x&&(s.x=n.x),n.y>r.y&&(r.y=n.y),n.y<s.y&&(s.y=n.y),n.z>r.z&&(r.z=n.z),n.z<s.z&&(s.z=n.z)}return t&&(t.vadd(s,s),t.vadd(r,r)),i&&(s.x-=i,s.y-=i,s.z-=i,r.x+=i,r.y+=i,r.z+=i),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new so).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,i=e.lowerBound,s=e.upperBound,r=i.x<=n.x&&n.x<=s.x||t.x<=s.x&&s.x<=n.x,o=i.y<=n.y&&n.y<=s.y||t.y<=s.y&&s.y<=n.y,a=i.z<=n.z&&n.z<=s.z||t.z<=s.z&&s.z<=n.z;return r&&o&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,i=e.lowerBound,s=e.upperBound;return t.x<=i.x&&n.x>=s.x&&t.y<=i.y&&n.y>=s.y&&t.z<=i.z&&n.z>=s.z}getCorners(e,t,n,i,s,r,o,a){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),n.set(c.x,c.y,l.z),i.set(l.x,c.y,c.z),s.set(c.x,l.y,c.z),r.set(l.x,c.y,l.z),o.set(l.x,l.y,c.z),a.copy(c)}toLocalFrame(e,t){const n=oo,i=n[0],s=n[1],r=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(i,s,r,o,a,l,c,u);for(let t=0;8!==t;t++){const i=n[t];e.pointToLocal(i,i)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=oo,i=n[0],s=n[1],r=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(i,s,r,o,a,l,c,u);for(let t=0;8!==t;t++){const i=n[t];e.pointToWorld(i,i)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,i=1/t.x,s=1/t.y,r=1/t.z,o=(this.lowerBound.x-n.x)*i,a=(this.upperBound.x-n.x)*i,l=(this.lowerBound.y-n.y)*s,c=(this.upperBound.y-n.y)*s,u=(this.lowerBound.z-n.z)*r,h=(this.upperBound.z-n.z)*r,d=Math.max(Math.max(Math.min(o,a),Math.min(l,c)),Math.min(u,h)),p=Math.min(Math.min(Math.max(o,a),Math.max(l,c)),Math.max(u,h));return!(p<0||d>p)}}const ro=new eo,oo=[new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo];class ao{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:i}=t;if(i>n){const e=i;i=n,n=e}return this.matrix[(n*(n+1)>>1)+i-1]}set(e,t,n){let{index:i}=e,{index:s}=t;if(s>i){const e=s;s=i,i=e}this.matrix[(i*(i+1)>>1)+s-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class lo{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;return void 0===n[e]&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return!(void 0===n[e]||!n[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const n=this._listeners;if(void 0===n[e])return this;const i=n[e].indexOf(t);return-1!==i&&n[e].splice(i,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let n=0,i=t.length;n<i;n++)t[n].call(this,e)}return this}}class co{constructor(e,t,n,i){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),this.x=e,this.y=t,this.z=n,this.w=i}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(.5*t);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new eo),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=uo,n=ho;e.tangents(t,n),this.setFromAxisAngle(t,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new co);const n=this.x,i=this.y,s=this.z,r=this.w,o=e.x,a=e.y,l=e.z,c=e.w;return t.x=n*c+r*o+i*l-s*a,t.y=i*c+r*a+s*o-n*l,t.z=s*c+r*l+n*a-i*o,t.w=r*c-n*o-i*a-s*l,t}inverse(e){void 0===e&&(e=new co);const t=this.x,n=this.y,i=this.z,s=this.w;this.conjugate(e);const r=1/(t*t+n*n+i*i+s*s);return e.x*=r,e.y*=r,e.z*=r,e.w*=r,e}conjugate(e){return void 0===e&&(e=new co),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new eo);const n=e.x,i=e.y,s=e.z,r=this.x,o=this.y,a=this.z,l=this.w,c=l*n+o*s-a*i,u=l*i+a*n-r*s,h=l*s+r*i-o*n,d=-r*n-o*i-a*s;return t.x=c*l+d*-r+u*-a-h*-o,t.y=u*l+d*-o+h*-r-c*-a,t.z=h*l+d*-a+c*-o-u*-r,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let n,i,s;void 0===t&&(t="YZX");const r=this.x,o=this.y,a=this.z,l=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=r*o+a*l;if(e>.499&&(n=2*Math.atan2(r,l),i=Math.PI/2,s=0),e<-.499&&(n=-2*Math.atan2(r,l),i=-Math.PI/2,s=0),void 0===n){const t=r*r,c=o*o,u=a*a;n=Math.atan2(2*o*l-2*r*a,1-2*c-2*u),i=Math.asin(2*e),s=Math.atan2(2*r*l-2*o*a,1-2*t-2*u)}}e.y=n,e.z=i,e.x=s}setFromEuler(e,t,n,i){void 0===i&&(i="XYZ");const s=Math.cos(e/2),r=Math.cos(t/2),o=Math.cos(n/2),a=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(n/2);return"XYZ"===i?(this.x=a*r*o+s*l*c,this.y=s*l*o-a*r*c,this.z=s*r*c+a*l*o,this.w=s*r*o-a*l*c):"YXZ"===i?(this.x=a*r*o+s*l*c,this.y=s*l*o-a*r*c,this.z=s*r*c-a*l*o,this.w=s*r*o+a*l*c):"ZXY"===i?(this.x=a*r*o-s*l*c,this.y=s*l*o+a*r*c,this.z=s*r*c+a*l*o,this.w=s*r*o-a*l*c):"ZYX"===i?(this.x=a*r*o-s*l*c,this.y=s*l*o+a*r*c,this.z=s*r*c-a*l*o,this.w=s*r*o+a*l*c):"YZX"===i?(this.x=a*r*o+s*l*c,this.y=s*l*o+a*r*c,this.z=s*r*c-a*l*o,this.w=s*r*o-a*l*c):"XZY"===i&&(this.x=a*r*o-s*l*c,this.y=s*l*o-a*r*c,this.z=s*r*c+a*l*o,this.w=s*r*o+a*l*c),this}clone(){return new co(this.x,this.y,this.z,this.w)}slerp(e,t,n){void 0===n&&(n=new co);const i=this.x,s=this.y,r=this.z,o=this.w;let a,l,c,u,h,d=e.x,p=e.y,f=e.z,m=e.w;return l=i*d+s*p+r*f+o*m,l<0&&(l=-l,d=-d,p=-p,f=-f,m=-m),1-l>1e-6?(a=Math.acos(l),c=Math.sin(a),u=Math.sin((1-t)*a)/c,h=Math.sin(t*a)/c):(u=1-t,h=t),n.x=u*i+h*d,n.y=u*s+h*p,n.z=u*r+h*f,n.w=u*o+h*m,n}integrate(e,t,n,i){void 0===i&&(i=new co);const s=e.x*n.x,r=e.y*n.y,o=e.z*n.z,a=this.x,l=this.y,c=this.z,u=this.w,h=.5*t;return i.x+=h*(s*u+r*c-o*l),i.y+=h*(r*u+o*a-s*c),i.z+=h*(o*u+s*l-r*a),i.w+=h*(-s*a-r*l-o*c),i}}const uo=new eo,ho=new eo;class po{constructor(e){void 0===e&&(e={}),this.id=po.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,n,i){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}po.idCounter=0,po.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class fo{constructor(e){void 0===e&&(e={}),this.position=new eo,this.quaternion=new co,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return fo.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return fo.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new eo),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,i){return void 0===i&&(i=new eo),n.vsub(e,i),t.conjugate(mo),mo.vmult(i,i),i}static pointToWorldFrame(e,t,n,i){return void 0===i&&(i=new eo),t.vmult(n,i),i.vadd(e,i),i}static vectorToWorldFrame(e,t,n){return void 0===n&&(n=new eo),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,i){return void 0===i&&(i=new eo),t.w*=-1,t.vmult(n,i),t.w*=-1,i}}const mo=new co;class go extends po{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:n=[],normals:i=[],axes:s,boundingSphereRadius:r}=e;super({type:po.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=i,0===this.faceNormals.length&&this.computeNormals(),r?this.boundingSphereRadius=r:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=s?s.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const i=new eo;for(let s=0;s!==e.length;s++){const r=e[s],o=r.length;for(let e=0;e!==o;e++){const s=(e+1)%o;t[r[e]].vsub(t[r[s]],i),i.normalize();let a=!1;for(let e=0;e!==n.length;e++)if(n[e].almostEquals(i)||n[e].almostEquals(i)){a=!0;break}a||n.push(i.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new eo;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],i=this.vertices[n[0]],s=this.vertices[n[1]],r=this.vertices[n[2]];go.computeNormal(i,s,r,t)}static computeNormal(e,t,n,i){const s=new eo,r=new eo;t.vsub(e,r),n.vsub(t,s),s.cross(r,i),i.isZero()||i.normalize()}clipAgainstHull(e,t,n,i,s,r,o,a,l){const c=new eo;let u=-1,h=-Number.MAX_VALUE;for(let e=0;e<n.faces.length;e++){c.copy(n.faceNormals[e]),s.vmult(c,c);const t=c.dot(r);t>h&&(h=t,u=e)}const d=[];for(let e=0;e<n.faces[u].length;e++){const t=n.vertices[n.faces[u][e]],r=new eo;r.copy(t),s.vmult(r,r),i.vadd(r,r),d.push(r)}u>=0&&this.clipFaceAgainstHull(r,e,t,d,o,a,l)}findSeparatingAxis(e,t,n,i,s,r,o,a){const l=new eo,c=new eo,u=new eo,h=new eo,d=new eo,p=new eo;let f=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let o=0;o!==m.uniqueAxes.length;o++){n.vmult(m.uniqueAxes[o],l);const a=m.testSepAxis(l,e,t,n,i,s);if(!1===a)return!1;a<f&&(f=a,r.copy(l))}else{const a=o?o.length:m.faces.length;for(let c=0;c<a;c++){const a=o?o[c]:c;l.copy(m.faceNormals[a]),n.vmult(l,l);const u=m.testSepAxis(l,e,t,n,i,s);if(!1===u)return!1;u<f&&(f=u,r.copy(l))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){s.vmult(e.uniqueAxes[o],c);const a=m.testSepAxis(c,e,t,n,i,s);if(!1===a)return!1;a<f&&(f=a,r.copy(c))}else{const o=a?a.length:e.faces.length;for(let l=0;l<o;l++){const o=a?a[l]:l;c.copy(e.faceNormals[o]),s.vmult(c,c);const u=m.testSepAxis(c,e,t,n,i,s);if(!1===u)return!1;u<f&&(f=u,r.copy(c))}}for(let o=0;o!==m.uniqueEdges.length;o++){n.vmult(m.uniqueEdges[o],h);for(let o=0;o!==e.uniqueEdges.length;o++)if(s.vmult(e.uniqueEdges[o],d),h.cross(d,p),!p.almostZero()){p.normalize();const o=m.testSepAxis(p,e,t,n,i,s);if(!1===o)return!1;o<f&&(f=o,r.copy(p))}}return i.vsub(t,u),u.dot(r)>0&&r.negate(r),!0}testSepAxis(e,t,n,i,s,r){go.project(this,e,n,i,vo),go.project(t,e,s,r,yo);const o=vo[0],a=vo[1],l=yo[0],c=yo[1];if(o<c||l<a)return!1;const u=o-c,h=l-a;return u<h?u:h}calculateLocalInertia(e,t){const n=new eo,i=new eo;this.computeLocalAABB(i,n);const s=n.x-i.x,r=n.y-i.y,o=n.z-i.z;t.x=1/12*e*(2*r*2*r+2*o*2*o),t.y=1/12*e*(2*s*2*s+2*o*2*o),t.z=1/12*e*(2*r*2*r+2*s*2*s)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],i=this.vertices[t[0]];return-n.dot(i)}clipFaceAgainstHull(e,t,n,i,s,r,o){const a=new eo,l=new eo,c=new eo,u=new eo,h=new eo,d=new eo,p=new eo,f=new eo,m=this,g=i,v=[];let y=-1,x=Number.MAX_VALUE;for(let t=0;t<m.faces.length;t++){a.copy(m.faceNormals[t]),n.vmult(a,a);const i=a.dot(e);i<x&&(x=i,y=t)}if(y<0)return;const w=m.faces[y];w.connectedFaces=[];for(let e=0;e<m.faces.length;e++)for(let t=0;t<m.faces[e].length;t++)-1!==w.indexOf(m.faces[e][t])&&e!==y&&-1===w.connectedFaces.indexOf(e)&&w.connectedFaces.push(e);const _=w.length;for(let e=0;e<_;e++){const i=m.vertices[w[e]],s=m.vertices[w[(e+1)%_]];i.vsub(s,l),c.copy(l),n.vmult(c,c),t.vadd(c,c),u.copy(this.faceNormals[y]),n.vmult(u,u),t.vadd(u,u),c.cross(u,h),h.negate(h),d.copy(i),n.vmult(d,d),t.vadd(d,d);const r=w.connectedFaces[e];p.copy(this.faceNormals[r]);const o=this.getPlaneConstantOfFace(r);f.copy(p),n.vmult(f,f);const a=o-f.dot(t);for(this.clipFaceAgainstPlane(g,v,f,a);g.length;)g.shift();for(;v.length;)g.push(v.shift())}p.copy(this.faceNormals[y]);const b=this.getPlaneConstantOfFace(y);f.copy(p),n.vmult(f,f);const k=b-f.dot(t);for(let e=0;e<g.length;e++){let t=f.dot(g[e])+k;if(t<=s&&(console.log(`clamped: depth=${t} to minDist=${s}`),t=s),t<=r){const n=g[e];if(t<=1e-6){const e={point:n,normal:f,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,n,i){let s,r;const o=e.length;if(o<2)return t;let a=e[e.length-1],l=e[0];s=n.dot(a)+i;for(let c=0;c<o;c++){if(l=e[c],r=n.dot(l)+i,s<0)if(r<0){const e=new eo;e.copy(l),t.push(e)}else{const e=new eo;a.lerp(l,s/(s-r),e),t.push(e)}else if(r<0){const e=new eo;a.lerp(l,s/(s-r),e),t.push(e),t.push(l)}a=l,s=r}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new eo);const n=this.vertices,i=this.worldVertices;for(let s=0;s!==this.vertices.length;s++)t.vmult(n[s],i[s]),e.vadd(i[s],i[s]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const s=n[i];s.x<e.x?e.x=s.x:s.x>t.x&&(t.x=s.x),s.y<e.y?e.y=s.y:s.y>t.y&&(t.y=s.y),s.z<e.z?e.z=s.z:s.z>t.z&&(t.z=s.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new eo);const n=this.faceNormals,i=this.worldFaceNormals;for(let s=0;s!==t;s++)e.vmult(n[s],i[s]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const i=t[n].lengthSquared();i>e&&(e=i)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,i){const s=this.vertices;let r,o,a,l,c,u,h=new eo;for(let n=0;n<s.length;n++){h.copy(s[n]),t.vmult(h,h),e.vadd(h,h);const i=h;(void 0===r||i.x<r)&&(r=i.x),(void 0===l||i.x>l)&&(l=i.x),(void 0===o||i.y<o)&&(o=i.y),(void 0===c||i.y>c)&&(c=i.y),(void 0===a||i.z<a)&&(a=i.z),(void 0===u||i.z>u)&&(u=i.z)}n.set(r,o,a),i.set(l,c,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new eo);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,i=this.vertices;if(t){for(let e=0;e<n;e++){const n=i[e];t.vmult(n,n)}for(let e=0;e<this.faceNormals.length;e++){const n=this.faceNormals[e];t.vmult(n,n)}}if(e)for(let t=0;t<n;t++){const n=i[t];n.vadd(e,n)}}pointIsInside(e){const t=this.vertices,n=this.faces,i=this.faceNormals,s=new eo;this.getAveragePointLocal(s);for(let r=0;r<this.faces.length;r++){let o=i[r];const a=t[n[r][0]],l=new eo;e.vsub(a,l);const c=o.dot(l),u=new eo;s.vsub(a,u);const h=o.dot(u);if(c<0&&h>0||c>0&&h<0)return!1}return-1}static project(e,t,n,i,s){const r=e.vertices.length,o=xo;let a=0,l=0;const c=wo,u=e.vertices;c.setZero(),fo.vectorToLocalFrame(n,i,t,o),fo.pointToLocalFrame(n,i,c,c);const h=c.dot(o);l=a=u[0].dot(o);for(let e=1;e<r;e++){const t=u[e].dot(o);t>a&&(a=t),t<l&&(l=t)}if(l-=h,a-=h,l>a){const e=l;l=a,a=e}s[0]=a,s[1]=l}}const vo=[],yo=[],xo=(new eo,new eo),wo=new eo;class _o extends po{constructor(e){super({type:po.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,i=eo,s=[new i(-e,-t,-n),new i(e,-t,-n),new i(e,t,-n),new i(-e,t,-n),new i(-e,-t,n),new i(e,-t,n),new i(e,t,n),new i(-e,t,n)],r=[new i(0,0,1),new i(0,1,0),new i(1,0,0)],o=new go({vertices:s,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:r});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new eo),_o.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const i=e;n.x=1/12*t*(2*i.y*2*i.y+2*i.z*2*i.z),n.y=1/12*t*(2*i.x*2*i.x+2*i.z*2*i.z),n.z=1/12*t*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(e,t){const n=e,i=this.halfExtents;if(n[0].set(i.x,0,0),n[1].set(0,i.y,0),n[2].set(0,0,i.z),n[3].set(-i.x,0,0),n[4].set(0,-i.y,0),n[5].set(0,0,-i.z),void 0!==t)for(let e=0;e!==n.length;e++)t.vmult(n[e],n[e]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const i=this.halfExtents,s=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let i=0;i<s.length;i++)bo.set(s[i][0],s[i][1],s[i][2]),t.vmult(bo,bo),e.vadd(bo,bo),n(bo.x,bo.y,bo.z)}calculateWorldAABB(e,t,n,i){const s=this.halfExtents;ko[0].set(s.x,s.y,s.z),ko[1].set(-s.x,s.y,s.z),ko[2].set(-s.x,-s.y,s.z),ko[3].set(-s.x,-s.y,-s.z),ko[4].set(s.x,-s.y,-s.z),ko[5].set(s.x,s.y,-s.z),ko[6].set(-s.x,s.y,-s.z),ko[7].set(s.x,-s.y,s.z);const r=ko[0];t.vmult(r,r),e.vadd(r,r),i.copy(r),n.copy(r);for(let s=1;s<8;s++){const r=ko[s];t.vmult(r,r),e.vadd(r,r);const o=r.x,a=r.y,l=r.z;o>i.x&&(i.x=o),a>i.y&&(i.y=a),l>i.z&&(i.z=l),o<n.x&&(n.x=o),a<n.y&&(n.y=a),l<n.z&&(n.z=l)}}}const bo=new eo,ko=[new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo];class Ao extends lo{constructor(e){void 0===e&&(e={}),super(),this.id=Ao.idCounter++,this.index=-1,this.world=null,this.vlambda=new eo,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new eo,this.previousPosition=new eo,this.interpolatedPosition=new eo,this.initPosition=new eo,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new eo,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new eo,this.force=new eo;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Ao.STATIC:Ao.DYNAMIC,typeof e.type==typeof Ao.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Ao.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new eo,this.quaternion=new co,this.initQuaternion=new co,this.previousQuaternion=new co,this.interpolatedQuaternion=new co,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new eo,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new eo,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new eo,this.invInertia=new eo,this.invInertiaWorld=new Qr,this.invMassSolve=0,this.invInertiaSolve=new eo,this.invInertiaWorldSolve=new Qr,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new eo(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new eo(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new so,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new eo,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=Ao.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Ao.SLEEPING&&this.dispatchEvent(Ao.wakeupEvent)}sleep(){this.sleepState=Ao.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;t===Ao.AWAKE&&n<i?(this.sleepState=Ao.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Ao.sleepyEvent)):t===Ao.SLEEPY&&n>i?this.wakeUp():t===Ao.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Ao.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Ao.SLEEPING||this.type===Ao.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new eo),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new eo),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new eo),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new eo),this.quaternion.vmult(e,t),t}addShape(e,t,n){const i=new eo,s=new co;return t&&i.copy(t),n&&s.copy(n),this.shapes.push(e),this.shapeOffsets.push(i),this.shapeOrientations.push(s),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let i=0;for(let s=0;s!==n;s++){const n=e[s];n.updateBoundingSphereRadius();const r=t[s].length(),o=n.boundingSphereRadius;r+o>i&&(i=r+o)}this.boundingRadius=i}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,i=e.length,s=Eo,r=So,o=this.quaternion,a=this.aabb,l=To;for(let c=0;c!==i;c++){const i=e[c];o.vmult(t[c],s),s.vadd(this.position,s),o.mult(n[c],r),i.calculateWorldAABB(s,r,l.lowerBound,l.upperBound),0===c?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=Mo,n=Po;e.setRotationFromQuaternion(this.quaternion),e.transpose(n),e.scale(t,e),e.mmult(n,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new eo),this.type!==Ao.DYNAMIC)return;this.sleepState===Ao.SLEEPING&&this.wakeUp();const n=zo;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new eo),this.type!==Ao.DYNAMIC)return;const n=Co,i=Io;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,i),this.applyForce(n,i)}applyTorque(e){this.type===Ao.DYNAMIC&&(this.sleepState===Ao.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new eo),this.type!==Ao.DYNAMIC)return;this.sleepState===Ao.SLEEPING&&this.wakeUp();const n=t,i=Bo;i.copy(e),i.scale(this.invMass,i),this.velocity.vadd(i,this.velocity);const s=Oo;n.cross(e,s),this.invInertiaWorld.vmult(s,s),this.angularVelocity.vadd(s,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new eo),this.type!==Ao.DYNAMIC)return;const n=No,i=Ro;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,i),this.applyImpulse(n,i)}updateMassProperties(){const e=Uo;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),_o.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new eo;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Ao.DYNAMIC&&this.type!==Ao.KINEMATIC||this.sleepState===Ao.SLEEPING)return;const i=this.velocity,s=this.angularVelocity,r=this.position,o=this.force,a=this.torque,l=this.quaternion,c=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,d=c*e;i.x+=o.x*d*h.x,i.y+=o.y*d*h.y,i.z+=o.z*d*h.z;const p=u.elements,f=this.angularFactor,m=a.x*f.x,g=a.y*f.y,v=a.z*f.z;s.x+=e*(p[0]*m+p[1]*g+p[2]*v),s.y+=e*(p[3]*m+p[4]*g+p[5]*v),s.z+=e*(p[6]*m+p[7]*g+p[8]*v),r.x+=i.x*e,r.y+=i.y*e,r.z+=i.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(n?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Ao.idCounter=0,Ao.COLLIDE_EVENT_NAME="collide",Ao.DYNAMIC=1,Ao.STATIC=2,Ao.KINEMATIC=4,Ao.AWAKE=0,Ao.SLEEPY=1,Ao.SLEEPING=2,Ao.wakeupEvent={type:"wakeup"},Ao.sleepyEvent={type:"sleepy"},Ao.sleepEvent={type:"sleep"};const Eo=new eo,So=new co,To=new so,Mo=new Qr,Po=new Qr,zo=(new Qr,new eo),Co=new eo,Io=new eo,Bo=new eo,Oo=new eo,No=new eo,Ro=new eo,Uo=new eo;class Fo{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&Ao.STATIC)&&e.sleepState!==Ao.SLEEPING||0==(t.type&Ao.STATIC)&&t.sleepState!==Ao.SLEEPING)}intersectionTest(e,t,n,i){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,i):this.doBoundingSphereBroadphase(e,t,n,i)}doBoundingSphereBroadphase(e,t,n,i){const s=Do;t.position.vsub(e.position,s);const r=(e.boundingRadius+t.boundingRadius)**2;s.lengthSquared()<r&&(n.push(e),i.push(t))}doBoundingBoxBroadphase(e,t,n,i){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),i.push(t))}makePairsUnique(e,t){const n=Lo,i=qo,s=jo,r=e.length;for(let n=0;n!==r;n++)i[n]=e[n],s[n]=t[n];e.length=0,t.length=0;for(let e=0;e!==r;e++){const t=i[e].id,r=s[e].id,o=t<r?`${t},${r}`:`${r},${t}`;n[o]=e,n.keys.push(o)}for(let r=0;r!==n.keys.length;r++){const r=n.keys.pop(),o=n[r];e.push(i[o]),t.push(s[o]),delete n[r]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new eo;e.position.vsub(t.position,n);const i=e.shapes[0],s=t.shapes[0];return Math.pow(i.boundingSphereRadius+s.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Do=new eo;new eo,new co,new eo;const Lo={keys:[]},qo=[],jo=[];new eo,new eo,new eo;class Vo extends Fo{constructor(){super()}collisionPairs(e,t,n){const i=e.bodies,s=i.length;let r,o;for(let e=0;e!==s;e++)for(let s=0;s!==e;s++)r=i[e],o=i[s],this.needBroadphaseCollision(r,o)&&this.intersectionTest(r,o,t,n)}aabbQuery(e,t,n){void 0===n&&(n=[]);for(let i=0;i<e.bodies.length;i++){const s=e.bodies[i];s.aabbNeedsUpdate&&s.updateAABB(),s.aabb.overlaps(t)&&n.push(s)}return n}}class Go{constructor(){this.rayFromWorld=new eo,this.rayToWorld=new eo,this.hitNormalWorld=new eo,this.hitPointWorld=new eo,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,i,s,r,o){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(i),this.shape=s,this.body=r,this.distance=o}}let $o,Ho,Wo,Yo,Xo,Zo,Ko;$o=po.types.SPHERE,Ho=po.types.PLANE,Wo=po.types.BOX,Yo=po.types.CYLINDER,Xo=po.types.CONVEXPOLYHEDRON,Zo=po.types.HEIGHTFIELD,Ko=po.types.TRIMESH;class Qo{get[$o](){return this._intersectSphere}get[Ho](){return this._intersectPlane}get[Wo](){return this._intersectBox}get[Yo](){return this._intersectConvex}get[Xo](){return this._intersectConvex}get[Zo](){return this._intersectHeightfield}get[Ko](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new eo),void 0===t&&(t=new eo),this.from=e.clone(),this.to=t.clone(),this.direction=new eo,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Qo.ANY,this.result=new Go,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||Qo.ANY,this.result=t.result||new Go,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(Jo),ea.length=0,e.broadphase.aabbQuery(e,Jo,ea),this.intersectBodies(ea),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const i=ia,s=sa;for(let t=0,r=e.shapes.length;t<r;t++){const r=e.shapes[t];if((!n||r.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],s),e.quaternion.vmult(e.shapeOffsets[t],i),i.vadd(e.position,i),this.intersectShape(r,s,i,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,n=e.length;!this.result.shouldStop&&t<n;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,i){const s=function(e,t,n){n.vsub(e,Ea);const i=Ea.dot(t);t.scale(i,Sa),Sa.vadd(e,Sa);return n.distanceTo(Sa)}(this.from,this.direction,n);if(s>e.boundingSphereRadius)return;const r=this[e.type];r&&r.call(this,e,t,n,i,e)}_intersectBox(e,t,n,i,s){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,i,s)}_intersectPlane(e,t,n,i,s){const r=this.from,o=this.to,a=this.direction,l=new eo(0,0,1);t.vmult(l,l);const c=new eo;r.vsub(n,c);const u=c.dot(l);if(o.vsub(n,c),u*c.dot(l)>0)return;if(r.distanceTo(o)<u)return;const h=l.dot(a);if(Math.abs(h)<this.precision)return;const d=new eo,p=new eo,f=new eo;r.vsub(n,d);const m=-l.dot(d)/h;a.scale(m,p),r.vadd(p,f),this.reportIntersection(l,f,s,i,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,i=this.to,s=this.from;t.x=Math.min(i.x,s.x),t.y=Math.min(i.y,s.y),t.z=Math.min(i.z,s.z),n.x=Math.max(i.x,s.x),n.y=Math.max(i.y,s.y),n.z=Math.max(i.z,s.z)}_intersectHeightfield(e,t,n,i,s){e.data,e.elementSize;const r=ha;r.from.copy(this.from),r.to.copy(this.to),fo.pointToLocalFrame(n,t,r.from,r.from),fo.pointToLocalFrame(n,t,r.to,r.to),r.updateDirection();const o=da;let a,l,c,u;a=l=0,c=u=e.data.length-1;const h=new so;r.getAABB(h),e.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,o,!0),a=Math.max(a,o[0]),l=Math.max(l,o[1]),e.getIndexOfPosition(h.upperBound.x,h.upperBound.y,o,!0),c=Math.min(c,o[0]+1),u=Math.min(u,o[1]+1);for(let o=a;o<c;o++)for(let a=l;a<u;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(o,a,h),h.overlapsRay(r)){if(e.getConvexTrianglePillar(o,a,!1),fo.pointToWorldFrame(n,t,e.pillarOffset,ua),this._intersectConvex(e.pillarConvex,t,ua,i,s,ca),this.result.shouldStop)return;e.getConvexTrianglePillar(o,a,!0),fo.pointToWorldFrame(n,t,e.pillarOffset,ua),this._intersectConvex(e.pillarConvex,t,ua,i,s,ca)}}}_intersectSphere(e,t,n,i,s){const r=this.from,o=this.to,a=e.radius,l=(o.x-r.x)**2+(o.y-r.y)**2+(o.z-r.z)**2,c=2*((o.x-r.x)*(r.x-n.x)+(o.y-r.y)*(r.y-n.y)+(o.z-r.z)*(r.z-n.z)),u=c**2-4*l*((r.x-n.x)**2+(r.y-n.y)**2+(r.z-n.z)**2-a**2),h=pa,d=fa;if(!(u<0))if(0===u)r.lerp(o,u,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,s,i,-1);else{const e=(-c-Math.sqrt(u))/(2*l),t=(-c+Math.sqrt(u))/(2*l);if(e>=0&&e<=1&&(r.lerp(o,e,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,s,i,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(r.lerp(o,t,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,s,i,-1))}}_intersectConvex(e,t,n,i,s,r){const o=ma,a=ga,l=r&&r.faceList||null,c=e.faces,u=e.vertices,h=e.faceNormals,d=this.direction,p=this.from,f=this.to,m=p.distanceTo(f),g=l?l.length:c.length,v=this.result;for(let e=0;!v.shouldStop&&e<g;e++){const r=l?l[e]:e,f=c[r],g=h[r],y=t,x=n;a.copy(u[f[0]]),y.vmult(a,a),a.vadd(x,a),a.vsub(p,a),y.vmult(g,o);const w=d.dot(o);if(Math.abs(w)<this.precision)continue;const _=o.dot(a)/w;if(!(_<0)){d.scale(_,ra),ra.vadd(p,ra),oa.copy(u[f[0]]),y.vmult(oa,oa),x.vadd(oa,oa);for(let e=1;!v.shouldStop&&e<f.length-1;e++){aa.copy(u[f[e]]),la.copy(u[f[e+1]]),y.vmult(aa,aa),y.vmult(la,la),x.vadd(aa,aa),x.vadd(la,la);const t=ra.distanceTo(p);!Qo.pointInTriangle(ra,oa,aa,la)&&!Qo.pointInTriangle(ra,aa,oa,la)||t>m||this.reportIntersection(o,ra,s,i,r)}}}}_intersectTrimesh(e,t,n,i,s,r){const o=va,a=ka,l=Aa,c=ga,u=ya,h=xa,d=wa,p=ba,f=_a,m=e.indices;e.vertices;const g=this.from,v=this.to,y=this.direction;l.position.copy(n),l.quaternion.copy(t),fo.vectorToLocalFrame(n,t,y,u),fo.pointToLocalFrame(n,t,g,h),fo.pointToLocalFrame(n,t,v,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,d.vsub(h,u),u.normalize();const x=h.distanceSquared(d);e.tree.rayQuery(this,l,a);for(let r=0,l=a.length;!this.result.shouldStop&&r!==l;r++){const l=a[r];e.getNormal(l,o),e.getVertex(m[3*l],oa),oa.vsub(h,c);const d=u.dot(o),g=o.dot(c)/d;if(g<0)continue;u.scale(g,ra),ra.vadd(h,ra),e.getVertex(m[3*l+1],aa),e.getVertex(m[3*l+2],la);const v=ra.distanceSquared(h);!Qo.pointInTriangle(ra,aa,oa,la)&&!Qo.pointInTriangle(ra,oa,aa,la)||v>x||(fo.vectorToWorldFrame(t,o,f),fo.pointToWorldFrame(n,t,ra,p),this.reportIntersection(f,p,s,i,l))}a.length=0}reportIntersection(e,t,n,i,s){const r=this.from,o=this.to,a=r.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==s?s:-1,this.mode){case Qo.ALL:this.hasHit=!0,l.set(r,o,e,t,n,i,a),l.hasHit=!0,this.callback(l);break;case Qo.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(r,o,e,t,n,i,a));break;case Qo.ANY:this.hasHit=!0,l.hasHit=!0,l.set(r,o,e,t,n,i,a),l.shouldStop=!0}}static pointInTriangle(e,t,n,i){i.vsub(t,Ea),n.vsub(t,ta),e.vsub(t,na);const s=Ea.dot(Ea),r=Ea.dot(ta),o=Ea.dot(na),a=ta.dot(ta),l=ta.dot(na);let c,u;return(c=a*o-r*l)>=0&&(u=s*l-r*o)>=0&&c+u<s*a-r*r}}Qo.CLOSEST=1,Qo.ANY=2,Qo.ALL=4;const Jo=new so,ea=[],ta=new eo,na=new eo,ia=new eo,sa=new co,ra=new eo,oa=new eo,aa=new eo,la=new eo;new eo,new Go;const ca={faceList:[0]},ua=new eo,ha=new Qo,da=[],pa=new eo,fa=new eo,ma=new eo,ga=(new eo,new eo,new eo),va=new eo,ya=new eo,xa=new eo,wa=new eo,_a=new eo,ba=new eo;new so;const ka=[],Aa=new fo,Ea=new eo,Sa=new eo;class Ta{static defaults(e,t){void 0===e&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class Ma{constructor(e,t,n){void 0===n&&(n={}),n=Ta.defaults(n,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=Ma.idCounter++,this.collideConnected=n.collideConnected,n.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}Ma.idCounter=0;class Pa{constructor(){this.spatial=new eo,this.rotational=new eo}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class za{constructor(e,t,n,i){void 0===n&&(n=-1e6),void 0===i&&(i=1e6),this.id=za.idCounter++,this.minForce=n,this.maxForce=i,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new Pa,this.jacobianElementB=new Pa,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const i=t,s=e,r=n;this.a=4/(r*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(r*r*s*(1+4*i))}computeB(e,t,n){const i=this.computeGW();return-this.computeGq()*e-i*t-this.computeGiMf()*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,s=n.position,r=i.position;return e.spatial.dot(s)+t.spatial.dot(r)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,s=n.velocity,r=i.velocity,o=n.angularVelocity,a=i.angularVelocity;return e.multiplyVectors(s,o)+t.multiplyVectors(r,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,s=n.vlambda,r=i.vlambda,o=n.wlambda,a=i.wlambda;return e.multiplyVectors(s,o)+t.multiplyVectors(r,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,s=n.force,r=n.torque,o=i.force,a=i.torque,l=n.invMassSolve,c=i.invMassSolve;return s.scale(l,Ca),o.scale(c,Ia),n.invInertiaWorldSolve.vmult(r,Ba),i.invInertiaWorldSolve.vmult(a,Oa),e.multiplyVectors(Ca,Ba)+t.multiplyVectors(Ia,Oa)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,s=n.invMassSolve,r=i.invMassSolve,o=n.invInertiaWorldSolve,a=i.invInertiaWorldSolve;let l=s+r;return o.vmult(e.rotational,Na),l+=Na.dot(e.rotational),a.vmult(t.rotational,Na),l+=Na.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,i=this.bi,s=this.bj,r=Ra;i.vlambda.addScaledVector(i.invMassSolve*e,t.spatial,i.vlambda),s.vlambda.addScaledVector(s.invMassSolve*e,n.spatial,s.vlambda),i.invInertiaWorldSolve.vmult(t.rotational,r),i.wlambda.addScaledVector(e,r,i.wlambda),s.invInertiaWorldSolve.vmult(n.rotational,r),s.wlambda.addScaledVector(e,r,s.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}za.idCounter=0;const Ca=new eo,Ia=new eo,Ba=new eo,Oa=new eo,Na=new eo,Ra=new eo;class Ua extends za{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new eo,this.rj=new eo,this.ni=new eo}computeB(e){const t=this.a,n=this.b,i=this.bi,s=this.bj,r=this.ri,o=this.rj,a=Fa,l=Da,c=i.velocity,u=i.angularVelocity;i.force,i.torque;const h=s.velocity,d=s.angularVelocity;s.force,s.torque;const p=La,f=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;r.cross(g,a),o.cross(g,l),g.negate(f.spatial),a.negate(f.rotational),m.spatial.copy(g),m.rotational.copy(l),p.copy(s.position),p.vadd(o,p),p.vsub(i.position,p),p.vsub(r,p);const v=g.dot(p),y=this.restitution+1;return-v*t-(y*h.dot(g)-y*c.dot(g)+d.dot(l)-u.dot(a))*n-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=qa,t=ja,n=Va,i=Ga,s=$a;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,i),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(i,t),e.vsub(t,s),this.ni.dot(s)}}const Fa=new eo,Da=new eo,La=new eo,qa=new eo,ja=new eo,Va=new eo,Ga=new eo,$a=new eo;new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo;class Ha extends za{constructor(e,t,n){super(e,t,-n,n),this.ri=new eo,this.rj=new eo,this.t=new eo}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,i=this.rj,s=Wa,r=Ya,o=this.t;n.cross(o,s),i.cross(o,r);const a=this.jacobianElementA,l=this.jacobianElementB;return o.negate(a.spatial),s.negate(a.rotational),l.spatial.copy(o),l.rotational.copy(r),-this.computeGW()*t-e*this.computeGiMf()}}const Wa=new eo,Ya=new eo;class Xa{constructor(e,t,n){n=Ta.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Xa.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}Xa.idCounter=0;class Za{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=Za.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}Za.idCounter=0,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new Qo,new eo,new eo,new eo,new eo(1,0,0),new eo(0,1,0),new eo(0,0,1),new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new so,new eo,new so,new eo,new eo,new eo,new eo,new eo,new eo,new eo,new so,new eo,new fo,new so;class Ka{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);-1!==n&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class Qa extends Ka{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const i=this.iterations,s=this.tolerance*this.tolerance,r=this.equations,o=r.length,a=t.bodies,l=a.length,c=e;let u,h,d,p,f,m;if(0!==o)for(let e=0;e!==l;e++)a[e].updateSolveMassProperties();const g=el,v=tl,y=Ja;g.length=o,v.length=o,y.length=o;for(let e=0;e!==o;e++){const t=r[e];y[e]=0,v[e]=t.computeB(c),g[e]=1/t.computeC()}if(0!==o){for(let e=0;e!==l;e++){const t=a[e],n=t.vlambda,i=t.wlambda;n.set(0,0,0),i.set(0,0,0)}for(n=0;n!==i;n++){p=0;for(let e=0;e!==o;e++){const t=r[e];u=v[e],h=g[e],m=y[e],f=t.computeGWlambda(),d=h*(u-f-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),y[e]+=d,p+=d>0?d:-d,t.addToWlambda(d)}if(p*p<s)break}for(let e=0;e!==l;e++){const t=a[e],n=t.velocity,i=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),n.vadd(t.vlambda,n),t.wlambda.vmul(t.angularFactor,t.wlambda),i.vadd(t.wlambda,i)}let e=r.length;const t=1/c;for(;e--;)r[e].multiplier=y[e]*t}return n}}const Ja=[],el=[],tl=[];Ao.STATIC;class nl{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class il extends nl{constructor(){super(...arguments),this.type=eo}constructObject(){return new eo}}const sl=po.types.SPHERE,rl=po.types.SPHERE|po.types.PLANE,ol=po.types.BOX|po.types.BOX,al=po.types.SPHERE|po.types.BOX,ll=po.types.PLANE|po.types.BOX,cl=po.types.CONVEXPOLYHEDRON,ul=po.types.SPHERE|po.types.CONVEXPOLYHEDRON,hl=po.types.PLANE|po.types.CONVEXPOLYHEDRON,dl=po.types.BOX|po.types.CONVEXPOLYHEDRON,pl=po.types.SPHERE|po.types.HEIGHTFIELD,fl=po.types.BOX|po.types.HEIGHTFIELD,ml=po.types.CONVEXPOLYHEDRON|po.types.HEIGHTFIELD,gl=po.types.PARTICLE|po.types.SPHERE,vl=po.types.PLANE|po.types.PARTICLE,yl=po.types.BOX|po.types.PARTICLE,xl=po.types.PARTICLE|po.types.CONVEXPOLYHEDRON,wl=po.types.CYLINDER,_l=po.types.SPHERE|po.types.CYLINDER,bl=po.types.PLANE|po.types.CYLINDER,kl=po.types.BOX|po.types.CYLINDER,Al=po.types.CONVEXPOLYHEDRON|po.types.CYLINDER,El=po.types.HEIGHTFIELD|po.types.CYLINDER,Sl=po.types.PARTICLE|po.types.CYLINDER,Tl=po.types.SPHERE|po.types.TRIMESH,Ml=po.types.PLANE|po.types.TRIMESH;class Pl{get[sl](){return this.sphereSphere}get[rl](){return this.spherePlane}get[ol](){return this.boxBox}get[al](){return this.sphereBox}get[ll](){return this.planeBox}get[cl](){return this.convexConvex}get[ul](){return this.sphereConvex}get[hl](){return this.planeConvex}get[dl](){return this.boxConvex}get[pl](){return this.sphereHeightfield}get[fl](){return this.boxHeightfield}get[ml](){return this.convexHeightfield}get[gl](){return this.sphereParticle}get[vl](){return this.planeParticle}get[yl](){return this.boxParticle}get[xl](){return this.convexParticle}get[wl](){return this.convexConvex}get[_l](){return this.sphereConvex}get[bl](){return this.planeConvex}get[kl](){return this.boxConvex}get[Al](){return this.convexConvex}get[El](){return this.heightfieldCylinder}get[Sl](){return this.particleCylinder}get[Tl](){return this.sphereTrimesh}get[Ml](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new il,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,i,s,r){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=e,o.bj=t):o=new Ua(e,t),o.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&i.collisionResponse;const a=this.currentContactMaterial;o.restitution=a.restitution,o.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=n.material||e.material,c=i.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(o.restitution=l.restitution*c.restitution),o.si=s||n,o.sj=r||i,o}createFrictionEquationsFromContact(e,t){const n=e.bi,i=e.bj,s=e.si,r=e.sj,o=this.world,a=this.currentContactMaterial;let l=a.friction;const c=s.material||n.material,u=r.material||i.material;if(c&&u&&c.friction>=0&&u.friction>=0&&(l=c.friction*u.friction),l>0){const s=l*(o.frictionGravity||o.gravity).length();let r=n.invMass+i.invMass;r>0&&(r=1/r);const c=this.frictionEquationPool,u=c.length?c.pop():new Ha(n,i,s*r),h=c.length?c.pop():new Ha(n,i,s*r);return u.bi=h.bi=n,u.bj=h.bj=i,u.minForce=h.minForce=-s*r,u.maxForce=h.maxForce=s*r,u.ri.copy(e.ri),u.rj.copy(e.rj),h.ri.copy(e.ri),h.rj.copy(e.rj),e.ni.tangents(u.t,h.t),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),u.enabled=h.enabled=e.enabled,t.push(u,h),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const n=this.frictionResult[this.frictionResult.length-2],i=this.frictionResult[this.frictionResult.length-1];zl.setZero(),Cl.setZero(),Il.setZero();const s=t.bi;t.bj;for(let n=0;n!==e;n++)t=this.result[this.result.length-1-n],t.bi!==s?(zl.vadd(t.ni,zl),Cl.vadd(t.ri,Cl),Il.vadd(t.rj,Il)):(zl.vsub(t.ni,zl),Cl.vadd(t.rj,Cl),Il.vadd(t.ri,Il));const r=1/e;Cl.scale(r,n.ri),Il.scale(r,n.rj),i.ri.copy(n.ri),i.rj.copy(n.rj),zl.normalize(),zl.tangents(n.t,i.t)}getContacts(e,t,n,i,s,r,o){this.contactPointPool=s,this.frictionEquationPool=o,this.result=i,this.frictionResult=r;const a=Nl,l=Rl,c=Bl,u=Ol;for(let i=0,s=e.length;i!==s;i++){const s=e[i],r=t[i];let o=null;s.material&&r.material&&(o=n.getContactMaterial(s.material,r.material)||null);const h=s.type&Ao.KINEMATIC&&r.type&Ao.STATIC||s.type&Ao.STATIC&&r.type&Ao.KINEMATIC||s.type&Ao.KINEMATIC&&r.type&Ao.KINEMATIC;for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],a),s.quaternion.vmult(s.shapeOffsets[e],c),c.vadd(s.position,c);const t=s.shapes[e];for(let e=0;e<r.shapes.length;e++){r.quaternion.mult(r.shapeOrientations[e],l),r.quaternion.vmult(r.shapeOffsets[e],u),u.vadd(r.position,u);const i=r.shapes[e];if(!(t.collisionFilterMask&i.collisionFilterGroup&&i.collisionFilterMask&t.collisionFilterGroup))continue;if(c.distanceTo(u)>t.boundingSphereRadius+i.boundingSphereRadius)continue;let d=null;t.material&&i.material&&(d=n.getContactMaterial(t.material,i.material)||null),this.currentContactMaterial=d||o||n.defaultContactMaterial;const p=this[t.type|i.type];if(p){let e=!1;e=t.type<i.type?p.call(this,t,i,c,u,a,l,s,r,t,i,h):p.call(this,i,t,u,c,l,a,r,s,t,i,h),e&&h&&(n.shapeOverlapKeeper.set(t.id,i.id),n.bodyOverlapKeeper.set(s.id,r.id))}}}}}sphereSphere(e,t,n,i,s,r,o,a,l,c,u){if(u)return n.distanceSquared(i)<(e.radius+t.radius)**2;const h=this.createContactEquation(o,a,e,t,l,c);i.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(o.position,h.ri),h.rj.vadd(i,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,n,i,s,r,o,a,l,c,u){const h=this.createContactEquation(o,a,e,t,l,c);if(h.ni.set(0,0,1),r.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),n.vsub(i,tc),h.ni.scale(h.ni.dot(tc),nc),tc.vsub(nc,h.rj),-tc.dot(h.ni)<=e.radius){if(u)return!0;const e=h.ri,t=h.rj;e.vadd(n,e),e.vsub(o.position,e),t.vadd(i,t),t.vsub(a.position,t),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,n,i,s,r,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,i,s,r,o,a,e,t,u)}sphereBox(e,t,n,i,s,r,o,a,l,c,u){const h=this.v3pool,d=hc;n.vsub(i,ac),t.getSideNormals(d,r);const p=e.radius;let f=!1;const m=pc,g=fc,v=mc;let y=null,x=0,w=0,_=0,b=null;for(let e=0,t=d.length;e!==t&&!1===f;e++){const t=lc;t.copy(d[e]);const n=t.length();t.normalize();const i=ac.dot(t);if(i<n+p&&i>0){const s=cc,r=uc;s.copy(d[(e+1)%3]),r.copy(d[(e+2)%3]);const o=s.length(),a=r.length();s.normalize(),r.normalize();const l=ac.dot(s),c=ac.dot(r);if(l<o&&l>-o&&c<a&&c>-a){const e=Math.abs(i-n-p);if((null===b||e<b)&&(b=e,w=l,_=c,y=n,m.copy(t),g.copy(s),v.copy(r),x++,u))return!0}}}if(x){f=!0;const s=this.createContactEquation(o,a,e,t,l,c);m.scale(-p,s.ri),s.ni.copy(m),s.ni.negate(s.ni),m.scale(y,m),g.scale(w,g),m.vadd(g,m),v.scale(_,v),m.vadd(v,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),s.rj.vadd(i,s.rj),s.rj.vsub(a.position,s.rj),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}let k=h.get();const A=dc;for(let s=0;2!==s&&!f;s++)for(let r=0;2!==r&&!f;r++)for(let h=0;2!==h&&!f;h++)if(k.set(0,0,0),s?k.vadd(d[0],k):k.vsub(d[0],k),r?k.vadd(d[1],k):k.vsub(d[1],k),h?k.vadd(d[2],k):k.vsub(d[2],k),i.vadd(k,A),A.vsub(n,A),A.lengthSquared()<p*p){if(u)return!0;f=!0;const s=this.createContactEquation(o,a,e,t,l,c);s.ri.copy(A),s.ri.normalize(),s.ni.copy(s.ri),s.ri.scale(p,s.ri),s.rj.copy(k),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),s.rj.vadd(i,s.rj),s.rj.vsub(a.position,s.rj),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}h.release(k),k=null;const E=h.get(),S=h.get(),T=h.get(),M=h.get(),P=h.get(),z=d.length;for(let s=0;s!==z&&!f;s++)for(let r=0;r!==z&&!f;r++)if(s%3!=r%3){d[r].cross(d[s],E),E.normalize(),d[s].vadd(d[r],S),T.copy(n),T.vsub(S,T),T.vsub(i,T);const h=T.dot(E);E.scale(h,M);let m=0;for(;m===s%3||m===r%3;)m++;P.copy(n),P.vsub(M,P),P.vsub(S,P),P.vsub(i,P);const g=Math.abs(h),v=P.length();if(g<d[m].length()&&v<p){if(u)return!0;f=!0;const s=this.createContactEquation(o,a,e,t,l,c);S.vadd(M,s.rj),s.rj.copy(s.rj),P.negate(s.ni),s.ni.normalize(),s.ri.copy(s.rj),s.ri.vadd(i,s.ri),s.ri.vsub(n,s.ri),s.ri.normalize(),s.ri.scale(p,s.ri),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),s.rj.vadd(i,s.rj),s.rj.vsub(a.position,s.rj),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}h.release(E,S,T,M,P)}planeBox(e,t,n,i,s,r,o,a,l,c,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,i,s,r,o,a,e,t,u)}convexConvex(e,t,n,i,s,r,o,a,l,c,u,h,d){const p=zc;if(!(n.distanceTo(i)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,s,i,r,p,h,d)){const h=[],d=Cc;e.clipAgainstHull(n,s,t,i,r,p,-100,100,h);let f=0;for(let s=0;s!==h.length;s++){if(u)return!0;const r=this.createContactEquation(o,a,e,t,l,c),m=r.ri,g=r.rj;p.negate(r.ni),h[s].normal.negate(d),d.scale(h[s].depth,d),h[s].point.vadd(d,m),g.copy(h[s].point),m.vsub(n,m),g.vsub(i,g),m.vadd(n,m),m.vsub(o.position,m),g.vadd(i,g),g.vsub(a.position,g),this.result.push(r),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(r,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}}sphereConvex(e,t,n,i,s,r,o,a,l,c,u){const h=this.v3pool;n.vsub(i,gc);const d=t.faceNormals,p=t.faces,f=t.vertices,m=e.radius;let g=!1;for(let s=0;s!==f.length;s++){const h=f[s],d=wc;r.vmult(h,d),i.vadd(d,d);const p=xc;if(d.vsub(n,p),p.lengthSquared()<m*m){if(u)return!0;g=!0;const s=this.createContactEquation(o,a,e,t,l,c);return s.ri.copy(p),s.ri.normalize(),s.ni.copy(s.ri),s.ri.scale(m,s.ri),d.vsub(i,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),s.rj.vadd(i,s.rj),s.rj.vsub(a.position,s.rj),this.result.push(s),void this.createFrictionEquationsFromContact(s,this.frictionResult)}}for(let s=0,v=p.length;s!==v&&!1===g;s++){const v=d[s],y=p[s],x=_c;r.vmult(v,x);const w=bc;r.vmult(f[y[0]],w),w.vadd(i,w);const _=kc;x.scale(-m,_),n.vadd(_,_);const b=Ac;_.vsub(w,b);const k=b.dot(x),A=Ec;if(n.vsub(w,A),k<0&&A.dot(x)>0){const s=[];for(let e=0,t=y.length;e!==t;e++){const t=h.get();r.vmult(f[y[e]],t),i.vadd(t,t),s.push(t)}if(oc(s,x,n)){if(u)return!0;g=!0;const r=this.createContactEquation(o,a,e,t,l,c);x.scale(-m,r.ri),x.negate(r.ni);const d=h.get();x.scale(-k,d);const p=h.get();x.scale(-m,p),n.vsub(i,r.rj),r.rj.vadd(p,r.rj),r.rj.vadd(d,r.rj),r.rj.vadd(i,r.rj),r.rj.vsub(a.position,r.rj),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),h.release(d),h.release(p),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult);for(let e=0,t=s.length;e!==t;e++)h.release(s[e]);return}for(let d=0;d!==y.length;d++){const p=h.get(),g=h.get();r.vmult(f[y[(d+1)%y.length]],p),r.vmult(f[y[(d+2)%y.length]],g),i.vadd(p,p),i.vadd(g,g);const v=vc;g.vsub(p,v);const x=yc;v.unit(x);const w=h.get(),_=h.get();n.vsub(p,_);const b=_.dot(x);x.scale(b,w),w.vadd(p,w);const k=h.get();if(w.vsub(n,k),b>0&&b*b<v.lengthSquared()&&k.lengthSquared()<m*m){if(u)return!0;const r=this.createContactEquation(o,a,e,t,l,c);w.vsub(i,r.rj),w.vsub(n,r.ni),r.ni.normalize(),r.ni.scale(m,r.ri),r.rj.vadd(i,r.rj),r.rj.vsub(a.position,r.rj),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult);for(let e=0,t=s.length;e!==t;e++)h.release(s[e]);return h.release(p),h.release(g),h.release(w),h.release(k),void h.release(_)}h.release(p),h.release(g),h.release(w),h.release(k),h.release(_)}for(let e=0,t=s.length;e!==t;e++)h.release(s[e])}}}planeConvex(e,t,n,i,s,r,o,a,l,c,u){const h=Sc,d=Tc;d.set(0,0,1),s.vmult(d,d);let p=0;const f=Mc;for(let s=0;s!==t.vertices.length;s++)if(h.copy(t.vertices[s]),r.vmult(h,h),i.vadd(h,h),h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c),r=Pc;d.scale(d.dot(f),r),h.vsub(r,r),r.vsub(n,s.ri),s.ni.copy(d),h.vsub(i,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),s.rj.vadd(i,s.rj),s.rj.vsub(a.position,s.rj),this.result.push(s),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(e,t,n,i,s,r,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,i,s,r,o,a,e,t,u)}sphereHeightfield(e,t,n,i,s,r,o,a,l,c,u){const h=t.data,d=e.radius,p=t.elementSize,f=$c,m=Gc;fo.pointToLocalFrame(i,r,n,m);let g=Math.floor((m.x-d)/p)-1,v=Math.ceil((m.x+d)/p)+1,y=Math.floor((m.y-d)/p)-1,x=Math.ceil((m.y+d)/p)+1;if(v<0||x<0||g>h.length||y>h[0].length)return;g<0&&(g=0),v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),g>=h.length&&(g=h.length-1),v>=h.length&&(v=h.length-1),x>=h[0].length&&(x=h[0].length-1),y>=h[0].length&&(y=h[0].length-1);const w=[];t.getRectMinMax(g,y,v,x,w);const _=w[0],b=w[1];if(m.z-d>b||m.z+d<_)return;const k=this.result;for(let l=g;l<v;l++)for(let c=y;c<x;c++){const h=k.length;let d=!1;if(t.getConvexTrianglePillar(l,c,!1),fo.pointToWorldFrame(i,r,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,s,r,o,a,e,t,u)),u&&d)return!0;if(t.getConvexTrianglePillar(l,c,!0),fo.pointToWorldFrame(i,r,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,s,r,o,a,e,t,u)),u&&d)return!0;if(k.length-h>2)return}}boxHeightfield(e,t,n,i,s,r,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,i,s,r,o,a,e,t,u)}convexHeightfield(e,t,n,i,s,r,o,a,l,c,u){const h=t.data,d=t.elementSize,p=e.boundingSphereRadius,f=jc,m=Vc,g=qc;fo.pointToLocalFrame(i,r,n,g);let v=Math.floor((g.x-p)/d)-1,y=Math.ceil((g.x+p)/d)+1,x=Math.floor((g.y-p)/d)-1,w=Math.ceil((g.y+p)/d)+1;if(y<0||w<0||v>h.length||x>h[0].length)return;v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),w<0&&(w=0),v>=h.length&&(v=h.length-1),y>=h.length&&(y=h.length-1),w>=h[0].length&&(w=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const _=[];t.getRectMinMax(v,x,y,w,_);const b=_[0],k=_[1];if(!(g.z-p>k||g.z+p<b))for(let l=v;l<y;l++)for(let c=x;c<w;c++){let h=!1;if(t.getConvexTrianglePillar(l,c,!1),fo.pointToWorldFrame(i,r,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,s,r,o,a,null,null,u,m,null)),u&&h)return!0;if(t.getConvexTrianglePillar(l,c,!0),fo.pointToWorldFrame(i,r,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,s,r,o,a,null,null,u,m,null)),u&&h)return!0}}sphereParticle(e,t,n,i,s,r,o,a,l,c,u){const h=Nc;if(h.set(0,0,1),i.vsub(n,h),h.lengthSquared()<=e.radius*e.radius){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);h.normalize(),n.rj.copy(h),n.rj.scale(e.radius,n.rj),n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}planeParticle(e,t,n,i,s,r,o,a,l,c,u){const h=Ic;h.set(0,0,1),o.quaternion.vmult(h,h);const d=Bc;if(i.vsub(o.position,d),h.dot(d)<=0){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0);const s=Oc;h.scale(h.dot(i),s),i.vsub(s,s),n.rj.copy(s),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}boxParticle(e,t,n,i,s,r,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,i,s,r,o,a,e,t,u)}convexParticle(e,t,n,i,s,r,o,a,l,c,u){let h=-1;const d=Fc,p=Lc;let f=null;const m=Uc;if(m.copy(i),m.vsub(n,m),s.conjugate(Rc),Rc.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,s),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(s);for(let t=0,n=e.faces.length;t!==n;t++){const n=[e.worldVertices[e.faces[t][0]]],s=e.worldFaceNormals[t];i.vsub(n[0],Dc);const r=-s.dot(Dc);if(null===f||Math.abs(r)<Math.abs(f)){if(u)return!0;f=r,h=t,d.copy(s)}}if(-1!==h){const s=this.createContactEquation(a,o,t,e,l,c);d.scale(f,p),p.vadd(i,p),p.vsub(n,p),s.rj.copy(p),d.negate(s.ni),s.ri.set(0,0,0);const r=s.ri,u=s.rj;r.vadd(i,r),r.vsub(a.position,r),u.vadd(n,u),u.vsub(o.position,u),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,i,s,r,o,a,l,c,u){return this.convexHeightfield(t,e,i,n,r,s,a,o,l,c,u)}particleCylinder(e,t,n,i,s,r,o,a,l,c,u){return this.convexParticle(t,e,i,n,r,s,a,o,l,c,u)}sphereTrimesh(e,t,n,i,s,r,o,a,l,c,u){const h=Gl,d=$l,p=Hl,f=Wl,m=Yl,g=Xl,v=Jl,y=Vl,x=ql,w=ec;fo.pointToLocalFrame(i,r,n,m);const _=e.radius;v.lowerBound.set(m.x-_,m.y-_,m.z-_),v.upperBound.set(m.x+_,m.y+_,m.z+_),t.getTrianglesInAABB(v,w);const b=jl,k=e.radius*e.radius;for(let s=0;s<w.length;s++)for(let h=0;h<3;h++)if(t.getVertex(t.indices[3*w[s]+h],b),b.vsub(m,x),x.lengthSquared()<=k){if(y.copy(b),fo.pointToWorldFrame(i,r,y,b),b.vsub(n,x),u)return!0;let s=this.createContactEquation(o,a,e,t,l,c);s.ni.copy(x),s.ni.normalize(),s.ri.copy(s.ni),s.ri.scale(e.radius,s.ri),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),s.rj.copy(b),s.rj.vsub(a.position,s.rj),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}for(let s=0;s<w.length;s++)for(let v=0;v<3;v++){t.getVertex(t.indices[3*w[s]+v],h),t.getVertex(t.indices[3*w[s]+(v+1)%3],d),d.vsub(h,p),m.vsub(d,g);const y=g.dot(p);m.vsub(h,g);let x=g.dot(p);if(x>0&&y<0&&(m.vsub(h,g),f.copy(p),f.normalize(),x=g.dot(f),f.scale(x,g),g.vadd(h,g),g.distanceTo(m)<e.radius)){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,s.ni),s.ni.normalize(),s.ni.scale(e.radius,s.ri),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),fo.pointToWorldFrame(i,r,g,g),g.vsub(a.position,s.rj),fo.vectorToWorldFrame(r,s.ni,s.ni),fo.vectorToWorldFrame(r,s.ri,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}const A=Zl,E=Kl,S=Ql,T=Ll;for(let s=0,h=w.length;s!==h;s++){t.getTriangleVertices(w[s],A,E,S),t.getNormal(w[s],T),m.vsub(A,g);let h=g.dot(T);if(T.scale(h,g),m.vsub(g,g),h=g.distanceTo(m),Qo.pointInTriangle(g,A,E,S)&&h<e.radius){if(u)return!0;let s=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,s.ni),s.ni.normalize(),s.ni.scale(e.radius,s.ri),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),fo.pointToWorldFrame(i,r,g,g),g.vsub(a.position,s.rj),fo.vectorToWorldFrame(r,s.ni,s.ni),fo.vectorToWorldFrame(r,s.ri,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}w.length=0}planeTrimesh(e,t,n,i,s,r,o,a,l,c,u){const h=new eo,d=Ul;d.set(0,0,1),s.vmult(d,d);for(let s=0;s<t.vertices.length/3;s++){t.getVertex(s,h);const p=new eo;p.copy(h),fo.pointToWorldFrame(i,r,p,h);const f=Fl;if(h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const n=this.createContactEquation(o,a,e,t,l,c);n.ni.copy(d);const i=Dl;d.scale(f.dot(d),i),h.vsub(i,i),n.ri.copy(i),n.ri.vsub(o.position,n.ri),n.rj.copy(h),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}}const zl=new eo,Cl=new eo,Il=new eo,Bl=new eo,Ol=new eo,Nl=new co,Rl=new co,Ul=new eo,Fl=new eo,Dl=new eo,Ll=new eo,ql=new eo;new eo;const jl=new eo,Vl=new eo,Gl=new eo,$l=new eo,Hl=new eo,Wl=new eo,Yl=new eo,Xl=new eo,Zl=new eo,Kl=new eo,Ql=new eo,Jl=new so,ec=[],tc=new eo,nc=new eo,ic=new eo,sc=new eo,rc=new eo;function oc(e,t,n){let i=null;const s=e.length;for(let r=0;r!==s;r++){const o=e[r],a=ic;e[(r+1)%s].vsub(o,a);const l=sc;a.cross(t,l);const c=rc;n.vsub(o,c);const u=l.dot(c);if(!(null===i||u>0&&!0===i||u<=0&&!1===i))return!1;null===i&&(i=u>0)}return!0}const ac=new eo,lc=new eo,cc=new eo,uc=new eo,hc=[new eo,new eo,new eo,new eo,new eo,new eo],dc=new eo,pc=new eo,fc=new eo,mc=new eo,gc=new eo,vc=new eo,yc=new eo,xc=new eo,wc=new eo,_c=new eo,bc=new eo,kc=new eo,Ac=new eo,Ec=new eo;new eo,new eo;const Sc=new eo,Tc=new eo,Mc=new eo,Pc=new eo,zc=new eo,Cc=new eo,Ic=new eo,Bc=new eo,Oc=new eo,Nc=new eo,Rc=new co,Uc=new eo;new eo;const Fc=new eo,Dc=new eo,Lc=new eo,qc=new eo,jc=new eo,Vc=[0],Gc=new eo,$c=new eo;class Hc{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),i=this.current;let s=0;for(;n>i[s];)s++;if(n!==i[s]){for(let e=i.length-1;e>=s;e--)i[e+1]=i[e];i[s]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,i=this.previous,s=n.length,r=i.length;let o=0;for(let t=0;t<s;t++){let s=!1;const r=n[t];for(;r>i[o];)o++;s=r===i[o],s||Wc(e,r)}o=0;for(let e=0;e<r;e++){let s=!1;const r=i[e];for(;r>n[o];)o++;s=n[o]===r,s||Wc(t,r)}}}function Wc(e,t){e.push((4294901760&t)>>16,65535&t)}const Yc=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class Xc{constructor(){this.data={keys:[]}}get(e,t){const n=Yc(e,t);return this.data[n]}set(e,t,n){const i=Yc(e,t);this.get(e,t)||this.data.keys.push(i),this.data[i]=n}delete(e,t){const n=Yc(e,t),i=this.data.keys.indexOf(n);-1!==i&&this.data.keys.splice(i,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;)delete e[t.pop()]}}class Zc extends lo{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new eo,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new eo,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new Vo,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new Qa,this.constraints=[],this.narrowphase=new Pl(this),this.collisionMatrix=new ao,this.collisionMatrixPrevious=new ao,this.bodyOverlapKeeper=new Hc,this.shapeOverlapKeeper=new Hc,this.contactmaterials=[],this.contactMaterialTable=new Xc,this.defaultMaterial=new Za("default"),this.defaultContactMaterial=new Xa(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof Go?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,i){return void 0===n&&(n={}),n.mode=Qo.ALL,n.from=e,n.to=t,n.callback=i,Kc.intersectWorld(this,n)}raycastAny(e,t,n,i){return void 0===n&&(n={}),n.mode=Qo.ANY,n.from=e,n.to=t,n.result=i,Kc.intersectWorld(this,n)}raycastClosest(e,t,n,i){return void 0===n&&(n={}),n.mode=Qo.CLOSEST,n.from=e,n.to=t,n.result=i,Kc.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Ao&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,i=n.indexOf(e);if(-1!==i){n.splice(i,1);for(let e=0;e!==n.length;e++)n[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const i=t[n].shapes;for(let t=0;t<i.length;t++){const n=i[t];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const n=Qc.now()/1e3;if(this.lastCallTime){const i=n-this.lastCallTime;this.step(e,i,t)}else this.step(e,void 0,t);this.lastCallTime=n}step(e,t,n){if(void 0===n&&(n=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const i=Qc.now();let s=0;for(;this.accumulator>=e&&s<n&&(this.internalStep(e),this.accumulator-=e,s++,!(Qc.now()-i>1e3*e)););this.accumulator=this.accumulator%e;const r=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,r,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,r,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=su,i=ru,s=this.bodies.length,r=this.bodies,o=this.solver,a=this.gravity,l=this.doProfiling,c=this.profile,u=Ao.DYNAMIC;let h=-1/0;const d=this.constraints,p=iu;a.length();const f=a.x,m=a.y,g=a.z;let v=0;for(l&&(h=Qc.now()),v=0;v!==s;v++){const e=r[v];if(e.type===u){const t=e.force,n=e.mass;t.x+=n*f,t.y+=n*m,t.z+=n*g}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(h=Qc.now()),n.length=0,i.length=0,this.broadphase.collisionPairs(this,n,i),l&&(c.broadphase=Qc.now()-h);let y=d.length;for(v=0;v!==y;v++){const e=d[v];if(!e.collideConnected)for(let t=n.length-1;t>=0;t-=1)(e.bodyA===n[t]&&e.bodyB===i[t]||e.bodyB===n[t]&&e.bodyA===i[t])&&(n.splice(t,1),i.splice(t,1))}this.collisionMatrixTick(),l&&(h=Qc.now());const x=nu,w=t.length;for(v=0;v!==w;v++)x.push(t[v]);t.length=0;const _=this.frictionEquations.length;for(v=0;v!==_;v++)p.push(this.frictionEquations[v]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,i,this,t,x,this.frictionEquations,p),l&&(c.narrowphase=Qc.now()-h),l&&(h=Qc.now()),v=0;v<this.frictionEquations.length;v++)o.addEquation(this.frictionEquations[v]);const b=t.length;for(let e=0;e!==b;e++){const n=t[e],i=n.bi,s=n.bj,r=n.si,a=n.sj;let l;l=i.material&&s.material&&this.getContactMaterial(i.material,s.material)||this.defaultContactMaterial,l.friction,i.material&&s.material&&(i.material.friction>=0&&s.material.friction>=0&&(i.material.friction,s.material.friction),i.material.restitution>=0&&s.material.restitution>=0&&(n.restitution=i.material.restitution*s.material.restitution)),o.addEquation(n),i.allowSleep&&i.type===Ao.DYNAMIC&&i.sleepState===Ao.SLEEPING&&s.sleepState===Ao.AWAKE&&s.type!==Ao.STATIC&&s.velocity.lengthSquared()+s.angularVelocity.lengthSquared()>=2*s.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0),s.allowSleep&&s.type===Ao.DYNAMIC&&s.sleepState===Ao.SLEEPING&&i.sleepState===Ao.AWAKE&&i.type!==Ao.STATIC&&i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(s.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(i,s,!0),this.collisionMatrixPrevious.get(i,s)||(tu.body=s,tu.contact=n,i.dispatchEvent(tu),tu.body=i,s.dispatchEvent(tu)),this.bodyOverlapKeeper.set(i.id,s.id),this.shapeOverlapKeeper.set(r.id,a.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=Qc.now()-h,h=Qc.now()),v=0;v!==s;v++){const e=r[v];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(y=d.length,v=0;v!==y;v++){const e=d[v];e.update();for(let t=0,n=e.equations.length;t!==n;t++){const n=e.equations[t];o.addEquation(n)}}o.solve(e,this),l&&(c.solve=Qc.now()-h),o.removeAllEquations();const k=Math.pow;for(v=0;v!==s;v++){const t=r[v];if(t.type&u){const n=k(1-t.linearDamping,e),i=t.velocity;i.scale(n,i);const s=t.angularVelocity;if(s){const n=k(1-t.angularDamping,e);s.scale(n,s)}}}this.dispatchEvent(eu),l&&(h=Qc.now());const A=this.stepnumber%(this.quatNormalizeSkip+1)==0,E=this.quatNormalizeFast;for(v=0;v!==s;v++)r[v].integrate(e,A,E);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=Qc.now()-h),this.stepnumber+=1,this.dispatchEvent(Jc);let S=!0;if(this.allowSleep)for(S=!1,v=0;v!==s;v++){const e=r[v];e.sleepTick(this.time),e.sleepState!==Ao.SLEEPING&&(S=!0)}this.hasActiveBodies=S}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(ou,au),e){for(let e=0,t=ou.length;e<t;e+=2)lu.bodyA=this.getBodyById(ou[e]),lu.bodyB=this.getBodyById(ou[e+1]),this.dispatchEvent(lu);lu.bodyA=lu.bodyB=null}if(t){for(let e=0,t=au.length;e<t;e+=2)cu.bodyA=this.getBodyById(au[e]),cu.bodyB=this.getBodyById(au[e+1]),this.dispatchEvent(cu);cu.bodyA=cu.bodyB=null}ou.length=au.length=0;const n=this.hasAnyEventListener("beginShapeContact"),i=this.hasAnyEventListener("endShapeContact");if((n||i)&&this.shapeOverlapKeeper.getDiff(ou,au),n){for(let e=0,t=ou.length;e<t;e+=2){const t=this.getShapeById(ou[e]),n=this.getShapeById(ou[e+1]);uu.shapeA=t,uu.shapeB=n,t&&(uu.bodyA=t.body),n&&(uu.bodyB=n.body),this.dispatchEvent(uu)}uu.bodyA=uu.bodyB=uu.shapeA=uu.shapeB=null}if(i){for(let e=0,t=au.length;e<t;e+=2){const t=this.getShapeById(au[e]),n=this.getShapeById(au[e+1]);hu.shapeA=t,hu.shapeB=n,t&&(hu.bodyA=t.body),n&&(hu.bodyB=n.body),this.dispatchEvent(hu)}hu.bodyA=hu.bodyB=hu.shapeA=hu.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const t=e[n];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new so;const Kc=new Qo,Qc=globalThis.performance||{};if(!Qc.now){let e=Date.now();Qc.timing&&Qc.timing.navigationStart&&(e=Qc.timing.navigationStart),Qc.now=()=>Date.now()-e}new eo;const Jc={type:"postStep"},eu={type:"preStep"},tu={type:Ao.COLLIDE_EVENT_NAME,body:null,contact:null},nu=[],iu=[],su=[],ru=[],ou=[],au=[],lu={type:"beginContact",bodyA:null,bodyB:null},cu={type:"endContact",bodyA:null,bodyB:null},uu={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},hu={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class du extends e{world=new Zc({gravity:new eo(0,-150,0)});constructor(){super()}}class pu extends e{speed=1;rotationSpeed=.025;player;constructor(e=0,t=1,n=.025){super(),this.player=e,this.speed=t,this.rotationSpeed=n}}class fu extends e{bodyId;halfExtents;options;constructor(e,t={}){super(),this.halfExtents=new eo(e[0]/2,e[1]/2,e[2]/2),this.options=t}}const mu=new class{lastTime=0;entities=new Map;systems=new Map;nextEntityID=0;entitiesToDestroy=new Array;addEntity(){let e=this.nextEntityID;return this.nextEntityID++,this.entities.set(e,new n),e}removeEntity(e){this.entitiesToDestroy.push(e)}addComponent(e,t){this.entities.get(e).add(t),this.checkE(e)}addComponents(e,...t){for(let n of t)this.addComponent(e,n)}getComponents(e){return this.entities.get(e)}removeComponent(e,t){this.entities.get(e).delete(t),this.checkE(e)}addSystem(e){if(0==e.componentsRequired.size)return console.warn("System not added: empty Components list."),void console.warn(e);e.ecs=this,this.systems.set(e,new Set);for(let t of this.entities.keys())this.checkES(t,e)}removeSystem(e){this.systems.delete(e)}update(e){let t=e-this.lastTime;for(let[n,i]of this.systems.entries())n.update(i,e,t);for(;this.entitiesToDestroy.length>0;)this.destroyEntity(this.entitiesToDestroy.pop());this.lastTime=e}destroyEntity(e){this.entities.delete(e);for(let t of this.systems.values())t.delete(e)}checkE(e){for(let t of this.systems.keys())this.checkES(e,t)}checkES(e,t){let n=this.entities.get(e),i=t.componentsRequired;n.hasAll(i)?this.systems.get(t).add(e):this.systems.get(t).delete(e)}getEntitiesithComponent(e){let t=new Set;for(let[n,i]of this.entities)i.has(e)&&t.add(n);return t}};mu.addSystem(new class extends t{keyboardControls=new Zr;componentsRequired=new Set([Us,Kr]);update(e,t,n){for(const t of e){const e=this.ecs.getComponents(t),i=e.get(Us),s=e.get(Kr),r=s.speed*n,o=s.rotationSpeed*n;this.keyboardControls.pressed.a&&(i.position=te.add(i.position,te.mulScalar(i.left,r))),this.keyboardControls.pressed.d&&(i.position=te.add(i.position,te.mulScalar(i.right,r))),this.keyboardControls.pressed.w&&(i.position=te.add(i.position,te.mulScalar(i.direction,r))),this.keyboardControls.pressed.s&&(i.position=te.sub(i.position,te.mulScalar(i.direction,r))),this.keyboardControls.pressed.q&&(i.rotation=je.rotateY(i.rotation,-o)),this.keyboardControls.pressed.e&&(i.rotation=je.rotateY(i.rotation,o)),this.keyboardControls.pressed[" "]&&(i.position=te.add(i.position,te.mulScalar(i.up,r))),this.keyboardControls.pressed.shift&&(i.position=te.add(i.position,te.mulScalar(i.down,r)))}}}),mu.addSystem(new class extends t{componentsRequired=new Set([Fs,Us]);constructor(){super(),(async()=>{const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});let t;console.log(e);try{t=await e.requestDevice({requiredFeatures:["timestamp-query"],requiredLimits:{maxColorAttachmentBytesPerSample:64}})}catch(n){console.warn("Timestamp query or 64 byte colour attachment not supported, falling back"),t=await e.requestDevice()}return t})().then((async e=>{const t=new Yr(e),n=(e=>{const t=e.getEntitiesithComponent(Xr).values().next().value;return e.getComponents(t).get(Xr)})(this.ecs);n.device=e,n.volumeAtlas=t;const i=await(async(e,t,n,i)=>{t.dictionary[i]||await Vr(i,0,t);const{size:s,location:r,paletteIndex:o,octreeOffset:a}=t.dictionary[i];return new Fs({name:n,size:s,atlasLocation:r,paletteIndex:o,octreeBufferIndex:a})})(0,t,"Terrain","./terrain.vxm"),s=this.ecs.addEntity();this.ecs.addComponent(s,new Fs(i)),this.ecs.addComponent(s,new Us([0,0,0],je.fromEuler(0,0,0,"xyz"),[1,1,1])),Ir(e,t,this.ecs)}))}update(e,t){const n=this.ecs.getEntitiesithComponent(Ur).values().next().value,i=this.ecs.getComponents(n),s=i.get(Ur),r=i.get(Us);Rr(t,this.ecs,s,r,Array.from(e))}}),mu.addSystem(new class extends t{componentsRequired=new Set([fu,Us,pu]);update(e,t,n){const i=this.ecs.getEntitiesithComponent(du).values().next().value,s=this.ecs.getComponents(i).get(du).world;for(const t of e){const e=this.ecs.getComponents(t),i=e.get(fu),r=e.get(Us),o=e.get(pu),a=navigator.getGamepads()[o.player];if(!a)return;const l=te.mulScalar(r.right,a.axes[0]),c=te.mulScalar(r.direction,-a.axes[1]),u=te.add(l,c),h=te.add(r.position,te.mulScalar(u,o.speed)),d=s.getBodyById(i.bodyId);if(!d)continue;d.position.set(h[0],h[1],h[2]);const p=je.rotateY(r.rotation,o.rotationSpeed*a.axes[2]),f=a.buttons[0].pressed,m=a.buttons[1].pressed,g=.001*n;f&&(r.scale=te.add(r.scale,te.create(g,g,g))),m&&(r.scale=te.sub(r.scale,te.create(g,g,g))),s.getBodyById(i.bodyId).quaternion.set(p[0],p[1],p[2],p[3])}}});const gu=mu.addEntity();mu.addComponent(gu,new Xr),mu.addComponent(gu,new du);const vu=mu.addEntity();mu.addComponents(vu,new Ur({fieldOfView:Math.PI/180*70,near:.5,far:1e4}),new Us(te.create(0,50,-120),je.fromEuler(0,0,0,"xyz"),te.create(1,1,1)),new Kr);const yu=mu.addEntity();mu.addComponents(yu,new Us(te.create(0,0,0),je.identity(),te.create(1,1,1)),new Kr);const xu=()=>{mu.update(performance.now()),requestAnimationFrame(xu)};xu()})();