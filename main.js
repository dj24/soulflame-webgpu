(()=>{"use strict";class e{}class t{ecs}class n{map=new Map;add(e){this.map.set(e.constructor,e)}get(e){return this.map.get(e)}has(e){return this.map.has(e)}hasAll(e){for(let t of e)if(!this.map.has(t))return!1;return!0}delete(e){this.map.delete(e)}}let r=1e-6,i=Float32Array;function s(e=0,t=0){const n=new i(2);return void 0!==e&&(n[0]=e,void 0!==t&&(n[1]=t)),n}let o=Float32Array;function a(e,t,n){const r=new o(3);return void 0!==e&&(r[0]=e,void 0!==t&&(r[1]=t,void 0!==n&&(r[2]=n))),r}const c=s;function l(e,t,n){return(n=n||new i(2))[0]=e[0]-t[0],n[1]=e[1]-t[1],n}const u=l;function h(e,t,n){return(n=n||new i(2))[0]=e[0]*t,n[1]=e[1]*t,n}const d=h;function f(e,t){return(t=t||new i(2))[0]=1/e[0],t[1]=1/e[1],t}const p=f;function m(e,t){return e[0]*t[0]+e[1]*t[1]}function g(e){const t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}const y=g;function v(e){const t=e[0],n=e[1];return t*t+n*n}const x=v;function w(e,t){const n=e[0]-t[0],r=e[1]-t[1];return Math.sqrt(n*n+r*r)}const b=w;function _(e,t){const n=e[0]-t[0],r=e[1]-t[1];return n*n+r*r}const k=_;function T(e,t){return(t=t||new i(2))[0]=e[0],t[1]=e[1],t}const S=T;function P(e,t,n){return(n=n||new i(2))[0]=e[0]*t[0],n[1]=e[1]*t[1],n}const E=P;function A(e,t,n){return(n=n||new i(2))[0]=e[0]/t[0],n[1]=e[1]/t[1],n}const M=A;var z=Object.freeze({__proto__:null,create:s,setDefaultType:function(e){const t=i;return i=e,t},fromValues:c,set:function(e,t,n){return(n=n||new i(2))[0]=e,n[1]=t,n},ceil:function(e,t){return(t=t||new i(2))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},floor:function(e,t){return(t=t||new i(2))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},round:function(e,t){return(t=t||new i(2))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},clamp:function(e,t=0,n=1,r){return(r=r||new i(2))[0]=Math.min(n,Math.max(t,e[0])),r[1]=Math.min(n,Math.max(t,e[1])),r},add:function(e,t,n){return(n=n||new i(2))[0]=e[0]+t[0],n[1]=e[1]+t[1],n},addScaled:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},angle:function(e,t){const n=e[0],r=e[1],i=e[0],s=e[1],o=Math.sqrt(n*n+r*r)*Math.sqrt(i*i+s*s),a=o&&m(e,t)/o;return Math.acos(a)},subtract:l,sub:u,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r},lerpV:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+n[0]*(t[0]-e[0]),r[1]=e[1]+n[1]*(t[1]-e[1]),r},max:function(e,t,n){return(n=n||new i(2))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n},min:function(e,t,n){return(n=n||new i(2))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n},mulScalar:h,scale:d,divScalar:function(e,t,n){return(n=n||new i(2))[0]=e[0]/t,n[1]=e[1]/t,n},inverse:f,invert:p,cross:function(e,t,n){n=n||new o(3);const r=e[0]*t[1]-e[1]*t[0];return n[0]=0,n[1]=0,n[2]=r,n},dot:m,length:g,len:y,lengthSq:v,lenSq:x,distance:w,dist:b,distanceSq:_,distSq:k,normalize:function(e,t){t=t||new i(2);const n=e[0],r=e[1],s=Math.sqrt(n*n+r*r);return s>1e-5?(t[0]=n/s,t[1]=r/s):(t[0]=0,t[1]=0),t},negate:function(e,t){return(t=t||new i(2))[0]=-e[0],t[1]=-e[1],t},copy:T,clone:S,multiply:P,mul:E,divide:A,div:M,random:function(e=1,t){t=t||new i(2);const n=2*Math.random()*Math.PI;return t[0]=Math.cos(n)*e,t[1]=Math.sin(n)*e,t},zero:function(e){return(e=e||new i(2))[0]=0,e[1]=0,e},transformMat4:function(e,t,n){n=n||new i(2);const r=e[0],s=e[1];return n[0]=r*t[0]+s*t[4]+t[12],n[1]=r*t[1]+s*t[5]+t[13],n},transformMat3:function(e,t,n){n=n||new i(2);const r=e[0],s=e[1];return n[0]=t[0]*r+t[4]*s+t[8],n[1]=t[1]*r+t[5]*s+t[9],n}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);const I=a;function C(e,t,n){return(n=n||new o(3))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}const B=C;function O(e,t,n){return(n=n||new o(3))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n}const R=O;function U(e,t){return(t=t||new o(3))[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}const N=U;function j(e,t,n){n=n||new o(3);const r=e[2]*t[0]-e[0]*t[2],i=e[0]*t[1]-e[1]*t[0];return n[0]=e[1]*t[2]-e[2]*t[1],n[1]=r,n[2]=i,n}function D(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function q(e){const t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)}const F=q;function L(e){const t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r}const V=L;function G(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return Math.sqrt(n*n+r*r+i*i)}const W=G;function Y(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return n*n+r*r+i*i}const H=Y;function $(e,t){t=t||new o(3);const n=e[0],r=e[1],i=e[2],s=Math.sqrt(n*n+r*r+i*i);return s>1e-5?(t[0]=n/s,t[1]=r/s,t[2]=i/s):(t[0]=0,t[1]=0,t[2]=0),t}function X(e,t){return(t=t||new o(3))[0]=e[0],t[1]=e[1],t[2]=e[2],t}const Z=X;function K(e,t,n){return(n=n||new o(3))[0]=e[0]*t[0],n[1]=e[1]*t[1],n[2]=e[2]*t[2],n}const Q=K;function J(e,t,n){return(n=n||new o(3))[0]=e[0]/t[0],n[1]=e[1]/t[1],n[2]=e[2]/t[2],n}const ee=J;var te=Object.freeze({__proto__:null,create:a,setDefaultType:function(e){const t=o;return o=e,t},fromValues:I,set:function(e,t,n,r){return(r=r||new o(3))[0]=e,r[1]=t,r[2]=n,r},ceil:function(e,t){return(t=t||new o(3))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},floor:function(e,t){return(t=t||new o(3))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},round:function(e,t){return(t=t||new o(3))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},clamp:function(e,t=0,n=1,r){return(r=r||new o(3))[0]=Math.min(n,Math.max(t,e[0])),r[1]=Math.min(n,Math.max(t,e[1])),r[2]=Math.min(n,Math.max(t,e[2])),r},add:function(e,t,n){return(n=n||new o(3))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n},addScaled:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r},angle:function(e,t){const n=e[0],r=e[1],i=e[2],s=e[0],o=e[1],a=e[2],c=Math.sqrt(n*n+r*r+i*i)*Math.sqrt(s*s+o*o+a*a),l=c&&D(e,t)/c;return Math.acos(l)},subtract:C,sub:B,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r[2]=e[2]+n*(t[2]-e[2]),r},lerpV:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+n[0]*(t[0]-e[0]),r[1]=e[1]+n[1]*(t[1]-e[1]),r[2]=e[2]+n[2]*(t[2]-e[2]),r},max:function(e,t,n){return(n=n||new o(3))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n[2]=Math.max(e[2],t[2]),n},min:function(e,t,n){return(n=n||new o(3))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n},mulScalar:O,scale:R,divScalar:function(e,t,n){return(n=n||new o(3))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n},inverse:U,invert:N,cross:j,dot:D,length:q,len:F,lengthSq:L,lenSq:V,distance:G,dist:W,distanceSq:Y,distSq:H,normalize:$,negate:function(e,t){return(t=t||new o(3))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},copy:X,clone:Z,multiply:K,mul:Q,divide:J,div:ee,random:function(e=1,t){t=t||new o(3);const n=2*Math.random()*Math.PI,r=2*Math.random()-1,i=Math.sqrt(1-r*r)*e;return t[0]=Math.cos(n)*i,t[1]=Math.sin(n)*i,t[2]=r*e,t},zero:function(e){return(e=e||new o(3))[0]=0,e[1]=0,e[2]=0,e},transformMat4:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2],a=t[3]*r+t[7]*i+t[11]*s+t[15]||1;return n[0]=(t[0]*r+t[4]*i+t[8]*s+t[12])/a,n[1]=(t[1]*r+t[5]*i+t[9]*s+t[13])/a,n[2]=(t[2]*r+t[6]*i+t[10]*s+t[14])/a,n},transformMat4Upper3x3:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2];return n[0]=r*t[0]+i*t[4]+s*t[8],n[1]=r*t[1]+i*t[5]+s*t[9],n[2]=r*t[2]+i*t[6]+s*t[10],n},transformMat3:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2];return n[0]=r*t[0]+i*t[4]+s*t[8],n[1]=r*t[1]+i*t[5]+s*t[9],n[2]=r*t[2]+i*t[6]+s*t[10],n},transformQuat:function(e,t,n){n=n||new o(3);const r=t[0],i=t[1],s=t[2],a=2*t[3],c=e[0],l=e[1],u=e[2],h=i*u-s*l,d=s*c-r*u,f=r*l-i*c;return n[0]=c+h*a+2*(i*f-s*d),n[1]=l+d*a+2*(s*h-r*f),n[2]=u+f*a+2*(r*d-i*h),n},getTranslation:function(e,t){return(t=t||new o(3))[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const r=4*t;return(n=n||new o(3))[0]=e[r+0],n[1]=e[r+1],n[2]=e[r+2],n},getScaling:function(e,t){t=t||new o(3);const n=e[0],r=e[1],i=e[2],s=e[4],a=e[5],c=e[6],l=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+r*r+i*i),t[1]=Math.sqrt(s*s+a*a+c*c),t[2]=Math.sqrt(l*l+u*u+h*h),t}});let ne=Float32Array;function re(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}const ie=re;function se(e){return(e=e||new ne(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function oe(e,t){t=t||new ne(16);const n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],h=e[9],d=e[10],f=e[11],p=e[12],m=e[13],g=e[14],y=e[15],v=d*y,x=g*f,w=c*y,b=g*l,_=c*f,k=d*l,T=i*y,S=g*s,P=i*f,E=d*s,A=i*l,M=c*s,z=u*m,I=p*h,C=o*m,B=p*a,O=o*h,R=u*a,U=n*m,N=p*r,j=n*h,D=u*r,q=n*a,F=o*r,L=v*a+b*h+_*m-(x*a+w*h+k*m),V=x*r+T*h+E*m-(v*r+S*h+P*m),G=w*r+S*a+A*m-(b*r+T*a+M*m),W=k*r+P*a+M*h-(_*r+E*a+A*h),Y=1/(n*L+o*V+u*G+p*W);return t[0]=Y*L,t[1]=Y*V,t[2]=Y*G,t[3]=Y*W,t[4]=Y*(x*o+w*u+k*p-(v*o+b*u+_*p)),t[5]=Y*(v*n+S*u+P*p-(x*n+T*u+E*p)),t[6]=Y*(b*n+T*o+M*p-(w*n+S*o+A*p)),t[7]=Y*(_*n+E*o+A*u-(k*n+P*o+M*u)),t[8]=Y*(z*l+B*f+O*y-(I*l+C*f+R*y)),t[9]=Y*(I*s+U*f+D*y-(z*s+N*f+j*y)),t[10]=Y*(C*s+N*l+q*y-(B*s+U*l+F*y)),t[11]=Y*(R*s+j*l+F*f-(O*s+D*l+q*f)),t[12]=Y*(C*d+R*g+I*c-(O*g+z*c+B*d)),t[13]=Y*(j*g+z*i+N*d-(U*d+D*g+I*i)),t[14]=Y*(U*c+F*g+B*i-(q*g+C*i+N*c)),t[15]=Y*(q*d+O*i+D*c-(j*c+F*d+R*i)),t}const ae=oe;function ce(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[4],c=e[5],l=e[6],u=e[7],h=e[8],d=e[9],f=e[10],p=e[11],m=e[12],g=e[13],y=e[14],v=e[15],x=t[0],w=t[1],b=t[2],_=t[3],k=t[4],T=t[5],S=t[6],P=t[7],E=t[8],A=t[9],M=t[10],z=t[11],I=t[12],C=t[13],B=t[14],O=t[15];return n[0]=r*x+a*w+h*b+m*_,n[1]=i*x+c*w+d*b+g*_,n[2]=s*x+l*w+f*b+y*_,n[3]=o*x+u*w+p*b+v*_,n[4]=r*k+a*T+h*S+m*P,n[5]=i*k+c*T+d*S+g*P,n[6]=s*k+l*T+f*S+y*P,n[7]=o*k+u*T+p*S+v*P,n[8]=r*E+a*A+h*M+m*z,n[9]=i*E+c*A+d*M+g*z,n[10]=s*E+l*A+f*M+y*z,n[11]=o*E+u*A+p*M+v*z,n[12]=r*I+a*C+h*B+m*O,n[13]=i*I+c*C+d*B+g*O,n[14]=s*I+l*C+f*B+y*O,n[15]=o*I+u*C+p*B+v*O,n}const le=ce;let ue,he,de;function fe(e,t,n){n=n||new ne(16);let r=e[0],i=e[1],s=e[2];const o=Math.sqrt(r*r+i*i+s*s);r/=o,i/=o,s/=o;const a=r*r,c=i*i,l=s*s,u=Math.cos(t),h=Math.sin(t),d=1-u;return n[0]=a+(1-a)*u,n[1]=r*i*d+s*h,n[2]=r*s*d-i*h,n[3]=0,n[4]=r*i*d-s*h,n[5]=c+(1-c)*u,n[6]=i*s*d+r*h,n[7]=0,n[8]=r*s*d+i*h,n[9]=i*s*d-r*h,n[10]=l+(1-l)*u,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}const pe=fe;function me(e,t,n,r){r=r||new ne(16);let i=t[0],s=t[1],o=t[2];const a=Math.sqrt(i*i+s*s+o*o);i/=a,s/=a,o/=a;const c=i*i,l=s*s,u=o*o,h=Math.cos(n),d=Math.sin(n),f=1-h,p=c+(1-c)*h,m=i*s*f+o*d,g=i*o*f-s*d,y=i*s*f-o*d,v=l+(1-l)*h,x=s*o*f+i*d,w=i*o*f+s*d,b=s*o*f-i*d,_=u+(1-u)*h,k=e[0],T=e[1],S=e[2],P=e[3],E=e[4],A=e[5],M=e[6],z=e[7],I=e[8],C=e[9],B=e[10],O=e[11];return r[0]=p*k+m*E+g*I,r[1]=p*T+m*A+g*C,r[2]=p*S+m*M+g*B,r[3]=p*P+m*z+g*O,r[4]=y*k+v*E+x*I,r[5]=y*T+v*A+x*C,r[6]=y*S+v*M+x*B,r[7]=y*P+v*z+x*O,r[8]=w*k+b*E+_*I,r[9]=w*T+b*A+_*C,r[10]=w*S+b*M+_*B,r[11]=w*P+b*z+_*O,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r}const ge=me;var ye=Object.freeze({__proto__:null,setDefaultType:function(e){const t=ne;return ne=e,t},create:function(e,t,n,r,i,s,o,a,c,l,u,h,d,f,p,m){const g=new ne(16);return void 0!==e&&(g[0]=e,void 0!==t&&(g[1]=t,void 0!==n&&(g[2]=n,void 0!==r&&(g[3]=r,void 0!==i&&(g[4]=i,void 0!==s&&(g[5]=s,void 0!==o&&(g[6]=o,void 0!==a&&(g[7]=a,void 0!==c&&(g[8]=c,void 0!==l&&(g[9]=l,void 0!==u&&(g[10]=u,void 0!==h&&(g[11]=h,void 0!==d&&(g[12]=d,void 0!==f&&(g[13]=f,void 0!==p&&(g[14]=p,void 0!==m&&(g[15]=m)))))))))))))))),g},set:function(e,t,n,r,i,s,o,a,c,l,u,h,d,f,p,m,g){return(g=g||new ne(16))[0]=e,g[1]=t,g[2]=n,g[3]=r,g[4]=i,g[5]=s,g[6]=o,g[7]=a,g[8]=c,g[9]=l,g[10]=u,g[11]=h,g[12]=d,g[13]=f,g[14]=p,g[15]=m,g},fromMat3:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=0,t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=0,t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromQuat:function(e,t){t=t||new ne(16);const n=e[0],r=e[1],i=e[2],s=e[3],o=n+n,a=r+r,c=i+i,l=n*o,u=r*o,h=r*a,d=i*o,f=i*a,p=i*c,m=s*o,g=s*a,y=s*c;return t[0]=1-h-p,t[1]=u+y,t[2]=d-g,t[3]=0,t[4]=u-y,t[5]=1-l-p,t[6]=f+m,t[7]=0,t[8]=d+g,t[9]=f-m,t[10]=1-l-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},negate:function(e,t){return(t=t||new ne(16))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t[9]=-e[9],t[10]=-e[10],t[11]=-e[11],t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=-e[15],t},copy:re,clone:ie,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r&&Math.abs(e[4]-t[4])<r&&Math.abs(e[5]-t[5])<r&&Math.abs(e[6]-t[6])<r&&Math.abs(e[7]-t[7])<r&&Math.abs(e[8]-t[8])<r&&Math.abs(e[9]-t[9])<r&&Math.abs(e[10]-t[10])<r&&Math.abs(e[11]-t[11])<r&&Math.abs(e[12]-t[12])<r&&Math.abs(e[13]-t[13])<r&&Math.abs(e[14]-t[14])<r&&Math.abs(e[15]-t[15])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},identity:se,transpose:function(e,t){if((t=t||new ne(16))===e){let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,t}const n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],h=e[9],d=e[10],f=e[11],p=e[12],m=e[13],g=e[14],y=e[15];return t[0]=n,t[1]=o,t[2]=u,t[3]=p,t[4]=r,t[5]=a,t[6]=h,t[7]=m,t[8]=i,t[9]=c,t[10]=d,t[11]=g,t[12]=s,t[13]=l,t[14]=f,t[15]=y,t},inverse:oe,determinant:function(e){const t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],a=e[6],c=e[7],l=e[8],u=e[9],h=e[10],d=e[11],f=e[12],p=e[13],m=e[14],g=e[15],y=h*g,v=m*d,x=a*g,w=m*c,b=a*d,_=h*c,k=r*g,T=m*i,S=r*d,P=h*i,E=r*c,A=a*i;return t*(y*o+w*u+b*p-(v*o+x*u+_*p))+s*(v*n+k*u+P*p-(y*n+T*u+S*p))+l*(x*n+T*o+E*p-(w*n+k*o+A*p))+f*(_*n+S*o+A*u-(b*n+P*o+E*u))},invert:ae,multiply:ce,mul:le,setTranslation:function(e,t,n){return e!==(n=n||se())&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11]),n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},getTranslation:function(e,t){return(t=t||a())[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const r=4*t;return(n=n||a())[0]=e[r+0],n[1]=e[r+1],n[2]=e[r+2],n},setAxis:function(e,t,n,r){r!==e&&(r=re(e,r));const i=4*n;return r[i+0]=t[0],r[i+1]=t[1],r[i+2]=t[2],r},getScaling:function(e,t){t=t||a();const n=e[0],r=e[1],i=e[2],s=e[4],o=e[5],c=e[6],l=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+r*r+i*i),t[1]=Math.sqrt(s*s+o*o+c*c),t[2]=Math.sqrt(l*l+u*u+h*h),t},perspective:function(e,t,n,r,i){i=i||new ne(16);const s=Math.tan(.5*Math.PI-.5*e);if(i[0]=s/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=s,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,r===1/0)i[10]=-1,i[14]=-n;else{const e=1/(n-r);i[10]=r*e,i[14]=r*n*e}return i},ortho:function(e,t,n,r,i,s,o){return(o=o||new ne(16))[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(r-n),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(i-s),o[11]=0,o[12]=(t+e)/(e-t),o[13]=(r+n)/(n-r),o[14]=i/(i-s),o[15]=1,o},frustum:function(e,t,n,r,i,s,o){const a=t-e,c=r-n,l=i-s;return(o=o||new ne(16))[0]=2*i/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*i/c,o[6]=0,o[7]=0,o[8]=(e+t)/a,o[9]=(r+n)/c,o[10]=s/l,o[11]=-1,o[12]=0,o[13]=0,o[14]=i*s/l,o[15]=0,o},aim:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),$(C(t,e,de),de),$(j(n,de,ue),ue),$(j(de,ue,he),he),r[0]=ue[0],r[1]=ue[1],r[2]=ue[2],r[3]=0,r[4]=he[0],r[5]=he[1],r[6]=he[2],r[7]=0,r[8]=de[0],r[9]=de[1],r[10]=de[2],r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r},cameraAim:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),$(C(e,t,de),de),$(j(n,de,ue),ue),$(j(de,ue,he),he),r[0]=ue[0],r[1]=ue[1],r[2]=ue[2],r[3]=0,r[4]=he[0],r[5]=he[1],r[6]=he[2],r[7]=0,r[8]=de[0],r[9]=de[1],r[10]=de[2],r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r},lookAt:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),$(C(e,t,de),de),$(j(n,de,ue),ue),$(j(de,ue,he),he),r[0]=ue[0],r[1]=he[0],r[2]=de[0],r[3]=0,r[4]=ue[1],r[5]=he[1],r[6]=de[1],r[7]=0,r[8]=ue[2],r[9]=he[2],r[10]=de[2],r[11]=0,r[12]=-(ue[0]*e[0]+ue[1]*e[1]+ue[2]*e[2]),r[13]=-(he[0]*e[0]+he[1]*e[1]+he[2]*e[2]),r[14]=-(de[0]*e[0]+de[1]*e[1]+de[2]*e[2]),r[15]=1,r},translation:function(e,t){return(t=t||new ne(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},translate:function(e,t,n){n=n||new ne(16);const r=t[0],i=t[1],s=t[2],o=e[0],a=e[1],c=e[2],l=e[3],u=e[4],h=e[5],d=e[6],f=e[7],p=e[8],m=e[9],g=e[10],y=e[11],v=e[12],x=e[13],w=e[14],b=e[15];return e!==n&&(n[0]=o,n[1]=a,n[2]=c,n[3]=l,n[4]=u,n[5]=h,n[6]=d,n[7]=f,n[8]=p,n[9]=m,n[10]=g,n[11]=y),n[12]=o*r+u*i+p*s+v,n[13]=a*r+h*i+m*s+x,n[14]=c*r+d*i+g*s+w,n[15]=l*r+f*i+y*s+b,n},rotationX:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateX:function(e,t,n){n=n||new ne(16);const r=e[4],i=e[5],s=e[6],o=e[7],a=e[8],c=e[9],l=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[4]=h*r+d*a,n[5]=h*i+d*c,n[6]=h*s+d*l,n[7]=h*o+d*u,n[8]=h*a-d*r,n[9]=h*c-d*i,n[10]=h*l-d*s,n[11]=h*u-d*o,e!==n&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationY:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=n,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateY:function(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[8],c=e[9],l=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[0]=h*r-d*a,n[1]=h*i-d*c,n[2]=h*s-d*l,n[3]=h*o-d*u,n[8]=h*a+d*r,n[9]=h*c+d*i,n[10]=h*l+d*s,n[11]=h*u+d*o,e!==n&&(n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationZ:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateZ:function(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[4],c=e[5],l=e[6],u=e[7],h=Math.cos(t),d=Math.sin(t);return n[0]=h*r+d*a,n[1]=h*i+d*c,n[2]=h*s+d*l,n[3]=h*o+d*u,n[4]=h*a-d*r,n[5]=h*c-d*i,n[6]=h*l-d*s,n[7]=h*u-d*o,e!==n&&(n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},axisRotation:fe,rotation:pe,axisRotate:me,rotate:ge,scaling:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},scale:function(e,t,n){n=n||new ne(16);const r=t[0],i=t[1],s=t[2];return n[0]=r*e[0],n[1]=r*e[1],n[2]=r*e[2],n[3]=r*e[3],n[4]=i*e[4],n[5]=i*e[5],n[6]=i*e[6],n[7]=i*e[7],n[8]=s*e[8],n[9]=s*e[9],n[10]=s*e[10],n[11]=s*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},uniformScaling:function(e,t){return(t=t||new ne(16))[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},uniformScale:function(e,t,n){return(n=n||new ne(16))[0]=t*e[0],n[1]=t*e[1],n[2]=t*e[2],n[3]=t*e[3],n[4]=t*e[4],n[5]=t*e[5],n[6]=t*e[6],n[7]=t*e[7],n[8]=t*e[8],n[9]=t*e[9],n[10]=t*e[10],n[11]=t*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n}});let ve=Float32Array;function xe(e,t,n,r){const i=new ve(4);return void 0!==e&&(i[0]=e,void 0!==t&&(i[1]=t,void 0!==n&&(i[2]=n,void 0!==r&&(i[3]=r)))),i}const we=xe;function be(e,t,n){n=n||new ve(4);const r=.5*t,i=Math.sin(r);return n[0]=i*e[0],n[1]=i*e[1],n[2]=i*e[2],n[3]=Math.cos(r),n}function _e(e,t,n){n=n||new ve(4);const r=e[0],i=e[1],s=e[2],o=e[3],a=t[0],c=t[1],l=t[2],u=t[3];return n[0]=r*u+o*a+i*l-s*c,n[1]=i*u+o*c+s*a-r*l,n[2]=s*u+o*l+r*c-i*a,n[3]=o*u-r*a-i*c-s*l,n}const ke=_e;function Te(e,t,n,i){i=i||new ve(4);const s=e[0],o=e[1],a=e[2],c=e[3];let l,u,h=t[0],d=t[1],f=t[2],p=t[3],m=s*h+o*d+a*f+c*p;if(m<0&&(m=-m,h=-h,d=-d,f=-f,p=-p),1-m>r){const e=Math.acos(m),t=Math.sin(e);l=Math.sin((1-n)*e)/t,u=Math.sin(n*e)/t}else l=1-n,u=n;return i[0]=l*s+u*h,i[1]=l*o+u*d,i[2]=l*a+u*f,i[3]=l*c+u*p,i}function Se(e,t){return(t=t||new ve(4))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}const Pe=Se;function Ee(e,t,n){return(n=n||new ve(4))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n}const Ae=Ee;function Me(e,t,n){return(n=n||new ve(4))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n}const ze=Me;function Ie(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Ce(e){const t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)}const Be=Ce;function Oe(e){const t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i}const Re=Oe;function Ue(e,t){t=t||new ve(4);const n=e[0],r=e[1],i=e[2],s=e[3],o=Math.sqrt(n*n+r*r+i*i+s*s);return o>1e-5?(t[0]=n/o,t[1]=r/o,t[2]=i/o,t[3]=s/o):(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}let Ne,je,De,qe,Fe;var Le=Object.freeze({__proto__:null,create:xe,setDefaultType:function(e){const t=ve;return ve=e,t},fromValues:we,set:function(e,t,n,r,i){return(i=i||new ve(4))[0]=e,i[1]=t,i[2]=n,i[3]=r,i},fromAxisAngle:be,toAxisAngle:function(e,t){t=t||a(4);const n=2*Math.acos(e[3]),i=Math.sin(.5*n);return i>r?(t[0]=e[0]/i,t[1]=e[1]/i,t[2]=e[2]/i):(t[0]=1,t[1]=0,t[2]=0),{angle:n,axis:t}},angle:function(e,t){const n=Ie(e,t);return Math.acos(2*n*n-1)},multiply:_e,mul:ke,rotateX:function(e,t,n){n=n||new ve(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],c=Math.sin(r),l=Math.cos(r);return n[0]=i*l+a*c,n[1]=s*l+o*c,n[2]=o*l-s*c,n[3]=a*l-i*c,n},rotateY:function(e,t,n){n=n||new ve(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],c=Math.sin(r),l=Math.cos(r);return n[0]=i*l-o*c,n[1]=s*l+a*c,n[2]=o*l+i*c,n[3]=a*l-s*c,n},rotateZ:function(e,t,n){n=n||new ve(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],c=Math.sin(r),l=Math.cos(r);return n[0]=i*l+s*c,n[1]=s*l-i*c,n[2]=o*l+a*c,n[3]=a*l-o*c,n},slerp:Te,inverse:function(e,t){t=t||new ve(4);const n=e[0],r=e[1],i=e[2],s=e[3],o=n*n+r*r+i*i+s*s,a=o?1/o:0;return t[0]=-n*a,t[1]=-r*a,t[2]=-i*a,t[3]=s*a,t},conjugate:function(e,t){return(t=t||new ve(4))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},fromMat:function(e,t){t=t||new ve(4);const n=e[0]+e[5]+e[10];if(n>0){const r=Math.sqrt(n+1);t[3]=.5*r;const i=.5/r;t[0]=(e[6]-e[9])*i,t[1]=(e[8]-e[2])*i,t[2]=(e[1]-e[4])*i}else{let n=0;e[5]>e[0]&&(n=1),e[10]>e[4*n+n]&&(n=2);const r=(n+1)%3,i=(n+2)%3,s=Math.sqrt(e[4*n+n]-e[4*r+r]-e[4*i+i]+1);t[n]=.5*s;const o=.5/s;t[3]=(e[4*r+i]-e[4*i+r])*o,t[r]=(e[4*r+n]+e[4*n+r])*o,t[i]=(e[4*i+n]+e[4*n+i])*o}return t},fromEuler:function(e,t,n,r,i){i=i||new ve(4);const s=.5*e,o=.5*t,a=.5*n,c=Math.sin(s),l=Math.cos(s),u=Math.sin(o),h=Math.cos(o),d=Math.sin(a),f=Math.cos(a);switch(r){case"xyz":i[0]=c*h*f+l*u*d,i[1]=l*u*f-c*h*d,i[2]=l*h*d+c*u*f,i[3]=l*h*f-c*u*d;break;case"xzy":i[0]=c*h*f-l*u*d,i[1]=l*u*f-c*h*d,i[2]=l*h*d+c*u*f,i[3]=l*h*f+c*u*d;break;case"yxz":i[0]=c*h*f+l*u*d,i[1]=l*u*f-c*h*d,i[2]=l*h*d-c*u*f,i[3]=l*h*f+c*u*d;break;case"yzx":i[0]=c*h*f+l*u*d,i[1]=l*u*f+c*h*d,i[2]=l*h*d-c*u*f,i[3]=l*h*f-c*u*d;break;case"zxy":i[0]=c*h*f-l*u*d,i[1]=l*u*f+c*h*d,i[2]=l*h*d+c*u*f,i[3]=l*h*f-c*u*d;break;case"zyx":i[0]=c*h*f-l*u*d,i[1]=l*u*f+c*h*d,i[2]=l*h*d-c*u*f,i[3]=l*h*f+c*u*d;break;default:throw new Error(`Unknown rotation order: ${r}`)}return i},copy:Se,clone:Pe,add:function(e,t,n){return(n=n||new ve(4))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n},subtract:Ee,sub:Ae,mulScalar:Me,scale:ze,divScalar:function(e,t,n){return(n=n||new ve(4))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n[3]=e[3]/t,n},dot:Ie,lerp:function(e,t,n,r){return(r=r||new ve(4))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r[2]=e[2]+n*(t[2]-e[2]),r[3]=e[3]+n*(t[3]-e[3]),r},length:Ce,len:Be,lengthSq:Oe,lenSq:Re,normalize:Ue,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(e){return(e=e||new ve(4))[0]=0,e[1]=0,e[2]=0,e[3]=1,e},rotationTo:function(e,t,n){n=n||new ve(4),Ne=Ne||a(),je=je||a(1,0,0),De=De||a(0,1,0);const r=D(e,t);return r<-.999999?(j(je,e,Ne),F(Ne)<1e-6&&j(De,e,Ne),$(Ne,Ne),be(Ne,Math.PI,n),n):r>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(j(e,t,Ne),n[0]=Ne[0],n[1]=Ne[1],n[2]=Ne[2],n[3]=1+r,Ue(n,n))},sqlerp:function(e,t,n,r,i,s){return s=s||new ve(4),qe=qe||new ve(4),Fe=Fe||new ve(4),Te(e,r,i,qe),Te(t,n,i,Fe),Te(qe,Fe,2*i*(1-i),s),s}});Float32Array;const Ve=(e,t)=>{const n=new Uint32Array(t);Vi.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},Ge=(e,t)=>{const n=new Uint32Array(e),r=Vi.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return Ve(r,e),r},We=(e,t)=>{if(t instanceof Float32Array)Vi.queue.writeBuffer(e,0,t.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT);else{const n=new Float32Array(t);Vi.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)}},Ye="fn calculateRayDirection(uv: vec2<f32>, inverseProjection: mat4x4<f32>) -> vec3<f32> {\r\n  let clipSpace = vec2(1.0 - uv.x, 1.0 - uv.y) * 2.0 - 1.0;\r\n  let viewRay = vec3<f32>(clipSpace, 1.0);\r\n  let viewRayView = inverseProjection * vec4(viewRay, 1.0);\r\n  return normalize(viewRayView.xyz);\r\n}\r\n\r\nfn normaliseValue(min: f32, max: f32, value: f32) -> f32 {\r\n  return (value - min) / (max - min);\r\n}",He="// TODO: actually make linear\r\nfn distanceToReversedLinearDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n  return (far - cameraDistance) / (far - near);//Reversed\r\n}\r\n\r\nfn reversedLinearDepthToDistance(linearDepth: f32, near: f32, far: f32) -> f32 {\r\n    return far - linearDepth * (far - near); //Reversed\r\n}\r\n\r\nfn distanceToLogarithmicDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n    return log2(cameraDistance / near + 1.0) / log2(far / near + 1.0);\r\n}\r\n\r\nfn logarithmicDepthToDistance(logDepth: f32, near: f32, far: f32) -> f32 {\r\n    let base = far / near + 1.0;\r\n    return near * (pow(base, logDepth) - 1.0);\r\n}",$e="r8unorm",Xe="rgba16float",Ze="r32float",Ke="struct BoxIntersectionResult {\r\n    tNear: f32,\r\n    tFar: f32,\r\n    normal: vec3<f32>,\r\n    isHit: bool,\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n    result.isHit = false;\r\n    result.tNear = -1.0;\r\n    result.tFar = -1.0;\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n    if (tN > tF || tF < 0.0) {\r\n        return result;\r\n    }\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n    normal *= -sign(rd);\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        return result;\r\n    }\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n    result.isHit = true;\r\n    return result;\r\n}\r\n\r\nfn get3x3From4x4(m: mat4x4<f32>) -> mat3x3<f32> {\r\n    return mat3x3<f32>(\r\n        m[0].xyz,\r\n        m[1].xyz,\r\n        m[2].xyz,\r\n    );\r\n}\r\n\r\n\r\nfn intersectOBB(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n    boxOrientation: mat3x3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n    result.isHit = false;\r\n    result.tNear = -1.0;\r\n    result.tFar = -1.0;\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n    if (tN > tF || tF < 0.0) {\r\n        return result;\r\n    }\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n    normal *= -sign(rd);\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        return result;\r\n    }\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n    result.isHit = true;\r\n    return result;\r\n}",Qe="const EPSILON = 0.001;\r\nconst MAX_RAY_STEPS = 256;\r\nconst FAR_PLANE = 10000.0;\r\nconst NEAR_PLANE = 0.5;\r\nconst STACK_LEN: u32 = 32u;\r\n\r\n// Function to transform a normal vector from object to world space\r\nfn transformNormal(inverseTransform: mat4x4<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let worldNormal = normalize((vec4<f32>(normal, 0.0) * inverseTransform).xyz);\r\n    return worldNormal;\r\n}\r\n\r\n// Function to transform an object space position to world space\r\nfn transformPosition(transform: mat4x4<f32>, position: vec3<f32>) -> vec3<f32> {\r\n    let worldPosition = (transform * vec4<f32>(position, 1.0)).xyz;\r\n    return worldPosition;\r\n}\r\n\r\nfn getMaxMipLevel(size: vec3<f32>) -> u32 {\r\n  return u32(log2(max(size.x, max(size.y, size.z))));\r\n}\r\n\r\nstruct VoxelObject {\r\n  transform: mat4x4<f32>,\r\n  inverseTransform: mat4x4<f32>,\r\n  previousTransform: mat4x4<f32>,\r\n  previousInverseTransform: mat4x4<f32>,\r\n  size : vec3<f32>,\r\n  atlasLocation : vec3<f32>,\r\n  paletteIndex : f32,\r\n  octreeBufferIndex: u32\r\n}\r\n\r\nstruct RayMarchResult {\r\n  voxelObjectIndex: i32,\r\n  colour: vec3<f32>,\r\n  normal: vec3<f32>,\r\n  hit: bool,\r\n  t: f32,\r\n  iterations: u32,\r\n}\r\n\r\nfn isInBounds(position: vec3<i32>, size: vec3<i32>) -> bool {\r\n  return all(position >= vec3(0)) && all(position <= size - vec3(1));\r\n}\r\n\r\nfn getMipLevelFromVoxelSize(voxelSize: vec3<f32>) -> u32 {\r\n  return u32(log2(max(voxelSize.x, max(voxelSize.y, voxelSize.z))));\r\n}\r\n\r\nfn convert1DTo3D(size: vec3<u32>, index: u32) -> vec3<u32> {\r\n  return vec3(\r\n    index % size.x,\r\n    index / size.y,\r\n    index / (size.x * size.y)\r\n  );\r\n}\r\n\r\nfn convert3DTo1D(size: vec3<u32>, position: vec3<u32>) -> u32 {\r\n  return position.x + position.y * size.x + position.z * (size.x * size.y);\r\n}\r\n\r\nfn getBit(value: u32, bitIndex: u32) -> bool {\r\n  return (value & (1u << bitIndex)) != 0;\r\n}\r\n\r\n\r\nfn getScaleFromMatrix(transform: mat4x4<f32>) -> vec3<f32> {\r\n  return vec3<f32>(length(transform[0].xyz), length(transform[1].xyz), length(transform[2].xyz));\r\n}\r\n\r\n\r\nfn rayMarchAtMip(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>, mipLevel: u32) -> RayMarchResult {\r\n  var output = RayMarchResult();\r\n\r\n//  var intersect = boxIntersection(objectRayOrigin, objectRayDirection,voxelObject.size * 0.5);\r\n//\r\n//  if(intersect.isHit){\r\n//    output.hit = true;\r\n//    output.t = intersect.tNear;\r\n//    output.normal = intersect.normal;\r\n//    output.colour = vec3<f32>(0.0, 1.0, 0.0);\r\n//    return output;\r\n//  }\r\n\r\n  let rayDirSign = sign(objectRayDirection);\r\n  let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\r\n  var voxelSize = vec3(f32(1 << mipLevel));\r\n  var shiftedRayOrigin = objectRayOrigin - objectRayDirection * EPSILON;\r\n  var objectPos = shiftedRayOrigin;\r\n  var currentIndex = vec3<i32>(floor(objectPos));\r\n  var scaledRayOrigin =  objectRayOrigin / voxelSize;\r\n  var scaledObjectPos = floor(objectPos / voxelSize);\r\n  var scaledOriginDifference = scaledObjectPos - scaledRayOrigin;\r\n  var tMax = voxelSize * (rayDirSign * scaledOriginDifference + (rayDirSign * 0.5) + 0.5) / abs(objectRayDirection);\r\n  let mask = vec3<f32>(tMax.xyz <= min(tMax.yzx, tMax.zxy));\r\n  var objectNormal = mask * -rayDirSign;\r\n  var tCurrent = min(tMax.x, min(tMax.y, tMax.z));\r\n\r\n  // RAYMARCH\r\n  for(var i = 0; i < MAX_RAY_STEPS; i++)\r\n  {\r\n    let samplePosition = vec3<u32>(currentIndex) + atlasLocation;\r\n    let mipSample0 = textureLoad(voxels, samplePosition / vec3((1u << mipLevel)), mipLevel);\r\n\r\n    if(mipSample0.r > 0.0 && isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n        output.normal = objectNormal;\r\n        output.hit = true;\r\n        output.t = tCurrent + EPSILON;\r\n        output.colour = vec3<f32>(mipSample0.r, 0,0);\r\n        output.iterations = u32(i);\r\n        return output;\r\n    }\r\n\r\n    var scaledRayOrigin = shiftedRayOrigin / voxelSize;\r\n    var scaledObjectPos = floor(objectPos / voxelSize);\r\n    var scaledOriginDifference = scaledObjectPos - scaledRayOrigin;\r\n    var tMax = voxelSize * (rayDirSign * scaledOriginDifference + (rayDirSign * 0.5) + 0.5) / abs(objectRayDirection);\r\n    let mask = vec3<f32>(tMax.xyz <= min(tMax.yzx, tMax.zxy));\r\n\r\n    tCurrent = min(tMax.x, min(tMax.y, tMax.z));\r\n    objectPos = objectRayOrigin + objectRayDirection * tCurrent;\r\n    currentIndex = vec3<i32>(floor(objectPos / voxelSize) * voxelSize);\r\n    objectNormal = mask * -rayDirSign;\r\n\r\n//    if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n//        break;\r\n//    }\r\n  }\r\n  return output;\r\n}\r\n\r\nfn rayMarchTransformed(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>, mipLevel: u32) -> RayMarchResult {\r\n      let halfExtents = voxelObject.size * 0.5;\r\n      var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz + halfExtents;\r\n      let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n      return  rayMarchAtMip(voxelObject, objectRayDirection, objectRayOrigin, mipLevel);\r\n}\r\n\r\nstruct Stack {\r\n  arr: array<i32, STACK_LEN>,\r\n\thead: u32,\r\n}\r\n\r\nfn stack_new() -> Stack {\r\n    var arr: array<i32, STACK_LEN>;\r\n    return Stack(arr, 0u);\r\n}\r\n\r\nfn stack_push(stack: ptr<function, Stack>, val: i32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stack_pop(stack: ptr<function, Stack>) -> i32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\nstruct StackU32 {\r\n  arr: array<u32, STACK_LEN>,\r\n  head: u32,\r\n}\r\n\r\nfn stacku32_new() -> StackU32 {\r\n    var arr: array<u32, STACK_LEN>;\r\n    return StackU32(arr, 0u);\r\n}\r\n\r\nfn stacku32_push(stack: ptr<function, StackU32>, val: u32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stacku32_pop(stack: ptr<function, StackU32>) -> u32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\nstruct Stack2 {\r\n  arr: array<vec2<u32>, STACK_LEN>,\r\n\thead: u32,\r\n}\r\n\r\nfn stack2_new() -> Stack2 {\r\n    var arr: array<vec2<u32>, STACK_LEN>;\r\n    return Stack2(arr, 0u);\r\n}\r\n\r\nfn stack2_push(stack: ptr<function, Stack2>, val: vec2<u32>) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stack2_pop(stack: ptr<function, Stack2>) -> vec2<u32> {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\nstruct InternalNode {\r\n  firstChildOffset: u32,\r\n  childMask: u32,\r\n  leafMask: u32,\r\n  x: u32,\r\n  y: u32,\r\n  z: u32,\r\n  size: u32,\r\n}\r\n\r\nfn getFirstChildIndexFromInternalNode(node: InternalNode, index: u32) -> u32 {\r\n  return index + node.firstChildOffset;\r\n}\r\n\r\nconst mask8 = 0xFFu;\r\nconst mask16 = 0xFFFFu;\r\n\r\n// if first child offset is 0, then it is a leaf\r\nfn isLeaf(node:vec2<u32>) -> bool {\r\n  return (node[0] & mask16) == 0;\r\n}\r\n\r\n//3nd, 4rd and 5th bytes are the red, green and blue values\r\nfn unpackLeaf(node: vec2<u32>) -> vec3<u32> {\r\n  let firstByte = node.x;\r\n  let secondByte = node.y;\r\n  return vec3<u32>(\r\n    (node[0] >> 16u) & mask8,\r\n    (node[0] >> 24u) & mask8,\r\n    node[1] & mask8\r\n  );\r\n}\r\n\r\n/**\r\n  * Unpacks an internal node from a 32 bit integer\r\n  * First 16 bits are the firstChildOffset\r\n  * The next 8 bits are the child mask\r\n  * The next 8 bits are the x position\r\n  * The next 8 bits are the y position\r\n  * The next 8 bits are the z position\r\n  * The next 8 bits are the size\r\n  */\r\nfn unpackInternal(node: vec2<u32>) -> InternalNode {\r\n  var output = InternalNode();\r\n  let first4Bytes = node.x;\r\n  let second4Bytes = node.y;\r\n  output.firstChildOffset = first4Bytes & mask16;\r\n  output.childMask = (first4Bytes >> 16u) & mask8;\r\n  output.leafMask = (first4Bytes >> 24u) & mask8;\r\n  output.x = second4Bytes & mask8;\r\n  output.y = (second4Bytes >> 8u) & mask8;\r\n  output.z = (second4Bytes >> 16u) & mask8;\r\n  output.size = (second4Bytes >> 24u) & mask8;\r\n  return output;\r\n}\r\n\r\nfn getNodeSizeAtDepth(rootSize: u32, depth: u32) -> u32 {\r\n  return rootSize >> depth;\r\n}\r\n\r\nfn octantIndexToOffset(index: u32) -> vec3<u32> {\r\n  return vec3<u32>(\r\n    select(0u, 1u, (index & 1u) != 0u),\r\n    select(0u, 1u, (index & 2u) != 0u),\r\n    select(0u, 1u, (index & 4u) != 0u)\r\n  );\r\n}\r\n\r\nfn octantOffsetToIndex(offset: vec3<u32>) -> u32 {\r\n  return offset.x + offset.y * 2u + offset.z * 4u;\r\n}\r\n\r\nfn ceilToPowerOfTwo(value: f32) -> f32 {\r\n  return pow(2.0, ceil(log2(value)));\r\n}\r\n\r\nfn max3(value: vec3<f32>) -> f32 {\r\n  return max(value.x, max(value.y, value.z));\r\n}\r\n\r\nfn planeIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, planeNormal: vec3<f32>, planeDistance: f32) -> f32 {\r\n  return -(dot(rayOrigin,planeNormal)+planeDistance)/dot(rayDirection,planeNormal);\r\n}\r\n\r\nfn sort3Asc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    min(a, min(b, c)),\r\n    max(min(a, b), min(max(a, b), c)),\r\n    max(a, max(b, c))\r\n  );\r\n}\r\n\r\nfn sort3Desc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    max(a, max(b, c)),\r\n    max(min(a, b), min(max(a, b), c)),\r\n    min(a, min(b, c))\r\n  );\r\n}\r\n\r\nfn getPlaneIntersections(rayOrigin: vec3<f32>, rayDirection:vec3<f32>, nodeSize: f32) -> vec3<f32> {\r\n    let boxExtents = nodeSize * 0.5;\r\n\r\n    var yPlaneIntersection = planeIntersection(rayOrigin, rayDirection, vec3(0.0, -1, 0.0), boxExtents);\r\n    var xPlaneIntersection = planeIntersection(rayOrigin, rayDirection, vec3(-1, 0.0, 0.0), boxExtents);\r\n    var zPlaneIntersection = planeIntersection(rayOrigin, rayDirection, vec3(0.0, 0.0, -1), boxExtents);\r\n\r\n    // If the intersection is outside the bounds of the node, set it to a large value to ignore it\r\n    let yPlaneHitPosition = rayOrigin + rayDirection * yPlaneIntersection - EPSILON;\r\n    if(any(yPlaneHitPosition < vec3(0.0)) || any(yPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      yPlaneIntersection = 10000.0;\r\n    }\r\n    let xPlaneHitPosition = rayOrigin + rayDirection * xPlaneIntersection - EPSILON;\r\n    if(any(xPlaneHitPosition < vec3(0.0)) || any(xPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      xPlaneIntersection = 10000.0;\r\n    }\r\n    let zPlaneHitPosition = rayOrigin + rayDirection * zPlaneIntersection - EPSILON;\r\n    if(any(zPlaneHitPosition < vec3(0.0)) || any(zPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      zPlaneIntersection = 10000.0;\r\n    }\r\n    return vec3<f32>(xPlaneIntersection, yPlaneIntersection, zPlaneIntersection);\r\n}\r\n\r\n\r\n//fn rayMarchOctree(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> RayMarchResult {\r\n//    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz;\r\n//    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n//    var output = RayMarchResult();\r\n//\r\n//    // Set the initial t value to the far plane - essentially an out of bounds value\r\n//    output.t = FAR_PLANE;\r\n//\r\n//    // Create a stack to hold the indices of the nodes we need to check\r\n//    var stack = stacku32_new();\r\n//\r\n//    // Push the root node index onto the stack\r\n//    stacku32_push(&stack, 0);\r\n//\r\n//    // Main loop\r\n//    while (stack.head > 0u && output.iterations < MAX_STEPS) {\r\n//      let nodeIndex = stacku32_pop(&stack);\r\n//      let node = unpackInternal(octreeBuffer[nodeIndex]);\r\n//      let nodeRayOrigin = objectRayOrigin - vec3(f32(node.x), f32(node.y), f32(node.z));\r\n//      let firstChildIndex = getFirstChildIndexFromInternalNode(node, nodeIndex);\r\n//\r\n//      // Check each child octant of the node for intersections\r\n//      for(var i = 0u; i < 8u; i++){\r\n//        // If the child is not present, skip it\r\n//        if(!getBit(node.childMask, i)){\r\n//          continue;\r\n//        }\r\n//        let octantPosition = octantIndexToOffset(i);\r\n//        let childRayOrigin = nodeRayOrigin - vec3(f32(node.size) * 0.5) * vec3<f32>(octantPosition);\r\n//        let childNodeIntersection = boxIntersection(childRayOrigin, objectRayDirection, vec3(f32(node.size) * 0.25));\r\n//\r\n//        // If the octant is hit by the ray, process it\r\n//        if(childNodeIntersection.isHit){\r\n//          // Child is a leaf node\r\n////          if(getBit(node.leafMask, i) && childNodeIntersection.tNear < output.t){\r\n//            if(childNodeIntersection.tNear < output.t){\r\n//            output.t = childNodeIntersection.tNear;\r\n//            output.hit = true;\r\n//            output.normal = abs(childNodeIntersection.normal);\r\n//            output.colour = vec3<f32>(0.0, 1.0, 0.0);\r\n//          }\r\n//          // Child is an internal node, push it to the stack\r\n//          stacku32_push(&stack, firstChildIndex + i);\r\n//        }\r\n//      }\r\n//\r\n//      // We hit a leaf node, so we can break out of the loop\r\n//      if(output.hit){\r\n//        return output;\r\n//      }\r\n//\r\n//      // Increment the number of iterations for the loop and debug purposes\r\n//      output.iterations += 1u;\r\n//    }\r\n//    return output;\r\n//}\r\n\r\n\r\nconst colours = array<vec3<f32>, 8>(\r\n  vec3<f32>(0.5),\r\n  vec3<f32>(1.0, 0.0, 0.0),\r\n  vec3<f32>(0.0, 1.0, 0.0),\r\n  vec3<f32>(1.0, 1.0, 0.0),\r\n  vec3<f32>(0.0, 0.0, 1.0),\r\n  vec3<f32>(1.0, 0.0, 1.0),\r\n  vec3<f32>(0.0, 1.0, 1.0),\r\n  vec3<f32>(1.0, 1.0, 1.0)\r\n);\r\n\r\nfn debugColourFromIndex(index: i32) -> vec3<f32> {\r\n  return colours[index % 8];\r\n}\r\n",Je="const BRICK_SIZE = 8;\r\nconst MAX_STEPS = 256;\r\n\r\n\r\nstruct BVHNode {\r\n  leftIndex: i32,\r\n  rightIndex: i32,\r\n  objectCount: u32,\r\n  AABBMin: vec3<f32>,\r\n  AABBMax: vec3<f32>\r\n}\r\n\r\nfn getDistanceToNode(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, node: BVHNode) -> f32 {\r\n  if(all(rayOrigin >= node.AABBMin) && all(rayOrigin <= node.AABBMax)){\r\n    return 0.0;\r\n  }\r\n  let boxSize = (node.AABBMax - node.AABBMin) / 2;\r\n  let intersection = boxIntersection(rayOrigin - node.AABBMin, rayDirection, boxSize);\r\n  if(intersection.isHit){\r\n    return intersection.tNear;\r\n  }\r\n  return -1.0;\r\n\r\n}\r\n\r\n// Stack-based BVH traversal\r\nfn rayMarchBVH(rayOrigin: vec3<f32>, rayDirection: vec3<f32>) -> RayMarchResult {\r\n  var closestIntersection = RayMarchResult();\r\n closestIntersection.t = FAR_PLANE;\r\n\r\n  // Create a stack to store the nodes to visit\r\n  var stack = stack_new();\r\n  stack_push(&stack, 0);\r\n\r\n  var iterations = 0;\r\n  var nodeIndex = 0;\r\n  var closestRayMarchDistance = FAR_PLANE;\r\n\r\n  while (stack.head > 0u && iterations < MAX_STEPS) {\r\n    let node = bvhNodes[nodeIndex];\r\n    if(node.objectCount > 1){\r\n      let leftNode = bvhNodes[node.leftIndex];\r\n      let rightNode = bvhNodes[node.rightIndex];\r\n      let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\r\n      let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\r\n      let hitLeft = leftDist >= 0.0;\r\n      let hitRight = rightDist >= 0.0;\r\n      if(hitLeft){\r\n        var nearIndex = node.leftIndex;\r\n        // We hit both left and right, choose the closest one\r\n        if(hitRight){\r\n          if(leftDist < rightDist){\r\n            // left is closer, push right to stack\r\n            stack_push(&stack, node.rightIndex);\r\n          } else {\r\n            // right is closer, push left to stack\r\n            stack_push(&stack, node.leftIndex);\r\n            nearIndex = node.rightIndex;\r\n          }\r\n        }\r\n        nodeIndex = nearIndex;\r\n      }\r\n      // We only hit the right Node\r\n      else if(hitRight){\r\n        nodeIndex = node.rightIndex;\r\n      }\r\n      // We didn't hit any node, pop the stack\r\n      else{\r\n        nodeIndex = stack_pop(&stack);\r\n      }\r\n    }\r\n    // valid leaf, raymarch it\r\n    else if(node.objectCount == 1){\r\n//        closestIntersection.t = 10.0;\r\n//        closestIntersection.hit = true;\r\n//        closestIntersection.normal = vec3<f32>(0.0, 0.0, 0.0);\r\n//        closestIntersection.colour = vec3<f32>(0.0, 0.0, 0.0);\r\n//        return closestIntersection;\r\n        let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\r\n        if(distanceToLeaf > closestRayMarchDistance){\r\n          nodeIndex = stack_pop(&stack);\r\n          continue;\r\n        }\r\n        let worldPos = rayOrigin + rayDirection * distanceToLeaf;\r\n        let voxelObject = voxelObjects[node.leftIndex];\r\n         var rayMarchResult = rayMarchTransformed(voxelObject, rayDirection, worldPos, 0);\r\n//        var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, rayOrigin);\r\n        rayMarchResult.voxelObjectIndex = node.leftIndex;\r\n\r\n        let totalDistance = rayMarchResult.t + distanceToLeaf;\r\n        if(rayMarchResult.hit && totalDistance < closestRayMarchDistance){\r\n          closestIntersection = rayMarchResult;\r\n          closestRayMarchDistance = totalDistance;\r\n        }\r\n\r\n        nodeIndex = stack_pop(&stack);\r\n    }\r\n\r\n    iterations += 1;\r\n//    closestIntersection.colour += vec3<f32>(0.0075);\r\n  }\r\n\r\n  return closestIntersection;\r\n}\r\n\r\nconst MAX_SHADOW_BVH_VISITS = 32;\r\n\r\nfn rayMarchBVHShadows(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, mipLevel: u32) -> RayMarchResult {\r\n   var closestIntersection = RayMarchResult();\r\n   closestIntersection.t = FAR_PLANE;\r\n\r\n   // Create a stack to store the nodes to visit\r\n   var stack = stack_new();\r\n   stack_push(&stack, 0);\r\n\r\n   var iterations = 0;\r\n   var nodeIndex = 0;\r\n\r\n   while (stack.head > 0u && iterations < MAX_SHADOW_BVH_VISITS) {\r\n     let node = bvhNodes[nodeIndex];\r\n     if(node.objectCount > 1){\r\n       let leftNode = bvhNodes[node.leftIndex];\r\n       let rightNode = bvhNodes[node.rightIndex];\r\n       let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\r\n       let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\r\n       let hitLeft = leftDist >= 0.0;\r\n       let hitRight = rightDist >= 0.0;\r\n       if(hitLeft){\r\n         var nearIndex = node.leftIndex;\r\n         // We hit both left and right, choose the closest one\r\n         if(hitRight){\r\n           if(leftDist < rightDist){\r\n             // left is closer, push right to stack\r\n             stack_push(&stack, node.rightIndex);\r\n           } else {\r\n             // right is closer, push left to stack\r\n             stack_push(&stack, node.leftIndex);\r\n             nearIndex = node.rightIndex;\r\n           }\r\n         }\r\n         nodeIndex = nearIndex;\r\n       }\r\n       // We only hit the right Node\r\n       else if(hitRight){\r\n         nodeIndex = node.rightIndex;\r\n       }\r\n       // We didn't hit any node, pop the stack\r\n       else{\r\n         nodeIndex = stack_pop(&stack);\r\n       }\r\n     }\r\n     // valid leaf, raymarch it\r\n     else if(node.objectCount == 1){\r\n         let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\r\n         if(distanceToLeaf < 0.0){\r\n           nodeIndex = stack_pop(&stack);\r\n           continue;\r\n         }\r\n         let worldPos = rayOrigin + rayDirection * distanceToLeaf;\r\n         let voxelObject = voxelObjects[node.leftIndex];\r\n//         var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, worldPos, 3);\r\n         var rayMarchResult = rayMarchTransformed(voxelObject, rayDirection, worldPos, mipLevel);\r\n         rayMarchResult.t += distanceToLeaf;\r\n//\r\n         rayMarchResult.voxelObjectIndex = node.leftIndex;\r\n         if(rayMarchResult.hit){\r\n           return rayMarchResult;\r\n         }\r\n\r\n         nodeIndex = stack_pop(&stack);\r\n     }\r\n\r\n     iterations += 1;\r\n //    closestIntersection.colour += vec3<f32>(0.0075);\r\n   }\r\n\r\n   return closestIntersection;\r\n }",et="struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\r\n\r\n\r\nfn plainIntersect(ro: vec3<f32>, rd: vec3<f32>, p: vec4<f32>) -> f32 {\r\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\r\n}\r\n\r\nfn getVelocityStatic(worldPos: vec3<f32>, viewProjections:ViewProjectionMatrices) -> vec2<f32>{\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  let clipSpace = vp * vec4(worldPos.xyz, 1.0);\r\n  let previousClipSpace = previousVp * vec4(worldPos.xyz, 1.0);\r\n\r\n  let ndc = clipSpace.xyz / clipSpace.w;\r\n  let previousNdc = previousClipSpace.xyz / previousClipSpace.w;\r\n\r\n  var uv = ndc.xy * 0.5 + 0.5;\r\n  var previousUv = previousNdc.xy * 0.5 + 0.5;\r\n\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getVelocity(objectPos: vec3<f32>, modelMatrix: mat4x4<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec2<f32> {\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  // Get current object space position of the current pixel\r\n  let objectClipSpace = vp * modelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let objectNDC = objectClipSpace.xyz / objectClipSpace.w;\r\n\r\n  // Get previous position of the current object space position\r\n  let previousObjectClipSpace = previousVp * previousModelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let previousObjectNDC = previousObjectClipSpace.xyz / previousObjectClipSpace.w;\r\n\r\n  // UV\r\n  var uv = objectNDC.xy * 0.5 + 0.5;\r\n  var previousUv = previousObjectNDC.xy * 0.5 + 0.5;\r\n  uv.y = 1.0 - uv.y;\r\n  previousUv.y = 1.0 - previousUv.y;\r\n\r\n  // Get velocity based on the difference between the current and previous positions\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getLeftChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 1;\r\n}\r\n\r\nfn getRightChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 2;\r\n}\r\n\r\nfn getParentIndex(index: i32) -> i32 {\r\n  return (index - 1) / 2;\r\n}\r\n\r\n\r\nfn dirIsNegative(dir: vec3<f32>, axis: i32) -> bool {\r\n  return dir[axis] < 0.0;\r\n}\r\n\r\nfn getDebugColour(index: i32) -> vec3<f32> {\r\n  let colours = array<vec3<f32>, 6>(\r\n    vec3<f32>(1.0, 0.0, 0.0),\r\n    vec3<f32>(0.0, 1.0, 0.0),\r\n    vec3<f32>(0.0, 0.0, 1.0),\r\n    vec3<f32>(1.0, 1.0, 0.0),\r\n    vec3<f32>(1.0, 0.0, 1.0),\r\n    vec3<f32>(0.0, 1.0, 1.0)\r\n  );\r\n  return colours[index % 6];\r\n}\r\n\r\n\r\nfn customNormalize(value: f32, min: f32, max: f32) -> f32 {\r\n    return (value - min) / (max - min);\r\n}\r\n\r\nconst IDENTITY_MATRIX = mat4x4<f32>(\r\n  vec4<f32>(1.0, 0.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 1.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n);\r\n\r\nfn intersectSphere(origin: vec3<f32>, dir: vec3<f32>, spherePos: vec3<f32>, sphereRad: f32) -> f32\r\n{\r\n\tlet oc = origin - spherePos;\r\n\tlet b = 2.0 * dot(dir, oc);\r\n\tlet c = dot(oc, oc) - sphereRad*sphereRad;\r\n\tlet disc = b * b - 4.0 * c;\r\n\tif (disc < 0.0)\r\n\t{\r\n\t  return -1.0;\r\n\t}\r\n\r\n//    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\r\n  let q = (-b + select(sqrt(disc), -sqrt(disc), b < 0.0)) / 2.0;\r\n\tvar t0 = q;\r\n\tvar t1 = c / q;\r\n\tif (t0 > t1) {\r\n\t\tvar temp = t0;\r\n\t\tt0 = t1;\r\n\t\tt1 = temp;\r\n\t}\r\n\tif (t1 < 0.0){\r\n\t  return -1.0;\r\n\t}\r\n\r\n  return select(t0, t1, t0 < 0.0);\r\n}\r\n\r\nfn skyDomeIntersection(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\r\n    return intersectSphere(ro, rd, vec3<f32>(0.0, 0.0, 0.0), 100.0);\r\n}\r\n\r\nfn reprojectWorldPos(worldPos: vec3<f32>, viewProjections: ViewProjectionMatrices) -> vec3<f32> {\r\n  let clipSpace = viewProjections.previousViewProjection * vec4(worldPos.xyz, 1.0);\r\n  return 0.5 * (clipSpace.xyz / clipSpace.w) + 0.5;\r\n}\r\n\r\nfn reprojectObjectWorldPos(worldPos: vec3<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec3<f32> {\r\n  let clipSpace = viewProjections.previousViewProjection * previousModelMatrix * vec4(worldPos.xyz, 1.0);\r\n  return 0.5 * (clipSpace.xyz / clipSpace.w) + 0.5;\r\n}\r\n\r\nfn simplePhongShading(normal: vec3<f32>, lightDir: vec3<f32>, lightColour: vec3<f32>, ambient: vec3<f32>, diffuse: vec3<f32>, specular: vec3<f32>, shininess: f32) -> vec3<f32> {\r\n  let nDotL = max(dot(normal, lightDir), 0.0);\r\n  let diffuseComponent = lightColour * diffuse * nDotL;\r\n\r\n  let reflectDir = reflect(-lightDir, normal);\r\n  let viewDir = normalize(vec3<f32>(0.0, 0.0, 1.0));\r\n  let spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\r\n  let specularComponent = lightColour * specular * spec;\r\n\r\n  return ambient + diffuseComponent + specularComponent;\r\n}\r\n\r\nfn tracePixel(pixel: vec2<u32>){\r\n   let resolution = textureDimensions(albedoTex);\r\n   var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\r\n   let rayDirection = calculateRayDirection(uv,viewProjections.inverseViewProjection);\r\n    var rayOrigin = cameraPosition;\r\n    var closestIntersection = RayMarchResult();\r\n\r\n    let bvhResult = rayMarchBVH(rayOrigin, rayDirection);\r\n//    if(!bvhResult.hit){\r\n//      textureStore(albedoTex, pixel, vec4(0));\r\n//      textureStore(normalTex, pixel, vec4(0));\r\n//      textureStore(depthWrite, pixel, vec4(0));\r\n//      let worldPos = rayOrigin + skyDomeIntersection(rayOrigin, rayDirection) * rayDirection;\r\n//      let velocity = getVelocityStatic(worldPos, viewProjections);\r\n//      textureStore(velocityTex, pixel, vec4(velocity,0, -1.0));\r\n//      return;\r\n//    }\r\n    closestIntersection = bvhResult;\r\n\r\n    let voxelObject = voxelObjects[closestIntersection.voxelObjectIndex];\r\n//    let albedo = closestIntersection.colour;\r\n\r\n    var albedo = vec3<f32>(0.0);\r\n    if(closestIntersection.hit){\r\n        let paletteX = i32(closestIntersection.colour.r * 255.0);\r\n        let paletteY = i32(voxelObject.paletteIndex);\r\n        albedo = textureLoad(paletteTex, vec2(paletteX, paletteY), 0).rgb;\r\n    }\r\n\r\n    let normal = transformNormal(voxelObject.inverseTransform,vec3<f32>(closestIntersection.normal));\r\n    let worldPos = rayOrigin + rayDirection * closestIntersection.t;\r\n    let velocity = getVelocityStatic(worldPos, viewProjections);\r\n    let cameraDistance = closestIntersection.t;\r\n//    let normalisedDepth = distanceToReversedLinearDepth(cameraDistance, NEAR_PLANE, FAR_PLANE);\r\nlet logDepth = distanceToLogarithmicDepth(cameraDistance, NEAR_PLANE, FAR_PLANE);\r\n\r\n//    textureStore(albedoTex, pixel, vec4(albedo, 1));\r\n    let lightDirection = normalize(vec3<f32>(0.0, 0.5, 0.5));\r\n    let lightColour = vec3<f32>(1.0);\r\n    let ambientColour = vec3<f32>(0.5);\r\n    let diffuseColour = vec3<f32>(0.2);\r\n    let specularColour = vec3<f32>(0.5);\r\n    let shininess = 1.0;\r\n    var shaded = simplePhongShading(normal, lightDirection, lightColour, ambientColour, diffuseColour, specularColour, shininess) * albedo;\r\n    if(all(shaded <= vec3(0.0))){\r\n      shaded = vec3<f32>(uv.y, uv.y * 0.5, 1.0);\r\n    }\r\n    textureStore(albedoTex, pixel, vec4(shaded, 1));\r\n//    if(!bvhResult.hit){\r\n//      var debugColour = vec4(closestIntersection.normal, 1);\r\n//      var debugColour = vec4(f32(closestIntersection.iterations)/ 64.0);\r\n//      textureStore(albedoTex, pixel, debugColour);\r\n//    }\r\n//    textureStore(albedoTex, pixel, vec4(albedo, 1));\r\n    textureStore(normalTex, pixel, vec4(normal,1));\r\n    textureStore(velocityTex, pixel, vec4(velocity,0,f32(closestIntersection.voxelObjectIndex)));\r\n    textureStore(depthWrite, pixel, vec4(logDepth));\r\n}\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn main(\r\n   @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  tracePixel(pixel);\r\n}\r\n\r\n@group(1) @binding(0) var<storage, read> screenRayBuffer : array<vec2<u32>>;\r\n\r\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\r\n  vec2<u32>(0,1),\r\n  vec2<u32>(1,0),\r\n  vec2<u32>(1,1),\r\n  vec2<u32>(2,0),\r\n  vec2<u32>(2,1),\r\n  vec2<u32>(0,2),\r\n  vec2<u32>(1,2),\r\n  vec2<u32>(2,2)\r\n);\r\n\r\n@compute @workgroup_size(64, 1, 1)\r\nfn bufferMarch(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n) {\r\n  let bufferIndex = GlobalInvocationID.x / 8;\r\n  let localRayIndex = GlobalInvocationID.x % 8;\r\n  let pixel = screenRayBuffer[bufferIndex];\r\n  let offsetPixel = pixel + REMAINING_RAY_OFFSETS[localRayIndex];\r\n\r\n  tracePixel(offsetPixel);\r\n//  textureStore(depthWrite, offsetPixel, vec4(0,0,0,0));\r\n//   textureStore(albedoTex, offsetPixel, vec4(1,0,0,1));\r\n}",tt=Symbol(),nt=e=>new Proxy(e,{construct:(e,t,n)=>e.prototype!==n.prototype?Reflect.construct(e,t,n):(e[tt]||(e[tt]=Reflect.construct(e,t,n)),e[tt])});const rt=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,it=(e,t,n=rt)=>{let r=class{#e;#t;#n;#r;#i=t;#s=n;#o=e;constructor(r,i,s){this.#e=r.createTexture({label:e,size:[i,s,1],format:t,usage:n}),this.#t=this.#e.createView({label:e}),this.#n=i,this.#r=s}get texture(){return this.#e}get view(){return this.#t}get width(){return this.#n}get height(){return this.#r}get format(){return this.#i}get usage(){return this.#s}get label(){return this.#o}};return r=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o}([nt],r),r},st=it("albedo","rgba8unorm"),ot=it("normal","rgba16float"),at=it("depth",Ze,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST),ct=it("velocity","rgba16float"),lt=it("world position","rgba32float"),ut=it("output",Xe),ht=async()=>{const e=await(async()=>{const e=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba32float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}}]}),t=await Vi.createComputePipelineAsync({label:"reconstruct world pos",layout:Vi.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:Vi.createShaderModule({code:`\n          ${Ye}\n          ${He}\n          struct ViewProjectionMatrices {\n            viewProjection : mat4x4<f32>,\n            previousViewProjection : mat4x4<f32>,\n            inverseViewProjection : mat4x4<f32>,\n            projection : mat4x4<f32>,\n            inverseProjection: mat4x4<f32>\n          };\n          \n          @group(0) @binding(0) var depthTex : texture_2d<f32>;\n          @group(0) @binding(1) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(2) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(3) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n        \n          const NEAR_PLANE = 0.5;\n          const FAR_PLANE = 10000.0;\n         \n          \n          @compute @workgroup_size(8, 8, 1)\n          fn main(\n            @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\n          ) {\n            let resolution = textureDimensions(worldPosTex);\n            let pixel = GlobalInvocationID.xy;\n            var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\n            let depth = textureLoad(depthTex, pixel, 0).r;\n            let distanceToSurface = logarithmicDepthToDistance(depth, NEAR_PLANE, FAR_PLANE);\n            let rayDirection = calculateRayDirection(uv, viewProjections.inverseViewProjection);\n            var worldPos = cameraPosition + rayDirection * distanceToSurface;\n            \n            if(depth == 0.0) {\n              worldPos = vec3<f32>(0.0, 0.0, 0.0);\n            }\n            \n            //let normal = computeNormalImproved(vec2<i32>(pixel)); \n            //textureStore(normalTex, pixel, vec4(normal, 1));\n            textureStore(worldPosTex, pixel, vec4(worldPos, 1));\n          }\n`}),entryPoint:"main"}});let n;return(r,i)=>{n||(n=(t=>Vi.createBindGroup({layout:e,entries:[{binding:0,resource:t.outputTextures.depthTexture.view},{binding:1,resource:{buffer:t.viewProjectionMatricesBuffer}},{binding:2,resource:t.outputTextures.worldPositionTexture.view},{binding:3,resource:{buffer:t.cameraPositionBuffer}},{binding:4,resource:t.outputTextures.normalTexture.view}]}))(i)),r.setPipeline(t),r.setBindGroup(0,n),r.dispatchWorkgroups(Math.ceil(Gi[0]/8),Math.ceil(Gi[1]/8))}})(),t=await(async()=>{const e={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},t={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",viewDimension:"2d"}},n={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},r={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Ze,viewDimension:"2d"}},i={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},s={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:12,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},a={binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},c=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s,e,t,r,n,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},i,o,a]}),l=await Vi.createComputePipelineAsync({label:"raymarch g-buffer",layout:Vi.createPipelineLayout({bindGroupLayouts:[c]}),compute:{module:Vi.createShaderModule({code:`\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba8unorm, write>;\n          @group(0) @binding(6) var depthWrite : texture_storage_2d<${Ze}, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(11) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(12) var paletteTex : texture_2d<f32>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${Ye}\n          ${Ke}\n          ${Qe}\n          ${Je}\n          ${He}\n          ${et}`}),entryPoint:"main"}});let u;return(e,t)=>{u=(e=>Vi.createBindGroup({layout:c,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.depthTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:12,resource:e.volumeAtlas.paletteTextureView},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),e.setPipeline(l),e.setBindGroup(0,u),e.dispatchWorkgroups(Math.ceil(Gi[0]/16),Math.ceil(Gi[1]/8))}})(),n=(await(async()=>{const e=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Ze,viewDimension:"2d"}},{binding:5,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},{binding:7,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),t=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),n=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),r=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),i=await Vi.createComputePipelineAsync({label:"interpolate g-buffer",layout:Vi.createPipelineLayout({bindGroupLayouts:[e,t,n,r]}),compute:{module:Vi.createShaderModule({code:`${He}${Ye}struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\r\n\r\nstruct VoxelObject {\r\n  transform: mat4x4<f32>,\r\n  inverseTransform: mat4x4<f32>,\r\n  previousTransform: mat4x4<f32>,\r\n  previousInverseTransform: mat4x4<f32>,\r\n  size : vec3<f32>,\r\n  atlasLocation : vec3<f32>,\r\n  paletteIndex : f32,\r\n  octreeBufferIndex: u32\r\n}\r\n\r\n// Textures\r\n@group(0) @binding(0) var albedoTex : texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var albedoCopyTex : texture_2d<f32>;\r\n@group(0) @binding(2) var velocityTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(3) var velocityCopyTex : texture_2d<f32>;\r\n@group(0) @binding(4) var depthTex : texture_storage_2d<r32float, write>;\r\n@group(0) @binding(5) var depthCopyTex : texture_2d<f32>;\r\n@group(0) @binding(6) var normalTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(7) var normalCopyTex : texture_2d<f32>;\r\n\r\n// Camera\r\n@group(1) @binding(0) var<uniform> cameraPosition : vec3<f32>;\r\n@group(1) @binding(1) var<uniform> viewProjections : ViewProjectionMatrices;\r\n\r\n// Voxels\r\n@group(2) @binding(0) var<storage> voxelObjects : array<VoxelObject>;\r\n@group(2) @binding(1) var volumeAtlasTex : texture_3d<f32>;\r\n@group(2) @binding(2) var paletteTex : texture_2d<f32>;\r\n\r\n// Screen Rays\r\nstruct ScreenRay {\r\n  pixel : vec2<u32>,\r\n};\r\n@group(3) @binding(0) var<storage, read_write> indirectArgs : array<atomic<u32>>;\r\n@group(3) @binding(1) var<storage, read_write> screenRays : array<ScreenRay>;\r\n@group(3) @binding(2) var<storage, read_write> counter : array<atomic<u32>>;\r\n\r\nconst neighborOffsets = array<vec2<i32>, 4>(\r\n  vec2<i32>(0, 0),\r\n  vec2<i32>(3, 0),\r\n  vec2<i32>(0, 3),\r\n  vec2<i32>(3, 3)\r\n);\r\n\r\n// Normal is in voxel (object) space, so will only have 1 or -1 values on one axis\r\nfn isOnSharedPlane(\r\n  normal : vec3<f32>,\r\n  voxelPos : vec3<f32>,\r\n  neighborVoxelPos : vec3<f32>,\r\n  neighborNormal : vec3<f32>\r\n) -> bool {\r\n  let epsilon = 0.001;\r\n  if(abs(neighborNormal.y) > 0.0 && abs(normal.y) > 0.0){\r\n    return abs(voxelPos.y - neighborVoxelPos.y) < epsilon;\r\n  }\r\n  if(abs(neighborNormal.x) > 0.0 && abs(normal.x) > 0.0){\r\n    return abs(voxelPos.x - neighborVoxelPos.x) < epsilon;\r\n  }\r\n  if(abs(neighborNormal.z) > 0.0 && abs(normal.z) > 0.0){\r\n    return abs(voxelPos.z - neighborVoxelPos.z) < epsilon;\r\n  }\r\n  return false;\r\n}\r\n\r\nconst NEAR_PLANE = 0.5;\r\nconst FAR_PLANE = 10000.0;\r\n\r\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\r\n  vec2<u32>(0,1),\r\n  vec2<u32>(1,0),\r\n  vec2<u32>(1,1),\r\n  vec2<u32>(2,0),\r\n  vec2<u32>(2,1),\r\n  vec2<u32>(0,2),\r\n  vec2<u32>(1,2),\r\n  vec2<u32>(2,2)\r\n);\r\n\r\n// Increment the count of the ray buffers, and only increment the dispatch indirect args every 8 rays, due to the 64x1x1 workgroup size (8 ray groups, 8 rays per group)\r\nfn incrementCounters() -> u32{\r\n  let count = atomicAdd(&counter[0], 1);\r\n  if(count % 8 == 0){\r\n   atomicAdd(&indirectArgs[0], 1);\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n  * Interpolate the depth, normal and uv of the pixel from the 4 nearest neighbors\r\n  * if not valid for interpolation, add to a ray buffer for use in the next pass\r\n  * Ray buffer is a list of pixel groups that need to be re-marched at full resolution\r\n  * The stored value is the origin of the group ([0,0] in a [3x3] kernel)\r\n  */\r\n@compute @workgroup_size(16, 16, 1)\r\n fn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n) {\r\n  let texSize = textureDimensions(albedoCopyTex);\r\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\r\n  let uv = vec2<f32>(pixel) / vec2<f32>(texSize);\r\n  let nearestFilledPixel = (pixel / 3) * 3;\r\n  let isOriginPixel = all(pixel == nearestFilledPixel);\r\n\r\n  let isCornerPixel = all(pixel == nearestFilledPixel + vec2(2));\r\n  let nearestUV = vec2<f32>(nearestFilledPixel) / vec2<f32>(texSize);\r\n  let velocityRef = textureLoad(velocityCopyTex, nearestFilledPixel, 0);\r\n  let depthRef = textureLoad(depthCopyTex, nearestFilledPixel, 0).r;\r\n  let distanceToSurface = logarithmicDepthToDistance(depthRef, NEAR_PLANE, FAR_PLANE);\r\n\r\n  // disable interpolation for distances greater than 1000, due to precision issues\r\n//  if(distanceToSurface > 9000){\r\n//    if(isOriginPixel){\r\n//      // Add to ray buffer\r\n//      let count = incrementCounters();\r\n//      screenRays[count].pixel = vec2<u32>(pixel);\r\n//    }else{\r\n//      textureStore(albedoTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n//      textureStore(normalTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n//      textureStore(velocityTex, pixel, vec4(velocityRef.xyz, -1.0));\r\n//      textureStore(depthTex, pixel, vec4(0.0));\r\n//    }\r\n//    return;\r\n//  }\r\n\r\n  var hasFoundObject = false;\r\n  // Check if each neightbor is the same object\r\n  for(var i = 1; i < 4; i = i + 1) {\r\n    let objectIndex = textureLoad(velocityCopyTex, nearestFilledPixel + neighborOffsets[i], 0).a;\r\n    if(objectIndex != velocityRef.a) {\r\n       if(isOriginPixel){\r\n         // Add to ray buffer\r\n         let count = incrementCounters();\r\n         screenRays[count].pixel = vec2<u32>(pixel);\r\n       }\r\n       return;\r\n    }\r\n    if(objectIndex != -1.0) {\r\n      hasFoundObject = true;\r\n    }\r\n  }\r\n  if(!hasFoundObject) {\r\n    // Dont march any more rays - we have hit the sky\r\n    textureStore(velocityTex, pixel, vec4(velocityRef.xyz, -1.0));\r\n    textureStore(depthTex, pixel, vec4(0.0));\r\n    textureStore(normalTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n    textureStore(albedoTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n    return;\r\n  }\r\n  let voxelObject = voxelObjects[i32(velocityRef.a)];\r\n\r\n  let normalRef = textureLoad(normalCopyTex, nearestFilledPixel, 0).xyz;\r\n  let localNormal = (voxelObject.inverseTransform * vec4(normalRef, 0.0)).xyz;\r\n  let rayDirection = calculateRayDirection(nearestUV, viewProjections.inverseViewProjection);\r\n  let worldPosRef = cameraPosition + rayDirection * distanceToSurface;\r\n  let localPosRef = (voxelObject.inverseTransform * vec4(worldPosRef, 1.0)).xyz;\r\n  let voxelPosRef = floor(localPosRef);\r\n\r\n  // Check if each neightbor is the same voxel plane\r\n  for(var i = 0; i < 4; i = i + 1) {\r\n    let neighborPixel = nearestFilledPixel + neighborOffsets[i];\r\n    let neighborUV = vec2<f32>(neighborPixel) / vec2<f32>(texSize);\r\n    let neighborDepth = textureLoad(depthCopyTex, neighborPixel, 0).r;\r\n    let neighborNormal = textureLoad(normalCopyTex, neighborPixel, 0).xyz;\r\n    let neighborLocalNormal = (voxelObject.inverseTransform * vec4(neighborNormal, 0.0)).xyz;\r\n    let neighborRayDirection = calculateRayDirection(neighborUV, viewProjections.inverseViewProjection);\r\n    let neighborWorldPos = cameraPosition + neighborRayDirection * logarithmicDepthToDistance(neighborDepth, NEAR_PLANE, FAR_PLANE);\r\n    let neighborLocalPos = (voxelObject.inverseTransform * vec4(neighborWorldPos, 1.0)).xyz;\r\n    let neighborVoxelPos = floor(neighborLocalPos);\r\n\r\n    if(!isOnSharedPlane(localNormal, voxelPosRef, neighborVoxelPos, neighborLocalNormal)) {\r\n      if(isOriginPixel){\r\n        // Add to ray buffer\r\n        let count = incrementCounters();\r\n        screenRays[count].pixel = vec2<u32>(pixel);\r\n      }else{\r\n        textureStore(albedoTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n        textureStore(normalTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n        textureStore(velocityTex, pixel, vec4(velocityRef.xyz, -1.0));\r\n        textureStore(depthTex, pixel, vec4(0.0));\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  let pixel0 = nearestFilledPixel;\r\n  let pixel1 = nearestFilledPixel + vec2<i32>(3, 0);\r\n  let pixel2 = nearestFilledPixel + vec2<i32>(0, 3);\r\n  let pixel3 = nearestFilledPixel + vec2<i32>(3, 3);\r\n\r\n  // Interpolate\r\n  let normal0 = normalRef;\r\n  let normal1 = textureLoad(normalCopyTex, pixel1, 0).xyz;\r\n  let normal2 = textureLoad(normalCopyTex, pixel2, 0).xyz;\r\n  let normal3 = textureLoad(normalCopyTex, pixel3, 0).xyz;\r\n\r\n  let depth0 = depthRef;\r\n  let depth1 = textureLoad(depthCopyTex, pixel1, 0).r;\r\n  let depth2 = textureLoad(depthCopyTex, pixel2, 0).r;\r\n  let depth3 = textureLoad(depthCopyTex, pixel3, 0).r;\r\n\r\n  let xInterp = f32(pixel.x) % 3.0 / 3.0;\r\n  let yInterp = f32(pixel.y) % 3.0 / 3.0;\r\n\r\n  let depthBottom = mix(depth0, depth1, xInterp);\r\n  let depthTop = mix(depth2, depth3, xInterp);\r\n  let depth = mix(depthBottom, depthTop, yInterp);\r\n\r\n  let normalTop = mix(normal0, normal1, xInterp);\r\n  let normalBottom = mix(normal2, normal3, xInterp);\r\n  let normal = mix(normalTop, normalBottom, yInterp);\r\n\r\n  let worldPos =\r\n    cameraPosition\r\n    + calculateRayDirection(uv, viewProjections.inverseViewProjection)\r\n    * logarithmicDepthToDistance(depth, NEAR_PLANE, FAR_PLANE);\r\n\r\n  let localPos = (voxelObject.inverseTransform * vec4(worldPos, 1.0)).xyz;\r\n  let voxelPos = floor(localPos);\r\n  let atlasSamplePos = vec3<i32>(voxelObject.atlasLocation + voxelPos);\r\n  let palettePos = textureLoad(volumeAtlasTex, atlasSamplePos, 0).r;\r\n  let paletteX = i32(palettePos* 255.0);\r\n  let paletteY = i32(voxelObject.paletteIndex);\r\n  let albedo = textureLoad(paletteTex, vec2(paletteX, paletteY), 0).rgb;\r\n\r\n  textureStore(albedoTex, pixel, vec4(albedo, 1.0));\r\n  textureStore(velocityTex, pixel, velocityRef);\r\n  textureStore(depthTex, pixel, vec4(depth));\r\n  textureStore(normalTex, pixel, vec4(normal, 1.0));\r\n\r\n}`}),entryPoint:"main"}});let s,o,a,c;return(l,u,h,d,f,p,m,g,y)=>{s||(s=((t,n,r,i,s)=>Vi.createBindGroup({layout:e,entries:[{binding:0,resource:t.outputTextures.albedoTexture.view},{binding:1,resource:n},{binding:2,resource:t.outputTextures.velocityTexture.view},{binding:3,resource:r},{binding:4,resource:t.outputTextures.depthTexture.view},{binding:5,resource:i},{binding:6,resource:t.outputTextures.normalTexture.view},{binding:7,resource:s}]}))(u,h,d,f,p)),o||(o=(e=>Vi.createBindGroup({layout:t,entries:[{binding:0,resource:{buffer:e.cameraPositionBuffer}},{binding:1,resource:{buffer:e.viewProjectionMatricesBuffer}}]}))(u)),a||(a=(e=>Vi.createBindGroup({layout:n,entries:[{binding:0,resource:{buffer:e.transformationMatrixBuffer}},{binding:1,resource:e.volumeAtlas.atlasTextureView},{binding:2,resource:e.volumeAtlas.paletteTextureView}]}))(u)),c||(c=((e,t,n)=>Vi.createBindGroup({layout:r,entries:[{binding:0,resource:{buffer:e}},{binding:1,resource:{buffer:t}},{binding:2,resource:{buffer:n}}]}))(m,g,y)),l.setPipeline(i),l.setBindGroup(0,s),l.setBindGroup(1,o),l.setBindGroup(2,a),l.setBindGroup(3,c),l.dispatchWorkgroups(Math.ceil(Gi[0]/16),Math.ceil(Gi[1]/8))}})(),await(async()=>{const e={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},t={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",viewDimension:"2d"}},n={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},r={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Ze,viewDimension:"2d"}},i={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},s={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:12,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},a={binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},c=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s,e,t,r,n,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},i,o,a]}),l=Vi.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),u=await Vi.createComputePipelineAsync({label:"raymarch g-buffer indirect",layout:Vi.createPipelineLayout({bindGroupLayouts:[c,l]}),compute:{module:Vi.createShaderModule({code:`\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba8unorm, write>;\n          @group(0) @binding(6) var depthWrite : texture_storage_2d<${Ze}, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(11) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(12) var paletteTex : texture_2d<f32>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${Ye}\n          ${Ke}\n          ${Qe}\n          ${Je}\n          ${He}\n          ${et}`}),entryPoint:"bufferMarch"}});let h,d;return(e,t,n,r)=>{h=(e=>Vi.createBindGroup({layout:c,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.depthTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:12,resource:e.volumeAtlas.paletteTextureView},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),d=(e=>Vi.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:e}}]}))(n),e.setPipeline(u),e.setBindGroup(0,h),e.setBindGroup(1,d),e.dispatchWorkgroupsIndirect(r,0)}})());let r,i,s,o={albedoTexture:null,velocityTexture:null,depthTexture:null,normalTexture:null};return{render:a=>{if(!i){i=Vi.createBuffer({size:12,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),r=Vi.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const e=new Uint32Array(3);e[0]=1,e[1]=1,e[2]=1,Vi.queue.writeBuffer(i,0,e,0,e.length);const{width:t,height:n}=a.outputTextures.finalTexture,o=(c=t/3*(n/3)*4,4,4*Math.ceil(c/4));s=Vi.createBuffer({size:o,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}var c;Object.keys(o).forEach((e=>{const t=a.outputTextures[e];null===o[e]&&(o[e]=((e,t)=>new(it(`${t.label}-copy`,t.format,t.usage))(e,t.width,t.height))(Vi,t))}));const{commandEncoder:l,timestampWrites:u}=a;l.clearBuffer(i,0,4),l.clearBuffer(r,0,4),l.clearBuffer(s);let h=l.beginComputePass({timestampWrites:u});t(h,a),h.end(),Object.keys(o).forEach((e=>{const t=a.outputTextures[e],n=o[e];((e,t,n)=>{if(t.width!==n.width||t.height!==n.height)throw new Error("Source and destination textures must have the same dimensions");e.copyTextureToTexture({texture:t.texture},{texture:n.texture},{width:t.texture.width,height:t.texture.height,depthOrArrayLayers:1})})(l,t,n)})),h=l.beginComputePass({timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+4,endOfPassWriteIndex:u.endOfPassWriteIndex+4}}),n(h,a,s,i),h.end(),h=l.beginComputePass({timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+6,endOfPassWriteIndex:u.endOfPassWriteIndex+6}}),e(h,a),h.end()},label:"primary rays",timestampLabels:["sparse raymarch","interpolate","full raymarch","world pos reconstruct"]}},dt=async e=>{const t=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n//@group(0) @binding(2) var debugTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\nfn get_debug_colour(index : i32) -> vec4<f32> {\r\n  if(index < 0){\r\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\r\n  }\r\n\r\n  let colours = array(\r\n    vec4<f32>(1.0, 0.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(1.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\r\n  );\r\n  return colours[index % 8];\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n    let pixel = fragUV * vec2<f32>(textureDimensions(myTexture));\r\n    var colour = textureLoad(myTexture, vec2<u32>(pixel),0);\r\n    return colour;\r\n//    return colour;\r\n//    return abs(colour) % 8.0 * 0.125;\r\n//    return colour.gggg * 0.5;\r\n//    return (colour.rrrr * 500.0 % 1.0);\r\n//    return get_debug_colour(i32(colour.a));\r\n}\r\n"}),n=e.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vertex_main"},fragment:{module:t,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]}});return{render:t=>{const r=t.commandEncoder.beginRenderPass({timestampWrites:t.timestampWrites,colorAttachments:[{view:qi.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]}),i=e.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:1,resource:t.outputTextures.albedoTexture.view}]});r.setPipeline(n),r.setBindGroup(0,i),r.draw(6),r.end()},label:"fullscreen quad"}};var ft;!function(e){const t=[];e.updateAll=e=>{for(const n of t)n.update(e)},e.register=e=>class extends e{constructor(...e){super(...e),t.push(this)}}}(ft||(ft={}));const pt={duration:.3,delay:0,endDelay:0,repeat:0,easing:"ease"},mt=e=>1e3*e,gt=e=>e/1e3,yt=()=>{},vt=e=>e;function xt(e,t=!0){if(e&&"finished"!==e.playState)try{e.stop?e.stop():(t&&e.commitStyles(),e.cancel())}catch(e){}}const wt=e=>e(),bt=(e,t,n=pt.duration)=>new Proxy({animations:e.map(wt).filter(Boolean),duration:n,options:t},_t),_t={get:(e,t)=>{const n=e.animations[0];switch(t){case"duration":return e.duration;case"currentTime":return gt((null==n?void 0:n[t])||0);case"playbackRate":case"playState":return null==n?void 0:n[t];case"finished":return e.finished||(e.finished=Promise.all(e.animations.map(kt)).catch(yt)),e.finished;case"stop":return()=>{e.animations.forEach((e=>xt(e)))};case"forEachNative":return t=>{e.animations.forEach((n=>t(n,e)))};default:return void 0===(null==n?void 0:n[t])?void 0:()=>e.animations.forEach((e=>e[t]()))}},set:(e,t,n)=>{switch(t){case"currentTime":n=mt(n);case"playbackRate":for(let r=0;r<e.animations.length;r++)e.animations[r][t]=n;return!0}return!1}},kt=e=>e.finished,Tt=e=>"object"==typeof e&&Boolean(e.createAnimation),St=e=>"number"==typeof e,Pt=e=>Array.isArray(e)&&!St(e[0]),Et=(e,t,n)=>-n*e+n*t+e,At=(e,t,n)=>t-e==0?1:(n-e)/(t-e);function Mt(e,t){const n=e[e.length-1];for(let r=1;r<=t;r++){const i=At(0,t,r);e.push(Et(n,1,i))}}const zt=(e,t,n)=>Math.min(Math.max(n,e),t);const It=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e,Ct=1e-7,Bt=12;function Ot(e,t,n,r){if(e===t&&n===r)return vt;return i=>0===i||1===i?i:It(function(e,t,n,r,i){let s,o,a=0;do{o=t+(n-t)/2,s=It(o,r,i)-e,s>0?n=o:t=o}while(Math.abs(s)>Ct&&++a<Bt);return o}(i,0,1,e,n),t,r)}const Rt=e=>"function"==typeof e,Ut=e=>Array.isArray(e)&&St(e[0]),Nt={ease:Ot(.25,.1,.25,1),"ease-in":Ot(.42,0,1,1),"ease-in-out":Ot(.42,0,.58,1),"ease-out":Ot(0,0,.58,1)},jt=/\((.*?)\)/;function Dt(e){if(Rt(e))return e;if(Ut(e))return Ot(...e);if(Nt[e])return Nt[e];if(e.startsWith("steps")){const t=jt.exec(e);if(t){const e=t[1].split(",");return((e,t="end")=>n=>{const r=(n="end"===t?Math.min(n,.999):Math.max(n,.001))*e,i="end"===t?Math.floor(r):Math.ceil(r);return zt(0,1,i/e)})(parseFloat(e[0]),e[1].trim())}}return vt}class qt{constructor(e,t=[0,1],{easing:n,duration:r=pt.duration,delay:i=pt.delay,endDelay:s=pt.endDelay,repeat:o=pt.repeat,offset:a,direction:c="normal",autoplay:l=!0}={}){if(this.startTime=null,this.rate=1,this.t=0,this.cancelTimestamp=null,this.easing=vt,this.duration=0,this.totalDuration=0,this.repeat=0,this.playState="idle",this.finished=new Promise(((e,t)=>{this.resolve=e,this.reject=t})),n=n||pt.easing,Tt(n)){const e=n.createAnimation(t);n=e.easing,t=e.keyframes||t,r=e.duration||r}this.repeat=o,this.easing=Pt(n)?vt:Dt(n),this.updateDuration(r);const u=function(e,t=function(e){const t=[0];return Mt(t,e-1),t}(e.length),n=vt){const r=e.length,i=r-t.length;return i>0&&Mt(t,i),i=>{let s=0;for(;s<r-2&&!(i<t[s+1]);s++);let o=zt(0,1,At(t[s],t[s+1],i));const a=function(e,t){return Pt(e)?e[((e,t,n)=>{const r=t-e;return((n-e)%r+r)%r+e})(0,e.length,t)]:e}(n,s);return o=a(o),Et(e[s],e[s+1],o)}}(t,a,Pt(n)?n.map(Dt):vt);this.tick=t=>{var n;let r=0;r=void 0!==this.pauseTime?this.pauseTime:(t-this.startTime)*this.rate,this.t=r,r/=1e3,r=Math.max(r-i,0),"finished"===this.playState&&void 0===this.pauseTime&&(r=this.totalDuration);const o=r/this.duration;let a=Math.floor(o),l=o%1;!l&&o>=1&&(l=1),1===l&&a--;const h=a%2;("reverse"===c||"alternate"===c&&h||"alternate-reverse"===c&&!h)&&(l=1-l);const d=r>=this.totalDuration?1:Math.min(l,1),f=u(this.easing(d));e(f),void 0===this.pauseTime&&("finished"===this.playState||r>=this.totalDuration+s)?(this.playState="finished",null===(n=this.resolve)||void 0===n||n.call(this,f)):"idle"!==this.playState&&(this.frameRequestId=requestAnimationFrame(this.tick))},l&&this.play()}play(){const e=performance.now();this.playState="running",void 0!==this.pauseTime?this.startTime=e-this.pauseTime:this.startTime||(this.startTime=e),this.cancelTimestamp=this.startTime,this.pauseTime=void 0,this.frameRequestId=requestAnimationFrame(this.tick)}pause(){this.playState="paused",this.pauseTime=this.t}finish(){this.playState="finished",this.tick(0)}stop(){var e;this.playState="idle",void 0!==this.frameRequestId&&cancelAnimationFrame(this.frameRequestId),null===(e=this.reject)||void 0===e||e.call(this,!1)}cancel(){this.stop(),this.tick(this.cancelTimestamp)}reverse(){this.rate*=-1}commitStyles(){}updateDuration(e){this.duration=e,this.totalDuration=e*(this.repeat+1)}get currentTime(){return this.t}set currentTime(e){void 0!==this.pauseTime||0===this.rate?this.pauseTime=e:this.startTime=performance.now()-e/this.rate}get playbackRate(){return this.rate}set playbackRate(e){this.rate=e}}class Ft{setAnimation(e){this.animation=e,null==e||e.finished.then((()=>this.clearAnimation())).catch((()=>{}))}clearAnimation(){this.animation=this.generator=void 0}}const Lt=new WeakMap;function Vt(e){return Lt.has(e)||Lt.set(e,{transforms:[],values:new Map}),Lt.get(e)}const Gt=["","X","Y","Z"],Wt={x:"translateX",y:"translateY",z:"translateZ"},Yt={syntax:"<angle>",initialValue:"0deg",toDefaultUnit:e=>e+"deg"},Ht={translate:{syntax:"<length-percentage>",initialValue:"0px",toDefaultUnit:e=>e+"px"},rotate:Yt,scale:{syntax:"<number>",initialValue:1,toDefaultUnit:vt},skew:Yt},$t=new Map,Xt=e=>`--motion-${e}`,Zt=["x","y","z"];["translate","scale","rotate","skew"].forEach((e=>{Gt.forEach((t=>{Zt.push(e+t),$t.set(Xt(e+t),Ht[e])}))}));const Kt=(e,t)=>Zt.indexOf(e)-Zt.indexOf(t),Qt=new Set(Zt),Jt=e=>Qt.has(e),en=e=>e.sort(Kt).reduce(tn,"").trim(),tn=(e,t)=>`${e} ${t}(var(${Xt(t)}))`,nn=e=>e.startsWith("--"),rn=new Set,sn=(e,t)=>document.createElement("div").animate(e,t),on={cssRegisterProperty:()=>"undefined"!=typeof CSS&&Object.hasOwnProperty.call(CSS,"registerProperty"),waapi:()=>Object.hasOwnProperty.call(Element.prototype,"animate"),partialKeyframes:()=>{try{sn({opacity:[1]})}catch(e){return!1}return!0},finished:()=>Boolean(sn({opacity:[0,1]},{duration:.001}).finished),linearEasing:()=>{try{sn({opacity:0},{easing:"linear(0, 1)"})}catch(e){return!1}return!0}},an={},cn={};for(const e in on)cn[e]=()=>(void 0===an[e]&&(an[e]=on[e]()),an[e]);const ln=(e,t)=>Rt(e)?cn.linearEasing()?`linear(${((e,t)=>{let n="";const r=Math.round(t/.015);for(let t=0;t<r;t++)n+=e(At(0,r-1,t))+", ";return n.substring(0,n.length-2)})(e,t)})`:pt.easing:Ut(e)?un(e):e,un=([e,t,n,r])=>`cubic-bezier(${e}, ${t}, ${n}, ${r})`;function hn(e){return Wt[e]&&(e=Wt[e]),Jt(e)?Xt(e):e}const dn=(e,t)=>{t=hn(t);let n=nn(t)?e.style.getPropertyValue(t):getComputedStyle(e)[t];if(!n&&0!==n){const e=$t.get(t);e&&(n=e.initialValue)}return n},fn=(e,t,n)=>{t=hn(t),nn(t)?e.style.setProperty(t,n):e.style[t]=n},pn=e=>"string"==typeof e;function mn(e,t){var n;let r=(null==t?void 0:t.toDefaultUnit)||vt;const i=e[e.length-1];if(pn(i)){const e=(null===(n=i.match(/(-?[\d.]+)([a-z%]*)/))||void 0===n?void 0:n[2])||"";e&&(r=t=>t+e)}return r}function gn(e,t,n,r={},i){const s=window.__MOTION_DEV_TOOLS_RECORD,o=!1!==r.record&&s;let a,{duration:c=pt.duration,delay:l=pt.delay,endDelay:u=pt.endDelay,repeat:h=pt.repeat,easing:d=pt.easing,persist:f=!1,direction:p,offset:m,allowWebkitAcceleration:g=!1,autoplay:y=!0}=r;const v=Vt(e),x=Jt(t);let w=cn.waapi();x&&((e,t)=>{Wt[t]&&(t=Wt[t]);const{transforms:n}=Vt(e);var r,i;i=t,-1===(r=n).indexOf(i)&&r.push(i),e.style.transform=en(n)})(e,t);const b=hn(t),_=function(e,t){return e.has(t)||e.set(t,new Ft),e.get(t)}(v.values,b),k=$t.get(b);return xt(_.animation,!(Tt(d)&&_.generator)&&!1!==r.record),()=>{const v=()=>{var t,n;return null!==(n=null!==(t=dn(e,b))&&void 0!==t?t:null==k?void 0:k.initialValue)&&void 0!==n?n:0};let T=function(e,t){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=n?e[n-1]:t());return e}((e=>Array.isArray(e)?e:[e])(n),v);const S=mn(T,k);if(Tt(d)){const e=d.createAnimation(T,"opacity"!==t,v,b,_);d=e.easing,T=e.keyframes||T,c=e.duration||c}if(nn(b)&&(cn.cssRegisterProperty()?function(e){if(!rn.has(e)){rn.add(e);try{const{syntax:t,initialValue:n}=$t.has(e)?$t.get(e):{};CSS.registerProperty({name:e,inherits:!1,syntax:t,initialValue:n})}catch(e){}}}(b):w=!1),x&&!cn.linearEasing()&&(Rt(d)||Pt(d)&&d.some(Rt))&&(w=!1),w){k&&(T=T.map((e=>St(e)?k.toDefaultUnit(e):e))),1!==T.length||cn.partialKeyframes()&&!o||T.unshift(v());const t={delay:mt(l),duration:mt(c),endDelay:mt(u),easing:Pt(d)?void 0:ln(d,c),direction:p,iterations:h+1,fill:"both"};a=e.animate({[b]:T,offset:m,easing:Pt(d)?d.map((e=>ln(e,c))):void 0},t),a.finished||(a.finished=new Promise(((e,t)=>{a.onfinish=e,a.oncancel=t})));const n=T[T.length-1];a.finished.then((()=>{f||(fn(e,b,n),a.cancel())})).catch(yt),g||(a.playbackRate=1.000001)}else if(i&&x)T=T.map((e=>"string"==typeof e?parseFloat(e):e)),1===T.length&&T.unshift(parseFloat(v())),a=new i((t=>{fn(e,b,S?S(t):t)}),T,Object.assign(Object.assign({},r),{duration:c,easing:d}));else{const t=T[T.length-1];fn(e,b,k&&St(t)?k.toDefaultUnit(t):t)}return o&&s(e,t,T,{duration:c,delay:l,easing:d,repeat:h,offset:m},"motion-one"),_.setAnimation(a),a&&!y&&a.pause(),a}}const yn=(e,t)=>e[t]?Object.assign(Object.assign({},e),e[t]):Object.assign({},e);function vn(e,t,n){return Rt(e)?e(t,n):e}const xn=(wn=qt,function(e,t,n={}){const r=(e=function(e,t){return"string"==typeof e?e=document.querySelectorAll(e):e instanceof Element&&(e=[e]),Array.from(e||[])}(e)).length;Boolean(r),Boolean(t);const i=[];for(let s=0;s<r;s++){const o=e[s];for(const e in t){const a=yn(n,e);a.delay=vn(a.delay,s,r);const c=gn(o,e,t[e],a,wn);i.push(c)}}return bt(i,n,n.duration)});var wn;function bn(e,t={}){return bt([()=>{const n=new qt(e,[0,1],t);return n.finished.catch((()=>{})),n}],t,t.duration)}function _n(e,t,n){return(Rt(e)?bn:xn)(e,t,n)}function kn(e,t,n){const r=Math.max(t-5,0);return i=n-e(r),(s=t-r)?i*(1e3/s):0;var i,s}function Tn(e){return St(e)&&!isNaN(e)}function Sn(e){return pn(e)?parseFloat(e):e}const Pn=function(e){const t=new WeakMap;return(e={})=>{const n=new Map,r=(t=0,r=100,i=0,s=!1)=>{const o=`${t}-${r}-${i}-${s}`;return n.has(o)||n.set(o,(({from:e=0,velocity:t=0,power:n=.8,decay:r=.325,bounceDamping:i,bounceStiffness:s,changeTarget:o,min:a,max:c,restDistance:l=.5,restSpeed:u})=>{r=mt(r);const h={hasReachedTarget:!1,done:!1,current:e,target:e},d=e=>void 0===a?c:void 0===c||Math.abs(a-e)<Math.abs(c-e)?a:c;let f=n*t;const p=e+f,m=void 0===o?p:o(p);h.target=m,m!==p&&(f=m-e);const g=e=>-f*Math.exp(-e/r),y=e=>m+g(e),v=e=>{const t=g(e),n=y(e);h.done=Math.abs(t)<=l,h.current=h.done?m:n};let x,w;const b=e=>{var t;t=h.current,(void 0!==a&&t<a||void 0!==c&&t>c)&&(x=e,w=(({stiffness:e=100,damping:t=10,mass:n=1,from:r=0,to:i=1,velocity:s=0,restSpeed:o,restDistance:a}={})=>{s=s?gt(s):0;const c={done:!1,hasReachedTarget:!1,current:r,target:i},l=i-r,u=Math.sqrt(e/n)/1e3,h=((e=100,t=10,n=1)=>t/(2*Math.sqrt(e*n)))(e,t,n),d=Math.abs(l)<5;let f;if(o||(o=d?.01:2),a||(a=d?.005:.5),h<1){const e=u*Math.sqrt(1-h*h);f=t=>i-Math.exp(-h*u*t)*((h*u*l-s)/e*Math.sin(e*t)+l*Math.cos(e*t))}else f=e=>i-Math.exp(-u*e)*(l+(u*l-s)*e);return e=>{c.current=f(e);const t=0===e?s:kn(f,e,c.current),n=Math.abs(t)<=o,l=Math.abs(i-c.current)<=a;var u,h,d;return c.done=n&&l,c.hasReachedTarget=(u=r,h=i,d=c.current,u<h&&d>=h||u>h&&d<=h),c}})({from:h.current,to:d(h.current),velocity:kn(y,e,h.current),damping:i,stiffness:s,restDistance:l,restSpeed:u}))};return b(0),e=>{let t=!1;return w||void 0!==x||(t=!0,v(e),b(e)),void 0!==x&&e>x?(h.hasReachedTarget=!0,w(e-x)):(h.hasReachedTarget=!1,!t&&v(e),h)}})(Object.assign({from:t,to:r,velocity:i},e))),n.get(o)},i=(e,n)=>(t.has(e)||t.set(e,function(e,t=vt){let n,r=10,i=e(0);const s=[t(i.current)];for(;!i.done&&r<1e4;)i=e(r),s.push(t(i.done?i.target:i.current)),void 0===n&&i.hasReachedTarget&&(n=r),r+=10;const o=r-10;return 1===s.length&&s.push(i.current),{keyframes:s,duration:o/1e3,overshootDuration:(null!=n?n:o)/1e3}}(e,n)),t.get(e));return{createAnimation:(e,t=!0,n,s,o)=>{let a,c,l,u=0,h=vt;const d=e.length;if(t)if(h=mn(e,s?$t.get(hn(s)):void 0),l=Sn(e[d-1]),d>1&&null!==e[0])c=Sn(e[0]);else{const e=null==o?void 0:o.generator;if(e){const{animation:t,generatorStartTime:n}=o,r=(null==t?void 0:t.startTime)||n||0,i=(null==t?void 0:t.currentTime)||performance.now()-r,s=e(i).current;c=s,u=kn((t=>e(t).current),i,s)}else n&&(c=Sn(n()))}if(Tn(c)&&Tn(l)){const e=r(c,l,u,null==s?void 0:s.includes("scale"));a=Object.assign(Object.assign({},i(e,h)),{easing:"linear"}),o&&(o.generator=e,o.generatorStartTime=performance.now())}return a||(a={easing:"ease",duration:i(r(0,100)).overshootDuration}),a}}}}();var En=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};let An=class{value;target;constructor(e){this.value=e,this.target=e}update(){_n((e=>{this.value=te.lerp(this.value,this.target,e)}),{easing:Pn({velocity:2e-4*Hi})})}};An=En([ft.register],An);let Mn=class{value;target;constructor(e){this.value=e,this.target=e}update(){_n((e=>{this.value=this.value+(this.target-this.value)*e}),{easing:Pn({velocity:2e-4*Hi})})}};Mn=En([ft.register],Mn);let zn=class{value;target;constructor(e){this.value=e,this.target=e}update(){_n((e=>{this.value=Le.slerp(this.value,this.target,e)}),{easing:Pn({velocity:2e-4*Hi})})}};zn=En([ft.register],zn);const In=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength,Cn={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array},bool:{numElements:0,align:1,size:0,type:"bool",View:Uint32Array}},Bn={...Cn,"atomic<i32>":Cn.i32,"atomic<u32>":Cn.u32,"vec2<i32>":Cn.vec2i,"vec2<u32>":Cn.vec2u,"vec2<f32>":Cn.vec2f,"vec2<f16>":Cn.vec2h,"vec3<i32>":Cn.vec3i,"vec3<u32>":Cn.vec3u,"vec3<f32>":Cn.vec3f,"vec3<f16>":Cn.vec3h,"vec4<i32>":Cn.vec4i,"vec4<u32>":Cn.vec4u,"vec4<f32>":Cn.vec4f,"vec4<f16>":Cn.vec4h,"mat2x2<f32>":Cn.mat2x2f,"mat2x2<f16>":Cn.mat2x2h,"mat3x2<f32>":Cn.mat3x2f,"mat3x2<f16>":Cn.mat3x2h,"mat4x2<f32>":Cn.mat4x2f,"mat4x2<f16>":Cn.mat4x2h,"mat2x3<f32>":Cn.mat2x3f,"mat2x3<f16>":Cn.mat2x3h,"mat3x3<f32>":Cn.mat3x3f,"mat3x3<f16>":Cn.mat3x3h,"mat4x3<f32>":Cn.mat4x3f,"mat4x3<f16>":Cn.mat4x3h,"mat2x4<f32>":Cn.mat2x4f,"mat2x4<f16>":Cn.mat2x4h,"mat3x4<f32>":Cn.mat3x4f,"mat3x4<f16>":Cn.mat3x4h,"mat4x4<f32>":Cn.mat4x4f,"mat4x4<f16>":Cn.mat4x4h},On=(Rn=Bn,Object.keys(Rn));var Rn,Un,Nn,jn,Dn,qn;!function(e=[],t){const n=new Set;for(const r of On){const i=Bn[r];n.has(i)||(n.add(i),i.flatten=e.includes(r)?t:!t)}}(),new WeakMap;class Fn{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class Ln{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(Vn.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(Gn.instance)}}}class Vn extends Ln{}Vn.instance=new Vn;class Gn extends Ln{}Gn.instance=new Gn;class Wn extends Ln{constructor(){super()}}class Yn extends Wn{constructor(e,t,n,r){super(),this.name=e,this.args=t,this.returnType=n,this.body=r}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}}class Hn extends Wn{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class $n extends Wn{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Xn extends Wn{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class Zn extends Wn{constructor(e,t,n,r){super(),this.init=e,this.condition=t,this.increment=n,this.body=r}get astNodeType(){return"for"}search(e){var t,n,r;null===(t=this.init)||void 0===t||t.search(e),null===(n=this.condition)||void 0===n||n.search(e),null===(r=this.increment)||void 0===r||r.search(e),this.searchBlock(this.body,e)}}class Kn extends Wn{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class Qn extends Wn{constructor(e,t,n){super(),this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Jn extends Wn{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"let"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class er extends Wn{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}!function(e){e.increment="++",e.decrement="--"}(Un||(Un={})),function(e){e.parse=function(t){const n=t;if("parse"==n)throw new Error("Invalid value for IncrementOperator");return e[n]}}(Un||(Un={}));class tr extends Wn{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(Nn||(Nn={})),function(e){e.parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t}}(Nn||(Nn={}));class nr extends Wn{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.value.search(e)}}class rr extends Wn{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}}class ir extends Wn{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class sr extends Wn{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class or extends Wn{constructor(e,t,n,r){super(),this.condition=e,this.body=t,this.elseif=n,this.else=r}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class ar extends Wn{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class cr extends Wn{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class lr extends Wn{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class ur extends Wn{constructor(){super()}get astNodeType(){return"discard"}}class hr extends Wn{constructor(){super()}get astNodeType(){return"break"}}class dr extends Wn{constructor(){super()}get astNodeType(){return"continue"}}class fr extends Wn{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class pr extends fr{constructor(e,t){super(e),this.members=t}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class mr extends fr{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}}class gr extends fr{constructor(e,t,n,r){super(e),this.storage=t,this.type=n,this.access=r}get astNodeType(){return"pointer"}}class yr extends fr{constructor(e,t,n,r){super(e),this.attributes=t,this.format=n,this.count=r}get astNodeType(){return"array"}get isArray(){return!0}}class vr extends fr{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}}class xr extends Ln{constructor(){super()}}class wr extends xr{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class br extends xr{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}}class _r extends xr{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class kr extends xr{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this)}}class Tr extends xr{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,n;if(this.initializer instanceof br){const r=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),i=null===(n=this.initializer.type)||void 0===n?void 0:n.name,s=e.structs.get(i),o=null==s?void 0:s.getMemberIndex(r);if(-1!=o)return this.initializer.args[o].evaluate(e);console.log(o)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class Sr extends xr{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class Pr extends xr{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class Er extends xr{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}}class Ar extends xr{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class Mr extends xr{constructor(){super()}}class zr extends Mr{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}}class Ir extends Mr{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class Cr extends Ln{constructor(){super()}}class Br extends Cr{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class Or extends Cr{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class Rr extends Ln{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}}class Ur extends Ln{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Nr extends Ln{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}}class jr extends Ln{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(Dn||(Dn={}));class Dr{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class qr{}jn=qr,qr.none=new Dr("",Dn.reserved,""),qr.eof=new Dr("EOF",Dn.token,""),qr.reserved={asm:new Dr("asm",Dn.reserved,"asm"),bf16:new Dr("bf16",Dn.reserved,"bf16"),do:new Dr("do",Dn.reserved,"do"),enum:new Dr("enum",Dn.reserved,"enum"),f16:new Dr("f16",Dn.reserved,"f16"),f64:new Dr("f64",Dn.reserved,"f64"),handle:new Dr("handle",Dn.reserved,"handle"),i8:new Dr("i8",Dn.reserved,"i8"),i16:new Dr("i16",Dn.reserved,"i16"),i64:new Dr("i64",Dn.reserved,"i64"),mat:new Dr("mat",Dn.reserved,"mat"),premerge:new Dr("premerge",Dn.reserved,"premerge"),regardless:new Dr("regardless",Dn.reserved,"regardless"),typedef:new Dr("typedef",Dn.reserved,"typedef"),u8:new Dr("u8",Dn.reserved,"u8"),u16:new Dr("u16",Dn.reserved,"u16"),u64:new Dr("u64",Dn.reserved,"u64"),unless:new Dr("unless",Dn.reserved,"unless"),using:new Dr("using",Dn.reserved,"using"),vec:new Dr("vec",Dn.reserved,"vec"),void:new Dr("void",Dn.reserved,"void")},qr.keywords={array:new Dr("array",Dn.keyword,"array"),atomic:new Dr("atomic",Dn.keyword,"atomic"),bool:new Dr("bool",Dn.keyword,"bool"),f32:new Dr("f32",Dn.keyword,"f32"),i32:new Dr("i32",Dn.keyword,"i32"),mat2x2:new Dr("mat2x2",Dn.keyword,"mat2x2"),mat2x3:new Dr("mat2x3",Dn.keyword,"mat2x3"),mat2x4:new Dr("mat2x4",Dn.keyword,"mat2x4"),mat3x2:new Dr("mat3x2",Dn.keyword,"mat3x2"),mat3x3:new Dr("mat3x3",Dn.keyword,"mat3x3"),mat3x4:new Dr("mat3x4",Dn.keyword,"mat3x4"),mat4x2:new Dr("mat4x2",Dn.keyword,"mat4x2"),mat4x3:new Dr("mat4x3",Dn.keyword,"mat4x3"),mat4x4:new Dr("mat4x4",Dn.keyword,"mat4x4"),ptr:new Dr("ptr",Dn.keyword,"ptr"),sampler:new Dr("sampler",Dn.keyword,"sampler"),sampler_comparison:new Dr("sampler_comparison",Dn.keyword,"sampler_comparison"),struct:new Dr("struct",Dn.keyword,"struct"),texture_1d:new Dr("texture_1d",Dn.keyword,"texture_1d"),texture_2d:new Dr("texture_2d",Dn.keyword,"texture_2d"),texture_2d_array:new Dr("texture_2d_array",Dn.keyword,"texture_2d_array"),texture_3d:new Dr("texture_3d",Dn.keyword,"texture_3d"),texture_cube:new Dr("texture_cube",Dn.keyword,"texture_cube"),texture_cube_array:new Dr("texture_cube_array",Dn.keyword,"texture_cube_array"),texture_multisampled_2d:new Dr("texture_multisampled_2d",Dn.keyword,"texture_multisampled_2d"),texture_storage_1d:new Dr("texture_storage_1d",Dn.keyword,"texture_storage_1d"),texture_storage_2d:new Dr("texture_storage_2d",Dn.keyword,"texture_storage_2d"),texture_storage_2d_array:new Dr("texture_storage_2d_array",Dn.keyword,"texture_storage_2d_array"),texture_storage_3d:new Dr("texture_storage_3d",Dn.keyword,"texture_storage_3d"),texture_depth_2d:new Dr("texture_depth_2d",Dn.keyword,"texture_depth_2d"),texture_depth_2d_array:new Dr("texture_depth_2d_array",Dn.keyword,"texture_depth_2d_array"),texture_depth_cube:new Dr("texture_depth_cube",Dn.keyword,"texture_depth_cube"),texture_depth_cube_array:new Dr("texture_depth_cube_array",Dn.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new Dr("texture_depth_multisampled_2d",Dn.keyword,"texture_depth_multisampled_2d"),texture_external:new Dr("texture_external",Dn.keyword,"texture_external"),u32:new Dr("u32",Dn.keyword,"u32"),vec2:new Dr("vec2",Dn.keyword,"vec2"),vec3:new Dr("vec3",Dn.keyword,"vec3"),vec4:new Dr("vec4",Dn.keyword,"vec4"),bitcast:new Dr("bitcast",Dn.keyword,"bitcast"),block:new Dr("block",Dn.keyword,"block"),break:new Dr("break",Dn.keyword,"break"),case:new Dr("case",Dn.keyword,"case"),continue:new Dr("continue",Dn.keyword,"continue"),continuing:new Dr("continuing",Dn.keyword,"continuing"),default:new Dr("default",Dn.keyword,"default"),discard:new Dr("discard",Dn.keyword,"discard"),else:new Dr("else",Dn.keyword,"else"),enable:new Dr("enable",Dn.keyword,"enable"),fallthrough:new Dr("fallthrough",Dn.keyword,"fallthrough"),false:new Dr("false",Dn.keyword,"false"),fn:new Dr("fn",Dn.keyword,"fn"),for:new Dr("for",Dn.keyword,"for"),function:new Dr("function",Dn.keyword,"function"),if:new Dr("if",Dn.keyword,"if"),let:new Dr("let",Dn.keyword,"let"),const:new Dr("const",Dn.keyword,"const"),loop:new Dr("loop",Dn.keyword,"loop"),while:new Dr("while",Dn.keyword,"while"),private:new Dr("private",Dn.keyword,"private"),read:new Dr("read",Dn.keyword,"read"),read_write:new Dr("read_write",Dn.keyword,"read_write"),return:new Dr("return",Dn.keyword,"return"),storage:new Dr("storage",Dn.keyword,"storage"),switch:new Dr("switch",Dn.keyword,"switch"),true:new Dr("true",Dn.keyword,"true"),alias:new Dr("alias",Dn.keyword,"alias"),type:new Dr("type",Dn.keyword,"type"),uniform:new Dr("uniform",Dn.keyword,"uniform"),var:new Dr("var",Dn.keyword,"var"),override:new Dr("override",Dn.keyword,"override"),workgroup:new Dr("workgroup",Dn.keyword,"workgroup"),write:new Dr("write",Dn.keyword,"write"),r8unorm:new Dr("r8unorm",Dn.keyword,"r8unorm"),r8snorm:new Dr("r8snorm",Dn.keyword,"r8snorm"),r8uint:new Dr("r8uint",Dn.keyword,"r8uint"),r8sint:new Dr("r8sint",Dn.keyword,"r8sint"),r16uint:new Dr("r16uint",Dn.keyword,"r16uint"),r16sint:new Dr("r16sint",Dn.keyword,"r16sint"),r16float:new Dr("r16float",Dn.keyword,"r16float"),rg8unorm:new Dr("rg8unorm",Dn.keyword,"rg8unorm"),rg8snorm:new Dr("rg8snorm",Dn.keyword,"rg8snorm"),rg8uint:new Dr("rg8uint",Dn.keyword,"rg8uint"),rg8sint:new Dr("rg8sint",Dn.keyword,"rg8sint"),r32uint:new Dr("r32uint",Dn.keyword,"r32uint"),r32sint:new Dr("r32sint",Dn.keyword,"r32sint"),r32float:new Dr("r32float",Dn.keyword,"r32float"),rg16uint:new Dr("rg16uint",Dn.keyword,"rg16uint"),rg16sint:new Dr("rg16sint",Dn.keyword,"rg16sint"),rg16float:new Dr("rg16float",Dn.keyword,"rg16float"),rgba8unorm:new Dr("rgba8unorm",Dn.keyword,"rgba8unorm"),rgba8unorm_srgb:new Dr("rgba8unorm_srgb",Dn.keyword,"rgba8unorm_srgb"),rgba8snorm:new Dr("rgba8snorm",Dn.keyword,"rgba8snorm"),rgba8uint:new Dr("rgba8uint",Dn.keyword,"rgba8uint"),rgba8sint:new Dr("rgba8sint",Dn.keyword,"rgba8sint"),bgra8unorm:new Dr("bgra8unorm",Dn.keyword,"bgra8unorm"),bgra8unorm_srgb:new Dr("bgra8unorm_srgb",Dn.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new Dr("rgb10a2unorm",Dn.keyword,"rgb10a2unorm"),rg11b10float:new Dr("rg11b10float",Dn.keyword,"rg11b10float"),rg32uint:new Dr("rg32uint",Dn.keyword,"rg32uint"),rg32sint:new Dr("rg32sint",Dn.keyword,"rg32sint"),rg32float:new Dr("rg32float",Dn.keyword,"rg32float"),rgba16uint:new Dr("rgba16uint",Dn.keyword,"rgba16uint"),rgba16sint:new Dr("rgba16sint",Dn.keyword,"rgba16sint"),rgba16float:new Dr("rgba16float",Dn.keyword,"rgba16float"),rgba32uint:new Dr("rgba32uint",Dn.keyword,"rgba32uint"),rgba32sint:new Dr("rgba32sint",Dn.keyword,"rgba32sint"),rgba32float:new Dr("rgba32float",Dn.keyword,"rgba32float"),static_assert:new Dr("static_assert",Dn.keyword,"static_assert")},qr.tokens={decimal_float_literal:new Dr("decimal_float_literal",Dn.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new Dr("hex_float_literal",Dn.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new Dr("int_literal",Dn.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new Dr("uint_literal",Dn.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new Dr("ident",Dn.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new Dr("and",Dn.token,"&"),and_and:new Dr("and_and",Dn.token,"&&"),arrow:new Dr("arrow ",Dn.token,"->"),attr:new Dr("attr",Dn.token,"@"),attr_left:new Dr("attr_left",Dn.token,"[["),attr_right:new Dr("attr_right",Dn.token,"]]"),forward_slash:new Dr("forward_slash",Dn.token,"/"),bang:new Dr("bang",Dn.token,"!"),bracket_left:new Dr("bracket_left",Dn.token,"["),bracket_right:new Dr("bracket_right",Dn.token,"]"),brace_left:new Dr("brace_left",Dn.token,"{"),brace_right:new Dr("brace_right",Dn.token,"}"),colon:new Dr("colon",Dn.token,":"),comma:new Dr("comma",Dn.token,","),equal:new Dr("equal",Dn.token,"="),equal_equal:new Dr("equal_equal",Dn.token,"=="),not_equal:new Dr("not_equal",Dn.token,"!="),greater_than:new Dr("greater_than",Dn.token,">"),greater_than_equal:new Dr("greater_than_equal",Dn.token,">="),shift_right:new Dr("shift_right",Dn.token,">>"),less_than:new Dr("less_than",Dn.token,"<"),less_than_equal:new Dr("less_than_equal",Dn.token,"<="),shift_left:new Dr("shift_left",Dn.token,"<<"),modulo:new Dr("modulo",Dn.token,"%"),minus:new Dr("minus",Dn.token,"-"),minus_minus:new Dr("minus_minus",Dn.token,"--"),period:new Dr("period",Dn.token,"."),plus:new Dr("plus",Dn.token,"+"),plus_plus:new Dr("plus_plus",Dn.token,"++"),or:new Dr("or",Dn.token,"|"),or_or:new Dr("or_or",Dn.token,"||"),paren_left:new Dr("paren_left",Dn.token,"("),paren_right:new Dr("paren_right",Dn.token,")"),semicolon:new Dr("semicolon",Dn.token,";"),star:new Dr("star",Dn.token,"*"),tilde:new Dr("tilde",Dn.token,"~"),underscore:new Dr("underscore",Dn.token,"_"),xor:new Dr("xor",Dn.token,"^"),plus_equal:new Dr("plus_equal",Dn.token,"+="),minus_equal:new Dr("minus_equal",Dn.token,"-="),times_equal:new Dr("times_equal",Dn.token,"*="),division_equal:new Dr("division_equal",Dn.token,"/="),modulo_equal:new Dr("modulo_equal",Dn.token,"%="),and_equal:new Dr("and_equal",Dn.token,"&="),or_equal:new Dr("or_equal",Dn.token,"|="),xor_equal:new Dr("xor_equal",Dn.token,"^="),shift_right_equal:new Dr("shift_right_equal",Dn.token,">>="),shift_left_equal:new Dr("shift_left_equal",Dn.token,"<<=")},qr.storage_class=[jn.keywords.function,jn.keywords.private,jn.keywords.workgroup,jn.keywords.uniform,jn.keywords.storage],qr.access_mode=[jn.keywords.read,jn.keywords.write,jn.keywords.read_write],qr.sampler_type=[jn.keywords.sampler,jn.keywords.sampler_comparison],qr.sampled_texture_type=[jn.keywords.texture_1d,jn.keywords.texture_2d,jn.keywords.texture_2d_array,jn.keywords.texture_3d,jn.keywords.texture_cube,jn.keywords.texture_cube_array],qr.multisampled_texture_type=[jn.keywords.texture_multisampled_2d],qr.storage_texture_type=[jn.keywords.texture_storage_1d,jn.keywords.texture_storage_2d,jn.keywords.texture_storage_2d_array,jn.keywords.texture_storage_3d],qr.depth_texture_type=[jn.keywords.texture_depth_2d,jn.keywords.texture_depth_2d_array,jn.keywords.texture_depth_cube,jn.keywords.texture_depth_cube_array,jn.keywords.texture_depth_multisampled_2d],qr.texture_external_type=[jn.keywords.texture_external],qr.any_texture_type=[...jn.sampled_texture_type,...jn.multisampled_texture_type,...jn.storage_texture_type,...jn.depth_texture_type,...jn.texture_external_type],qr.texel_format=[jn.keywords.r8unorm,jn.keywords.r8snorm,jn.keywords.r8uint,jn.keywords.r8sint,jn.keywords.r16uint,jn.keywords.r16sint,jn.keywords.r16float,jn.keywords.rg8unorm,jn.keywords.rg8snorm,jn.keywords.rg8uint,jn.keywords.rg8sint,jn.keywords.r32uint,jn.keywords.r32sint,jn.keywords.r32float,jn.keywords.rg16uint,jn.keywords.rg16sint,jn.keywords.rg16float,jn.keywords.rgba8unorm,jn.keywords.rgba8unorm_srgb,jn.keywords.rgba8snorm,jn.keywords.rgba8uint,jn.keywords.rgba8sint,jn.keywords.bgra8unorm,jn.keywords.bgra8unorm_srgb,jn.keywords.rgb10a2unorm,jn.keywords.rg11b10float,jn.keywords.rg32uint,jn.keywords.rg32sint,jn.keywords.rg32float,jn.keywords.rgba16uint,jn.keywords.rgba16sint,jn.keywords.rgba16float,jn.keywords.rgba32uint,jn.keywords.rgba32sint,jn.keywords.rgba32float],qr.const_literal=[jn.tokens.int_literal,jn.tokens.uint_literal,jn.tokens.decimal_float_literal,jn.tokens.hex_float_literal,jn.keywords.true,jn.keywords.false],qr.literal_or_ident=[jn.tokens.ident,jn.tokens.int_literal,jn.tokens.uint_literal,jn.tokens.decimal_float_literal,jn.tokens.hex_float_literal],qr.element_count_expression=[jn.tokens.int_literal,jn.tokens.uint_literal,jn.tokens.ident],qr.template_types=[jn.keywords.vec2,jn.keywords.vec3,jn.keywords.vec4,jn.keywords.mat2x2,jn.keywords.mat2x3,jn.keywords.mat2x4,jn.keywords.mat3x2,jn.keywords.mat3x3,jn.keywords.mat3x4,jn.keywords.mat4x2,jn.keywords.mat4x3,jn.keywords.mat4x4,jn.keywords.atomic,jn.keywords.bitcast,...jn.any_texture_type],qr.attribute_name=[jn.tokens.ident,jn.keywords.block],qr.assignment_operators=[jn.tokens.equal,jn.tokens.plus_equal,jn.tokens.minus_equal,jn.tokens.times_equal,jn.tokens.division_equal,jn.tokens.modulo_equal,jn.tokens.and_equal,jn.tokens.or_equal,jn.tokens.xor_equal,jn.tokens.shift_right_equal,jn.tokens.shift_left_equal],qr.increment_operators=[jn.tokens.plus_plus,jn.tokens.minus_minus];class Fr{constructor(e,t,n){this.type=e,this.lexeme=t,this.line=n}toString(){return this.lexeme}isTemplateType(){return-1!=qr.template_types.indexOf(this.type)}isArrayType(){return this.type==qr.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class Lr{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new Fr(qr.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}let t=qr.none;for(;;){let n=this._findType(e);const r=this._peekAhead();if(">"==e&&(">"==r||"="==r)){let e=!1,t=this._tokens.length-1;for(let n=0;n<5&&t>=0;++n,--t)if(this._tokens[t].type===qr.tokens.less_than){t>0&&this._tokens[t-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(n),!0}if(n===qr.none){let r=e,i=0;const s=2;for(let e=0;e<s;++e)if(r+=this._peekAhead(e),n=this._findType(r),n!==qr.none){i=e;break}if(n===qr.none)return t!==qr.none&&(this._current--,this._addToken(t),!0);e=r,this._current+=i+1}if(t=n,this._isAtEnd())break;e+=this._advance()}return t!==qr.none&&(this._addToken(t),!0)}_findType(e){for(const t in qr.keywords){const n=qr.keywords[t];if(this._match(e,n.rule))return n}for(const t in qr.tokens){const n=qr.tokens[t];if(this._match(e,n.rule))return n}return qr.none}_match(e,t){if("string"==typeof t){if(t==e)return!0}else{const n=t.exec(e);if(n&&0==n.index&&n[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new Fr(e,t,this._line))}}class Vr{constructor(){this._tokens=[],this._current=0,this._context=new Fn}parse(e){this._initialize(e);let t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}return t}_initialize(e){if(e)if("string"==typeof e){const t=new Lr(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return console.error(e,t),{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==qr.eof}_match(e){if(e instanceof Dr)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const n=e[t];if(this._check(n))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){let n=t.type;return-1!=e.indexOf(n)}return t.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(qr.tokens.semicolon)&&!this._isAtEnd(););if(this._match(qr.keywords.alias)){const e=this._type_alias();return this._consume(qr.tokens.semicolon,"Expected ';'"),e}if(this._match(qr.keywords.enable)){const e=this._enable_directive();return this._consume(qr.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(qr.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(qr.tokens.semicolon,"Expected ';'."),t}if(this._check(qr.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(qr.tokens.semicolon,"Expected ';'."),t}if(this._check(qr.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(qr.tokens.semicolon,"Expected ';'."),t}if(this._check(qr.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(qr.tokens.semicolon,"Expected ';'."),t}if(this._check(qr.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(qr.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(qr.keywords.fn))return null;const e=this._consume(qr.tokens.ident,"Expected function name.").toString();this._consume(qr.tokens.paren_left,"Expected '(' for function arguments.");const t=[];if(!this._check(qr.tokens.paren_right))do{if(this._check(qr.tokens.paren_right))break;const e=this._attribute(),n=this._consume(qr.tokens.ident,"Expected argument name.").toString();this._consume(qr.tokens.colon,"Expected ':' for argument type.");const r=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=r,t.push(new Rr(n,i,e)))}while(this._match(qr.tokens.comma));this._consume(qr.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(qr.tokens.arrow)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}const r=this._compound_statement();return new Yn(e,t,n,r)}_compound_statement(){const e=[];for(this._consume(qr.tokens.brace_left,"Expected '{' for block.");!this._check(qr.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(qr.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(qr.tokens.semicolon)&&!this._isAtEnd(););if(this._check(qr.keywords.if))return this._if_statement();if(this._check(qr.keywords.switch))return this._switch_statement();if(this._check(qr.keywords.loop))return this._loop_statement();if(this._check(qr.keywords.for))return this._for_statement();if(this._check(qr.keywords.while))return this._while_statement();if(this._check(qr.keywords.continuing))return this._continuing_statement();if(this._check(qr.keywords.static_assert))return this._static_assert_statement();if(this._check(qr.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(qr.keywords.return)?this._return_statement():this._check([qr.keywords.var,qr.keywords.let,qr.keywords.const])?this._variable_statement():this._match(qr.keywords.discard)?new ur:this._match(qr.keywords.break)?new hr:this._match(qr.keywords.continue)?new dr:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(qr.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(qr.keywords.static_assert))return null;let e=this._optional_paren_expression();return new Hn(e)}_while_statement(){if(!this._match(qr.keywords.while))return null;let e=this._optional_paren_expression();const t=this._compound_statement();return new $n(e,t)}_continuing_statement(){if(!this._match(qr.keywords.continuing))return null;const e=this._compound_statement();return new Xn(e)}_for_statement(){if(!this._match(qr.keywords.for))return null;this._consume(qr.tokens.paren_left,"Expected '('.");const e=this._check(qr.tokens.semicolon)?null:this._for_init();this._consume(qr.tokens.semicolon,"Expected ';'.");const t=this._check(qr.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(qr.tokens.semicolon,"Expected ';'.");const n=this._check(qr.tokens.paren_right)?null:this._for_increment();this._consume(qr.tokens.paren_right,"Expected ')'.");const r=this._compound_statement();return new Zn(e,t,n,r)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(qr.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(qr.tokens.equal)&&(t=this._short_circuit_or_expression()),new Kn(e.name,e.type,e.storage,e.access,t)}if(this._match(qr.keywords.let)){const e=this._consume(qr.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(qr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(qr.tokens.equal,"Expected '=' for let.");const n=this._short_circuit_or_expression();return new Jn(e,t,null,null,n)}if(this._match(qr.keywords.const)){const e=this._consume(qr.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(qr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(qr.tokens.equal,"Expected '=' for const.");const n=this._short_circuit_or_expression();return new er(e,t,null,null,n)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(qr.increment_operators))return this._current=e,null;const n=this._consume(qr.increment_operators,"Expected increment operator");return new tr(n.type===qr.tokens.plus_plus?Un.increment:Un.decrement,t)}_assignment_statement(){let e=null;if(this._check(qr.tokens.brace_right))return null;let t=this._match(qr.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const n=this._consume(qr.assignment_operators,"Expected assignment operator."),r=this._short_circuit_or_expression();return new nr(Nn.parse(n.lexeme),e,r)}_func_call_statement(){if(!this._check(qr.tokens.ident))return null;const e=this._current,t=this._consume(qr.tokens.ident,"Expected function name."),n=this._argument_expression_list();return null===n?(this._current=e,null):new rr(t.lexeme,n)}_loop_statement(){if(!this._match(qr.keywords.loop))return null;this._consume(qr.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let n of t)e.push(n);else e.push(t);t=this._statement()}let n=null;return this._match(qr.keywords.continuing)&&(n=this._compound_statement()),this._consume(qr.tokens.brace_right,"Expected '}' for loop."),new ir(e,n)}_switch_statement(){if(!this._match(qr.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(qr.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(qr.tokens.brace_right,"Expected '}' for switch."),new sr(e,t)}_switch_body(){const e=[];if(this._match(qr.keywords.case)){const t=this._case_selectors();this._match(qr.tokens.colon),this._consume(qr.tokens.brace_left,"Exected '{' for switch case.");const n=this._case_body();this._consume(qr.tokens.brace_right,"Exected '}' for switch case."),e.push(new Br(t,n))}if(this._match(qr.keywords.default)){this._match(qr.tokens.colon),this._consume(qr.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(qr.tokens.brace_right,"Exected '}' for switch default."),e.push(new Or(t))}if(this._check([qr.keywords.default,qr.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){var e,t,n,r;const i=[null!==(t=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==t?t:""];for(;this._match(qr.tokens.comma);)i.push(null!==(r=null===(n=this._shift_expression())||void 0===n?void 0:n.evaluate(this._context).toString())&&void 0!==r?r:"");return i}_case_body(){if(this._match(qr.keywords.fallthrough))return this._consume(qr.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(qr.keywords.if))return null;const e=this._optional_paren_expression(),t=this._compound_statement();let n=[];this._match_elseif()&&(n=this._elseif_statement(n));let r=null;return this._match(qr.keywords.else)&&(r=this._compound_statement()),new or(e,t,n,r)}_match_elseif(){return this._tokens[this._current].type===qr.keywords.else&&this._tokens[this._current+1].type===qr.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(new Ur(t,n)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(qr.keywords.return))return null;const e=this._short_circuit_or_expression();return new ar(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(qr.tokens.or_or);)e=new Ir(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(qr.tokens.and_and);)e=new Ir(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(qr.tokens.or);)e=new Ir(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(qr.tokens.xor);)e=new Ir(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(qr.tokens.and);)e=new Ir(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([qr.tokens.equal_equal,qr.tokens.not_equal])?new Ir(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([qr.tokens.less_than,qr.tokens.greater_than,qr.tokens.less_than_equal,qr.tokens.greater_than_equal]);)e=new Ir(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([qr.tokens.shift_left,qr.tokens.shift_right]);)e=new Ir(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([qr.tokens.plus,qr.tokens.minus]);)e=new Ir(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([qr.tokens.star,qr.tokens.forward_slash,qr.tokens.modulo]);)e=new Ir(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([qr.tokens.minus,qr.tokens.bang,qr.tokens.tilde,qr.tokens.star,qr.tokens.and])?new zr(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(qr.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(qr.tokens.bracket_right,"Expected ']'.");const t=this._postfix_expression();return t&&(e.postfix=t),e}if(this._match(qr.tokens.period)){const e=this._consume(qr.tokens.ident,"Expected member name."),t=this._postfix_expression(),n=new wr(e.lexeme);return t&&(n.postfix=t),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(qr.tokens.ident)){const e=this._previous().toString();if(this._check(qr.tokens.paren_left)){const t=this._argument_expression_list(),n=this._getStruct(e);return null!=n?new br(n,t):new _r(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new Tr(e,t.value)}return new kr(e)}if(this._match(qr.const_literal))return new Sr(parseFloat(this._previous().toString()));if(this._check(qr.tokens.paren_left))return this._paren_expression();if(this._match(qr.keywords.bitcast)){this._consume(qr.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(qr.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new Pr(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new Er(e,t)}_argument_expression_list(){if(!this._match(qr.tokens.paren_left))return null;const e=[];do{if(this._check(qr.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(qr.tokens.comma));return this._consume(qr.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(qr.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(qr.tokens.paren_right),new Ar([e])}_paren_expression(){this._consume(qr.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(qr.tokens.paren_right,"Expected ')'."),new Ar([e])}_struct_decl(){if(!this._match(qr.keywords.struct))return null;const e=this._consume(qr.tokens.ident,"Expected name for struct.").toString();this._consume(qr.tokens.brace_left,"Expected '{' for struct body.");const t=[];for(;!this._check(qr.tokens.brace_right);){const e=this._attribute(),n=this._consume(qr.tokens.ident,"Expected variable name.").toString();this._consume(qr.tokens.colon,"Expected ':' for struct member type.");const r=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=r),this._check(qr.tokens.brace_right)?this._match(qr.tokens.comma):this._consume(qr.tokens.comma,"Expected ',' for struct member."),t.push(new Nr(n,i,e))}this._consume(qr.tokens.brace_right,"Expected '}' after struct body.");const n=new pr(e,t);return this._context.structs.set(e,n),n}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(qr.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(qr.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(qr.keywords.const))return null;const e=this._consume(qr.tokens.ident,"Expected variable name");let t=null;if(this._match(qr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;if(this._match(qr.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof br)n=e;else if(e instanceof Tr&&e.initializer instanceof br)n=e.initializer;else try{const t=e.evaluate(this._context);n=new Sr(t)}catch(t){n=e}}const r=new er(e.toString(),t,"","",n);return this._context.constants.set(r.name,r),r}_global_let_decl(){if(!this._match(qr.keywords.let))return null;const e=this._consume(qr.tokens.ident,"Expected variable name");let t=null;if(this._match(qr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;return this._match(qr.tokens.equal)&&(n=this._const_expression()),new Jn(e.toString(),t,"","",n)}_const_expression(){if(this._match(qr.const_literal))return new wr(this._previous().toString());const e=this._type_decl();this._consume(qr.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(qr.tokens.paren_right)&&(t.push(this._const_expression()),this._check(qr.tokens.comma));)this._advance();return this._consume(qr.tokens.paren_right,"Expected ')'."),new br(e,t)}_variable_decl(){if(!this._match(qr.keywords.var))return null;let e="",t="";this._match(qr.tokens.less_than)&&(e=this._consume(qr.storage_class,"Expected storage_class.").toString(),this._match(qr.tokens.comma)&&(t=this._consume(qr.access_mode,"Expected access_mode.").toString()),this._consume(qr.tokens.greater_than,"Expected '>'."));const n=this._consume(qr.tokens.ident,"Expected variable name");let r=null;if(this._match(qr.tokens.colon)){const e=this._attribute();r=this._type_decl(),null!=r&&(r.attributes=e)}return new Kn(n.toString(),r,e,t,null)}_override_decl(){if(!this._match(qr.keywords.override))return null;const e=this._consume(qr.tokens.ident,"Expected variable name");let t=null;if(this._match(qr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new Qn(e.toString(),t,null)}_enable_directive(){const e=this._consume(qr.tokens.ident,"identity expected.");return new cr(e.toString())}_type_alias(){const e=this._consume(qr.tokens.ident,"identity expected.");this._consume(qr.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=new lr(e.toString(),t);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([qr.tokens.ident,...qr.texel_format,qr.keywords.bool,qr.keywords.f32,qr.keywords.i32,qr.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new fr(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(qr.template_types)){let e=this._advance().toString(),t=null,n=null;return this._match(qr.tokens.less_than)&&(t=this._type_decl(),n=null,this._match(qr.tokens.comma)&&(n=this._consume(qr.access_mode,"Expected access_mode for pointer").toString()),this._consume(qr.tokens.greater_than,"Expected '>' for type.")),new mr(e,t,n)}if(this._match(qr.keywords.ptr)){let e=this._previous().toString();this._consume(qr.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(qr.storage_class,"Expected storage_class for pointer");this._consume(qr.tokens.comma,"Expected ',' for pointer.");const n=this._type_decl();let r=null;return this._match(qr.tokens.comma)&&(r=this._consume(qr.access_mode,"Expected access_mode for pointer").toString()),this._consume(qr.tokens.greater_than,"Expected '>' for pointer."),new gr(e,t.toString(),n,r)}const t=this._attribute();if(this._match(qr.keywords.array)){let e=null,n=-1;const r=this._previous();if(this._match(qr.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";this._match(qr.tokens.comma)&&(t=this._shift_expression().evaluate(this._context).toString()),this._consume(qr.tokens.greater_than,"Expected '>' for array."),n=t?parseInt(t):0}return new yr(r.toString(),t,e,n)}return null}_texture_sampler_types(){if(this._match(qr.sampler_type))return new vr(this._previous().toString(),null,null);if(this._match(qr.depth_texture_type))return new vr(this._previous().toString(),null,null);if(this._match(qr.sampled_texture_type)||this._match(qr.multisampled_texture_type)){const e=this._previous();this._consume(qr.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(qr.tokens.greater_than,"Expected '>' for sampler type."),new vr(e.toString(),t,null)}if(this._match(qr.storage_texture_type)){const e=this._previous();this._consume(qr.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(qr.texel_format,"Invalid texel format.").toString();this._consume(qr.tokens.comma,"Expected ',' after texel format.");const n=this._consume(qr.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(qr.tokens.greater_than,"Expected '>' for sampler type."),new vr(e.toString(),t,n)}return null}_attribute(){let e=[];for(;this._match(qr.tokens.attr);){const t=this._consume(qr.attribute_name,"Expected attribute name"),n=new jr(t.toString(),null);if(this._match(qr.tokens.paren_left)){if(n.value=this._consume(qr.literal_or_ident,"Expected attribute value").toString(),this._check(qr.tokens.comma)){this._advance();do{const e=this._consume(qr.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(e)}while(this._match(qr.tokens.comma))}this._consume(qr.tokens.paren_right,"Expected ')'")}e.push(n)}for(;this._match(qr.tokens.attr_left);){if(!this._check(qr.tokens.attr_right))do{const t=this._consume(qr.attribute_name,"Expected attribute name"),n=new jr(t.toString(),null);if(this._match(qr.tokens.paren_left)){if(n.value=[this._consume(qr.literal_or_ident,"Expected attribute value").toString()],this._check(qr.tokens.comma)){this._advance();do{const e=this._consume(qr.literal_or_ident,"Expected attribute value").toString();n.value.push(e)}while(this._match(qr.tokens.comma))}this._consume(qr.tokens.paren_right,"Expected ')'")}e.push(n)}while(this._match(qr.tokens.comma));this._consume(qr.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class Gr{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class Wr{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class Yr extends Gr{constructor(e,t){super(e,t),this.members=[],this.align=0}get isStruct(){return!0}}class Hr extends Gr{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class $r extends Gr{constructor(e,t,n,r){super(e,n),this.format=t,this.access=r}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(qn||(qn={}));class Xr{constructor(e,t,n,r,i,s,o){this.name=e,this.type=t,this.group=n,this.binding=r,this.attributes=i,this.resourceType=s,this.access=o}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class Zr{constructor(e,t){this.name=e,this.type=t}}class Kr{constructor(e,t){this.align=e,this.size=t}}class Qr{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r,this.interpolation=null}}class Jr{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r}}class ei{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.name=e,this.stage=t}}class ti{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class ni{constructor(e,t,n,r){this.name=e,this.type=t,this.attributes=n,this.id=r}}class ri{constructor(e){this.resources=null,this.node=e}}class ii{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new ti,this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new Vr).parse(e);for(const e of t)e instanceof Yn&&this._functions.set(e.name,new ri(e));for(const e of t)if(e instanceof pr){const t=this._getTypeInfo(e,null);t instanceof Yr&&this.structs.push(t)}else if(e instanceof lr)this.aliases.push(this._getAliasInfo(e));else if(e instanceof Qn){const t=e,n=this._getAttributeNum(t.attributes,"id",0),r=null!=t.type?this._getTypeInfo(t.type,t.attributes):null;this.overrides.push(new ni(t.name,r,t.attributes,n))}else if(this._isUniformVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new Xr(t.name,i,n,r,t.attributes,qn.Uniform,t.access);this.uniforms.push(s)}else if(this._isStorageVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new Xr(t.name,i,n,r,t.attributes,s?qn.StorageTexture:qn.Storage,t.access);this.storage.push(o)}else if(this._isTextureVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new Xr(t.name,i,n,r,t.attributes,s?qn.StorageTexture:qn.Texture,t.access);s?this.storage.push(o):this.textures.push(o)}else if(this._isSamplerVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new Xr(t.name,i,n,r,t.attributes,qn.Sampler,t.access);this.samplers.push(s)}else if(e instanceof Yn){const t=this._getAttribute(e,"vertex"),n=this._getAttribute(e,"fragment"),r=this._getAttribute(e,"compute"),i=t||n||r;if(i){const t=new ei(e.name,null==i?void 0:i.name);t.inputs=this._getInputs(e.args),t.outputs=this._getOutputs(e.returnType),t.resources=this._findResources(e),this.entry[i.name].push(t)}}}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_findResources(e){const t=[],n=this,r=[];return e.search((e=>{if(e instanceof Vn)r.push({});else if(e instanceof Gn)r.pop();else if(e instanceof Kn){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof Jn){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof kr){const i=e;if(r.length>0&&r[r.length-1][i.name])return;const s=n._findResource(i.name);s&&t.push(s)}else if(e instanceof _r){const r=e,i=n._functions.get(r.name);i&&(null===i.resources&&(i.resources=n._findResources(i.node)),t.push(...i.resources))}})),[...new Map(t.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,n){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),n>=e[t].length&&(e[t].length=n+1)}for(const n of this.uniforms)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.storage)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.textures)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.samplers)t(n.group,n.binding),e[n.group][n.binding]=n;return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof pr)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);null!==n&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof pr)this._getStructOutputs(n.type,t);else{const e=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(null!==e){const r=this._getTypeInfo(n.type,n.type.attributes),i=this._parseInt(e.value),s=new Jr(n.name,r,e.name,i);t.push(s)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getTypeInfo(e,e.attributes),r=this._parseInt(t.value);return new Jr("",n,t.name,r)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const n of e)if(n.type instanceof pr)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof pr)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getAttribute(e,"interpolation"),r=this._getTypeInfo(e.type,e.attributes),i=this._parseInt(t.value),s=new Qr(e.name,r,t.name,i);return null!==n&&(s.interpolation=this._parseString(n.value)),s}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new Zr(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof yr){const n=e,r=this._getTypeInfo(n.format,n.attributes),i=new Hr(n.name,t);return i.format=r,i.count=n.count,this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof pr){const n=e,r=new Yr(n.name,t);for(const e of n.members){const t=this._getTypeInfo(e.type,e.attributes);r.members.push(new Wr(e.name,t,e.attributes))}return this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof vr){const n=e,r=n.format instanceof fr,i=n.format?r?this._getTypeInfo(n.format,null):new Gr(n.format,null):null,s=new $r(n.name,i,t,n.access);return this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof mr){const n=e,r=n.format?this._getTypeInfo(n.format,null):null,i=new $r(n.name,r,t,n.access);return this._types.set(e,i),this._updateTypeInfo(i),i}const n=new Gr(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n;const r=this._getTypeSize(e);if(e.size=null!==(t=null==r?void 0:r.size)&&void 0!==t?t:0,e instanceof Hr){const t=this._getTypeSize(e.format);e.stride=null!==(n=null==t?void 0:t.size)&&void 0!==n?n:0,this._updateTypeInfo(e.format)}e instanceof Yr&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,r=0,i=0,s=0;for(let o=0,a=e.members.length;o<a;++o){const a=e.members[o],c=this._getTypeSize(a);if(!c)continue;null!==(t=this._getAlias(a.type.name))&&void 0!==t||a.type;const l=c.align,u=c.size;n=this._roundUp(l,n+r),r=u,i=n,s=Math.max(s,l),a.offset=n,a.size=u,this._updateTypeInfo(a.type)}e.size=this._roundUp(s,i+r),e.align=s}_getTypeSize(e){var t;if(null==e)return null;const n=this._getAttributeNum(e.attributes,"size",0),r=this._getAttributeNum(e.attributes,"align",0);if(e instanceof Wr&&(e=e.type),e instanceof Gr){const t=this._getAlias(e.name);null!==t&&(e=t)}{const t=ii._typeInfo[e.name];if(void 0!==t){const i="f16"===e.format?2:1;return new Kr(Math.max(r,t.align/i),Math.max(n,t.size/i))}}{const t=ii._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const i="h"===e.name[e.name.length-1]?2:1;return new Kr(Math.max(r,t.align/i),Math.max(n,t.size/i))}}if(e instanceof Hr){let i=e,s=8,o=8;const a=this._getTypeSize(i.format);return null!==a&&(o=a.size,s=a.align),o=i.count*this._getAttributeNum(null!==(t=null==e?void 0:e.attributes)&&void 0!==t?t:null,"stride",this._roundUp(s,o)),n&&(o=n),new Kr(Math.max(r,s),Math.max(n,o))}if(e instanceof Yr){let t=0,i=0,s=0,o=0,a=0;for(const n of e.members){const e=this._getTypeSize(n.type);null!==e&&(t=Math.max(e.align,t),s=this._roundUp(e.align,s+o),o=e.size,a=s)}return i=this._roundUp(t,a+o),new Kr(Math.max(r,t),Math.max(n,i))}return null}_isUniformVar(e){return e instanceof Kn&&"uniform"==e.storage}_isStorageVar(e){return e instanceof Kn&&"storage"==e.storage}_isTextureVar(e){return e instanceof Kn&&null!==e.type&&-1!=ii._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof Kn&&null!==e.type&&-1!=ii._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const r=n.attributes;for(let e of r)if(e.name==t)return e;return null}_getAttributeNum(e,t,n){if(null===e)return n;for(let r of e)if(r.name==t){let e=null!==r&&null!==r.value?r.value:n;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}function si(e,t){const n=function(e){return Array.isArray(e)||In(e)?[...e,1,1].slice(0,3):function(e){return[e.width,e.height||1,e.depthOrArrayLayers||1]}(e)}(e),r=Math.max(...n.slice(0,"3d"===t?3:2));return 1+Math.log2(r)|0}ii._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},ii._textureTypes=qr.any_texture_type.map((e=>e.name)),ii._samplerTypes=qr.sampler_type.map((e=>e.name));const oi=new WeakMap;const ai=new Map([[Int8Array,{formats:["sint8","snorm8"],defaultForType:1}],[Uint8Array,{formats:["uint8","unorm8"],defaultForType:1}],[Int16Array,{formats:["sint16","snorm16"],defaultForType:1}],[Uint16Array,{formats:["uint16","unorm16"],defaultForType:1}],[Int32Array,{formats:["sint32","snorm32"],defaultForType:0}],[Uint32Array,{formats:["uint32","unorm32"],defaultForType:0}],[Float32Array,{formats:["float32","float32"],defaultForType:0}]]);function ci(e){return In(e)||Array.isArray(e)||function(e){const t=e;return In(t.data)||Array.isArray(t.data)}(e)}function li(e){switch(e){case"1d":return"1d";case"3d":return"3d";default:return"2d"}}new Map([...ai.entries()].map((([e,{formats:[t,n]}])=>[[t,e],[n,e]])).flat());const ui={"8snorm":Int8Array,"8unorm":Uint8Array,"8sint":Int8Array,"8uint":Uint8Array,"16snorm":Int16Array,"16unorm":Uint16Array,"16sint":Int16Array,"16uint":Uint16Array,"32snorm":Int32Array,"32unorm":Uint32Array,"32sint":Int32Array,"32uint":Uint32Array,"16float":Uint16Array,"32float":Float32Array},hi=/([a-z]+)(\d+)([a-z]+)/;function di(e){const[,t,n,r]=hi.exec(e),i=t.length,s=parseInt(n)/8;return{channels:t,numChannels:i,bytesPerChannel:s,bytesPerElement:i*s,Type:ui[`${n}${r}`]}}function fi(e,t,n,r={}){n.forEach(((n,i)=>{const s=[0,0,i+(r.baseArrayLayer||0)];if(ci(n))!function(e,t,n,r){const i=function(e,t){if(In(e))return e;const{Type:n}=di(t);return new n(e)}(n.data||n,t.format),s=function(e,t){return[e.width,e.height,e.depthOrArrayLayers].map((e=>Math.max(1,Math.floor(e/1))))}(t),{bytesPerElement:o}=di(t.format),a=r.origin||[0,0,0];e.queue.writeTexture({texture:t,origin:a},i,{bytesPerRow:o*s[0],rowsPerImage:s[1]},s)}(e,t,n,{origin:s});else{const i=n,{flipY:o,premultipliedAlpha:a,colorSpace:c}=r;e.queue.copyExternalImageToTexture({source:i,flipY:o},{texture:t,premultipliedAlpha:a,colorSpace:c,origin:s},pi(i,r))}})),t.mipLevelCount>1&&function(e,t,n){let r=oi.get(e);r||(r={pipelineByFormatAndView:{},moduleByViewType:{}},oi.set(e,r));let{sampler:i,uniformBuffer:s,uniformValues:o}=r;const{pipelineByFormatAndView:a,moduleByViewType:c}=r;n=n||function(e){switch(e.dimension){case"1d":return"1d";case"3d":return"3d";default:return e.depthOrArrayLayers>1?"2d-array":"2d"}}(t);let l=c[n];if(!l){const t=function(e){let t,n;switch(e){case"2d":t="texture_2d<f32>",n="textureSample(ourTexture, ourSampler, fsInput.texcoord)";break;case"2d-array":t="texture_2d_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              fsInput.texcoord,\n              uni.layer)";break;case"cube":t="texture_cube<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1))";break;case"cube-array":t="texture_cube_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1), uni.layer)";break;default:throw new Error(`unsupported view: ${e}`)}return`\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n          var pos = array<vec2f, 3>(\n            vec2f(-1.0, -1.0),\n            vec2f(-1.0,  3.0),\n            vec2f( 3.0, -1.0),\n          );\n\n          var vsOutput: VSOutput;\n          let xy = pos[vertexIndex];\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n          return vsOutput;\n        }\n\n        struct Uniforms {\n          layer: u32,\n        };\n\n        @group(0) @binding(0) var ourSampler: sampler;\n        @group(0) @binding(1) var ourTexture: ${t};\n        @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni.layer; // make sure this is used so all pipelines have the same bindings\n          return ${n};\n        }\n      `}(n);l=e.createShaderModule({label:`mip level generation for ${n}`,code:t}),c[n]=l}i||(i=e.createSampler({minFilter:"linear",magFilter:"linear"}),s=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=new Uint32Array(1),Object.assign(r,{sampler:i,uniformBuffer:s,uniformValues:o}));const u=`${t.format}.${n}`;a[u]||(a[u]=e.createRenderPipeline({label:`mip level generator pipeline for ${n}`,layout:"auto",vertex:{module:l,entryPoint:"vs"},fragment:{module:l,entryPoint:"fs",targets:[{format:t.format}]}}));const h=a[u];for(let r=1;r<t.mipLevelCount;++r)for(let a=0;a<t.depthOrArrayLayers;++a){o[0]=a,e.queue.writeBuffer(s,0,o);const c=e.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:i},{binding:1,resource:t.createView({dimension:n,baseMipLevel:r-1,mipLevelCount:1})},{binding:2,resource:{buffer:s}}]}),l={label:"mip gen renderPass",colorAttachments:[{view:t.createView({dimension:"2d",baseMipLevel:r,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},u=e.createCommandEncoder({label:"mip gen encoder"}),d=u.beginRenderPass(l);d.setPipeline(h),d.setBindGroup(0,c),d.draw(3),d.end();const f=u.finish();e.queue.submit([f])}}(e,t)}function pi(e,t){if(e instanceof HTMLVideoElement)return[e.videoWidth,e.videoHeight,1];{const n=e,{width:r,height:i}=n;if(r>0&&i>0&&!ci(e))return[r,i,1];const s=t.format||"rgba8unorm",{bytesPerElement:o,bytesPerChannel:a}=di(s),c=In(e)||Array.isArray(e)?e:e.data;return function(e,t,n,r="2d"){if(n%1!=0)throw new Error("can't guess dimensions");if(e||t){if(t){if(!e&&(e=n/t)%1)throw new Error("can't guess dimensions")}else if((t=n/e)%1)throw new Error("can't guess dimensions")}else{const i=Math.sqrt(n/("cube"===r?6:1));i%1==0?(e=i,t=i):(e=n,t=1)}const i=n/e/t;if(i%1)throw new Error("can't guess dimensions");return[e,t,i]}(r,i,(In(c)?c.byteLength:c.length*a)/o)}}async function mi(e,t,n={}){const r=await Promise.all(t.map((e=>async function(e,t={}){const n=await fetch(e),r=await n.blob(),i={...t,...void 0!==t.colorSpaceConversion&&{colorSpaceConversion:"none"}};return await createImageBitmap(r,i)}(e))));return function(e,t,n={}){const r=pi(t[0],n);r[2]=r[2]>1?r[2]:t.length;const i=e.createTexture({dimension:li(n.dimension),format:n.format||"rgba8unorm",mipLevelCount:n.mipLevelCount?n.mipLevelCount:n.mips?si(r):1,size:r,usage:(n.usage??0)|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return fi(e,i,t,n),i}(e,r,n)}const gi=e=>{let t=te.create(1/0,1/0,1/0),n=te.create(-1/0,-1/0,-1/0);for(const{AABB:r}of e)t=te.min(r.min,t),n=te.max(r.max,n);return{min:t,max:n}},yi=e=>{const t=gi(e),n=(t.max[0]-t.min[0])*(t.max[1]-t.min[1])*(t.max[2]-t.min[2]);return e.length*n},vi=(44,16,16*Math.ceil(2.75));class xi{#a;#c;#l;#u;#h;constructor(e,t){this.#a=e,this.#l=t.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#c=[],this.#d(this.#l,0),this.#f()}get gpuBuffer(){const e=this.#a.createBuffer({size:this.#h.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),t=this.#a.createCommandEncoder();return t.copyBufferToBuffer(this.#h,0,e,0,this.#h.size),this.#a.queue.submit([t.finish()]),e.mapAsync(GPUMapMode.READ).then((()=>{new Float32Array(e.getMappedRange())})),this.#h}update(e){this.#l=e.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#c=[],this.#d(this.#l,0),this.#f()}#d(e,t){if(0===this.#l.length)return;if(1===e.length)return void(this.#c[t]={leftChildIndex:this.#l.indexOf(e[0]),rightChildIndex:-1,objectCount:1,AABBMax:e[0].AABB.max,AABBMin:e[0].AABB.min});const n=gi(e);let r=-1,i=-1;const{left:s,right:o}=(e=>{let t=1/0,n=-1;const r=Math.floor(e.length/2);for(let i=1;i<e.length;i++){const s=e.slice(0,i),o=e.slice(i),a=yi(s)+yi(o),c=1e3*Math.abs(i-r)+1*a;c<t&&(t=c,n=i)}return{left:e.slice(0,n),right:e.slice(n)}})(e);s.length>0&&(r=++this.#u,this.#d(s,r)),o.length>0&&(i=++this.#u,this.#d(o,i)),this.#c[t]={leftChildIndex:r,rightChildIndex:i,objectCount:e.length,AABBMax:n.max,AABBMin:n.min}}#f(){return this.#h=this.#a.createBuffer({size:Math.max(this.#c.length,1)*vi,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1,label:"bvh buffer"}),this.#c.forEach(((e,t)=>{const n=t*vi,r=new ArrayBuffer(vi),i=new DataView(r);i.setInt32(0,e.leftChildIndex,!0),i.setInt32(4,e.rightChildIndex,!0),i.setUint32(8,e.objectCount,!0),i.setFloat32(16,e.AABBMin[0],!0),i.setFloat32(20,e.AABBMin[1],!0),i.setFloat32(24,e.AABBMin[2],!0),i.setFloat32(32,e.AABBMax[0],!0),i.setFloat32(36,e.AABBMax[1],!0),i.setFloat32(40,e.AABBMax[2],!0),this.#a.queue.writeBuffer(this.#h,n,r,0,vi)})),this.#h}}const wi="clear",bi=async()=>{const e=Vi.createShaderModule({code:"\n    struct VertexOutput {\n      @builtin(position) position : vec4f,\n    }\n    @vertex\n    fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n      var output : VertexOutput;\n      return output;\n    }\n    @fragment\n    fn fragment_main(@builtin(position) position : vec4f) -> @location(0) vec4<f32> {\n        return vec4(0.0);\n    }"}),t=Vi.createRenderPipeline({label:wi,layout:"auto",vertex:{module:e,entryPoint:"vertex_main"},fragment:{module:e,entryPoint:"fragment_main",targets:[{format:Xe}]}});return{render:e=>{const n=e.commandEncoder.beginRenderPass({label:wi,timestampWrites:e.timestampWrites,colorAttachments:[{view:e.outputTextures.finalTexture.view,loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});n.setPipeline(t),n.draw(6),n.end()},label:wi}};function _i(e,t){let n=0,r=1/t,i=e;for(;i>0;)n+=r*(i%t),i=Math.floor(i/t),r/=t;return n}let ki,Ti=!1;class Si extends e{position;rotation;scale;#p;constructor(e,t,n){super(),this.position=e,this.rotation=t,this.scale=n,this.#p=ye.identity()}get transform(){let e=ye.identity();return ye.translate(e,this.position,e),ye.multiply(e,ye.fromQuat(this.rotation),e),ye.scale(e,this.scale,e),e}get previousTransform(){return this.#p}set previousTransform(e){this.#p=e}get direction(){return te.transformQuat(te.create(0,0,1),this.rotation)}get right(){return te.transformQuat(te.create(1,0,0),this.rotation)}get left(){return te.transformQuat(te.create(-1,0,0),this.rotation)}get up(){return te.transformQuat(te.create(0,1,0),this.rotation)}get down(){return te.transformQuat(te.create(0,-1,0),this.rotation)}}class Pi extends e{size;atlasLocation;paletteIndex;octreeBufferIndex;name;constructor({size:e,atlasLocation:t,paletteIndex:n,octreeBufferIndex:r,name:i}){super(),this.size=e,this.atlasLocation=t,this.paletteIndex=n,this.octreeBufferIndex=r,this.name=i}}const Ei=(e,t)=>{const n=te.create(e.size[0]/2,e.size[1]/2,e.size[2]/2);return(e=>{let t=te.create(1/0,1/0,1/0),n=te.create(-1/0,-1/0,-1/0);for(const r of e)t=te.min(t,r),n=te.max(n,r);return{min:t,max:n}})([te.create(-n[0],-n[1],-n[2]),te.create(-n[0],-n[1],n[2]),te.create(-n[0],n[1],-n[2]),te.create(-n[0],n[1],n[2]),te.create(n[0],-n[1],-n[2]),te.create(n[0],-n[1],n[2]),te.create(n[0],n[1],-n[2]),te.create(n[0],n[1],n[2])].map((e=>te.transformMat4(e,t.transform))))},Ai={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},Mi={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},zi={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Xe}},Ii={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Ci={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},Bi={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Oi={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},Ri={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Ui={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},Ni=(GPUShaderStage.COMPUTE,[Ai,Mi,zi,Ii,Ci,Bi,Oi,Ri,Ui,{binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},{binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}}]),ji=async()=>(async({shaderCode:e,entryPoint:t,label:n})=>{const r=Vi.createBindGroupLayout({entries:Ni}),i=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${Xe}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\n// Constants\r\nconst infinity : f32 = 99999999.0;\r\n\r\n// Utility functions\r\nfn degreesToRadians(degrees : f32) -> f32 {\r\n    return degrees * (3.1415926535897932385 / 180.0);\r\n}\r\n\r\nfn unitVector(v : vec3<f32>) -> vec3<f32> {\r\n    return v / length(v);\r\n}\r\n\r\nfn lengthSquared(v : vec3<f32>) -> f32 {\r\n    return v.x * v.x + v.y * v.y + v.z * v.z;\r\n}\r\n\r\nfn random(co : vec2<f32>) -> f32 {\r\n    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nfn randomMinMax(co : vec2<f32>, min : f32, max : f32) -> f32 {\r\n    return min + (max - min) * random(co);\r\n}\r\n\r\nfn randomFloat3(co : vec2<f32>) -> vec3<f32> {\r\n    return vec3<f32>(random(co), random(co * 2.0), random(co * 3.0));\r\n}\r\n\r\nfn randomFloat3MinMax(co : vec2<f32>, min : f32, max : f32) -> vec3<f32> {\r\n    return vec3<f32>(randomMinMax(co, min, max), randomMinMax(co * 2.0, min, max), randomMinMax(co * 3.0, min, max));\r\n}\r\n\r\nfn randomInUnitSphere(co : vec2<f32>) -> vec3<f32> {\r\n    var p : vec3<f32> = randomFloat3MinMax(co, -1.0, 1.0);\r\n    while (lengthSquared(p) < 1.0) {\r\n        p = randomFloat3MinMax(co, -1.0, 1.0);\r\n    }\r\n    return p;\r\n}\r\n\r\nfn randomInUnitDisk(seed : vec2<f32>) -> vec2<f32> {\r\n    let r = sqrt(random(seed));\r\n    let theta = 2.0 * 3.14159265359 * random(vec2<f32>(seed.y, seed.x));\r\n    return vec2<f32>(cos(theta), sin(theta)) * r;\r\n}\r\n\r\nfn randomInPlanarUnitDisk(seed : vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let disk = randomInUnitDisk(seed);\r\n    var diskNormal = cross(normal, vec3<f32>(0.0, 1.0, 0.0));\r\n    if (length(diskNormal) < 0.01) {\r\n        diskNormal = cross(normal, vec3<f32>(1.0, 0.0, 0.0));\r\n    }\r\n    diskNormal = normalize(diskNormal);\r\n    let diskTangent = cross(diskNormal, normal);\r\n    return disk.x * diskTangent + disk.y * diskNormal;\r\n}\r\n\r\nfn reflect(v : vec3<f32>, n : vec3<f32>) -> vec3<f32> {\r\n    return v - 2.0 * dot(v, n) * n;\r\n}\r\n\r\nfn randomUnitVector(co : vec2<f32>) -> vec3<f32> {\r\n    return unitVector(randomInUnitSphere(co));\r\n}\r\n\r\nfn nearZero(e : vec3<f32>) -> bool {\r\n    const s : f32 = 1e-8;\r\n    return (abs(e.x) < s) && (abs(e.y) < s) && (abs(e.z) < s);\r\n}\r\n\r\nfn randomInHemisphere(co : vec2<f32>, normal : vec3<f32>) -> vec3<f32> {\r\n    let inUnitSphere = randomUnitVector(co);\r\n    if (dot(inUnitSphere, normal) > 0.0) {\r\n        return inUnitSphere;\r\n    }\r\n    return -inUnitSphere;\r\n}\r\n\r\nfn randomAlongVector(co : vec2<f32>, direction : vec3<f32>) -> vec3<f32> {\r\n    return normalize(direction) * random(co);\r\n}\r\n\r\n// Function to perturb the normal vector within the hemisphere\r\nfn perturbDirection(normal: vec3<f32>, scatterAmount: f32, co: vec2<f32>) -> vec3<f32> {\r\n    // Generate a random vector in a hemisphere\r\n    let hemisphereVector : vec3<f32> = randomInHemisphere(co, normal);\r\n\r\n    // Combine the perturbation with the original normal\r\n    let perturbedDir : vec3<f32> = normalize(normal + scatterAmount * hemisphereVector);\r\n\r\n    return perturbedDir;\r\n}\r\n\r\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\r\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\r\nfn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\n\r\nfn perlinNoise3(P: vec3<f32>) -> f32 {\r\n    var Pi0 : vec3<f32> = floor(P); // Integer part for indexing\r\n    var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1\r\n    Pi0 = Pi0 % vec3<f32>(289.);\r\n    Pi1 = Pi1 % vec3<f32>(289.);\r\n    let Pf0 = fract(P); // Fractional part for interpolation\r\n    let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.\r\n    let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    let iy = vec4<f32>(Pi0.yy, Pi1.yy);\r\n    let iz0 = Pi0.zzzz;\r\n    let iz1 = Pi1.zzzz;\r\n\r\n    let ixy = permute4(permute4(ix) + iy);\r\n    let ixy0 = permute4(ixy + iz0);\r\n    let ixy1 = permute4(ixy + iz1);\r\n\r\n    var gx0: vec4<f32> = ixy0 / 7.;\r\n    var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;\r\n    gx0 = fract(gx0);\r\n    var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\r\n    var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));\r\n    gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);\r\n    gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);\r\n\r\n    var gx1: vec4<f32> = ixy1 / 7.;\r\n    var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;\r\n    gx1 = fract(gx1);\r\n    var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\r\n    var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));\r\n    gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);\r\n    gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);\r\n\r\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\r\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\r\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\r\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\r\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\r\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\r\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\r\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\r\n\r\n    let norm0 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 = g000 * norm0.x;\r\n    g010 = g010 * norm0.y;\r\n    g100 = g100 * norm0.z;\r\n    g110 = g110 * norm0.w;\r\n    let norm1 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 = g001 * norm1.x;\r\n    g011 = g011 * norm1.y;\r\n    g101 = g101 * norm1.z;\r\n    g111 = g111 * norm1.w;\r\n\r\n    let n000 = dot(g000, Pf0);\r\n    let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\r\n    let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\r\n    let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\r\n    let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\r\n    let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\r\n    let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\r\n    let n111 = dot(g111, Pf1);\r\n\r\n    var fade_xyz: vec3<f32> = fade3(Pf0);\r\n    let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix\r\n    let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);\r\n    let n_yz = mix(n_z.xy, n_z.zw, vec2f(f32(fade_xyz.y))); // simplify after chrome bug fix\r\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 2.2 * n_xyz;\r\n}\n${Ye}\n${Ke}\n${Qe}\n${Je}\nconst MAX_COARSE_RAY_STEPS = 64;\r\n\r\nfn rayMarchCoarse(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>) -> bool {\r\n    let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\r\n    var voxelSize = vec3<f32>(1.0);\r\n    var objectPos = objectRayOrigin;\r\n    var currentIndex = vec3<i32>(round(objectPos));\r\n    var tDelta = voxelSize / abs(objectRayDirection);\r\n    var tIncrement = min(tDelta.x, min(tDelta.y, tDelta.z));\r\n\r\n    for(var i = 0; i < MAX_COARSE_RAY_STEPS; i++)\r\n    {\r\n      let samplePosition = objectPos + voxelObject.atlasLocation;\r\n      let uv = samplePosition / vec3<f32>(textureDimensions(voxels));\r\n      let mipSample0 = textureSampleLevel(voxels, nearestSampler, uv, 0.0);\r\n\r\n      if(mipSample0.a > 0.0){\r\n          return true;\r\n      }\r\n\r\n      objectPos += objectRayDirection * tIncrement;\r\n      currentIndex = vec3<i32>(round(objectPos));\r\n//      if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n//          break;\r\n//      }\r\n    }\r\n    return false;\r\n}\r\n\r\nfn rayMarchTransformedCoarse(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> bool {\r\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz;\r\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n    return rayMarchCoarse(voxelObject, objectRayDirection, objectRayOrigin);\r\n}\r\n\r\n// Used for shadows, return first hit\r\nfn rayMarchBVHCoarse(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxDistance: f32) -> bool {\r\n  // Create a stack to store the nodes to visit\r\n      var stack = stack_new();\r\n      stack_push(&stack, 0);\r\n\r\n      var iterations = 0;\r\n      var nodeIndex = 0;\r\n\r\n      while (stack.head > 0u && iterations < 32) {\r\n        let node = bvhNodes[nodeIndex];\r\n        if(node.objectCount == 0){\r\n          nodeIndex = stack_pop(&stack);\r\n        }\r\n        // valid leaf, raymarch it\r\n        else if(node.objectCount == 1){\r\n            // Raymarch the voxel object if it's a leaf node\r\n            let voxelObject = voxelObjects[node.leftIndex]; // left index represents the voxel object index for leaf nodes\r\n            let AABBDist = getDistanceToNode(rayOrigin, rayDirection, node);\r\n            if(rayMarchTransformedCoarse(voxelObject, rayDirection, rayOrigin + rayDirection * AABBDist)){\r\n              return true;\r\n            }\r\n            // Pop the stack and continue\r\n            nodeIndex = stack_pop(&stack);\r\n        }\r\n        else{\r\n          let leftDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.leftIndex]);\r\n          let rightDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.rightIndex]);\r\n          let hitLeft = leftDist >= 0.0 && leftDist < maxDistance;\r\n          let hitRight = rightDist >= 0.0 && rightDist < maxDistance;\r\n          if(hitLeft){\r\n            var nearIndex = node.leftIndex;\r\n            // We hit both left and right, choose the closest one\r\n            if(hitRight){\r\n              if(leftDist < rightDist){\r\n                // left is closer, push right to stack\r\n                stack_push(&stack, node.rightIndex);\r\n              } else {\r\n                // right is closer, push left to stack\r\n                stack_push(&stack, node.leftIndex);\r\n                nearIndex = node.rightIndex;\r\n              }\r\n            }\r\n            nodeIndex = nearIndex;\r\n          }\r\n          // We only hit the right Node\r\n          else if(hitRight){\r\n            nodeIndex = node.rightIndex;\r\n          }\r\n          // We didn't hit any node, pop the stack\r\n          else{\r\n            nodeIndex = stack_pop(&stack);\r\n          }\r\n        }\r\n\r\n        iterations += 1;\r\n      }\r\n\r\n      return false;\r\n}\n${e}`,s=Vi.createComputePipeline({layout:Vi.createPipelineLayout({bindGroupLayouts:[r]}),compute:{module:Vi.createShaderModule({code:i}),entryPoint:t}});let o,a,c,l=Vi.createSampler({magFilter:"nearest",minFilter:"nearest"}),u=Vi.createSampler({magFilter:"linear",minFilter:"linear"});return{render:({commandEncoder:e,outputTextures:t,timestampWrites:n,viewProjectionMatricesBuffer:i,volumeAtlas:h,cameraPositionBuffer:d,transformationMatrixBuffer:f,sunDirectionBuffer:p,blueNoiseTextureView:m,timeBuffer:g,bvhBuffer:y})=>{if(o||(o=Vi.createTexture({size:[t.finalTexture.width,t.finalTexture.height,1],format:t.finalTexture.format,usage:t.finalTexture.usage}),a=o.createView()),e.copyTextureToTexture({texture:t.finalTexture.texture},{texture:o},{width:t.finalTexture.width,height:t.finalTexture.height,depthOrArrayLayers:1}),!c){const e=[{binding:0,resource:t.depthTexture.view},{binding:1,resource:a},{binding:2,resource:t.finalTexture.view},{binding:3,resource:{buffer:i}},{binding:4,resource:h.atlasTextureView},{binding:5,resource:{buffer:d}},{binding:6,resource:{buffer:f}},{binding:7,resource:{buffer:p}},{binding:8,resource:u},{binding:10,resource:t.normalTexture.view},{binding:11,resource:m},{binding:12,resource:{buffer:g}},{binding:13,resource:l},{binding:14,resource:t.velocityTexture.view},{binding:15,resource:{buffer:y}},{binding:16,resource:t.worldPositionTexture.view},{binding:17,resource:t.albedoTexture.view},{binding:18,resource:t.skyTexture.createView({dimension:"cube"})}],n={layout:r,entries:e};c=Vi.createBindGroup(n)}const v=e.beginComputePass({timestampWrites:n});v.setPipeline(s),v.setBindGroup(0,c),v.dispatchWorkgroups(Math.ceil(t.finalTexture.width/8),Math.ceil(t.finalTexture.height/8)),v.end()},label:n}})({shaderCode:"fn uncharted2_tonemap_partial(x: vec3<f32>) -> vec3<f32>\r\n{\r\n    let A = 0.15f;\r\n    let B = 0.50f;\r\n    let C = 0.10f;\r\n    let D = 0.20f;\r\n    let E = 0.02f;\r\n    let F = 0.30f;\r\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\r\n}\r\n\r\nfn luminance(v: vec3<f32>) -> f32\r\n{\r\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn reverse_aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(v*(c-e)-b))/(a-v*(d-e)), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn uncharted2_filmic(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let exposure_bias = 0.5f;\r\n    let curr = uncharted2_tonemap_partial(v * exposure_bias);\r\n    let W = vec3(11.2f);\r\n    let white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\r\n    return curr * white_scale;\r\n}\r\n\r\nfn reinhard_jodie(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let l = luminance(v);\r\n    let tv = v / (1.0f + v);\r\n    return mix(v / (1.0f + l), tv, tv);\r\n}\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  let inputSample = textureLoad(inputTex, pixel, 0);\r\n  let toneMapped = uncharted2_filmic(inputSample.rgb);\r\n//  let gammaCorrected = pow(toneMapped, vec3(1.0f / 0.3f));\r\n  textureStore(outputTex,pixel,vec4(toneMapped,1));\r\n}",entryPoint:"main",label:"tonemap"}),Di=new class{#m;#g;#y;#v;constructor(){this.#m=new Mn(1),this.#g=new Mn(0),this.#y=new Mn(0),this.#v=new Mn(-3)}set targetScale(e){this.#m.target=e}set targetTranslateX(e){this.#g.target=e}set targetRotateY(e){this.#y.target=e}set targetSunRotateY(e){this.#v.target=e}get targetScale(){return this.#m.target}get targetTranslateX(){return this.#g.target}get targetRotateY(){return this.#y.target}get targetSunRotateY(){return this.#v.target}get sunRotateY(){return this.#v.value}get scale(){return this.#m.value}get translateX(){return this.#g.value}};let qi,Fi,Li,Vi,Gi=z.create(4,4),Wi=0,Yi=Wi,Hi=0,$i=0;const Xi=new class{gui;timingsFolder;passesFolder;constructor(){}log(e){}setupDebugControls(e){}},Zi=(()=>{let e={};const t=t=>{const n=e[t];return n?n.reduce(((e,t)=>e+t))/n.length:0};return{addSample:(t,n)=>{e[t]||(e[t]=[]),e[t].push(n)>50&&e[t].shift()},clearEntry:t=>{e[t]&&(e[t]=[0])},toString:()=>Object.keys(e).map((e=>`${e}: ${t(e).toFixed(2)}ms`)).join("\n"),toHTML:()=>Object.keys(e).map((e=>`<div class="debug-row">\n                    <div>\n                        ${e}\n                    </div>\n                   <div>${t(e).toFixed(2)}ms</div>\n                </div>`)).join("\n"),getAverages:()=>Object.keys(e).reduce(((e,n)=>(e[n]=t(n),e)),{})}})();Zi.addSample("frame time",0);let Ki,Qi,Ji,es,ts,ns,rs,is,ss,os,as,cs,ls,us,hs,ds,fs,ps,ms,gs,ys,vs,xs,ws=ye.create();Qi=Array.from({length:200}).map((()=>({position:[-80*Math.random(),50*Math.random(),-200*Math.random()],size:4,color:te.normalize(te.create(Math.random(),Math.random(),Math.random()))})));const bs=async(e,t,n,r)=>{if(Vi=e,Li=t,!navigator.gpu)throw new Error("WebGPU not supported");ks=((e,t,n)=>{const r=new Float32Array(t),i=e.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"camera position"});return We(i,t),i})(Vi,[0,0,0,0]),_s(Vi),ps=new xi(Vi,r.map((e=>Ei(n.getComponents(e).get(Pi),n.getComponents(e).get(Si))))),Ki=Vi.createTexture({label:"sky texture",dimension:"2d",size:[640,640,6],format:"rgba16float",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),Ji=await Promise.all([bi(),ht(),ji(),dt(Vi)]),xs=Ji.reduce(((e,t)=>t.timestampLabels?e.concat(t.timestampLabels):e.concat(t.label)),[]),Fi=document.getElementById("webgpu-canvas"),Fi.style.imageRendering="pixelated",qi=Fi.getContext("webgpu"),qi.configure({device:Vi,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT}),ys=Vi.createSampler({magFilter:"linear",minFilter:"linear"}),vs=Vi.createSampler({magFilter:"nearest",minFilter:"nearest"}),Vi.features.has("timestamp-query")&&(ms=Vi.createQuerySet({type:"timestamp",count:1e3}),gs=Vi.createBuffer({label:"timestamp query",size:8*ms.count,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}));const{clientWidth:i,clientHeight:s}=Fi.parentElement,o=z.create(1*i,1*s);Gi=z.mulScalar(o,1),Fi.width=o[0],Fi.height=o[1],Fi.style.transform="scale(1)"},_s=async e=>{const t=await async function(e,t,n={}){return mi(e,[t],n)}(e,"blue-noise-rg.png",{usage:GPUTextureUsage.COPY_SRC});os=t.createView()};let ks;setInterval((()=>{Xi.log(Zi.getAverages())}),500);const Ts=(e,t,n,r,i)=>{if(!Vi||!Ji||!Li)return;const s=Vi.createCommandEncoder();0===Wi&&(Wi=e),s.pushDebugGroup("frame");const o=e-Wi;Hi=o-Yi,Zi.addSample("frame time",Hi),Yi=o,$i++,((e,t)=>{const n=function(e,t,n,r,i,s){const o=2*Math.tan(r/2)*s,a=o*i,c=2/t,l=2/n;return[(_i(e,2)-.5)*c*a,(_i(e,3)-.5)*l*o]}($i,Gi[0],Gi[1],"fieldOfView"in e.config?e.config.fieldOfView:90,Gi[0]/Gi[1],"near"in e.config?e.config.near:.1),r=function(e,t){const n=new Float32Array(e);return n[8]+=t[0],n[9]+=t[1],n}(e.projectionMatrix,n),i=(e=>{const t=e.position;return ye.lookAt(t,te.add(t,e.direction),e.up)})(t),s=ye.mul(r,i);ds=new Float32Array([...s,...ws,...ye.invert(s),...ye.invert(ws),...r,...ye.invert(r)]),us||(us=Vi.createBuffer({size:ds.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"view matrices buffer"})),Vi.queue.writeBuffer(us,0,ds.buffer,0,ds.length*Float32Array.BYTES_PER_ELEMENT);const o=ye.mul((a=r,ye.invert(a)),s);var a;const c=ye.invert(o);fs=new Float32Array(ye.getTranslation(c)),Vi.queue.writeBuffer(ks,0,fs.buffer,0,fs.length*Float32Array.BYTES_PER_ELEMENT),ws=s})(n,r),((e,t,n)=>{const r=n.map((e=>{return n=t.getComponents(e).get(Pi),[...(r=t.getComponents(e).get(Si)).transform,...ye.invert(r.transform),...r.previousTransform,...ye.invert(r.previousTransform),...n.size,0,...n.atlasLocation,n.paletteIndex,0,0,0,n.octreeBufferIndex];var n,r})).flat(),i=new Float32Array(r).byteLength;ls&&i===ls.size||(ls=e.createBuffer({size:i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"voxel objects buffer"})),e.queue.writeBuffer(ls,0,new Float32Array(r).buffer,0,r.length*Float32Array.BYTES_PER_ELEMENT)})(Vi,t,i),as||(as=Ge([$i,0,0],"time buffer")),Vi.queue.writeBuffer(as,4,new Float32Array([Hi])),Vi.queue.writeBuffer(as,0,new Uint32Array([$i])),Vi.queue.writeBuffer(as,8,new Float32Array([Yi/1e3])),cs?Ve(cs,[Gi[0],Gi[1]]):cs=Ge([Gi[0],Gi[1]]),(()=>{const e=ye.identity();ye.rotateY(e,Di.sunRotateY,e);const t=te.normalize(te.transformMat4(te.create(0,.5,-.8),e));hs?We(hs,[t[0],t[1],t[2]]):hs=Ge([t[0],t[1],t[2]],"sun buffer")})(),ps.update(i.map((e=>Ei(t.getComponents(e).get(Pi),t.getComponents(e).get(Si))))),ts=new st(Vi,Gi[0],Gi[1]),es=new ot(Vi,Gi[0],Gi[1]),rs=new at(Vi,Gi[0],Gi[1]),is=new ct(Vi,Gi[0],Gi[1]),ns=new ut(Vi,Gi[0],Gi[1]),ss=new lt(Vi,Gi[0],Gi[1]);let a=0;Ji.forEach(((e,o)=>{const{render:c,label:l}=e;let u;Vi.features.has("timestamp-query")&&s.clearBuffer(gs),Vi.features.has("timestamp-query")&&(u={querySet:ms,beginningOfPassWriteIndex:a,endOfPassWriteIndex:a+1}),l&&s.pushDebugGroup(l),c({enabled:document.getElementById(`flag-${l}`)?.checked,commandEncoder:s,resolutionBuffer:cs,timeBuffer:as,outputTextures:{finalTexture:ns,albedoTexture:ts,normalTexture:es,depthTexture:rs,skyTexture:Ki,velocityTexture:is,worldPositionTexture:ss},cameraPositionBuffer:ks,volumeAtlas:Li,transformationMatrixBuffer:ls,viewProjectionMatricesArray:ds,viewProjectionMatricesBuffer:us,timestampWrites:u,sunDirectionBuffer:hs,blueNoiseTextureView:os,bvhBuffer:ps.gpuBuffer,lights:Qi,linearSampler:ys,nearestSampler:vs,camera:n,cameraTransform:r,renderableEntities:i,ecs:t}),a+=xs?.length>0?2*xs.length:2,l&&s.popDebugGroup()})),s.popDebugGroup(),Vi.features.has("timestamp-query")&&(async(e,t,n)=>{const r=n.size;ki||(ki=Vi.createBuffer({size:r,label:"gpu read buffer",usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}));const i=Vi.createCommandEncoder();if(Ti)return;Ti=!0,i.resolveQuerySet(t,0,t.count,n,0),i.copyBufferToBuffer(n,0,ki,0,r),Vi.queue.submit([i.finish()]),await Vi.queue.onSubmittedWorkDone(),await ki.mapAsync(GPUMapMode.READ).finally((()=>{Ti=!1}));const s=ki.getMappedRange(),o=new BigInt64Array(s),a=[];o.forEach((e=>{a.push(Number(e)/1e6)})),a.reduce(((e,t,n)=>(n%2==0&&e.push(a[n+1]-t),e)),[]).forEach(((t,n)=>{Zi.addSample(e[n],t)})),ki.unmap()})(xs,ms,gs),Vi.queue.submit([s.finish()])};class Ss extends e{config;constructor(e){super(),this.config=e}get projectionMatrix(){return"size"in this.config?ye.ortho(-Gi[0]/this.config.size,Gi[0]/this.config.size,-Gi[1]/this.config.size,Gi[1]/this.config.size,this.config.size,-this.config.size):ye.perspective(this.config.fieldOfView,Gi[0]/Gi[1],this.config.near,this.config.far)}}class Ps{index;dataView;constructor(e){this.dataView=new DataView(e),this.index=0}readUint8(){const e=this.dataView.getUint8(this.index);return this.index++,e}readUint32(){const e=this.dataView.getUint32(this.index,!0);return this.index+=4,e}readFloat32(){const e=this.dataView.getFloat32(this.index,!0);return this.index+=4,e}skip(e){this.index+=e}}const Es=e=>0===e,As=(e,t)=>e|1<<t,Ms=e=>[1&e?1:0,2&e?1:0,4&e?1:0];class zs{nodes;#x;#w;constructor(e){var t;this.nodes=[],this.#x=0,this.#w=(t=e.SIZE,Math.ceil(Math.log2(Math.max(...t)))),this.#d(e,0,[0,0,0],0),console.log(this.nodes.slice(0,20))}#b(e=8){return this.#x+=e,this.#x-(e-1)}#d(e,t,n,r){if(1===e.XYZI.length){const n=e.XYZI[0].c;return void(this.nodes[t]={red:e.RGBA[n].r,green:e.RGBA[n].g,blue:e.RGBA[n].b})}const i=Array.from({length:8},(()=>null)),s=r+1,o=(e=>Math.pow(2,Math.ceil(Math.log2(e))))(Math.max(...e.SIZE)),a=o/2;for(let t=0;t<8;t++){const r=Ms(t),s=n[0]+r[0]*a,o=n[1]+r[1]*a,c=n[2]+r[2]*a,l=e.XYZI.filter((e=>e.x>=s&&e.x<s+a&&e.y>=o&&e.y<o+a&&e.z>=c&&e.z<c+a));l.length>0&&(i[t]={SIZE:[a,a,a],XYZI:l,RGBA:e.RGBA,VOX:l.length})}const c=i.reduce(((e,t,n)=>t?As(e,n):e),0),l=this.#b(),u=l-t;let h=0;i.forEach(((e,t)=>{if(e){const r=l+t,i=Ms(t),o=n[0]+i[0]*a,c=n[1]+i[1]*a,u=n[2]+i[2]*a;1===e.XYZI.length&&s==this.#w&&(h=As(h,t)),this.#d(e,r,[o,c,u],s)}})),this.nodes[t]={firstChildIndex:u,childMask:c,voxels:{...e,SIZE:[o,o,o]},x:n[0],y:n[1],z:n[2],size:o,leafMask:h}}get totalSize(){return 8*this.nodes.length}}const Is=async(e,t,n)=>{console.time(`Fetch ${e}`);const r=await fetch(e);console.timeEnd(`Fetch ${e}`);const i=(e=>{console.time("convert vxm");const t=new Ps(e);let n,r=[],i="",s=[];if(i=String.fromCodePoint(t.readUint8(),t.readUint8(),t.readUint8(),t.readUint8()),"VXMC"!==i&&"VXMA"!==i)throw new Error(`Incorrect magic: ${i}`);if(i[3].charCodeAt(0)>="0".charCodeAt(0)&&i[3].charCodeAt(0)<="9".charCodeAt(0))n=i[3].charCodeAt(0)-"0".charCodeAt(0);else{if(!(i[3].charCodeAt(0)>="A".charCodeAt(0)&&i[3].charCodeAt(0)<="C".charCodeAt(0)))throw new Error("Unsupported version found");n=10+i[3].charCodeAt(0)-"A".charCodeAt(0)}if(n<11||n>12)throw new Error(`Could not load vxm file: Unsupported version found (${n})`);let o=[0,0,0];o[0]=t.readUint32(),o[1]=t.readUint32(),o[2]=t.readUint32();let a=[.5,0,.5];if(a[0]=t.readFloat32(),a[1]=t.readFloat32(),a[2]=t.readFloat32(),t.readUint8()>0){let e=0,n=0;t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),e=t.readUint32(),n=t.readUint32();let r=e*n;t.skip(4*r)}n>=8&&t.skip(16);let c=t.readUint32();for(let e=0;e<c;++e){let e=t.readUint32(),n=t.readUint32();if(e>2048||n>2048)throw new Error("Size of texture exceeds the max allowed value");let r=t.readUint32();t.skip(r);for(let e=0;e<6;++e){let e=t.readUint32();e>262144&&console.warn(`Size of quads exceeds the max allowed value: ${e}`);let n=4*e*20;t.skip(n)}}t.skip(1024),t.skip(1024);let l=t.readUint8();for(let e=0;e<l;++e)t.skip(1024),t.readUint8(),t.readUint8();let u=t.readUint8();for(let e=0;e<u;++e){let n=t.readUint8(),i=t.readUint8(),s=t.readUint8(),o=t.readUint8();o=1===t.readUint8()?2:255,r[e]={r:s,g:i,b:n,a:o}}let h=1;n>=12&&(h=t.readUint8());let d={min:te.create(9999,9999,9999),max:te.create(0,0,0)};for(let e=0;e<h;++e){let r=0,i=!0,a="";if(n>=12){for(;;){const e=t.readUint8();if(Es(e))break;a=`${a}${String.fromCharCode(e)}`}i=t.readUint8()>0}else a=`Layer ${e}`;for(;;){let e=t.readUint8();if(0===e)break;let n=t.readUint8();if(255!==n)if(n>=u)r+=e;else{for(let t=r;t<r+e;t++){let e=Math.floor(t/(o[1]*o[2])),r=Math.floor(t/o[2]%o[1]),i=Math.floor(t%o[2]);d.min=te.min(d.min,[e,r,i]),d.max=te.max(d.max,[e,r,i]),s.push({x:e,y:r,z:i,c:n})}r+=e}else r+=e}}s=s.map((({x:e,y:t,z:n,c:r})=>({x:e-d.min[0],y:t-d.min[1],z:n-d.min[2],c:r})));const f=te.sub(d.max,d.min);return console.timeEnd("convert vxm"),{VOX:s.length,SIZE:[f[0]+1,f[1]+1,f[2]+1],XYZI:s,RGBA:r}})(await r.arrayBuffer());console.time(`Create texture from voxels for ${e}`);let s=await(async(e,t)=>{const n=e.createTexture({size:{width:t.SIZE[0],height:t.SIZE[1],depthOrArrayLayers:t.SIZE[2]},format:$e,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:4}),r=n.width*n.height*n.depthOrArrayLayers,i=e.createBuffer({size:4*r*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.STORAGE}),s=e.createBuffer({size:256*t.SIZE[2],usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.UNIFORM,label:"voxels buffer"}),o=Array.from({length:t.SIZE[2]},((e,t)=>t));for(let t=0;t<o.length;t++)e.queue.writeBuffer(s,256*t,new Uint32Array([o[t]]).buffer);for(let n=0;n<t.XYZI.length;n++){const{x:r,y:s,z:o,c:l}=t.XYZI[n],u=(a=t.SIZE,(c=[r,s,o])[0]+c[1]*a[0]+c[2]*(a[0]*a[1]));e.queue.writeBuffer(i,16*u,new Uint32Array([r,s,o,l]).buffer)}var a,c;const l=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"storage"}}]}),u=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[l]}),vertex:{module:e.createShaderModule({code:"\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n          }\n          \n          @vertex\n          fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            const pos = array(\n              vec2( 1.0,  1.0),\n              vec2( 1.0, -1.0),\n              vec2(-1.0, -1.0),\n              vec2( 1.0,  1.0),\n              vec2(-1.0, -1.0),\n              vec2(-1.0,  1.0),\n            );\n            var output : VertexOutput;\n            output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n            return output;\n          }"}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:"\n          @group(0) @binding(0) var<uniform> zIndex: u32;\n          @group(0) @binding(1) var<storage, read_write> voxelBuffer: array<vec4<u32>>;\n          \n          override sizeX: u32;\n          override sizeY: u32;\n          override sizeZ: u32;\n           \n          fn convert3DTo1D(size: vec3<u32>, position: vec3<u32>) -> u32 {\n            return position.x + position.y * size.x + position.z * (size.x * size.y);\n          }\n          \n          @fragment\n          fn fragment_main(@builtin(position) position : vec4<f32>) -> @location(0) vec4<f32> { \n            let voxelPosition = vec3(position.xy, f32(zIndex));\n            let voxelIndex = convert3DTo1D(vec3<u32>(sizeX, sizeY, sizeZ), vec3<u32>(voxelPosition));\n            let voxel = voxelBuffer[voxelIndex];\n            let normalisedPaletteIndex = f32(voxel.a) / 255.0;\n            return vec4(normalisedPaletteIndex,0,0,0);\n          }\n        "}),entryPoint:"fragment_main",targets:[{format:$e}],constants:{sizeX:t.SIZE[0],sizeY:t.SIZE[1],sizeZ:t.SIZE[2]}}}),h=e.createCommandEncoder();for(let t=0;t<n.depthOrArrayLayers;t++){const r=e.createBindGroup({label:"create-texture-from-voxels",layout:l,entries:[{binding:0,resource:{buffer:s,offset:256*t,size:4}},{binding:1,resource:{buffer:i}}]}),o=h.beginRenderPass({colorAttachments:[{view:n.createView({baseArrayLayer:t,arrayLayerCount:1,mipLevelCount:1,dimension:"2d"}),loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});o.setPipeline(u),o.setBindGroup(0,r),o.draw(6),o.end()}return e.queue.submit([h.finish()]),await e.queue.onSubmittedWorkDone(),n})(t,i);console.timeEnd(`Create texture from voxels for ${e}`),console.time(`Create octree for ${e}`);const o=(e=>{const t=new ArrayBuffer(e.totalSize),n=new DataView(t);return e.nodes.forEach(((e,t)=>{"red"in e?((e,t,n)=>{e.setUint16(8*t,0),e.setUint8(8*t+2,n.red),e.setUint8(8*t+3,n.green),e.setUint8(8*t+4,n.blue)})(n,t,e):((e,t,n)=>{console.assert(n.firstChildIndex<65536,`First child index of ${n.firstChildIndex} is too large to fit in 2 bytes`),e.setUint16(8*t,n.firstChildIndex),e.setUint8(8*t+2,n.childMask),e.setUint8(8*t+3,n.leafMask),e.setUint8(8*t+4,n.x),e.setUint8(8*t+5,n.y),e.setUint8(8*t+6,n.z),e.setUint8(8*t+7,n.size),0===t&&console.log(n.size)})(n,t,e)})),console.debug(`Created octree of size ${(e.totalSize/1048576).toFixed(2)} MB`),t})(new zs(i));console.timeEnd(`Create octree for ${e}`),console.time(`Create palette texture for ${e}`);const a=await(async(e,t)=>{const n=e.createTexture({size:{width:256,height:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,dimension:"2d",mipLevelCount:1}),r=e.createBuffer({label:"palette buffer",size:1024,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});t.RGBA.forEach((({r:t,g:n,b:i,a:s},o)=>{const a=new Uint8Array([t,n,i,s]);e.queue.writeBuffer(r,4*o,a)}));const i=e.createCommandEncoder();return i.copyBufferToTexture({buffer:r},{texture:n},[255,1,1]),e.queue.submit([i.finish()]),await e.queue.onSubmittedWorkDone(),n})(t,i);console.timeEnd(`Create palette texture for ${e}`),await n.addVolume(s,a,e,o)},Cs=async(e,t,n,r)=>{t.dictionary[r]||await Is(r,e,t);const{size:i,location:s,paletteIndex:o,octreeOffset:a}=t.dictionary[r];return new Pi({name:n,size:i,atlasLocation:s,paletteIndex:o,octreeBufferIndex:a})},Bs=async(e,t,n)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const r=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const n=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:t.mipLevelCount}),r=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let i=0;i<t.depthOrArrayLayers>>e;i++)r.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:i}},{texture:n,mipLevel:e,origin:{x:0,y:0,z:i}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([r.finish()]),await e.queue.onSubmittedWorkDone(),n})(e,t),i=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),s=e.createBuffer({size:256*t.depthOrArrayLayers,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.UNIFORM,label:"z indices buffer"}),o=Array.from({length:t.depthOrArrayLayers},((e,t)=>t));for(let t=0;t<o.length;t++)e.queue.writeBuffer(s,256*t,new Uint32Array([o[t]]).buffer);const a=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[i]}),vertex:{module:e.createShaderModule({code:"\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n          }\n          const pos = array(\n              vec2( 1.0,  1.0),\n              vec2( 1.0, -1.0),\n              vec2(-1.0, -1.0),\n              vec2( 1.0,  1.0),\n              vec2(-1.0, -1.0),\n              vec2(-1.0,  1.0),\n            );\n          @vertex\n          fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            var output : VertexOutput;\n            output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n            return output;\n          }"}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:"\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> zIndex: u32;\n          @fragment\r\nfn fragment_main(@builtin(position) position : vec4<f32>) -> @location(0) vec4<f32> {\r\n  let srcTexel = vec3(vec2<u32>(position.xy),zIndex);\r\n  var colours = array<f32, 8>();\r\n  var isOctantEmpty = true;\r\n  for(var x = u32(0); x < 2; x++){\r\n    for(var y = u32(0); y < 2; y++){\r\n      for(var z = u32(0); z < 2; z++){\r\n        let voxelX = srcTexel.x * 2 + x;\r\n        let voxelY = srcTexel.y * 2 + y;\r\n        let voxelZ = srcTexel.z * 2 + z;\r\n        var voxelId = vec3<u32>(voxelX,voxelY,voxelZ);\r\n        var voxel = textureLoad(voxels,voxelId,0).r;\r\n        if(voxel > 0){\r\n          var index = x + y * 2 + z * 4;\r\n          colours[index] = voxel;\r\n          isOctantEmpty = false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // If all voxels in the octant are empty, keep it blank\r\n  if(isOctantEmpty){\r\n    discard;\r\n  }\r\n\r\n  // Get the most common colour in the octant\r\n  var mostCommonColour = f32(0);\r\n  var mostCommonColourCount = u32(0);\r\n  for(var i = u32(0); i < 8; i = i + 1u){\r\n    var colour = colours[i];\r\n    var count = u32(0);\r\n    for(var j = u32(0); j < 8; j = j + 1u){\r\n      if(colour > 0 && colour == colours[j]){\r\n        count++;\r\n      }\r\n    }\r\n    if(count > mostCommonColourCount){\r\n      mostCommonColour = colour;\r\n      mostCommonColourCount = count;\r\n    }\r\n  }\r\n\r\n  return vec4(mostCommonColour, 0,0,0);\r\n}\r\n\r\n\n        "}),entryPoint:"fragment_main",targets:[{format:t.format}]}}),c=e.createCommandEncoder(),l=Math.max(1,t.depthOrArrayLayers>>n);for(let o=0;o<l;o++){const l=e.createBindGroup({layout:i,entries:[{binding:0,resource:t.createView({label:`${n} mip level of volume texture`,dimension:"3d",baseMipLevel:n-1,mipLevelCount:1})},{binding:1,resource:{buffer:s,offset:256*o,size:4}}]}),u=c.beginRenderPass({colorAttachments:[{view:r.createView({label:"volume slice for rendering mips",baseArrayLayer:o,arrayLayerCount:1,baseMipLevel:n,mipLevelCount:1,dimension:"2d-array"}),loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});u.setPipeline(a),u.setBindGroup(0,l),u.draw(6),u.end()}return e.queue.submit([c.finish()]),await e.queue.onSubmittedWorkDone(),await(async(e,t)=>{if("2d"!==t.dimension)throw new Error("Input texture should be a 2D texture");const n=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d",mipLevelCount:t.mipLevelCount}),r=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let i=0;i<t.depthOrArrayLayers>>e;i++)r.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:i}},{texture:n,mipLevel:e,origin:{x:0,y:0,z:i}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([r.finish()]),await e.queue.onSubmittedWorkDone(),n})(e,r)},Os={format:$e,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d"},Rs=(e,t)=>Math.ceil(e/t)*t,Us=Math.pow(2,3),Ns=Us,js=256;class Ds{#_={};#k;#T;#a;#S;#P;#E;constructor(e){this.#a=e,this.#k=e.createTexture({size:{width:Ns,height:Ns,depthOrArrayLayers:Ns},...Os,label:"Volume atlas containing ",mipLevelCount:4}),this.#T=e.createTexture({size:{width:js,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1}),this.#S=this.#k.createView(),this.#P=this.#T.createView(),this.#E=e.createBuffer({size:0,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,label:"Octree buffer"})}get dictionary(){return this.#_}addVolume=async(e,t,n,r)=>{if(this.#_[n])throw new Error(`Error adding volume to atlas: volume with label ${n} already exists`);const i=this.#a.createCommandEncoder(),{width:s,height:o,depthOrArrayLayers:a}=e,c=Rs(s,Us),l=Rs(o,Us),u=Rs(a,Us),h=this.#k.width+c;if(h>this.#a.limits.maxTextureDimension3D)throw new Error(`Error adding volume to atlas: adding volume would exceed device max texture dimension of ${this.#a.limits.maxTextureDimension3D}`);const d=Math.max(this.#k.height,l),f=Math.max(this.#k.depthOrArrayLayers,u),p=this.#a.createTexture({size:{width:h,height:d,depthOrArrayLayers:f},mipLevelCount:this.#k.mipLevelCount,...Os,label:`${this.#k.label}, ${e.label||"unnamed volume"}`}),m=this.#k.width;i.copyTextureToTexture({texture:this.#k},{texture:p},{width:this.#k.width,height:this.#k.height,depthOrArrayLayers:this.#k.depthOrArrayLayers}),i.copyTextureToTexture({texture:e,mipLevel:0,origin:{x:0,y:0,z:0}},{texture:p,mipLevel:0,origin:{x:m,y:0,z:0}},{width:e.width,height:e.height,depthOrArrayLayers:e.depthOrArrayLayers}),this.#k=p;const g=this.#T.height;this.#_[n]={location:[m,0,0],size:[s,o,a],paletteIndex:g,octreeOffset:this.#E.size,octreeSizeBytes:r.byteLength,textureSizeBytes:e.width*e.height*e.depthOrArrayLayers};const y=this.#a.createTexture({size:{width:js,height:this.#T.height+1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1});i.copyTextureToTexture({texture:this.#T},{texture:y},{width:js,height:this.#T.height,depthOrArrayLayers:1}),i.copyTextureToTexture({texture:t},{texture:y,origin:{x:0,y:g,z:0}},{width:js,height:1,depthOrArrayLayers:1}),this.#T=y;const v=this.#a.createBuffer({label:"Octree buffer",size:this.#E.size+r.byteLength,usage:this.#E.usage});i.copyBufferToBuffer(this.#E,0,v,0,this.#E.size),this.#a.queue.writeBuffer(v,this.#E.size,r),this.#a.queue.submit([i.finish()]),await this.#a.queue.onSubmittedWorkDone(),this.#E=v,this.#E.unmap();{const e=this.#a.createBuffer({label:"Octree buffer copy",size:this.#E.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),t=this.#a.createCommandEncoder();t.copyBufferToBuffer(this.#E,0,e,0,this.#E.size),this.#a.queue.submit([t.finish()]),await this.#a.queue.onSubmittedWorkDone()}this.#k=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");let n=t;for(let r=1;r<t.mipLevelCount;r++)n=await Bs(e,n,r);return n})(this.#a,this.#k),this.#S=this.#k.createView(),this.#P=this.#T.createView()};get atlasTextureView(){return this.#S}get paletteTextureView(){return this.#P}get octreeBuffer(){return this.#E}}class qs{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new Ls);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new Ls);const n=this.elements,r=e.x,i=e.y,s=e.z;return t.x=n[0]*r+n[1]*i+n[2]*s,t.y=n[3]*r+n[4]*i+n[5]*s,t.z=n[6]*r+n[7]*i+n[8]*s,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new qs);const n=this.elements,r=e.elements,i=t.elements,s=n[0],o=n[1],a=n[2],c=n[3],l=n[4],u=n[5],h=n[6],d=n[7],f=n[8],p=r[0],m=r[1],g=r[2],y=r[3],v=r[4],x=r[5],w=r[6],b=r[7],_=r[8];return i[0]=s*p+o*y+a*w,i[1]=s*m+o*v+a*b,i[2]=s*g+o*x+a*_,i[3]=c*p+l*y+u*w,i[4]=c*m+l*v+u*b,i[5]=c*g+l*x+u*_,i[6]=h*p+d*y+f*w,i[7]=h*m+d*v+f*b,i[8]=h*g+d*x+f*_,t}scale(e,t){void 0===t&&(t=new qs);const n=this.elements,r=t.elements;for(let t=0;3!==t;t++)r[3*t+0]=e.x*n[3*t+0],r[3*t+1]=e.y*n[3*t+1],r[3*t+2]=e.z*n[3*t+2];return t}solve(e,t){void 0===t&&(t=new Ls);const n=[];let r,i;for(r=0;r<12;r++)n.push(0);for(r=0;r<3;r++)for(i=0;i<3;i++)n[r+4*i]=this.elements[r+3*i];n[3]=e.x,n[7]=e.y,n[11]=e.z;let s=3;const o=s;let a,c;do{if(r=o-s,0===n[r+4*r])for(i=r+1;i<o;i++)if(0!==n[r+4*i]){a=4;do{c=4-a,n[c+4*r]+=n[c+4*i]}while(--a);break}if(0!==n[r+4*r])for(i=r+1;i<o;i++){const e=n[r+4*i]/n[r+4*r];a=4;do{c=4-a,n[c+4*i]=c<=r?0:n[c+4*i]-n[c+4*r]*e}while(--a)}}while(--s);if(t.z=n[11]/n[10],t.y=(n[7]-n[6]*t.z)/n[5],t.x=(n[3]-n[2]*t.z-n[1]*t.y)/n[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(void 0===n)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new qs);const t=Fs;let n,r;for(n=0;n<3;n++)for(r=0;r<3;r++)t[n+6*r]=this.elements[n+3*r];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let i=3;const s=i;let o,a;do{if(n=s-i,0===t[n+6*n])for(r=n+1;r<s;r++)if(0!==t[n+6*r]){o=6;do{a=6-o,t[a+6*n]+=t[a+6*r]}while(--o);break}if(0!==t[n+6*n])for(r=n+1;r<s;r++){const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=a<=n?0:t[a+6*r]-t[a+6*n]*e}while(--o)}}while(--i);n=2;do{r=n-1;do{const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=t[a+6*r]-t[a+6*n]*e}while(--o)}while(r--)}while(--n);n=2;do{const e=1/t[n+6*n];o=6;do{a=6-o,t[a+6*n]=t[a+6*n]*e}while(--o)}while(n--);n=2;do{r=2;do{if(a=t[3+r+6*n],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(n,r,a)}while(r--)}while(n--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,r=e.z,i=e.w,s=t+t,o=n+n,a=r+r,c=t*s,l=t*o,u=t*a,h=n*o,d=n*a,f=r*a,p=i*s,m=i*o,g=i*a,y=this.elements;return y[0]=1-(h+f),y[1]=l-g,y[2]=u+m,y[3]=l+g,y[4]=1-(c+f),y[5]=d-p,y[6]=u-m,y[7]=d+p,y[8]=1-(c+h),this}transpose(e){void 0===e&&(e=new qs);const t=this.elements,n=e.elements;let r;return n[0]=t[0],n[4]=t[4],n[8]=t[8],r=t[1],n[1]=t[3],n[3]=r,r=t[2],n[2]=t[6],n[6]=r,r=t[5],n[5]=t[7],n[7]=r,e}}const Fs=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class Ls{constructor(e,t,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){void 0===t&&(t=new Ls);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z;return t.x=o*i-a*r,t.y=a*n-s*i,t.z=s*r-o*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new Ls(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new Ls(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new qs([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,r=Math.sqrt(e*e+t*t+n*n);if(r>0){const e=1/r;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return r}unit(e){void 0===e&&(e=new Ls);const t=this.x,n=this.y,r=this.z;let i=Math.sqrt(t*t+n*n+r*r);return i>0?(i=1/i,e.x=t*i,e.y=n*i,e.z=r*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return Math.sqrt((i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r))}distanceSquared(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return(i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r)}scale(e,t){void 0===t&&(t=new Ls);const n=this.x,r=this.y,i=this.z;return t.x=e*n,t.y=e*r,t.z=e*i,t}vmul(e,t){return void 0===t&&(t=new Ls),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return void 0===n&&(n=new Ls),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new Ls),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const r=Vs,i=1/n;r.set(this.x*i,this.y*i,this.z*i);const s=Gs;Math.abs(r.x)<.9?(s.set(1,0,0),r.cross(s,e)):(s.set(0,1,0),r.cross(s,e)),r.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const r=this.x,i=this.y,s=this.z;n.x=r+(e.x-r)*t,n.y=i+(e.y-i)*t,n.z=s+(e.z-s)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(Ws),Ws.almostEquals(e,t)}clone(){return new Ls(this.x,this.y,this.z)}}Ls.ZERO=new Ls(0,0,0),Ls.UNIT_X=new Ls(1,0,0),Ls.UNIT_Y=new Ls(0,1,0),Ls.UNIT_Z=new Ls(0,0,1);const Vs=new Ls,Gs=new Ls,Ws=new Ls;class Ys{constructor(e){void 0===e&&(e={}),this.lowerBound=new Ls,this.upperBound=new Ls,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,r){const i=this.lowerBound,s=this.upperBound,o=n;i.copy(e[0]),o&&o.vmult(i,i),s.copy(i);for(let t=1;t<e.length;t++){let n=e[t];o&&(o.vmult(n,Hs),n=Hs),n.x>s.x&&(s.x=n.x),n.x<i.x&&(i.x=n.x),n.y>s.y&&(s.y=n.y),n.y<i.y&&(i.y=n.y),n.z>s.z&&(s.z=n.z),n.z<i.z&&(i.z=n.z)}return t&&(t.vadd(i,i),t.vadd(s,s)),r&&(i.x-=r,i.y-=r,i.z-=r,s.x+=r,s.y+=r,s.z+=r),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new Ys).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound,s=r.x<=n.x&&n.x<=i.x||t.x<=i.x&&i.x<=n.x,o=r.y<=n.y&&n.y<=i.y||t.y<=i.y&&i.y<=n.y,a=r.z<=n.z&&n.z<=i.z||t.z<=i.z&&i.z<=n.z;return s&&o&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound;return t.x<=r.x&&n.x>=i.x&&t.y<=r.y&&n.y>=i.y&&t.z<=r.z&&n.z>=i.z}getCorners(e,t,n,r,i,s,o,a){const c=this.lowerBound,l=this.upperBound;e.copy(c),t.set(l.x,c.y,c.z),n.set(l.x,l.y,c.z),r.set(c.x,l.y,l.z),i.set(l.x,c.y,l.z),s.set(c.x,l.y,c.z),o.set(c.x,c.y,l.z),a.copy(l)}toLocalFrame(e,t){const n=$s,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],c=n[5],l=n[6],u=n[7];this.getCorners(r,i,s,o,a,c,l,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToLocal(r,r)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=$s,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],c=n[5],l=n[6],u=n[7];this.getCorners(r,i,s,o,a,c,l,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToWorld(r,r)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,r=1/t.x,i=1/t.y,s=1/t.z,o=(this.lowerBound.x-n.x)*r,a=(this.upperBound.x-n.x)*r,c=(this.lowerBound.y-n.y)*i,l=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*s,h=(this.upperBound.z-n.z)*s,d=Math.max(Math.max(Math.min(o,a),Math.min(c,l)),Math.min(u,h)),f=Math.min(Math.min(Math.max(o,a),Math.max(c,l)),Math.max(u,h));return!(f<0||d>f)}}const Hs=new Ls,$s=[new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls];class Xs{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:r}=t;if(r>n){const e=r;r=n,n=e}return this.matrix[(n*(n+1)>>1)+r-1]}set(e,t,n){let{index:r}=e,{index:i}=t;if(i>r){const e=i;i=r,r=e}this.matrix[(r*(r+1)>>1)+i-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class Zs{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;return void 0===n[e]&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return!(void 0===n[e]||!n[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const n=this._listeners;if(void 0===n[e])return this;const r=n[e].indexOf(t);return-1!==r&&n[e].splice(r,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let n=0,r=t.length;n<r;n++)t[n].call(this,e)}return this}}class Ks{constructor(e,t,n,r){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===r&&(r=1),this.x=e,this.y=t,this.z=n,this.w=r}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(.5*t);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new Ls),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=Qs,n=Js;e.tangents(t,n),this.setFromAxisAngle(t,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new Ks);const n=this.x,r=this.y,i=this.z,s=this.w,o=e.x,a=e.y,c=e.z,l=e.w;return t.x=n*l+s*o+r*c-i*a,t.y=r*l+s*a+i*o-n*c,t.z=i*l+s*c+n*a-r*o,t.w=s*l-n*o-r*a-i*c,t}inverse(e){void 0===e&&(e=new Ks);const t=this.x,n=this.y,r=this.z,i=this.w;this.conjugate(e);const s=1/(t*t+n*n+r*r+i*i);return e.x*=s,e.y*=s,e.z*=s,e.w*=s,e}conjugate(e){return void 0===e&&(e=new Ks),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new Ls);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z,c=this.w,l=c*n+o*i-a*r,u=c*r+a*n-s*i,h=c*i+s*r-o*n,d=-s*n-o*r-a*i;return t.x=l*c+d*-s+u*-a-h*-o,t.y=u*c+d*-o+h*-s-l*-a,t.z=h*c+d*-a+l*-o-u*-s,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let n,r,i;void 0===t&&(t="YZX");const s=this.x,o=this.y,a=this.z,c=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=s*o+a*c;if(e>.499&&(n=2*Math.atan2(s,c),r=Math.PI/2,i=0),e<-.499&&(n=-2*Math.atan2(s,c),r=-Math.PI/2,i=0),void 0===n){const t=s*s,l=o*o,u=a*a;n=Math.atan2(2*o*c-2*s*a,1-2*l-2*u),r=Math.asin(2*e),i=Math.atan2(2*s*c-2*o*a,1-2*t-2*u)}}e.y=n,e.z=r,e.x=i}setFromEuler(e,t,n,r){void 0===r&&(r="XYZ");const i=Math.cos(e/2),s=Math.cos(t/2),o=Math.cos(n/2),a=Math.sin(e/2),c=Math.sin(t/2),l=Math.sin(n/2);return"XYZ"===r?(this.x=a*s*o+i*c*l,this.y=i*c*o-a*s*l,this.z=i*s*l+a*c*o,this.w=i*s*o-a*c*l):"YXZ"===r?(this.x=a*s*o+i*c*l,this.y=i*c*o-a*s*l,this.z=i*s*l-a*c*o,this.w=i*s*o+a*c*l):"ZXY"===r?(this.x=a*s*o-i*c*l,this.y=i*c*o+a*s*l,this.z=i*s*l+a*c*o,this.w=i*s*o-a*c*l):"ZYX"===r?(this.x=a*s*o-i*c*l,this.y=i*c*o+a*s*l,this.z=i*s*l-a*c*o,this.w=i*s*o+a*c*l):"YZX"===r?(this.x=a*s*o+i*c*l,this.y=i*c*o+a*s*l,this.z=i*s*l-a*c*o,this.w=i*s*o-a*c*l):"XZY"===r&&(this.x=a*s*o-i*c*l,this.y=i*c*o-a*s*l,this.z=i*s*l+a*c*o,this.w=i*s*o+a*c*l),this}clone(){return new Ks(this.x,this.y,this.z,this.w)}slerp(e,t,n){void 0===n&&(n=new Ks);const r=this.x,i=this.y,s=this.z,o=this.w;let a,c,l,u,h,d=e.x,f=e.y,p=e.z,m=e.w;return c=r*d+i*f+s*p+o*m,c<0&&(c=-c,d=-d,f=-f,p=-p,m=-m),1-c>1e-6?(a=Math.acos(c),l=Math.sin(a),u=Math.sin((1-t)*a)/l,h=Math.sin(t*a)/l):(u=1-t,h=t),n.x=u*r+h*d,n.y=u*i+h*f,n.z=u*s+h*p,n.w=u*o+h*m,n}integrate(e,t,n,r){void 0===r&&(r=new Ks);const i=e.x*n.x,s=e.y*n.y,o=e.z*n.z,a=this.x,c=this.y,l=this.z,u=this.w,h=.5*t;return r.x+=h*(i*u+s*l-o*c),r.y+=h*(s*u+o*a-i*l),r.z+=h*(o*u+i*c-s*a),r.w+=h*(-i*a-s*c-o*l),r}}const Qs=new Ls,Js=new Ls;class eo{constructor(e){void 0===e&&(e={}),this.id=eo.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,n,r){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}eo.idCounter=0,eo.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class to{constructor(e){void 0===e&&(e={}),this.position=new Ls,this.quaternion=new Ks,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return to.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return to.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new Ls),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,r){return void 0===r&&(r=new Ls),n.vsub(e,r),t.conjugate(no),no.vmult(r,r),r}static pointToWorldFrame(e,t,n,r){return void 0===r&&(r=new Ls),t.vmult(n,r),r.vadd(e,r),r}static vectorToWorldFrame(e,t,n){return void 0===n&&(n=new Ls),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,r){return void 0===r&&(r=new Ls),t.w*=-1,t.vmult(n,r),t.w*=-1,r}}const no=new Ks;class ro extends eo{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:n=[],normals:r=[],axes:i,boundingSphereRadius:s}=e;super({type:eo.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=r,0===this.faceNormals.length&&this.computeNormals(),s?this.boundingSphereRadius=s:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const r=new Ls;for(let i=0;i!==e.length;i++){const s=e[i],o=s.length;for(let e=0;e!==o;e++){const i=(e+1)%o;t[s[e]].vsub(t[s[i]],r),r.normalize();let a=!1;for(let e=0;e!==n.length;e++)if(n[e].almostEquals(r)||n[e].almostEquals(r)){a=!0;break}a||n.push(r.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new Ls;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],r=this.vertices[n[0]],i=this.vertices[n[1]],s=this.vertices[n[2]];ro.computeNormal(r,i,s,t)}static computeNormal(e,t,n,r){const i=new Ls,s=new Ls;t.vsub(e,s),n.vsub(t,i),i.cross(s,r),r.isZero()||r.normalize()}clipAgainstHull(e,t,n,r,i,s,o,a,c){const l=new Ls;let u=-1,h=-Number.MAX_VALUE;for(let e=0;e<n.faces.length;e++){l.copy(n.faceNormals[e]),i.vmult(l,l);const t=l.dot(s);t>h&&(h=t,u=e)}const d=[];for(let e=0;e<n.faces[u].length;e++){const t=n.vertices[n.faces[u][e]],s=new Ls;s.copy(t),i.vmult(s,s),r.vadd(s,s),d.push(s)}u>=0&&this.clipFaceAgainstHull(s,e,t,d,o,a,c)}findSeparatingAxis(e,t,n,r,i,s,o,a){const c=new Ls,l=new Ls,u=new Ls,h=new Ls,d=new Ls,f=new Ls;let p=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let o=0;o!==m.uniqueAxes.length;o++){n.vmult(m.uniqueAxes[o],c);const a=m.testSepAxis(c,e,t,n,r,i);if(!1===a)return!1;a<p&&(p=a,s.copy(c))}else{const a=o?o.length:m.faces.length;for(let l=0;l<a;l++){const a=o?o[l]:l;c.copy(m.faceNormals[a]),n.vmult(c,c);const u=m.testSepAxis(c,e,t,n,r,i);if(!1===u)return!1;u<p&&(p=u,s.copy(c))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){i.vmult(e.uniqueAxes[o],l);const a=m.testSepAxis(l,e,t,n,r,i);if(!1===a)return!1;a<p&&(p=a,s.copy(l))}else{const o=a?a.length:e.faces.length;for(let c=0;c<o;c++){const o=a?a[c]:c;l.copy(e.faceNormals[o]),i.vmult(l,l);const u=m.testSepAxis(l,e,t,n,r,i);if(!1===u)return!1;u<p&&(p=u,s.copy(l))}}for(let o=0;o!==m.uniqueEdges.length;o++){n.vmult(m.uniqueEdges[o],h);for(let o=0;o!==e.uniqueEdges.length;o++)if(i.vmult(e.uniqueEdges[o],d),h.cross(d,f),!f.almostZero()){f.normalize();const o=m.testSepAxis(f,e,t,n,r,i);if(!1===o)return!1;o<p&&(p=o,s.copy(f))}}return r.vsub(t,u),u.dot(s)>0&&s.negate(s),!0}testSepAxis(e,t,n,r,i,s){ro.project(this,e,n,r,io),ro.project(t,e,i,s,so);const o=io[0],a=io[1],c=so[0],l=so[1];if(o<l||c<a)return!1;const u=o-l,h=c-a;return u<h?u:h}calculateLocalInertia(e,t){const n=new Ls,r=new Ls;this.computeLocalAABB(r,n);const i=n.x-r.x,s=n.y-r.y,o=n.z-r.z;t.x=1/12*e*(2*s*2*s+2*o*2*o),t.y=1/12*e*(2*i*2*i+2*o*2*o),t.z=1/12*e*(2*s*2*s+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],r=this.vertices[t[0]];return-n.dot(r)}clipFaceAgainstHull(e,t,n,r,i,s,o){const a=new Ls,c=new Ls,l=new Ls,u=new Ls,h=new Ls,d=new Ls,f=new Ls,p=new Ls,m=this,g=r,y=[];let v=-1,x=Number.MAX_VALUE;for(let t=0;t<m.faces.length;t++){a.copy(m.faceNormals[t]),n.vmult(a,a);const r=a.dot(e);r<x&&(x=r,v=t)}if(v<0)return;const w=m.faces[v];w.connectedFaces=[];for(let e=0;e<m.faces.length;e++)for(let t=0;t<m.faces[e].length;t++)-1!==w.indexOf(m.faces[e][t])&&e!==v&&-1===w.connectedFaces.indexOf(e)&&w.connectedFaces.push(e);const b=w.length;for(let e=0;e<b;e++){const r=m.vertices[w[e]],i=m.vertices[w[(e+1)%b]];r.vsub(i,c),l.copy(c),n.vmult(l,l),t.vadd(l,l),u.copy(this.faceNormals[v]),n.vmult(u,u),t.vadd(u,u),l.cross(u,h),h.negate(h),d.copy(r),n.vmult(d,d),t.vadd(d,d);const s=w.connectedFaces[e];f.copy(this.faceNormals[s]);const o=this.getPlaneConstantOfFace(s);p.copy(f),n.vmult(p,p);const a=o-p.dot(t);for(this.clipFaceAgainstPlane(g,y,p,a);g.length;)g.shift();for(;y.length;)g.push(y.shift())}f.copy(this.faceNormals[v]);const _=this.getPlaneConstantOfFace(v);p.copy(f),n.vmult(p,p);const k=_-p.dot(t);for(let e=0;e<g.length;e++){let t=p.dot(g[e])+k;if(t<=i&&(console.log(`clamped: depth=${t} to minDist=${i}`),t=i),t<=s){const n=g[e];if(t<=1e-6){const e={point:n,normal:p,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,n,r){let i,s;const o=e.length;if(o<2)return t;let a=e[e.length-1],c=e[0];i=n.dot(a)+r;for(let l=0;l<o;l++){if(c=e[l],s=n.dot(c)+r,i<0)if(s<0){const e=new Ls;e.copy(c),t.push(e)}else{const e=new Ls;a.lerp(c,i/(i-s),e),t.push(e)}else if(s<0){const e=new Ls;a.lerp(c,i/(i-s),e),t.push(e),t.push(c)}a=c,i=s}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new Ls);const n=this.vertices,r=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(n[i],r[i]),e.vadd(r[i],r[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let r=0;r<this.vertices.length;r++){const i=n[r];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new Ls);const n=this.faceNormals,r=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(n[i],r[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const r=t[n].lengthSquared();r>e&&(e=r)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,r){const i=this.vertices;let s,o,a,c,l,u,h=new Ls;for(let n=0;n<i.length;n++){h.copy(i[n]),t.vmult(h,h),e.vadd(h,h);const r=h;(void 0===s||r.x<s)&&(s=r.x),(void 0===c||r.x>c)&&(c=r.x),(void 0===o||r.y<o)&&(o=r.y),(void 0===l||r.y>l)&&(l=r.y),(void 0===a||r.z<a)&&(a=r.z),(void 0===u||r.z>u)&&(u=r.z)}n.set(s,o,a),r.set(c,l,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new Ls);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,r=this.vertices;if(t){for(let e=0;e<n;e++){const n=r[e];t.vmult(n,n)}for(let e=0;e<this.faceNormals.length;e++){const n=this.faceNormals[e];t.vmult(n,n)}}if(e)for(let t=0;t<n;t++){const n=r[t];n.vadd(e,n)}}pointIsInside(e){const t=this.vertices,n=this.faces,r=this.faceNormals,i=new Ls;this.getAveragePointLocal(i);for(let s=0;s<this.faces.length;s++){let o=r[s];const a=t[n[s][0]],c=new Ls;e.vsub(a,c);const l=o.dot(c),u=new Ls;i.vsub(a,u);const h=o.dot(u);if(l<0&&h>0||l>0&&h<0)return!1}return-1}static project(e,t,n,r,i){const s=e.vertices.length,o=oo;let a=0,c=0;const l=ao,u=e.vertices;l.setZero(),to.vectorToLocalFrame(n,r,t,o),to.pointToLocalFrame(n,r,l,l);const h=l.dot(o);c=a=u[0].dot(o);for(let e=1;e<s;e++){const t=u[e].dot(o);t>a&&(a=t),t<c&&(c=t)}if(c-=h,a-=h,c>a){const e=c;c=a,a=e}i[0]=a,i[1]=c}}const io=[],so=[],oo=(new Ls,new Ls),ao=new Ls;class co extends eo{constructor(e){super({type:eo.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,r=Ls,i=[new r(-e,-t,-n),new r(e,-t,-n),new r(e,t,-n),new r(-e,t,-n),new r(-e,-t,n),new r(e,-t,n),new r(e,t,n),new r(-e,t,n)],s=[new r(0,0,1),new r(0,1,0),new r(1,0,0)],o=new ro({vertices:i,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:s});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new Ls),co.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const r=e;n.x=1/12*t*(2*r.y*2*r.y+2*r.z*2*r.z),n.y=1/12*t*(2*r.x*2*r.x+2*r.z*2*r.z),n.z=1/12*t*(2*r.y*2*r.y+2*r.x*2*r.x)}getSideNormals(e,t){const n=e,r=this.halfExtents;if(n[0].set(r.x,0,0),n[1].set(0,r.y,0),n[2].set(0,0,r.z),n[3].set(-r.x,0,0),n[4].set(0,-r.y,0),n[5].set(0,0,-r.z),void 0!==t)for(let e=0;e!==n.length;e++)t.vmult(n[e],n[e]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const r=this.halfExtents,i=[[r.x,r.y,r.z],[-r.x,r.y,r.z],[-r.x,-r.y,r.z],[-r.x,-r.y,-r.z],[r.x,-r.y,-r.z],[r.x,r.y,-r.z],[-r.x,r.y,-r.z],[r.x,-r.y,r.z]];for(let r=0;r<i.length;r++)lo.set(i[r][0],i[r][1],i[r][2]),t.vmult(lo,lo),e.vadd(lo,lo),n(lo.x,lo.y,lo.z)}calculateWorldAABB(e,t,n,r){const i=this.halfExtents;uo[0].set(i.x,i.y,i.z),uo[1].set(-i.x,i.y,i.z),uo[2].set(-i.x,-i.y,i.z),uo[3].set(-i.x,-i.y,-i.z),uo[4].set(i.x,-i.y,-i.z),uo[5].set(i.x,i.y,-i.z),uo[6].set(-i.x,i.y,-i.z),uo[7].set(i.x,-i.y,i.z);const s=uo[0];t.vmult(s,s),e.vadd(s,s),r.copy(s),n.copy(s);for(let i=1;i<8;i++){const s=uo[i];t.vmult(s,s),e.vadd(s,s);const o=s.x,a=s.y,c=s.z;o>r.x&&(r.x=o),a>r.y&&(r.y=a),c>r.z&&(r.z=c),o<n.x&&(n.x=o),a<n.y&&(n.y=a),c<n.z&&(n.z=c)}}}const lo=new Ls,uo=[new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls];class ho extends Zs{constructor(e){void 0===e&&(e={}),super(),this.id=ho.idCounter++,this.index=-1,this.world=null,this.vlambda=new Ls,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new Ls,this.previousPosition=new Ls,this.interpolatedPosition=new Ls,this.initPosition=new Ls,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new Ls,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new Ls,this.force=new Ls;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?ho.STATIC:ho.DYNAMIC,typeof e.type==typeof ho.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=ho.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new Ls,this.quaternion=new Ks,this.initQuaternion=new Ks,this.previousQuaternion=new Ks,this.interpolatedQuaternion=new Ks,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new Ls,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new Ls,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new Ls,this.invInertia=new Ls,this.invInertiaWorld=new qs,this.invMassSolve=0,this.invInertiaSolve=new Ls,this.invInertiaWorldSolve=new qs,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new Ls(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new Ls(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new Ys,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new Ls,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=ho.AWAKE,this.wakeUpAfterNarrowphase=!1,e===ho.SLEEPING&&this.dispatchEvent(ho.wakeupEvent)}sleep(){this.sleepState=ho.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),r=this.sleepSpeedLimit**2;t===ho.AWAKE&&n<r?(this.sleepState=ho.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(ho.sleepyEvent)):t===ho.SLEEPY&&n>r?this.wakeUp():t===ho.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(ho.sleepEvent))}}updateSolveMassProperties(){this.sleepState===ho.SLEEPING||this.type===ho.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new Ls),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new Ls),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new Ls),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new Ls),this.quaternion.vmult(e,t),t}addShape(e,t,n){const r=new Ls,i=new Ks;return t&&r.copy(t),n&&i.copy(n),this.shapes.push(e),this.shapeOffsets.push(r),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let r=0;for(let i=0;i!==n;i++){const n=e[i];n.updateBoundingSphereRadius();const s=t[i].length(),o=n.boundingSphereRadius;s+o>r&&(r=s+o)}this.boundingRadius=r}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,r=e.length,i=fo,s=po,o=this.quaternion,a=this.aabb,c=mo;for(let l=0;l!==r;l++){const r=e[l];o.vmult(t[l],i),i.vadd(this.position,i),o.mult(n[l],s),r.calculateWorldAABB(i,s,c.lowerBound,c.upperBound),0===l?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=go,n=yo;e.setRotationFromQuaternion(this.quaternion),e.transpose(n),e.scale(t,e),e.mmult(n,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new Ls),this.type!==ho.DYNAMIC)return;this.sleepState===ho.SLEEPING&&this.wakeUp();const n=vo;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new Ls),this.type!==ho.DYNAMIC)return;const n=xo,r=wo;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyForce(n,r)}applyTorque(e){this.type===ho.DYNAMIC&&(this.sleepState===ho.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new Ls),this.type!==ho.DYNAMIC)return;this.sleepState===ho.SLEEPING&&this.wakeUp();const n=t,r=bo;r.copy(e),r.scale(this.invMass,r),this.velocity.vadd(r,this.velocity);const i=_o;n.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new Ls),this.type!==ho.DYNAMIC)return;const n=ko,r=To;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyImpulse(n,r)}updateMassProperties(){const e=So;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),co.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new Ls;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==ho.DYNAMIC&&this.type!==ho.KINEMATIC||this.sleepState===ho.SLEEPING)return;const r=this.velocity,i=this.angularVelocity,s=this.position,o=this.force,a=this.torque,c=this.quaternion,l=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,d=l*e;r.x+=o.x*d*h.x,r.y+=o.y*d*h.y,r.z+=o.z*d*h.z;const f=u.elements,p=this.angularFactor,m=a.x*p.x,g=a.y*p.y,y=a.z*p.z;i.x+=e*(f[0]*m+f[1]*g+f[2]*y),i.y+=e*(f[3]*m+f[4]*g+f[5]*y),i.z+=e*(f[6]*m+f[7]*g+f[8]*y),s.x+=r.x*e,s.y+=r.y*e,s.z+=r.z*e,c.integrate(this.angularVelocity,e,this.angularFactor,c),t&&(n?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}ho.idCounter=0,ho.COLLIDE_EVENT_NAME="collide",ho.DYNAMIC=1,ho.STATIC=2,ho.KINEMATIC=4,ho.AWAKE=0,ho.SLEEPY=1,ho.SLEEPING=2,ho.wakeupEvent={type:"wakeup"},ho.sleepyEvent={type:"sleepy"},ho.sleepEvent={type:"sleep"};const fo=new Ls,po=new Ks,mo=new Ys,go=new qs,yo=new qs,vo=(new qs,new Ls),xo=new Ls,wo=new Ls,bo=new Ls,_o=new Ls,ko=new Ls,To=new Ls,So=new Ls;class Po{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&ho.STATIC)&&e.sleepState!==ho.SLEEPING||0==(t.type&ho.STATIC)&&t.sleepState!==ho.SLEEPING)}intersectionTest(e,t,n,r){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,r):this.doBoundingSphereBroadphase(e,t,n,r)}doBoundingSphereBroadphase(e,t,n,r){const i=Eo;t.position.vsub(e.position,i);const s=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<s&&(n.push(e),r.push(t))}doBoundingBoxBroadphase(e,t,n,r){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),r.push(t))}makePairsUnique(e,t){const n=Ao,r=Mo,i=zo,s=e.length;for(let n=0;n!==s;n++)r[n]=e[n],i[n]=t[n];e.length=0,t.length=0;for(let e=0;e!==s;e++){const t=r[e].id,s=i[e].id,o=t<s?`${t},${s}`:`${s},${t}`;n[o]=e,n.keys.push(o)}for(let s=0;s!==n.keys.length;s++){const s=n.keys.pop(),o=n[s];e.push(r[o]),t.push(i[o]),delete n[s]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new Ls;e.position.vsub(t.position,n);const r=e.shapes[0],i=t.shapes[0];return Math.pow(r.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Eo=new Ls;new Ls,new Ks,new Ls;const Ao={keys:[]},Mo=[],zo=[];new Ls,new Ls,new Ls;class Io extends Po{constructor(){super()}collisionPairs(e,t,n){const r=e.bodies,i=r.length;let s,o;for(let e=0;e!==i;e++)for(let i=0;i!==e;i++)s=r[e],o=r[i],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,t,n)}aabbQuery(e,t,n){void 0===n&&(n=[]);for(let r=0;r<e.bodies.length;r++){const i=e.bodies[r];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&n.push(i)}return n}}class Co{constructor(){this.rayFromWorld=new Ls,this.rayToWorld=new Ls,this.hitNormalWorld=new Ls,this.hitPointWorld=new Ls,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,r,i,s,o){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(r),this.shape=i,this.body=s,this.distance=o}}let Bo,Oo,Ro,Uo,No,jo,Do;Bo=eo.types.SPHERE,Oo=eo.types.PLANE,Ro=eo.types.BOX,Uo=eo.types.CYLINDER,No=eo.types.CONVEXPOLYHEDRON,jo=eo.types.HEIGHTFIELD,Do=eo.types.TRIMESH;class qo{get[Bo](){return this._intersectSphere}get[Oo](){return this._intersectPlane}get[Ro](){return this._intersectBox}get[Uo](){return this._intersectConvex}get[No](){return this._intersectConvex}get[jo](){return this._intersectHeightfield}get[Do](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new Ls),void 0===t&&(t=new Ls),this.from=e.clone(),this.to=t.clone(),this.direction=new Ls,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=qo.ANY,this.result=new Co,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||qo.ANY,this.result=t.result||new Co,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(Fo),Lo.length=0,e.broadphase.aabbQuery(e,Fo,Lo),this.intersectBodies(Lo),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const r=Wo,i=Yo;for(let t=0,s=e.shapes.length;t<s;t++){const s=e.shapes[t];if((!n||s.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],i),e.quaternion.vmult(e.shapeOffsets[t],r),r.vadd(e.position,r),this.intersectShape(s,i,r,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,n=e.length;!this.result.shouldStop&&t<n;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,r){const i=function(e,t,n){n.vsub(e,fa);const r=fa.dot(t);t.scale(r,pa),pa.vadd(e,pa);return n.distanceTo(pa)}(this.from,this.direction,n);if(i>e.boundingSphereRadius)return;const s=this[e.type];s&&s.call(this,e,t,n,r,e)}_intersectBox(e,t,n,r,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,r,i)}_intersectPlane(e,t,n,r,i){const s=this.from,o=this.to,a=this.direction,c=new Ls(0,0,1);t.vmult(c,c);const l=new Ls;s.vsub(n,l);const u=l.dot(c);if(o.vsub(n,l),u*l.dot(c)>0)return;if(s.distanceTo(o)<u)return;const h=c.dot(a);if(Math.abs(h)<this.precision)return;const d=new Ls,f=new Ls,p=new Ls;s.vsub(n,d);const m=-c.dot(d)/h;a.scale(m,f),s.vadd(f,p),this.reportIntersection(c,p,i,r,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,r=this.to,i=this.from;t.x=Math.min(r.x,i.x),t.y=Math.min(r.y,i.y),t.z=Math.min(r.z,i.z),n.x=Math.max(r.x,i.x),n.y=Math.max(r.y,i.y),n.z=Math.max(r.z,i.z)}_intersectHeightfield(e,t,n,r,i){e.data,e.elementSize;const s=Jo;s.from.copy(this.from),s.to.copy(this.to),to.pointToLocalFrame(n,t,s.from,s.from),to.pointToLocalFrame(n,t,s.to,s.to),s.updateDirection();const o=ea;let a,c,l,u;a=c=0,l=u=e.data.length-1;const h=new Ys;s.getAABB(h),e.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,o,!0),a=Math.max(a,o[0]),c=Math.max(c,o[1]),e.getIndexOfPosition(h.upperBound.x,h.upperBound.y,o,!0),l=Math.min(l,o[0]+1),u=Math.min(u,o[1]+1);for(let o=a;o<l;o++)for(let a=c;a<u;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(o,a,h),h.overlapsRay(s)){if(e.getConvexTrianglePillar(o,a,!1),to.pointToWorldFrame(n,t,e.pillarOffset,Qo),this._intersectConvex(e.pillarConvex,t,Qo,r,i,Ko),this.result.shouldStop)return;e.getConvexTrianglePillar(o,a,!0),to.pointToWorldFrame(n,t,e.pillarOffset,Qo),this._intersectConvex(e.pillarConvex,t,Qo,r,i,Ko)}}}_intersectSphere(e,t,n,r,i){const s=this.from,o=this.to,a=e.radius,c=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2,l=2*((o.x-s.x)*(s.x-n.x)+(o.y-s.y)*(s.y-n.y)+(o.z-s.z)*(s.z-n.z)),u=l**2-4*c*((s.x-n.x)**2+(s.y-n.y)**2+(s.z-n.z)**2-a**2),h=ta,d=na;if(!(u<0))if(0===u)s.lerp(o,u,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1);else{const e=(-l-Math.sqrt(u))/(2*c),t=(-l+Math.sqrt(u))/(2*c);if(e>=0&&e<=1&&(s.lerp(o,e,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(s.lerp(o,t,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1))}}_intersectConvex(e,t,n,r,i,s){const o=ra,a=ia,c=s&&s.faceList||null,l=e.faces,u=e.vertices,h=e.faceNormals,d=this.direction,f=this.from,p=this.to,m=f.distanceTo(p),g=c?c.length:l.length,y=this.result;for(let e=0;!y.shouldStop&&e<g;e++){const s=c?c[e]:e,p=l[s],g=h[s],v=t,x=n;a.copy(u[p[0]]),v.vmult(a,a),a.vadd(x,a),a.vsub(f,a),v.vmult(g,o);const w=d.dot(o);if(Math.abs(w)<this.precision)continue;const b=o.dot(a)/w;if(!(b<0)){d.scale(b,Ho),Ho.vadd(f,Ho),$o.copy(u[p[0]]),v.vmult($o,$o),x.vadd($o,$o);for(let e=1;!y.shouldStop&&e<p.length-1;e++){Xo.copy(u[p[e]]),Zo.copy(u[p[e+1]]),v.vmult(Xo,Xo),v.vmult(Zo,Zo),x.vadd(Xo,Xo),x.vadd(Zo,Zo);const t=Ho.distanceTo(f);!qo.pointInTriangle(Ho,$o,Xo,Zo)&&!qo.pointInTriangle(Ho,Xo,$o,Zo)||t>m||this.reportIntersection(o,Ho,i,r,s)}}}}_intersectTrimesh(e,t,n,r,i,s){const o=sa,a=ha,c=da,l=ia,u=oa,h=aa,d=ca,f=ua,p=la,m=e.indices;e.vertices;const g=this.from,y=this.to,v=this.direction;c.position.copy(n),c.quaternion.copy(t),to.vectorToLocalFrame(n,t,v,u),to.pointToLocalFrame(n,t,g,h),to.pointToLocalFrame(n,t,y,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,d.vsub(h,u),u.normalize();const x=h.distanceSquared(d);e.tree.rayQuery(this,c,a);for(let s=0,c=a.length;!this.result.shouldStop&&s!==c;s++){const c=a[s];e.getNormal(c,o),e.getVertex(m[3*c],$o),$o.vsub(h,l);const d=u.dot(o),g=o.dot(l)/d;if(g<0)continue;u.scale(g,Ho),Ho.vadd(h,Ho),e.getVertex(m[3*c+1],Xo),e.getVertex(m[3*c+2],Zo);const y=Ho.distanceSquared(h);!qo.pointInTriangle(Ho,Xo,$o,Zo)&&!qo.pointInTriangle(Ho,$o,Xo,Zo)||y>x||(to.vectorToWorldFrame(t,o,p),to.pointToWorldFrame(n,t,Ho,f),this.reportIntersection(p,f,i,r,c))}a.length=0}reportIntersection(e,t,n,r,i){const s=this.from,o=this.to,a=s.distanceTo(t),c=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(c.hitFaceIndex=void 0!==i?i:-1,this.mode){case qo.ALL:this.hasHit=!0,c.set(s,o,e,t,n,r,a),c.hasHit=!0,this.callback(c);break;case qo.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(s,o,e,t,n,r,a));break;case qo.ANY:this.hasHit=!0,c.hasHit=!0,c.set(s,o,e,t,n,r,a),c.shouldStop=!0}}static pointInTriangle(e,t,n,r){r.vsub(t,fa),n.vsub(t,Vo),e.vsub(t,Go);const i=fa.dot(fa),s=fa.dot(Vo),o=fa.dot(Go),a=Vo.dot(Vo),c=Vo.dot(Go);let l,u;return(l=a*o-s*c)>=0&&(u=i*c-s*o)>=0&&l+u<i*a-s*s}}qo.CLOSEST=1,qo.ANY=2,qo.ALL=4;const Fo=new Ys,Lo=[],Vo=new Ls,Go=new Ls,Wo=new Ls,Yo=new Ks,Ho=new Ls,$o=new Ls,Xo=new Ls,Zo=new Ls;new Ls,new Co;const Ko={faceList:[0]},Qo=new Ls,Jo=new qo,ea=[],ta=new Ls,na=new Ls,ra=new Ls,ia=(new Ls,new Ls,new Ls),sa=new Ls,oa=new Ls,aa=new Ls,ca=new Ls,la=new Ls,ua=new Ls;new Ys;const ha=[],da=new to,fa=new Ls,pa=new Ls;class ma{static defaults(e,t){void 0===e&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class ga{constructor(e,t,n){void 0===n&&(n={}),n=ma.defaults(n,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=ga.idCounter++,this.collideConnected=n.collideConnected,n.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}ga.idCounter=0;class ya{constructor(){this.spatial=new Ls,this.rotational=new Ls}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class va{constructor(e,t,n,r){void 0===n&&(n=-1e6),void 0===r&&(r=1e6),this.id=va.idCounter++,this.minForce=n,this.maxForce=r,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new ya,this.jacobianElementB=new ya,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const r=t,i=e,s=n;this.a=4/(s*(1+4*r)),this.b=4*r/(1+4*r),this.eps=4/(s*s*i*(1+4*r))}computeB(e,t,n){const r=this.computeGW();return-this.computeGq()*e-r*t-this.computeGiMf()*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.position,s=r.position;return e.spatial.dot(i)+t.spatial.dot(s)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.velocity,s=r.velocity,o=n.angularVelocity,a=r.angularVelocity;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.vlambda,s=r.vlambda,o=n.wlambda,a=r.wlambda;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.force,s=n.torque,o=r.force,a=r.torque,c=n.invMassSolve,l=r.invMassSolve;return i.scale(c,xa),o.scale(l,wa),n.invInertiaWorldSolve.vmult(s,ba),r.invInertiaWorldSolve.vmult(a,_a),e.multiplyVectors(xa,ba)+t.multiplyVectors(wa,_a)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.invMassSolve,s=r.invMassSolve,o=n.invInertiaWorldSolve,a=r.invInertiaWorldSolve;let c=i+s;return o.vmult(e.rotational,ka),c+=ka.dot(e.rotational),a.vmult(t.rotational,ka),c+=ka.dot(t.rotational),c}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,r=this.bi,i=this.bj,s=Ta;r.vlambda.addScaledVector(r.invMassSolve*e,t.spatial,r.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,n.spatial,i.vlambda),r.invInertiaWorldSolve.vmult(t.rotational,s),r.wlambda.addScaledVector(e,s,r.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,s),i.wlambda.addScaledVector(e,s,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}va.idCounter=0;const xa=new Ls,wa=new Ls,ba=new Ls,_a=new Ls,ka=new Ls,Ta=new Ls;class Sa extends va{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new Ls,this.rj=new Ls,this.ni=new Ls}computeB(e){const t=this.a,n=this.b,r=this.bi,i=this.bj,s=this.ri,o=this.rj,a=Pa,c=Ea,l=r.velocity,u=r.angularVelocity;r.force,r.torque;const h=i.velocity,d=i.angularVelocity;i.force,i.torque;const f=Aa,p=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;s.cross(g,a),o.cross(g,c),g.negate(p.spatial),a.negate(p.rotational),m.spatial.copy(g),m.rotational.copy(c),f.copy(i.position),f.vadd(o,f),f.vsub(r.position,f),f.vsub(s,f);const y=g.dot(f),v=this.restitution+1;return-y*t-(v*h.dot(g)-v*l.dot(g)+d.dot(c)-u.dot(a))*n-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=Ma,t=za,n=Ia,r=Ca,i=Ba;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,r),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(r,t),e.vsub(t,i),this.ni.dot(i)}}const Pa=new Ls,Ea=new Ls,Aa=new Ls,Ma=new Ls,za=new Ls,Ia=new Ls,Ca=new Ls,Ba=new Ls;class Oa extends ga{constructor(e,t,n,r,i){void 0===t&&(t=new Ls),void 0===r&&(r=new Ls),void 0===i&&(i=1e6),super(e,n),this.pivotA=t.clone(),this.pivotB=r.clone();const s=this.equationX=new Sa(e,n),o=this.equationY=new Sa(e,n),a=this.equationZ=new Sa(e,n);this.equations.push(s,o,a),s.minForce=o.minForce=a.minForce=-i,s.maxForce=o.maxForce=a.maxForce=i,s.ni.set(1,0,0),o.ni.set(0,1,0),a.ni.set(0,0,1)}update(){const e=this.bodyA,t=this.bodyB,n=this.equationX,r=this.equationY,i=this.equationZ;e.quaternion.vmult(this.pivotA,n.ri),t.quaternion.vmult(this.pivotB,n.rj),r.ri.copy(n.ri),r.rj.copy(n.rj),i.ri.copy(n.ri),i.rj.copy(n.rj)}}new Ls,new Ls;class Ra extends va{constructor(e,t,n){void 0===n&&(n={});const r=void 0!==n.maxForce?n.maxForce:1e6;super(e,t,-r,r),this.axisA=n.axisA?n.axisA.clone():new Ls(1,0,0),this.axisB=n.axisB?n.axisB.clone():new Ls(0,1,0),this.maxAngle=Math.PI/2}computeB(e){const t=this.a,n=this.b,r=this.axisA,i=this.axisB,s=Ua,o=Na,a=this.jacobianElementA,c=this.jacobianElementB;return r.cross(i,s),i.cross(r,o),a.rotational.copy(o),c.rotational.copy(s),-(Math.cos(this.maxAngle)-r.dot(i))*t-this.computeGW()*n-e*this.computeGiMf()}}const Ua=new Ls,Na=new Ls;new Ls,new Ls,new Ls,new Ls;class ja extends va{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,-n,n),this.axisA=new Ls,this.axisB=new Ls,this.targetVelocity=0}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.axisA,r=this.axisB,i=this.jacobianElementA,s=this.jacobianElementB;return i.rotational.copy(n),r.negate(s.rotational),-(this.computeGW()-this.targetVelocity)*t-e*this.computeGiMf()}}class Da extends Oa{constructor(e,t,n){void 0===n&&(n={});const r=void 0!==n.maxForce?n.maxForce:1e6;super(e,n.pivotA?n.pivotA.clone():new Ls,t,n.pivotB?n.pivotB.clone():new Ls,r),(this.axisA=n.axisA?n.axisA.clone():new Ls(1,0,0)).normalize(),(this.axisB=n.axisB?n.axisB.clone():new Ls(1,0,0)).normalize(),this.collideConnected=!!n.collideConnected;const i=this.rotationalEquation1=new Ra(e,t,n),s=this.rotationalEquation2=new Ra(e,t,n),o=this.motorEquation=new ja(e,t,r);o.enabled=!1,this.equations.push(i,s,o)}enableMotor(){this.motorEquation.enabled=!0}disableMotor(){this.motorEquation.enabled=!1}setMotorSpeed(e){this.motorEquation.targetVelocity=e}setMotorMaxForce(e){this.motorEquation.maxForce=e,this.motorEquation.minForce=-e}update(){const e=this.bodyA,t=this.bodyB,n=this.motorEquation,r=this.rotationalEquation1,i=this.rotationalEquation2,s=qa,o=Fa,a=this.axisA,c=this.axisB;super.update(),e.quaternion.vmult(a,s),t.quaternion.vmult(c,o),s.tangents(r.axisA,i.axisA),r.axisB.copy(o),i.axisB.copy(o),this.motorEquation.enabled&&(e.quaternion.vmult(this.axisA,n.axisA),t.quaternion.vmult(this.axisB,n.axisB))}}const qa=new Ls,Fa=new Ls;class La extends va{constructor(e,t,n){super(e,t,-n,n),this.ri=new Ls,this.rj=new Ls,this.t=new Ls}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,r=this.rj,i=Va,s=Ga,o=this.t;n.cross(o,i),r.cross(o,s);const a=this.jacobianElementA,c=this.jacobianElementB;return o.negate(a.spatial),i.negate(a.rotational),c.spatial.copy(o),c.rotational.copy(s),-this.computeGW()*t-e*this.computeGiMf()}}const Va=new Ls,Ga=new Ls;class Wa{constructor(e,t,n){n=ma.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Wa.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}Wa.idCounter=0;class Ya{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=Ya.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}Ya.idCounter=0;class Ha{constructor(e,t,n){void 0===n&&(n={}),this.restLength="number"==typeof n.restLength?n.restLength:1,this.stiffness=n.stiffness||100,this.damping=n.damping||1,this.bodyA=e,this.bodyB=t,this.localAnchorA=new Ls,this.localAnchorB=new Ls,n.localAnchorA&&this.localAnchorA.copy(n.localAnchorA),n.localAnchorB&&this.localAnchorB.copy(n.localAnchorB),n.worldAnchorA&&this.setWorldAnchorA(n.worldAnchorA),n.worldAnchorB&&this.setWorldAnchorB(n.worldAnchorB)}setWorldAnchorA(e){this.bodyA.pointToLocalFrame(e,this.localAnchorA)}setWorldAnchorB(e){this.bodyB.pointToLocalFrame(e,this.localAnchorB)}getWorldAnchorA(e){this.bodyA.pointToWorldFrame(this.localAnchorA,e)}getWorldAnchorB(e){this.bodyB.pointToWorldFrame(this.localAnchorB,e)}applyForce(){const e=this.stiffness,t=this.damping,n=this.restLength,r=this.bodyA,i=this.bodyB,s=$a,o=Xa,a=Za,c=Ka,l=ic,u=Qa,h=Ja,d=ec,f=tc,p=nc,m=rc;this.getWorldAnchorA(u),this.getWorldAnchorB(h),u.vsub(r.position,d),h.vsub(i.position,f),h.vsub(u,s);const g=s.length();o.copy(s),o.normalize(),i.velocity.vsub(r.velocity,a),i.angularVelocity.cross(f,l),a.vadd(l,a),r.angularVelocity.cross(d,l),a.vsub(l,a),o.scale(-e*(g-n)-t*a.dot(o),c),r.force.vsub(c,r.force),i.force.vadd(c,i.force),d.cross(c,p),f.cross(c,m),r.torque.vsub(p,r.torque),i.torque.vadd(m,i.torque)}}const $a=new Ls,Xa=new Ls,Za=new Ls,Ka=new Ls,Qa=new Ls,Ja=new Ls,ec=new Ls,tc=new Ls,nc=new Ls,rc=new Ls,ic=new Ls;new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new qo,new Ls,new Ls,new Ls,new Ls(1,0,0),new Ls(0,1,0),new Ls(0,0,1),new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ys,new Ls,new Ys,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ls,new Ys,new Ls,new to,new Ys;class sc{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);-1!==n&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class oc extends sc{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const r=this.iterations,i=this.tolerance*this.tolerance,s=this.equations,o=s.length,a=t.bodies,c=a.length,l=e;let u,h,d,f,p,m;if(0!==o)for(let e=0;e!==c;e++)a[e].updateSolveMassProperties();const g=cc,y=lc,v=ac;g.length=o,y.length=o,v.length=o;for(let e=0;e!==o;e++){const t=s[e];v[e]=0,y[e]=t.computeB(l),g[e]=1/t.computeC()}if(0!==o){for(let e=0;e!==c;e++){const t=a[e],n=t.vlambda,r=t.wlambda;n.set(0,0,0),r.set(0,0,0)}for(n=0;n!==r;n++){f=0;for(let e=0;e!==o;e++){const t=s[e];u=y[e],h=g[e],m=v[e],p=t.computeGWlambda(),d=h*(u-p-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),v[e]+=d,f+=d>0?d:-d,t.addToWlambda(d)}if(f*f<i)break}for(let e=0;e!==c;e++){const t=a[e],n=t.velocity,r=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),n.vadd(t.vlambda,n),t.wlambda.vmul(t.angularFactor,t.wlambda),r.vadd(t.wlambda,r)}let e=s.length;const t=1/l;for(;e--;)s[e].multiplier=v[e]*t}return n}}const ac=[],cc=[],lc=[];ho.STATIC;class uc{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class hc extends uc{constructor(){super(...arguments),this.type=Ls}constructObject(){return new Ls}}const dc=eo.types.SPHERE,fc=eo.types.SPHERE|eo.types.PLANE,pc=eo.types.BOX|eo.types.BOX,mc=eo.types.SPHERE|eo.types.BOX,gc=eo.types.PLANE|eo.types.BOX,yc=eo.types.CONVEXPOLYHEDRON,vc=eo.types.SPHERE|eo.types.CONVEXPOLYHEDRON,xc=eo.types.PLANE|eo.types.CONVEXPOLYHEDRON,wc=eo.types.BOX|eo.types.CONVEXPOLYHEDRON,bc=eo.types.SPHERE|eo.types.HEIGHTFIELD,_c=eo.types.BOX|eo.types.HEIGHTFIELD,kc=eo.types.CONVEXPOLYHEDRON|eo.types.HEIGHTFIELD,Tc=eo.types.PARTICLE|eo.types.SPHERE,Sc=eo.types.PLANE|eo.types.PARTICLE,Pc=eo.types.BOX|eo.types.PARTICLE,Ec=eo.types.PARTICLE|eo.types.CONVEXPOLYHEDRON,Ac=eo.types.CYLINDER,Mc=eo.types.SPHERE|eo.types.CYLINDER,zc=eo.types.PLANE|eo.types.CYLINDER,Ic=eo.types.BOX|eo.types.CYLINDER,Cc=eo.types.CONVEXPOLYHEDRON|eo.types.CYLINDER,Bc=eo.types.HEIGHTFIELD|eo.types.CYLINDER,Oc=eo.types.PARTICLE|eo.types.CYLINDER,Rc=eo.types.SPHERE|eo.types.TRIMESH,Uc=eo.types.PLANE|eo.types.TRIMESH;class Nc{get[dc](){return this.sphereSphere}get[fc](){return this.spherePlane}get[pc](){return this.boxBox}get[mc](){return this.sphereBox}get[gc](){return this.planeBox}get[yc](){return this.convexConvex}get[vc](){return this.sphereConvex}get[xc](){return this.planeConvex}get[wc](){return this.boxConvex}get[bc](){return this.sphereHeightfield}get[_c](){return this.boxHeightfield}get[kc](){return this.convexHeightfield}get[Tc](){return this.sphereParticle}get[Sc](){return this.planeParticle}get[Pc](){return this.boxParticle}get[Ec](){return this.convexParticle}get[Ac](){return this.convexConvex}get[Mc](){return this.sphereConvex}get[zc](){return this.planeConvex}get[Ic](){return this.boxConvex}get[Cc](){return this.convexConvex}get[Bc](){return this.heightfieldCylinder}get[Oc](){return this.particleCylinder}get[Rc](){return this.sphereTrimesh}get[Uc](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new hc,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,r,i,s){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=e,o.bj=t):o=new Sa(e,t),o.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&r.collisionResponse;const a=this.currentContactMaterial;o.restitution=a.restitution,o.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=n.material||e.material,l=r.material||t.material;return c&&l&&c.restitution>=0&&l.restitution>=0&&(o.restitution=c.restitution*l.restitution),o.si=i||n,o.sj=s||r,o}createFrictionEquationsFromContact(e,t){const n=e.bi,r=e.bj,i=e.si,s=e.sj,o=this.world,a=this.currentContactMaterial;let c=a.friction;const l=i.material||n.material,u=s.material||r.material;if(l&&u&&l.friction>=0&&u.friction>=0&&(c=l.friction*u.friction),c>0){const i=c*(o.frictionGravity||o.gravity).length();let s=n.invMass+r.invMass;s>0&&(s=1/s);const l=this.frictionEquationPool,u=l.length?l.pop():new La(n,r,i*s),h=l.length?l.pop():new La(n,r,i*s);return u.bi=h.bi=n,u.bj=h.bj=r,u.minForce=h.minForce=-i*s,u.maxForce=h.maxForce=i*s,u.ri.copy(e.ri),u.rj.copy(e.rj),h.ri.copy(e.ri),h.rj.copy(e.rj),e.ni.tangents(u.t,h.t),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),u.enabled=h.enabled=e.enabled,t.push(u,h),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const n=this.frictionResult[this.frictionResult.length-2],r=this.frictionResult[this.frictionResult.length-1];jc.setZero(),Dc.setZero(),qc.setZero();const i=t.bi;t.bj;for(let n=0;n!==e;n++)t=this.result[this.result.length-1-n],t.bi!==i?(jc.vadd(t.ni,jc),Dc.vadd(t.ri,Dc),qc.vadd(t.rj,qc)):(jc.vsub(t.ni,jc),Dc.vadd(t.rj,Dc),qc.vadd(t.ri,qc));const s=1/e;Dc.scale(s,n.ri),qc.scale(s,n.rj),r.ri.copy(n.ri),r.rj.copy(n.rj),jc.normalize(),jc.tangents(n.t,r.t)}getContacts(e,t,n,r,i,s,o){this.contactPointPool=i,this.frictionEquationPool=o,this.result=r,this.frictionResult=s;const a=Vc,c=Gc,l=Fc,u=Lc;for(let r=0,i=e.length;r!==i;r++){const i=e[r],s=t[r];let o=null;i.material&&s.material&&(o=n.getContactMaterial(i.material,s.material)||null);const h=i.type&ho.KINEMATIC&&s.type&ho.STATIC||i.type&ho.STATIC&&s.type&ho.KINEMATIC||i.type&ho.KINEMATIC&&s.type&ho.KINEMATIC;for(let e=0;e<i.shapes.length;e++){i.quaternion.mult(i.shapeOrientations[e],a),i.quaternion.vmult(i.shapeOffsets[e],l),l.vadd(i.position,l);const t=i.shapes[e];for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],c),s.quaternion.vmult(s.shapeOffsets[e],u),u.vadd(s.position,u);const r=s.shapes[e];if(!(t.collisionFilterMask&r.collisionFilterGroup&&r.collisionFilterMask&t.collisionFilterGroup))continue;if(l.distanceTo(u)>t.boundingSphereRadius+r.boundingSphereRadius)continue;let d=null;t.material&&r.material&&(d=n.getContactMaterial(t.material,r.material)||null),this.currentContactMaterial=d||o||n.defaultContactMaterial;const f=this[t.type|r.type];if(f){let e=!1;e=t.type<r.type?f.call(this,t,r,l,u,a,c,i,s,t,r,h):f.call(this,r,t,u,l,c,a,s,i,t,r,h),e&&h&&(n.shapeOverlapKeeper.set(t.id,r.id),n.bodyOverlapKeeper.set(i.id,s.id))}}}}}sphereSphere(e,t,n,r,i,s,o,a,c,l,u){if(u)return n.distanceSquared(r)<(e.radius+t.radius)**2;const h=this.createContactEquation(o,a,e,t,c,l);r.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(o.position,h.ri),h.rj.vadd(r,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,n,r,i,s,o,a,c,l,u){const h=this.createContactEquation(o,a,e,t,c,l);if(h.ni.set(0,0,1),s.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),n.vsub(r,ll),h.ni.scale(h.ni.dot(ll),ul),ll.vsub(ul,h.rj),-ll.dot(h.ni)<=e.radius){if(u)return!0;const e=h.ri,t=h.rj;e.vadd(n,e),e.vsub(o.position,e),t.vadd(r,t),t.vsub(a.position,t),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,n,r,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,u)}sphereBox(e,t,n,r,i,s,o,a,c,l,u){const h=this.v3pool,d=xl;n.vsub(r,ml),t.getSideNormals(d,s);const f=e.radius;let p=!1;const m=bl,g=_l,y=kl;let v=null,x=0,w=0,b=0,_=null;for(let e=0,t=d.length;e!==t&&!1===p;e++){const t=gl;t.copy(d[e]);const n=t.length();t.normalize();const r=ml.dot(t);if(r<n+f&&r>0){const i=yl,s=vl;i.copy(d[(e+1)%3]),s.copy(d[(e+2)%3]);const o=i.length(),a=s.length();i.normalize(),s.normalize();const c=ml.dot(i),l=ml.dot(s);if(c<o&&c>-o&&l<a&&l>-a){const e=Math.abs(r-n-f);if((null===_||e<_)&&(_=e,w=c,b=l,v=n,m.copy(t),g.copy(i),y.copy(s),x++,u))return!0}}}if(x){p=!0;const i=this.createContactEquation(o,a,e,t,c,l);m.scale(-f,i.ri),i.ni.copy(m),i.ni.negate(i.ni),m.scale(v,m),g.scale(w,g),m.vadd(g,m),y.scale(b,y),m.vadd(y,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}let k=h.get();const T=wl;for(let i=0;2!==i&&!p;i++)for(let s=0;2!==s&&!p;s++)for(let h=0;2!==h&&!p;h++)if(k.set(0,0,0),i?k.vadd(d[0],k):k.vsub(d[0],k),s?k.vadd(d[1],k):k.vsub(d[1],k),h?k.vadd(d[2],k):k.vsub(d[2],k),r.vadd(k,T),T.vsub(n,T),T.lengthSquared()<f*f){if(u)return!0;p=!0;const i=this.createContactEquation(o,a,e,t,c,l);i.ri.copy(T),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(f,i.ri),i.rj.copy(k),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}h.release(k),k=null;const S=h.get(),P=h.get(),E=h.get(),A=h.get(),M=h.get(),z=d.length;for(let i=0;i!==z&&!p;i++)for(let s=0;s!==z&&!p;s++)if(i%3!=s%3){d[s].cross(d[i],S),S.normalize(),d[i].vadd(d[s],P),E.copy(n),E.vsub(P,E),E.vsub(r,E);const h=E.dot(S);S.scale(h,A);let m=0;for(;m===i%3||m===s%3;)m++;M.copy(n),M.vsub(A,M),M.vsub(P,M),M.vsub(r,M);const g=Math.abs(h),y=M.length();if(g<d[m].length()&&y<f){if(u)return!0;p=!0;const i=this.createContactEquation(o,a,e,t,c,l);P.vadd(A,i.rj),i.rj.copy(i.rj),M.negate(i.ni),i.ni.normalize(),i.ri.copy(i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(n,i.ri),i.ri.normalize(),i.ri.scale(f,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}h.release(S,P,E,A,M)}planeBox(e,t,n,r,i,s,o,a,c,l,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,u)}convexConvex(e,t,n,r,i,s,o,a,c,l,u,h,d){const f=jl;if(!(n.distanceTo(r)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,i,r,s,f,h,d)){const h=[],d=Dl;e.clipAgainstHull(n,i,t,r,s,f,-100,100,h);let p=0;for(let i=0;i!==h.length;i++){if(u)return!0;const s=this.createContactEquation(o,a,e,t,c,l),m=s.ri,g=s.rj;f.negate(s.ni),h[i].normal.negate(d),d.scale(h[i].depth,d),h[i].point.vadd(d,m),g.copy(h[i].point),m.vsub(n,m),g.vsub(r,g),m.vadd(n,m),m.vsub(o.position,m),g.vadd(r,g),g.vsub(a.position,g),this.result.push(s),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}}sphereConvex(e,t,n,r,i,s,o,a,c,l,u){const h=this.v3pool;n.vsub(r,Tl);const d=t.faceNormals,f=t.faces,p=t.vertices,m=e.radius;let g=!1;for(let i=0;i!==p.length;i++){const h=p[i],d=Al;s.vmult(h,d),r.vadd(d,d);const f=El;if(d.vsub(n,f),f.lengthSquared()<m*m){if(u)return!0;g=!0;const i=this.createContactEquation(o,a,e,t,c,l);return i.ri.copy(f),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(m,i.ri),d.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),void this.createFrictionEquationsFromContact(i,this.frictionResult)}}for(let i=0,y=f.length;i!==y&&!1===g;i++){const y=d[i],v=f[i],x=Ml;s.vmult(y,x);const w=zl;s.vmult(p[v[0]],w),w.vadd(r,w);const b=Il;x.scale(-m,b),n.vadd(b,b);const _=Cl;b.vsub(w,_);const k=_.dot(x),T=Bl;if(n.vsub(w,T),k<0&&T.dot(x)>0){const i=[];for(let e=0,t=v.length;e!==t;e++){const t=h.get();s.vmult(p[v[e]],t),r.vadd(t,t),i.push(t)}if(pl(i,x,n)){if(u)return!0;g=!0;const s=this.createContactEquation(o,a,e,t,c,l);x.scale(-m,s.ri),x.negate(s.ni);const d=h.get();x.scale(-k,d);const f=h.get();x.scale(-m,f),n.vsub(r,s.rj),s.rj.vadd(f,s.rj),s.rj.vadd(d,s.rj),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),h.release(d),h.release(f),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return}for(let d=0;d!==v.length;d++){const f=h.get(),g=h.get();s.vmult(p[v[(d+1)%v.length]],f),s.vmult(p[v[(d+2)%v.length]],g),r.vadd(f,f),r.vadd(g,g);const y=Sl;g.vsub(f,y);const x=Pl;y.unit(x);const w=h.get(),b=h.get();n.vsub(f,b);const _=b.dot(x);x.scale(_,w),w.vadd(f,w);const k=h.get();if(w.vsub(n,k),_>0&&_*_<y.lengthSquared()&&k.lengthSquared()<m*m){if(u)return!0;const s=this.createContactEquation(o,a,e,t,c,l);w.vsub(r,s.rj),w.vsub(n,s.ni),s.ni.normalize(),s.ni.scale(m,s.ri),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return h.release(f),h.release(g),h.release(w),h.release(k),void h.release(b)}h.release(f),h.release(g),h.release(w),h.release(k),h.release(b)}for(let e=0,t=i.length;e!==t;e++)h.release(i[e])}}}planeConvex(e,t,n,r,i,s,o,a,c,l,u){const h=Ol,d=Rl;d.set(0,0,1),i.vmult(d,d);let f=0;const p=Ul;for(let i=0;i!==t.vertices.length;i++)if(h.copy(t.vertices[i]),s.vmult(h,h),r.vadd(h,h),h.vsub(n,p),d.dot(p)<=0){if(u)return!0;const i=this.createContactEquation(o,a,e,t,c,l),s=Nl;d.scale(d.dot(p),s),h.vsub(s,s),s.vsub(n,i.ri),i.ni.copy(d),h.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(i,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}boxConvex(e,t,n,r,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}sphereHeightfield(e,t,n,r,i,s,o,a,c,l,u){const h=t.data,d=e.radius,f=t.elementSize,p=Jl,m=Ql;to.pointToLocalFrame(r,s,n,m);let g=Math.floor((m.x-d)/f)-1,y=Math.ceil((m.x+d)/f)+1,v=Math.floor((m.y-d)/f)-1,x=Math.ceil((m.y+d)/f)+1;if(y<0||x<0||g>h.length||v>h[0].length)return;g<0&&(g=0),y<0&&(y=0),v<0&&(v=0),x<0&&(x=0),g>=h.length&&(g=h.length-1),y>=h.length&&(y=h.length-1),x>=h[0].length&&(x=h[0].length-1),v>=h[0].length&&(v=h[0].length-1);const w=[];t.getRectMinMax(g,v,y,x,w);const b=w[0],_=w[1];if(m.z-d>_||m.z+d<b)return;const k=this.result;for(let c=g;c<y;c++)for(let l=v;l<x;l++){const h=k.length;let d=!1;if(t.getConvexTrianglePillar(c,l,!1),to.pointToWorldFrame(r,s,t.pillarOffset,p),n.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,p,i,s,o,a,e,t,u)),u&&d)return!0;if(t.getConvexTrianglePillar(c,l,!0),to.pointToWorldFrame(r,s,t.pillarOffset,p),n.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,p,i,s,o,a,e,t,u)),u&&d)return!0;if(k.length-h>2)return}}boxHeightfield(e,t,n,r,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}convexHeightfield(e,t,n,r,i,s,o,a,c,l,u){const h=t.data,d=t.elementSize,f=e.boundingSphereRadius,p=Zl,m=Kl,g=Xl;to.pointToLocalFrame(r,s,n,g);let y=Math.floor((g.x-f)/d)-1,v=Math.ceil((g.x+f)/d)+1,x=Math.floor((g.y-f)/d)-1,w=Math.ceil((g.y+f)/d)+1;if(v<0||w<0||y>h.length||x>h[0].length)return;y<0&&(y=0),v<0&&(v=0),x<0&&(x=0),w<0&&(w=0),y>=h.length&&(y=h.length-1),v>=h.length&&(v=h.length-1),w>=h[0].length&&(w=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const b=[];t.getRectMinMax(y,x,v,w,b);const _=b[0],k=b[1];if(!(g.z-f>k||g.z+f<_))for(let c=y;c<v;c++)for(let l=x;l<w;l++){let h=!1;if(t.getConvexTrianglePillar(c,l,!1),to.pointToWorldFrame(r,s,t.pillarOffset,p),n.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,p,i,s,o,a,null,null,u,m,null)),u&&h)return!0;if(t.getConvexTrianglePillar(c,l,!0),to.pointToWorldFrame(r,s,t.pillarOffset,p),n.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,p,i,s,o,a,null,null,u,m,null)),u&&h)return!0}}sphereParticle(e,t,n,r,i,s,o,a,c,l,u){const h=Vl;if(h.set(0,0,1),r.vsub(n,h),h.lengthSquared()<=e.radius*e.radius){if(u)return!0;const n=this.createContactEquation(a,o,t,e,c,l);h.normalize(),n.rj.copy(h),n.rj.scale(e.radius,n.rj),n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}planeParticle(e,t,n,r,i,s,o,a,c,l,u){const h=ql;h.set(0,0,1),o.quaternion.vmult(h,h);const d=Fl;if(r.vsub(o.position,d),h.dot(d)<=0){if(u)return!0;const n=this.createContactEquation(a,o,t,e,c,l);n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0);const i=Ll;h.scale(h.dot(r),i),r.vsub(i,i),n.rj.copy(i),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}boxParticle(e,t,n,r,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}convexParticle(e,t,n,r,i,s,o,a,c,l,u){let h=-1;const d=Yl,f=$l;let p=null;const m=Wl;if(m.copy(r),m.vsub(n,m),i.conjugate(Gl),Gl.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let t=0,n=e.faces.length;t!==n;t++){const n=[e.worldVertices[e.faces[t][0]]],i=e.worldFaceNormals[t];r.vsub(n[0],Hl);const s=-i.dot(Hl);if(null===p||Math.abs(s)<Math.abs(p)){if(u)return!0;p=s,h=t,d.copy(i)}}if(-1!==h){const i=this.createContactEquation(a,o,t,e,c,l);d.scale(p,f),f.vadd(r,f),f.vsub(n,f),i.rj.copy(f),d.negate(i.ni),i.ri.set(0,0,0);const s=i.ri,u=i.rj;s.vadd(r,s),s.vsub(a.position,s),u.vadd(n,u),u.vsub(o.position,u),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,r,i,s,o,a,c,l,u){return this.convexHeightfield(t,e,r,n,s,i,a,o,c,l,u)}particleCylinder(e,t,n,r,i,s,o,a,c,l,u){return this.convexParticle(t,e,r,n,s,i,a,o,c,l,u)}sphereTrimesh(e,t,n,r,i,s,o,a,c,l,u){const h=Qc,d=Jc,f=el,p=tl,m=nl,g=rl,y=al,v=Kc,x=Xc,w=cl;to.pointToLocalFrame(r,s,n,m);const b=e.radius;y.lowerBound.set(m.x-b,m.y-b,m.z-b),y.upperBound.set(m.x+b,m.y+b,m.z+b),t.getTrianglesInAABB(y,w);const _=Zc,k=e.radius*e.radius;for(let i=0;i<w.length;i++)for(let h=0;h<3;h++)if(t.getVertex(t.indices[3*w[i]+h],_),_.vsub(m,x),x.lengthSquared()<=k){if(v.copy(_),to.pointToWorldFrame(r,s,v,_),_.vsub(n,x),u)return!0;let i=this.createContactEquation(o,a,e,t,c,l);i.ni.copy(x),i.ni.normalize(),i.ri.copy(i.ni),i.ri.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.copy(_),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}for(let i=0;i<w.length;i++)for(let y=0;y<3;y++){t.getVertex(t.indices[3*w[i]+y],h),t.getVertex(t.indices[3*w[i]+(y+1)%3],d),d.vsub(h,f),m.vsub(d,g);const v=g.dot(f);m.vsub(h,g);let x=g.dot(f);if(x>0&&v<0&&(m.vsub(h,g),p.copy(f),p.normalize(),x=g.dot(p),p.scale(x,g),g.vadd(h,g),g.distanceTo(m)<e.radius)){if(u)return!0;const i=this.createContactEquation(o,a,e,t,c,l);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),to.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),to.vectorToWorldFrame(s,i.ni,i.ni),to.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}const T=il,S=sl,P=ol,E=$c;for(let i=0,h=w.length;i!==h;i++){t.getTriangleVertices(w[i],T,S,P),t.getNormal(w[i],E),m.vsub(T,g);let h=g.dot(E);if(E.scale(h,g),m.vsub(g,g),h=g.distanceTo(m),qo.pointInTriangle(g,T,S,P)&&h<e.radius){if(u)return!0;let i=this.createContactEquation(o,a,e,t,c,l);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),to.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),to.vectorToWorldFrame(s,i.ni,i.ni),to.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}w.length=0}planeTrimesh(e,t,n,r,i,s,o,a,c,l,u){const h=new Ls,d=Wc;d.set(0,0,1),i.vmult(d,d);for(let i=0;i<t.vertices.length/3;i++){t.getVertex(i,h);const f=new Ls;f.copy(h),to.pointToWorldFrame(r,s,f,h);const p=Yc;if(h.vsub(n,p),d.dot(p)<=0){if(u)return!0;const n=this.createContactEquation(o,a,e,t,c,l);n.ni.copy(d);const r=Hc;d.scale(p.dot(d),r),h.vsub(r,r),n.ri.copy(r),n.ri.vsub(o.position,n.ri),n.rj.copy(h),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}}const jc=new Ls,Dc=new Ls,qc=new Ls,Fc=new Ls,Lc=new Ls,Vc=new Ks,Gc=new Ks,Wc=new Ls,Yc=new Ls,Hc=new Ls,$c=new Ls,Xc=new Ls;new Ls;const Zc=new Ls,Kc=new Ls,Qc=new Ls,Jc=new Ls,el=new Ls,tl=new Ls,nl=new Ls,rl=new Ls,il=new Ls,sl=new Ls,ol=new Ls,al=new Ys,cl=[],ll=new Ls,ul=new Ls,hl=new Ls,dl=new Ls,fl=new Ls;function pl(e,t,n){let r=null;const i=e.length;for(let s=0;s!==i;s++){const o=e[s],a=hl;e[(s+1)%i].vsub(o,a);const c=dl;a.cross(t,c);const l=fl;n.vsub(o,l);const u=c.dot(l);if(!(null===r||u>0&&!0===r||u<=0&&!1===r))return!1;null===r&&(r=u>0)}return!0}const ml=new Ls,gl=new Ls,yl=new Ls,vl=new Ls,xl=[new Ls,new Ls,new Ls,new Ls,new Ls,new Ls],wl=new Ls,bl=new Ls,_l=new Ls,kl=new Ls,Tl=new Ls,Sl=new Ls,Pl=new Ls,El=new Ls,Al=new Ls,Ml=new Ls,zl=new Ls,Il=new Ls,Cl=new Ls,Bl=new Ls;new Ls,new Ls;const Ol=new Ls,Rl=new Ls,Ul=new Ls,Nl=new Ls,jl=new Ls,Dl=new Ls,ql=new Ls,Fl=new Ls,Ll=new Ls,Vl=new Ls,Gl=new Ks,Wl=new Ls;new Ls;const Yl=new Ls,Hl=new Ls,$l=new Ls,Xl=new Ls,Zl=new Ls,Kl=[0],Ql=new Ls,Jl=new Ls;class eu{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),r=this.current;let i=0;for(;n>r[i];)i++;if(n!==r[i]){for(let e=r.length-1;e>=i;e--)r[e+1]=r[e];r[i]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,r=this.previous,i=n.length,s=r.length;let o=0;for(let t=0;t<i;t++){let i=!1;const s=n[t];for(;s>r[o];)o++;i=s===r[o],i||tu(e,s)}o=0;for(let e=0;e<s;e++){let i=!1;const s=r[e];for(;s>n[o];)o++;i=n[o]===s,i||tu(t,s)}}}function tu(e,t){e.push((4294901760&t)>>16,65535&t)}const nu=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class ru{constructor(){this.data={keys:[]}}get(e,t){const n=nu(e,t);return this.data[n]}set(e,t,n){const r=nu(e,t);this.get(e,t)||this.data.keys.push(r),this.data[r]=n}delete(e,t){const n=nu(e,t),r=this.data.keys.indexOf(n);-1!==r&&this.data.keys.splice(r,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;)delete e[t.pop()]}}class iu extends Zs{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new Ls,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new Ls,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new Io,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new oc,this.constraints=[],this.narrowphase=new Nc(this),this.collisionMatrix=new Xs,this.collisionMatrixPrevious=new Xs,this.bodyOverlapKeeper=new eu,this.shapeOverlapKeeper=new eu,this.contactmaterials=[],this.contactMaterialTable=new ru,this.defaultMaterial=new Ya("default"),this.defaultContactMaterial=new Wa(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof Co?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,r){return void 0===n&&(n={}),n.mode=qo.ALL,n.from=e,n.to=t,n.callback=r,su.intersectWorld(this,n)}raycastAny(e,t,n,r){return void 0===n&&(n={}),n.mode=qo.ANY,n.from=e,n.to=t,n.result=r,su.intersectWorld(this,n)}raycastClosest(e,t,n,r){return void 0===n&&(n={}),n.mode=qo.CLOSEST,n.from=e,n.to=t,n.result=r,su.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof ho&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,r=n.indexOf(e);if(-1!==r){n.splice(r,1);for(let e=0;e!==n.length;e++)n[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const r=t[n].shapes;for(let t=0;t<r.length;t++){const n=r[t];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const n=ou.now()/1e3;if(this.lastCallTime){const r=n-this.lastCallTime;this.step(e,r,t)}else this.step(e,void 0,t);this.lastCallTime=n}step(e,t,n){if(void 0===n&&(n=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const r=ou.now();let i=0;for(;this.accumulator>=e&&i<n&&(this.internalStep(e),this.accumulator-=e,i++,!(ou.now()-r>1e3*e)););this.accumulator=this.accumulator%e;const s=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,s,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,s,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=du,r=fu,i=this.bodies.length,s=this.bodies,o=this.solver,a=this.gravity,c=this.doProfiling,l=this.profile,u=ho.DYNAMIC;let h=-1/0;const d=this.constraints,f=hu;a.length();const p=a.x,m=a.y,g=a.z;let y=0;for(c&&(h=ou.now()),y=0;y!==i;y++){const e=s[y];if(e.type===u){const t=e.force,n=e.mass;t.x+=n*p,t.y+=n*m,t.z+=n*g}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();c&&(h=ou.now()),n.length=0,r.length=0,this.broadphase.collisionPairs(this,n,r),c&&(l.broadphase=ou.now()-h);let v=d.length;for(y=0;y!==v;y++){const e=d[y];if(!e.collideConnected)for(let t=n.length-1;t>=0;t-=1)(e.bodyA===n[t]&&e.bodyB===r[t]||e.bodyB===n[t]&&e.bodyA===r[t])&&(n.splice(t,1),r.splice(t,1))}this.collisionMatrixTick(),c&&(h=ou.now());const x=uu,w=t.length;for(y=0;y!==w;y++)x.push(t[y]);t.length=0;const b=this.frictionEquations.length;for(y=0;y!==b;y++)f.push(this.frictionEquations[y]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,r,this,t,x,this.frictionEquations,f),c&&(l.narrowphase=ou.now()-h),c&&(h=ou.now()),y=0;y<this.frictionEquations.length;y++)o.addEquation(this.frictionEquations[y]);const _=t.length;for(let e=0;e!==_;e++){const n=t[e],r=n.bi,i=n.bj,s=n.si,a=n.sj;let c;c=r.material&&i.material&&this.getContactMaterial(r.material,i.material)||this.defaultContactMaterial,c.friction,r.material&&i.material&&(r.material.friction>=0&&i.material.friction>=0&&(r.material.friction,i.material.friction),r.material.restitution>=0&&i.material.restitution>=0&&(n.restitution=r.material.restitution*i.material.restitution)),o.addEquation(n),r.allowSleep&&r.type===ho.DYNAMIC&&r.sleepState===ho.SLEEPING&&i.sleepState===ho.AWAKE&&i.type!==ho.STATIC&&i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0),i.allowSleep&&i.type===ho.DYNAMIC&&i.sleepState===ho.SLEEPING&&r.sleepState===ho.AWAKE&&r.type!==ho.STATIC&&r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(r,i,!0),this.collisionMatrixPrevious.get(r,i)||(lu.body=i,lu.contact=n,r.dispatchEvent(lu),lu.body=r,i.dispatchEvent(lu)),this.bodyOverlapKeeper.set(r.id,i.id),this.shapeOverlapKeeper.set(s.id,a.id)}for(this.emitContactEvents(),c&&(l.makeContactConstraints=ou.now()-h,h=ou.now()),y=0;y!==i;y++){const e=s[y];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(v=d.length,y=0;y!==v;y++){const e=d[y];e.update();for(let t=0,n=e.equations.length;t!==n;t++){const n=e.equations[t];o.addEquation(n)}}o.solve(e,this),c&&(l.solve=ou.now()-h),o.removeAllEquations();const k=Math.pow;for(y=0;y!==i;y++){const t=s[y];if(t.type&u){const n=k(1-t.linearDamping,e),r=t.velocity;r.scale(n,r);const i=t.angularVelocity;if(i){const n=k(1-t.angularDamping,e);i.scale(n,i)}}}this.dispatchEvent(cu),c&&(h=ou.now());const T=this.stepnumber%(this.quatNormalizeSkip+1)==0,S=this.quatNormalizeFast;for(y=0;y!==i;y++)s[y].integrate(e,T,S);this.clearForces(),this.broadphase.dirty=!0,c&&(l.integrate=ou.now()-h),this.stepnumber+=1,this.dispatchEvent(au);let P=!0;if(this.allowSleep)for(P=!1,y=0;y!==i;y++){const e=s[y];e.sleepTick(this.time),e.sleepState!==ho.SLEEPING&&(P=!0)}this.hasActiveBodies=P}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(pu,mu),e){for(let e=0,t=pu.length;e<t;e+=2)gu.bodyA=this.getBodyById(pu[e]),gu.bodyB=this.getBodyById(pu[e+1]),this.dispatchEvent(gu);gu.bodyA=gu.bodyB=null}if(t){for(let e=0,t=mu.length;e<t;e+=2)yu.bodyA=this.getBodyById(mu[e]),yu.bodyB=this.getBodyById(mu[e+1]),this.dispatchEvent(yu);yu.bodyA=yu.bodyB=null}pu.length=mu.length=0;const n=this.hasAnyEventListener("beginShapeContact"),r=this.hasAnyEventListener("endShapeContact");if((n||r)&&this.shapeOverlapKeeper.getDiff(pu,mu),n){for(let e=0,t=pu.length;e<t;e+=2){const t=this.getShapeById(pu[e]),n=this.getShapeById(pu[e+1]);vu.shapeA=t,vu.shapeB=n,t&&(vu.bodyA=t.body),n&&(vu.bodyB=n.body),this.dispatchEvent(vu)}vu.bodyA=vu.bodyB=vu.shapeA=vu.shapeB=null}if(r){for(let e=0,t=mu.length;e<t;e+=2){const t=this.getShapeById(mu[e]),n=this.getShapeById(mu[e+1]);xu.shapeA=t,xu.shapeB=n,t&&(xu.bodyA=t.body),n&&(xu.bodyB=n.body),this.dispatchEvent(xu)}xu.bodyA=xu.bodyB=xu.shapeA=xu.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const t=e[n];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new Ys;const su=new qo,ou=globalThis.performance||{};if(!ou.now){let e=Date.now();ou.timing&&ou.timing.navigationStart&&(e=ou.timing.navigationStart),ou.now=()=>Date.now()-e}new Ls;const au={type:"postStep"},cu={type:"preStep"},lu={type:ho.COLLIDE_EVENT_NAME,body:null,contact:null},uu=[],hu=[],du=[],fu=[],pu=[],mu=[],gu={type:"beginContact",bodyA:null,bodyB:null},yu={type:"endContact",bodyA:null,bodyB:null},vu={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},xu={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class wu extends e{bodyId;halfExtents;mass;angularFactor;constructor(e,t=1,n=new Ls(1,1,1)){super(),this.halfExtents=new Ls(e[0]/2,e[1]/2,e[2]/2),this.mass=t,this.angularFactor=n}}class bu extends e{bodyId;halfExtents;options;constructor(e,t={}){super(),this.halfExtents=new Ls(e[0]/2,e[1]/2,e[2]/2),this.options=t}}class _u extends e{speed=1;rotationSpeed=.025;player;constructor(e=0,t=1,n=.025){super(),this.player=e,this.speed=t,this.rotationSpeed=n}}class ku extends e{constructor(){super()}}class Tu extends e{device;volumeAtlas}class Su extends e{playerEntity;bodyId;constructor(e){super(),this.playerEntity=e}}class Pu extends e{health=100;maxHealth=100;swordEntity;constructor(e){super(),this.swordEntity=e}}class Eu extends e{targetEntity;rotation;position;speed=.01;constructor(e,t=te.zero(),n=Le.identity()){super(),this.targetEntity=e,this.rotation=n,this.position=t}}class Au extends e{voxelObjects;constructor(e){super(),this.voxelObjects=e}}class Mu{pressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1," ":!1,shift:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1})),window.addEventListener("blur",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))})),window.addEventListener("contextmenu",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))}))}}class zu extends e{speed=.5;rotationSpeed=.025}class Iu extends e{world=new iu({gravity:new Ls(0,-150,0)});constructor(){super()}}const Cu=e=>{const t=e.getEntitiesithComponent(Iu).values().next().value;return e.getComponents(t).get(Iu).world},Bu=.1;class Ou extends e{entity1;entity2;pivot1;pivot2;config;constructor(e,t,n,r,i={}){super(),this.entity1=e,this.entity2=t,this.pivot1=n,this.pivot2=r,this.config=i}}const Ru=te.create(12,2,0),Uu=Le.fromEuler(Math.PI/180*90,0,0,"zxy");class Nu extends e{entity1;entity2;config;constructor(e,t,n={}){super(),this.entity1=e,this.entity2=t,this.config=n}}class ju extends e{timer;constructor(e=2){super(),this.timer=e}}const Du=new class{lastTime=0;entities=new Map;systems=new Map;nextEntityID=0;entitiesToDestroy=new Array;addEntity(){let e=this.nextEntityID;return this.nextEntityID++,this.entities.set(e,new n),e}removeEntity(e){this.entitiesToDestroy.push(e)}addComponent(e,t){this.entities.get(e).add(t),this.checkE(e)}addComponents(e,...t){for(let n of t)this.addComponent(e,n)}getComponents(e){return this.entities.get(e)}removeComponent(e,t){this.entities.get(e).delete(t),this.checkE(e)}addSystem(e){if(0==e.componentsRequired.size)return console.warn("System not added: empty Components list."),void console.warn(e);e.ecs=this,this.systems.set(e,new Set);for(let t of this.entities.keys())this.checkES(t,e)}removeSystem(e){this.systems.delete(e)}update(e){let t=e-this.lastTime;for(let[n,r]of this.systems.entries())n.update(r,e,t);for(;this.entitiesToDestroy.length>0;)this.destroyEntity(this.entitiesToDestroy.pop());this.lastTime=e}destroyEntity(e){this.entities.delete(e);for(let t of this.systems.values())t.delete(e)}checkE(e){for(let t of this.systems.keys())this.checkES(e,t)}checkES(e,t){let n=this.entities.get(e),r=t.componentsRequired;n.hasAll(r)?this.systems.get(t).add(e):this.systems.get(t).delete(e)}getEntitiesithComponent(e){let t=new Set;for(let[n,r]of this.entities)r.has(e)&&t.add(n);return t}};Du.addSystem(new class extends t{componentsRequired=new Set([Pi,Si]);constructor(){super(),(async()=>{const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});let t;console.log(e);try{t=await e.requestDevice({requiredFeatures:["timestamp-query"],requiredLimits:{maxColorAttachmentBytesPerSample:64}})}catch(n){console.warn("Timestamp query or 64 byte colour attachment not supported, falling back"),t=await e.requestDevice()}return t})().then((async e=>{const t=new Ds(e),n=(e=>{const t=e.getEntitiesithComponent(Tu).values().next().value;return e.getComponents(t).get(Tu)})(this.ecs);n.device=e,n.volumeAtlas=t;const r=await Cs(e,t,"floor","./game-jam/floor.vxm"),i=this.ecs.addEntity();this.ecs.addComponents(i,new Si([0,-10,0],Le.identity(),[10,10,10]),r,new ku,new bu(r.size));const s=await Cs(e,t,"Pot","./game-jam/Pot4.vxm"),o=await Cs(e,t,"Dragon","./game-jam/Dragon.vxm"),a=await Cs(e,t,"Potion","./game-jam/HealthPotion.vxm"),c=await Cs(e,t,"Bomb","./game-jam/bomb.vxm"),l=this.ecs.addEntity();this.ecs.addComponents(l,new Au([s,o,a,c]));const u=this.ecs.addEntity(),h=this.ecs.addEntity(),d=await Cs(e,t,"sword","./game-jam/wooden-sword.vxm");this.ecs.addComponents(u,new Si([-20,30,-80],Le.fromEuler(0,Math.PI/180*90,0,"xyz"),[1.1,1.1,1.1]),d,new bu(d.size,{isTrigger:!0}),new Su(h),new _u(0),new Eu(h,te.create(24,12,-2),Le.fromEuler(0,Math.PI/180*90,Math.PI/180*-90,"zxy")));const f=await Cs(e,t,"player","./game-jam/player.vxm");this.ecs.addComponents(h,new Si([-20,30,-80],Le.identity(),[1.2,1.2,1.2]),new Pu(u),f,new _u(0),new wu(f.size,2,new Ls(0,0,0)));const p=this.ecs.addEntity(),m=this.ecs.addEntity();this.ecs.addComponents(m,new Si([-20,30,-80],Le.fromEuler(0,Math.PI/180*90,0,"xyz"),[1.1,1.1,1.1]),d,new bu(d.size,{isTrigger:!0}),new Su(p),new _u(1),new Eu(p,te.create(24,12,-2),Le.fromEuler(0,Math.PI/180*90,Math.PI/180*-90,"zxy")));const g=await Cs(e,t,"player","./game-jam/player.vxm");this.ecs.addComponents(p,new Si([20,30,-60],Le.identity(),[1.2,1.2,1.2]),g,new _u(1),new wu(f.size,2,new Ls(0,0,0)),new Pu(-1)),bs(e,t,this.ecs,[])}))}update(e,t){const n=this.ecs.getEntitiesithComponent(Ss).values().next().value,r=this.ecs.getComponents(n),i=r.get(Ss),s=r.get(Si);Ts(t,this.ecs,i,s,Array.from(e))}}),Du.addSystem(new class extends t{keyboardControls=new Mu;componentsRequired=new Set([Si,zu]);update(e,t){for(const t of e){const e=this.ecs.getComponents(t),n=e.get(Si),r=e.get(zu);this.keyboardControls.pressed.a&&(n.position=te.add(n.position,te.mulScalar(n.left,r.speed))),this.keyboardControls.pressed.d&&(n.position=te.add(n.position,te.mulScalar(n.right,r.speed))),this.keyboardControls.pressed.w&&(n.position=te.add(n.position,te.mulScalar(n.direction,r.speed))),this.keyboardControls.pressed.s&&(n.position=te.sub(n.position,te.mulScalar(n.direction,r.speed))),this.keyboardControls.pressed.q&&(n.rotation=Le.rotateY(n.rotation,-r.rotationSpeed)),this.keyboardControls.pressed.e&&(n.rotation=Le.rotateY(n.rotation,r.rotationSpeed)),this.keyboardControls.pressed[" "]&&(n.position=te.add(n.position,te.mulScalar(n.up,r.speed))),this.keyboardControls.pressed.shift&&(n.position=te.add(n.position,te.mulScalar(n.down,r.speed)))}}}),Du.addSystem(new class extends t{componentsRequired=new Set([wu,Si]);addedEntities=new Map;update(e,t,n){const r=Cu(this.ecs);for(const t of e)if(!this.addedEntities.has(t)){const e=this.ecs.getComponents(t),n=e.get(wu),i=e.get(Si).position,s=e.get(Si).rotation,o=e.get(Si).scale,a=new ho({angularFactor:n.angularFactor,mass:n.mass,position:new Ls(i[0],i[1],i[2]),shape:new co(new Ls(n.halfExtents.x*o[0],n.halfExtents.y*o[1],n.halfExtents.z*o[2])),quaternion:new Ks(s[0],s[1],s[2],s[3])});this.addedEntities.set(t,a),r.addBody(a),n.bodyId=a.id}for(const[t,n]of this.addedEntities)e.has(t)||r.removeBody(n);r.fixedStep();for(const[e,t]of this.addedEntities){const n=this.ecs.getComponents(e);if(!n)continue;const r=n.get(wu),i=n.get(Si);t.shapes[0]=new co(new Ls(r.halfExtents.x*i.scale[0],r.halfExtents.y*i.scale[1],r.halfExtents.z*i.scale[2]));const{x:s,y:o,z:a}=t.position,{x:c,y:l,z:u,w:h}=t.quaternion;i.previousTransform=i.transform,i.position=[s,o,a],i.rotation=[c,l,u,h]}}}),Du.addSystem(new class extends t{componentsRequired=new Set([bu,Si]);addedEntities=new Map;update(e,t,n){const r=this.ecs.getEntitiesithComponent(Iu).values().next().value,i=this.ecs.getComponents(r).get(Iu).world;for(const t of e)if(!this.addedEntities.has(t)){const e=this.ecs.getComponents(t),n=e.get(bu),r=e.get(Si),{position:s}=r,o=new ho({mass:0,type:ho.KINEMATIC,position:new Ls(s[0],s[1],s[2]),shape:new co(new Ls(n.halfExtents.x*r.scale[0],n.halfExtents.y*r.scale[1],n.halfExtents.z*r.scale[2])),...n.options});this.addedEntities.set(t,o),n.bodyId=o.id,i.addBody(o)}for(const[t,n]of this.addedEntities)e.has(t)||i.removeBody(n);for(const[e,t]of this.addedEntities){const n=this.ecs.getComponents(e),r=n.get(bu),i=n.get(Si);t.shapes[0]=new co(new Ls(r.halfExtents.x*i.scale[0],r.halfExtents.y*i.scale[1],r.halfExtents.z*i.scale[2]));const{x:s,y:o,z:a}=t.position,{x:c,y:l,z:u,w:h}=t.quaternion;i.position=[s,o,a],i.rotation=[c,l,u,h]}}}),Du.addSystem(new class extends t{componentsRequired=new Set([ku,Si,wu]);springs;update(e,t,n){const r=this.ecs.getEntitiesithComponent(Iu).values().next().value,i=this.ecs.getComponents(r).get(Iu).world,s=e.values().next().value,o=this.ecs.getComponents(s);if(!o)return;const a=o.get(Si),c=o.get(wu),{position:l}=a;if(!this.springs){const e=i.getBodyById(c.bodyId),t=[c.halfExtents.x*a.scale[0],c.halfExtents.y*a.scale[1],c.halfExtents.z*a.scale[2]],n=[[-t[0],-20,-t[2]],[-t[0],-20,t[2]],[t[0],-20,-t[2]],[t[0],-20,t[2]]];this.springs=n.map((t=>{const[n,r,s]=t,o=new ho({mass:0,position:new Ls(n,r,s),shape:new co(new Ls(1,1,1))});return i.addBody(o),new Ha(e,o,{restLength:0,stiffness:100,damping:10,localAnchorA:new Ls(n,0,s),localAnchorB:new Ls(0,1,0)})}))}this.springs.forEach((e=>{e.applyForce()}))}}),Du.addSystem(new class extends t{componentsRequired=new Set([wu,Si,_u,Pu]);update(e,t,n){const r=Cu(this.ecs);for(const i of e){const e=this.ecs.getComponents(i),s=e.get(wu),o=e.get(Si),a=e.get(_u),c=navigator.getGamepads()[a.player];if(!c)return;const l=r.getBodyById(s.bodyId),{position:u}=o,{axes:h}=c;let d=te.create(0,0,0);Math.abs(h[0])>Bu&&(d[0]=h[0]),Math.abs(h[1])>Bu&&(d[2]=-h[1]),te.normalize(d,d);const f=te.add(u,te.mulScalar(d,.1*n)),p=Math.abs(h[0])>Bu||Math.abs(h[1])>Bu?.25*Math.sin(.02*t):0;l.position.set(f[0],f[1]+p,f[2])}}}),Du.addSystem(new class extends t{componentsRequired=new Set([wu,Si,_u,Pu]);update(e,t){const n=Cu(this.ecs);for(const t of e){const r=this.ecs.getComponents(t),i=r.get(Si),s=r.get(wu);let o=null;for(const n of e)n!==t&&(o=n);if(!o)return;const a=this.ecs.getComponents(o),c=te.sub(a.get(Si).position,i.position),l=Le.fromEuler(0,Math.atan2(c[0],c[2]),0,"xyz");n.getBodyById(s.bodyId).quaternion.set(l[0],l[1],l[2],l[3])}}}),Du.addSystem(new class extends t{componentsRequired=new Set([Ou]);addedSprings=new Map;update(e,t,n){const r=Cu(this.ecs);for(const t of e){const e=this.ecs.getComponents(t).get(Ou),n=this.ecs.getComponents(e.entity1).get(wu),i=this.ecs.getComponents(e.entity2).get(wu);if(n&&i&&!this.addedSprings.has(t)){const s=new Ha(r.getBodyById(n.bodyId),r.getBodyById(i.bodyId),{localAnchorA:e.pivot1,localAnchorB:e.pivot2,...e.config});this.addedSprings.set(t,s)}}for(const[,e]of this.addedSprings)e.applyForce()}}),Du.addSystem(new class extends t{componentsRequired=new Set([_u,Su,Eu,bu]);isSwinging=new Map;canSwing=new Map;addedEvents=new Map;update(e,t){const n=Cu(this.ecs);for(const t of e){this.isSwinging.has(t)||this.isSwinging.set(t,!1),this.canSwing.has(t)||this.canSwing.set(t,!0);const e=this.ecs.getComponents(t),r=e.get(Su),i=e.get(bu),s=n.getBodyById(i.bodyId),o=e.get(Eu),a=this.ecs.getComponents(r.playerEntity);r.bodyId=i.bodyId;const c=a.get(Si),l=e.get(_u),u=a.get(wu);if(!c||!u)return;const h=n.getBodyById(u.bodyId),d=te.add(te.mulScalar(c.left,250),te.mulScalar(c.direction,500));o.position=Ru,o.rotation=Uu,this.isSwinging.get(t)?s.velocity.set(d[0],d[1],d[2]):s.velocity.set(0,0,0);const f=navigator.getGamepads()[l.player];if(!f)return;if(!this.addedEvents.has(t)){const e=e=>{if(e.body.id!==h.id&&this.isSwinging.get(t)){e.body.applyImpulse(s.velocity.scale(.1),new Ls(0,0,0));const t=document.getElementById("sword-hit-audio");t.currentTime=0,t.volume=.1,t.play(),document.dispatchEvent(new CustomEvent("player-damaged",{detail:{bodyId:e.body.id}}))}};s.addEventListener("collide",e),this.addedEvents.set(t,e)}if(f.buttons[0].pressed&&this.canSwing.get(t)){this.isSwinging.set(t,!0),this.canSwing.set(t,!1);const e=document.getElementById("swoosh-audio");e.currentTime=0,e.volume=.5,e.play(),setTimeout((()=>{this.isSwinging.set(t,!1)}),100),setTimeout((()=>{this.canSwing.set(t,!0)}),500)}}}}),Du.addSystem(new class extends t{componentsRequired=new Set([Nu]);addedHinges=new Map;update(e,t,n){const r=Cu(this.ecs);for(const t of e){const e=this.ecs.getComponents(t).get(Nu),n=this.ecs.getComponents(e.entity1).get(wu),i=this.ecs.getComponents(e.entity2).get(wu);if(n&&i&&!this.addedHinges.has(t)){const s=new Da(r.getBodyById(n.bodyId),r.getBodyById(i.bodyId),e.config);this.addedHinges.set(t,s),r.addConstraint(s)}}}}),Du.addSystem(new class extends t{componentsRequired=new Set([Eu,Si,bu]);update(e,t,n){const r=Cu(this.ecs);for(const t of e){const e=this.ecs.getComponents(t),i=e.get(Eu),s=e.get(Si),o=e.get(bu),a=this.ecs.getComponents(i.targetEntity).get(Si);if(!a)return;const c=te.mulScalar(a.right,i.position[0]),l=te.mulScalar(a.up,i.position[1]),u=te.mulScalar(a.direction,i.position[2]),h=te.add(te.add(c,l),u),d=i.speed*n,f=r.getBodyById(o.bodyId),p=te.add(a.position,h),m=s.position,g=te.lerp(m,p,d);f.position.set(g[0],g[1],g[2]);const y=Le.mul(a.rotation,i.rotation),v=Le.slerp(s.rotation,y,d);f.quaternion.set(v[0],v[1],v[2],v[3])}}}),Du.addSystem(new class extends t{componentsRequired=new Set([Au]);timeSinceLastSpawn=0;update(e,t,n){if(this.timeSinceLastSpawn+=n,!(this.timeSinceLastSpawn<3e3)){this.timeSinceLastSpawn=0;for(const t of e){const e=this.ecs.getComponents(t).get(Au).voxelObjects,n=e[Math.floor(Math.random()*e.length)],r=this.ecs.addEntity();this.ecs.addComponents(r,n);const i=320*Math.random()-120,s=150,o=320*Math.random()-120,a=15/Math.min(...n.size);this.ecs.addComponents(r,new Si([i,s,o],Le.identity(),[a,a,a]),n,new wu(n.size)),"Bomb"===n.name&&this.ecs.addComponent(r,new ju(3))}}}}),Du.addSystem(new class extends t{componentsRequired=new Set([ju,wu,Si]);startTimes=new Map;update(e,t,n){const r=Cu(this.ecs),i=document.getElementById("bomb-fuse-audio"),s=document.getElementById("bomb-explosion-audio");for(const n of e){const e=this.ecs.getComponents(n),o=e.get(ju),a=e.get(wu),c=e.get(Si),l=r.getBodyById(a.bodyId);if(!l)continue;this.startTimes.has(n)||(this.startTimes.set(n,t),i.volume=.2,i.play(),i.currentTime=1,setTimeout((()=>{s.volume=.2,s.currentTime=0,s.play(),r.bodies.forEach((e=>{const t=e.position.vsub(l.position).unit(),n=500-e.position.distanceTo(l.position);e.applyImpulse(t.vmul(new Ls(n,n,n)))})),this.ecs.removeEntity(n),i.pause()}),1e3*o.timer));const u=t-this.startTimes.get(n),h=1+5e-4*u;c.scale=[h,h,h],u>1e3*o.timer-50&&(c.scale=[2*h,.5*h,2*h])}}}),Du.addSystem(new class extends t{componentsRequired=new Set([Pu,wu]);addedEvents=new Map;constructor(){super()}update(e,t,n){Cu(this.ecs);for(const t of e)if(!this.addedEvents.has(t)){const e=e=>{const{bodyId:n}=e.detail,r=this.ecs.getComponents(t),i=r.get(Pu);n===r.get(wu).bodyId&&(i.health-=1,console.log("Player health:",i.health))};document.addEventListener("player-damaged",e)}}});const qu=Du.addEntity();Du.addComponent(qu,new Tu),Du.addComponent(qu,new Iu);const Fu=Du.addEntity();Du.addComponents(Fu,new Ss({fieldOfView:Math.PI/180*50,near:.5,far:1e4}),new Si(te.create(0,250,-250),Le.fromEuler(Math.PI/180*50,0,0,"xyz"),te.create(1,1,1)));const Lu=Du.addEntity();Du.addComponents(Lu,new Si(te.create(0,0,0),Le.identity(),te.create(1,1,1)),new zu);const Vu=e=>{Du.update(e),requestAnimationFrame(Vu)};requestAnimationFrame(Vu)})();