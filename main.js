(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};e.d({},{nS:()=>p,JQ:()=>d,sL:()=>y,Uh:()=>u,ZU:()=>f});const t=(e,t)=>{const n=new Uint32Array(t);u.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},n=(e,n)=>{const r=new Uint32Array(e),i=u.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:n});return t(i,e),i},r=(e,t)=>{const n=new Float32Array(e),r=u.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return((e,t)=>{const n=new Float32Array(t);u.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)})(r,e),r};class i{x;y;constructor(e,t){this.x=e,this.y=t}get uniformBuffer(){return n([this.x,this.y])}static zero=new i(0,0);static one=new i(1,1);static up=new i(0,1);static down=new i(0,-1);static left=new i(-1,0);static right=new i(1,1);toArray(){return[this.x,this.y]}mul(e){if(e instanceof i)return new i(this.x*e.x,this.y*e.y);if("number"==typeof e)return new i(this.x*e,this.y*e);throw new Error("Can only multiply Vector2 by Vector2 or Number")}add(e){return new i(this.x+e.x,this.y+e.y)}subtract(e){return new i(this.x-e.x,this.y-e.y)}normalize(){const e=Math.sqrt(this.x**2+this.y**2);return new i(this.x/e,this.y/e)}negate(){return new i(-this.x,-this.y)}}class o{x;y;z;constructor(e,t,n){this.x=e,this.y=t,this.z=n}get uniformBuffer(){return n([this.x,this.y,this.z])}static zero=new o(0,0,0);static one=new o(1,1,1);static up=new o(0,1,0);static down=new o(0,-1,0);static left=new o(-1,0,0);static right=new o(1,0,0);toArray(){return[this.x,this.y,this.z]}mul(e){if(e instanceof o)return new o(this.x*e.x,this.y*e.y,this.z*e.z);if("number"==typeof e)return new o(this.x*e,this.y*e,this.z*e);throw new Error("Can only multiply Vector3 by Vector3 or Number")}add(e){return new o(this.x+e.x,this.y+e.y,this.z+e.z)}subtract(e){return new o(this.x-e.x,this.y-e.y,this.z-e.z)}cross(e){return new o(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}normalize(){const e=Math.sqrt(this.x**2+this.y**2+this.z**2);return new o(0!==this.x?this.x/e:0,0!==this.y?this.y/e:0,0!==this.z?this.z/e:0)}negate(){return new o(-this.x,-this.y,-this.z)}rotateAroundAxis(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x*(n+(1-n)*e.x*e.x)+this.y*((1-n)*e.x*e.y-r*e.z)+this.z*((1-n)*e.x*e.z+r*e.y),s=this.x*((1-n)*e.y*e.x+r*e.z)+this.y*(n+(1-n)*e.y*e.y)+this.z*((1-n)*e.y*e.z-r*e.x),a=this.x*((1-n)*e.z*e.x-r*e.y)+this.y*((1-n)*e.z*e.y+r*e.x)+this.z*(n+(1-n)*e.z*e.z);return new o(i,s,a)}}class s{position;targetPosition;velocity;constructor(e){this.position=e.position,this.targetPosition=this.position,this.velocity=o.zero}update(){p.velocity=p.velocity.mul(1-.015*y),this.position=this.position.add(this.velocity.mul(y))}}const a=new class{pressed={w:!1,a:!1,s:!1,d:!1," ":!1,Control:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1}))}},c=new class{velocity=i.zero;animationFrame;constructor(){window.addEventListener("mousemove",(e=>{cancelAnimationFrame(this.animationFrame),this.velocity=new i(e.movementX,e.movementY),this.animationFrame=requestAnimationFrame((()=>{this.velocity=i.zero}))}))}};let u,l,d,f=new i(0,0);const m=performance.now();let h=m,y=0,p=new class extends s{fieldOfView;direction;constructor(e){super({position:e.position}),this.fieldOfView=e.fieldOfView,this.direction=new o(0,0,1)}reset(e){this.position=new o(0,0,-5),this.targetPosition=this.position,this.fieldOfView=e.fieldOfView,this.direction=new o(0,0,1)}get right(){return o.up.cross(this.direction).normalize()}get left(){return this.direction.cross(o.up).normalize()}get up(){return this.direction.cross(this.right).normalize()}get down(){return this.up.negate()}rotateX(e){this.direction=this.direction.rotateAroundAxis(this.right,e)}rotateY(e){this.direction=this.direction.rotateAroundAxis(o.up,e)}}({fieldOfView:90,position:new o(0,0,-5)});new class{constructor(){document.getElementById("reset").addEventListener("click",(e=>{p.reset({fieldOfView:90}),document.getElementById("captures").innerHTML=""})),document.getElementById("capture").addEventListener("click",(e=>{const t=new Image;t.id=performance.now().toString(),t.src=d.toDataURL(),document.getElementById("captures").appendChild(t).addEventListener("click",(e=>{e.target,console.log(e.target)}))}))}};void 0!==navigator.gpu?navigator.gpu.requestAdapter().then((e=>{e.requestDevice().then((e=>{u=e;const s=(()=>{let e;return{start:()=>{e=u.createComputePipeline({layout:"auto",compute:{module:u.createShaderModule({code:"\n          // Function to mimic the ease_out_expo function\nfn ease_out_expo(x: f32) -> f32 {\n    let t: f32 = x;\n    let b: f32 = 0.0;\n    let c: f32 = 1.0;\n    let d: f32 = 1.0; // Set the duration within the function\n\n    let intermediate_result: f32 = c * (-pow(2.0, -10.0 * t / d) + 1.0) + b;\n\n    return select(intermediate_result, b + c, t == d);\n\n}\n\nfn sample_sky(rayDirection: vec3<f32>) -> vec3<f32> {\n    //TODO: add this to uniforms\n    let lightDirection = normalize(vec3(1.0,1.0,0.));\n    let y = clamp(ease_out_expo(rayDirection.y * 0.66), 0.0, 1.0);\n//    let y = rayDirection.y;\n    let sunHeight = clamp(lightDirection.y, 0.0, 1.0);\n    let horizon = mix(vec3<f32>(0.95, 0.5, 0.4), vec3<f32>(0.6, 0.8, 1.0), sunHeight);\n    let sky = mix(vec3<f32>(0.55, 0.7, 0.7), vec3<f32>(0.3, 0.6, 0.95), sunHeight);\n    let sunFalloff = 0.8;\n    let sunAmount = 1.0 - ease_out_expo(length(lightDirection - rayDirection) * sunFalloff);\n//    let sunAmount = 1.0 - length(lightDirection - rayDirection) * sunFalloff;\n    let skyColour = mix(horizon, sky, y);\n    let sunColour = mix(vec3<f32>(1.8, 1.6, 1.1), vec3<f32>(1.6, 1.6, 1.4), sunHeight);\n\n    let intensity = clamp(sunHeight, 0.75, 1.0);\n    return mix(skyColour, sunColour, clamp(sunAmount, 0.0, 1.0)) * intensity;\n}struct FrustumCornerDirections {\n  topLeft : vec3<f32>,\n  topRight : vec3<f32>,\n  bottomLeft : vec3<f32>,\n  bottomRight : vec3<f32>\n}\n\nfn calculateRayDirection(uv: vec2<f32>, directions: FrustumCornerDirections) -> vec3<f32> {\n  let topInterpolated = mix(directions.topLeft, directions.topRight, uv.x);\n  let bottomInterpolated = mix(directions.bottomLeft, directions.bottomRight, uv.x);\n  let finalInterpolated = mix(bottomInterpolated, topInterpolated, uv.y);\n  return normalize(finalInterpolated);\n}\n\nfn boxIntersection(\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n    boxSize: vec3<f32>,\n) -> vec4<f32> {\n    let m: vec3<f32> = 1.0 / rd;\n    let n: vec3<f32> = m * ro;\n    let k: vec3<f32> = abs(m) * boxSize;\n\n    let t1: vec3<f32> = -n - k;\n    let t2: vec3<f32> = -n + k;\n\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) {\n        return vec4<f32>(-1.0);\n    }\n\n    var normal = select(\n        step(vec3<f32>(tN), t1),\n        step(t2, vec3<f32>(tF)),\n        tN < 0.0,\n    );\n\n    normal *= -sign(rd);\n\n    return vec4<f32>(tN, normal);\n}\n\n@group(0) @binding(0) var outputTex : texture_storage_2d<rgba8unorm, write>;\n@group(0) @binding(1) var<uniform> time : u32;\n@group(0) @binding(2) var<uniform> resolution : vec2<u32>;\n@group(0) @binding(3) var<uniform> frustumCornerDirections : FrustumCornerDirections;\n@group(0) @binding(4) var<uniform> cameraPosition : vec3<f32>;\n\nconst EPSILON = 0.0001;\n\n@compute @workgroup_size(1, 1, 1)\nfn main(\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>\n) {\nlet timeOffset = (sin(f32(time) * 0.001) * 0.5 + 0.5) * 2.0;\n  let pixel = vec2<f32>(f32(WorkGroupID.x), f32(resolution.y - WorkGroupID.y));\n  let uv = pixel / vec2<f32>(resolution);\n  let rayOrigin = cameraPosition;\n  var rayDirection = calculateRayDirection(uv,frustumCornerDirections);\n  var boxSize = vec3<f32>(1.0);\n  let intersect = boxIntersection(rayOrigin, rayDirection, boxSize);\n  var colour = sample_sky(rayDirection);\n  let tNear = intersect.x;\n  if(tNear > 0.0){\n      let pos = rayOrigin + (intersect.x +EPSILON)  * rayDirection;\n      let normal = intersect.yzw;\n      colour = fract(pos);\n  }\n\n  textureStore(outputTex, WorkGroupID.xy, vec4(colour,1));\n}\n"}),entryPoint:"main"}})},render:({commandEncoder:t,timeBuffer:n,resolutionBuffer:i,outputTextureView:s})=>{const a=(e=>{const t=f.x/f.y,n=e.fieldOfView/2,r=Math.tan(n),i=o.up.cross(e.direction).normalize(),s=e.direction.cross(i).normalize().mul(r);return[e.direction.add(s).add(i.mul(-t*r)),e.direction.add(s).add(i.mul(t*r)),e.direction.subtract(s).add(i.mul(-t*r)),e.direction.subtract(s).add(i.mul(t*r))]})(p).flatMap((e=>[...e.toArray(),0])),c=r(a,"frustum corner directions"),l=r(p.position.toArray(),"camera position"),d=t.beginComputePass();d.setPipeline(e);const m=u.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:s},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:c}},{binding:4,resource:{buffer:l}}]});d.setBindGroup(0,m),d.dispatchWorkgroups(f.x,f.y),d.end()}}})();((e,r)=>{let s,u,x,g,v,w;d=document.getElementById("webgpu-canvas"),d.addEventListener("click",(async()=>{d.requestPointerLock()})),document.addEventListener("pointerlockchange",(()=>{w=null!==document.pointerLockElement})),l=d.getContext("webgpu");const b=navigator.gpu.getPreferredCanvasFormat();l.configure({device:e,format:b,usage:GPUTextureUsage.RENDER_ATTACHMENT});const z=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n}\n\n@vertex\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}\n\n@fragment\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\n//    return vec4(sin(f32(time) * 0.001), 0, 0, 1);\n    return textureSample(myTexture, mySampler, fragUV);\n}\n"}),E=e.createRenderPipeline({layout:"auto",vertex:{module:z,entryPoint:"vertex_main"},fragment:{module:z,entryPoint:"fragment_main",targets:[{format:b}]}}),P=async()=>{const i=performance.now()-m;y=i-h,h=i,w&&(()=>{const e=2e-4;if(p.rotateY(c.velocity.x*y*e),p.rotateX(c.velocity.y*y*e),!document.hasFocus())return;let t=o.zero;a.pressed.a&&(t=t.add(p.left)),a.pressed.d&&(t=t.add(p.right)),a.pressed.w&&(t=t.add(p.direction)),a.pressed.s&&(t=t.subtract(p.direction)),a.pressed[" "]&&(t=t.add(p.up)),a.pressed.Control&&(t=t.add(p.down)),t=t.normalize(),p.velocity=p.velocity.add(t.mul(.001))})(),p.update();const d=e.createCommandEncoder();g?t(g,[h]):g=n([h]),v?t(v,[f.x,f.y]):v=n([f.x,f.y]);const b=(u&&u.destroy(),u=e.createTexture({size:[f.x,f.y,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING}),u.createView());r.forEach((e=>{e.render({commandEncoder:d,timeBuffer:g,resolutionBuffer:v,outputTextureView:b})})),(({commandEncoder:t,outputTextureView:n})=>{const r=t.beginRenderPass({colorAttachments:[{view:l.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]});s=e.createBindGroup({layout:E.getBindGroupLayout(0),entries:[{binding:0,resource:e.createSampler({magFilter:"linear",minFilter:"linear"})},{binding:1,resource:n}]}),r.setPipeline(E),r.setBindGroup(0,s),r.draw(6),r.end()})({commandEncoder:d,outputTextureView:b}),e.queue.submit([d.finish()]),x=requestAnimationFrame(P)};new ResizeObserver((()=>{cancelAnimationFrame(x),(()=>{const{clientWidth:e,clientHeight:t}=d.parentElement;f=new i(e,t),d.width=f.x,d.height=f.y,r.forEach((e=>{e.start()})),x=requestAnimationFrame(P)})()})).observe(d.parentElement)})(u,[s])}))})):console.error("WebGPU not supported")})();