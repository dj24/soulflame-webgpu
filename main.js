(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};e.d({},{nS:()=>y,JQ:()=>d,sL:()=>h,Uh:()=>l,ZU:()=>f});const t=(e,t)=>{const n=new Uint32Array(t);l.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},n=(e,n)=>{const r=new Uint32Array(e),i=l.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:n});return t(i,e),i},r=(e,t)=>{const n=new Float32Array(e),r=l.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return((e,t)=>{const n=new Float32Array(t);l.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)})(r,e),r};class i{x;y;constructor(e,t){this.x=e,this.y=t}get uniformBuffer(){return n([this.x,this.y])}static zero=new i(0,0);static one=new i(1,1);static up=new i(0,1);static down=new i(0,-1);static left=new i(-1,0);static right=new i(1,1);toArray(){return[this.x,this.y]}mul(e){if(e instanceof i)return new i(this.x*e.x,this.y*e.y);if("number"==typeof e)return new i(this.x*e,this.y*e);throw new Error("Can only multiply Vector2 by Vector2 or Number")}add(e){return new i(this.x+e.x,this.y+e.y)}subtract(e){return new i(this.x-e.x,this.y-e.y)}normalize(){const e=Math.sqrt(this.x**2+this.y**2);return new i(this.x/e,this.y/e)}negate(){return new i(-this.x,-this.y)}}class o{x;y;z;constructor(e,t,n){this.x=e,this.y=t,this.z=n}get uniformBuffer(){return n([this.x,this.y,this.z])}static zero=new o(0,0,0);static one=new o(1,1,1);static up=new o(0,1,0);static down=new o(0,-1,0);static left=new o(-1,0,0);static right=new o(1,0,0);toArray(){return[this.x,this.y,this.z]}toString(){return`Vector3(${this.x.toFixed(2)},${this.y.toFixed(2)},${this.z.toFixed(2)})`}mul(e){if(e instanceof o)return new o(this.x*e.x,this.y*e.y,this.z*e.z);if("number"==typeof e)return new o(this.x*e,this.y*e,this.z*e);throw new Error("Can only multiply Vector3 by Vector3 or Number")}add(e){return new o(this.x+e.x,this.y+e.y,this.z+e.z)}subtract(e){return new o(this.x-e.x,this.y-e.y,this.z-e.z)}cross(e){return new o(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}normalize(){const e=Math.sqrt(this.x**2+this.y**2+this.z**2);return new o(0!==this.x?this.x/e:0,0!==this.y?this.y/e:0,0!==this.z?this.z/e:0)}negate(){return new o(-this.x,-this.y,-this.z)}rotateAroundAxis(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x*(n+(1-n)*e.x*e.x)+this.y*((1-n)*e.x*e.y-r*e.z)+this.z*((1-n)*e.x*e.z+r*e.y),s=this.x*((1-n)*e.y*e.x+r*e.z)+this.y*(n+(1-n)*e.y*e.y)+this.z*((1-n)*e.y*e.z-r*e.x),a=this.x*((1-n)*e.z*e.x-r*e.y)+this.y*((1-n)*e.z*e.y+r*e.x)+this.z*(n+(1-n)*e.z*e.z);return new o(i,s,a)}}class s{position;targetPosition;velocity;constructor(e){this.position=e.position,this.targetPosition=this.position,this.velocity=o.zero}update(){y.velocity=y.velocity.mul(1-.015*h),this.position=this.position.add(this.velocity.mul(h))}}const a=new class{pressed={w:!1,a:!1,s:!1,d:!1," ":!1,Control:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1}))}},c=new class{velocity=i.zero;animationFrame;constructor(){window.addEventListener("mousemove",(e=>{cancelAnimationFrame(this.animationFrame),this.velocity=new i(e.movementX,e.movementY),this.animationFrame=requestAnimationFrame((()=>{this.velocity=i.zero}))}))}};let l,u,d,f=new i(0,0),m=1;const x=performance.now();let v=x,h=0,y=new class extends s{fieldOfView;direction;constructor(e){super({position:e.position}),this.fieldOfView=e.fieldOfView,this.direction=e.direction}reset(e){this.position=new o(16,16,-16),this.targetPosition=this.position,this.fieldOfView=e.fieldOfView,this.direction=new o(0,0,1)}get right(){return o.up.cross(this.direction).normalize()}get left(){return this.direction.cross(o.up).normalize()}get up(){return this.direction.cross(this.right).normalize()}get down(){return this.up.negate()}rotateX(e){this.direction=this.direction.rotateAroundAxis(this.right,e)}rotateY(e){this.direction=this.direction.rotateAroundAxis(o.up,e)}}({fieldOfView:70,position:new o(120,120,120),direction:new o(-1,-1,-1).normalize()});const p=new class{logElement;constructor(){document.getElementById("reset").addEventListener("click",(e=>{y.reset({fieldOfView:90}),document.getElementById("captures").innerHTML=""})),document.getElementById("capture").addEventListener("click",(e=>{const t=new Image;t.id=performance.now().toString(),t.src=d.toDataURL(),document.getElementById("captures").appendChild(t).addEventListener("click",(e=>{e.target,console.log(e.target)}))})),document.getElementById("downscale").addEventListener("input",(e=>{const t=e.target;window.dispatchEvent(new CustomEvent("changeDownscale",{detail:t.value}))})),this.logElement=document.getElementById("log")}log(e){this.logElement.innerText=e}};let g;void 0!==navigator.gpu?navigator.gpu.requestAdapter().then((e=>{e.requestDevice().then((e=>{l=e;const s=(()=>{let e;return{start:()=>{e=l.createComputePipeline({layout:"auto",compute:{module:l.createShaderModule({code:"\n          // Function to mimic the ease_out_expo function\nfn ease_out_expo(x: f32) -> f32 {\n    let t: f32 = x;\n    let b: f32 = 0.0;\n    let c: f32 = 1.0;\n    let d: f32 = 1.0; // Set the duration within the function\n\n    let intermediate_result: f32 = c * (-pow(2.0, -10.0 * t / d) + 1.0) + b;\n\n    return select(intermediate_result, b + c, t == d);\n\n}\n\nfn sample_sky(rayDirection: vec3<f32>) -> vec3<f32> {\n    //TODO: add this to uniforms\n    let lightDirection = normalize(vec3(1.0,1.0,0.));\n    let y = clamp(ease_out_expo(rayDirection.y * 0.66), 0.0, 1.0);\n//    let y = rayDirection.y;\n    let sunHeight = clamp(lightDirection.y, 0.0, 1.0);\n    let horizon = mix(vec3<f32>(0.95, 0.5, 0.4), vec3<f32>(0.6, 0.8, 1.0), sunHeight);\n    let sky = mix(vec3<f32>(0.55, 0.7, 0.7), vec3<f32>(0.3, 0.6, 0.95), sunHeight);\n    let sunFalloff = 0.8;\n    let sunAmount = 1.0 - ease_out_expo(length(lightDirection - rayDirection) * sunFalloff);\n//    let sunAmount = 1.0 - length(lightDirection - rayDirection) * sunFalloff;\n    let skyColour = mix(horizon, sky, y);\n    let sunColour = mix(vec3<f32>(1.8, 1.6, 1.1), vec3<f32>(1.6, 1.6, 1.4), sunHeight);\n\n    let intensity = clamp(sunHeight, 0.75, 1.0);\n    return mix(skyColour, sunColour, clamp(sunAmount, 0.0, 1.0)) * intensity;\n}struct FrustumCornerDirections {\n  topLeft : vec3<f32>,\n  topRight : vec3<f32>,\n  bottomLeft : vec3<f32>,\n  bottomRight : vec3<f32>\n}\n\nfn calculateRayDirection(uv: vec2<f32>, directions: FrustumCornerDirections) -> vec3<f32> {\n  let topInterpolated = mix(directions.topLeft, directions.topRight, uv.x);\n  let bottomInterpolated = mix(directions.bottomLeft, directions.bottomRight, uv.x);\n  let finalInterpolated = mix(bottomInterpolated, topInterpolated, uv.y);\n  return normalize(finalInterpolated);\n}\n\nstruct BoxIntersectionResult {\n    tNear: f32,\n    tFar: f32,\n    normal: vec3<f32>,\n}\n\nfn boxIntersection(\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n    boxSize: vec3<f32>,\n) -> BoxIntersectionResult {\n    var result = BoxIntersectionResult();\n\n    let offsetRayOrigin = ro - boxSize;\n    let m: vec3<f32> = 1.0 / rd;\n    let n: vec3<f32> = m * offsetRayOrigin;\n    let k: vec3<f32> = abs(m) * boxSize;\n\n    let t1: vec3<f32> = -n - k;\n    let t2: vec3<f32> = -n + k;\n\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) {\n        result.tNear = -1.0;\n        result.tFar = -1.0;\n        result.normal = vec3(0.0);\n\n        return result;\n    }\n\n    // Check if the ray starts inside the volume\n    let insideVolume = tN < 0.0;\n\n    var normal = select(\n        step(vec3<f32>(tN), t1),\n        step(t2, vec3<f32>(tF)),\n        tN < 0.0,\n    );\n\n    normal *= -sign(rd);\n\n    // Check if the intersection is in the correct direction, only if inside the volume\n    if (insideVolume && dot(normal, rd) < 0.0) {\n        result.tNear = -1.0;\n        result.tFar = -1.0;\n        result.normal = vec3(0.0);\n        return result;\n    }\n\n\n\n    result.tNear = tN;\n    result.tFar = tF;\n    result.normal = normal;\n\n    return result;\n}\n\n@group(0) @binding(0) var outputTex : texture_storage_2d<rgba8unorm, write>;\n@group(0) @binding(1) var<uniform> time : u32;\n@group(0) @binding(2) var<uniform> resolution : vec2<u32>;\n@group(0) @binding(3) var<uniform> frustumCornerDirections : FrustumCornerDirections;\n@group(0) @binding(4) var<uniform> cameraPosition : vec3<f32>;\n\nconst EPSILON = 0.0001;\nconst BORDER_WIDTH = 0.05;\nconst BOUNDS_SIZE = 64.0;\nconst MAX_RAY_STEPS = 256;\n\nfn addVoxelBorderColour(baseColour: vec3<f32>, worldPos: vec3<f32>) -> vec3<f32> {\n  let positionInVoxel = fract(worldPos);\n  let voxelBorder = step(positionInVoxel, vec3(1 - BORDER_WIDTH)) - step(positionInVoxel, vec3(BORDER_WIDTH));\n  let isVoxelBorder = step(length(voxelBorder), 1.0);\n  return mix(baseColour,baseColour * 0.8,isVoxelBorder);\n}\n\nfn addBoundsBorderColour(baseColour: vec3<f32>, worldPos: vec3<f32>) -> vec3<f32> {\n  let positionInBounds = fract(worldPos / BOUNDS_SIZE);\n  let boundsBorderWidth = BORDER_WIDTH / BOUNDS_SIZE * 4.0;\n  let boundsBorder = step(positionInBounds, vec3(1 - boundsBorderWidth)) - step(positionInBounds, vec3(boundsBorderWidth));\n  let isBoundsBorder = step(length(boundsBorder), 1.0);\n  return mix(baseColour,vec3(1.0,0.0,1.0),isBoundsBorder);\n}\n\nfn sampleVoxel(position: vec3<f32>) -> bool {\n  let layer1 = (sin(position.x * 0.25) - sin(position.z * 0.25)) * 2;\n  let layer2 = (sin(position.x * 0.125) - sin(position.z * 0.125)) * 4;\n  let isSolidVoxel = layer1 + layer2 > (position.y - 32);\n  return isSolidVoxel;\n}\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  var voxelSize = 1.0;\n  let timeOffset = (sin(f32(time) * 0.001) * 0.5 + 0.5) * 2.0;\n  let pixel = vec2<f32>(f32(GlobalInvocationID.x), f32(resolution.y - GlobalInvocationID.y));\n  let uv = pixel / vec2<f32>(resolution);\n  var rayOrigin = cameraPosition;\n  var rayDirection = calculateRayDirection(uv,frustumCornerDirections);\n\n  let objectCenter = vec3<f32>(BOUNDS_SIZE / 2.0);\n  // Initialize the object transformation matrix as the identity matrix\n    var objectTransformMatrix: mat4x4<f32> = mat4x4<f32>(\n        vec4<f32>(1.0, 0.0, 0.0, 0.0),\n        vec4<f32>(0.0, 1.0, 0.0, 0.0),\n        vec4<f32>(0.0, 0.0, 1.0, 0.0),\n        vec4<f32>(0.0, 0.0, 0.0, 1.0)\n    );\n\n  // Translate the object to bring its center to the origin\n  let translateToOrigin: mat4x4<f32> = mat4x4<f32>(\n      vec4<f32>(1.0, 0.0, 0.0, -objectCenter.x),\n      vec4<f32>(0.0, 1.0, 0.0, -objectCenter.y),\n      vec4<f32>(0.0, 0.0, 1.0, -objectCenter.z),\n      vec4<f32>(0.0, 0.0, 0.0, 1.0)\n  );\n\n  // Rotate the object around its center based on time\n  let rotationAngle: f32 = f32(time) * 0.0005;\n  let rotationMatrix: mat4x4<f32> = mat4x4<f32>(\n      vec4<f32>(cos(rotationAngle), 0.0, sin(rotationAngle), 0.0),\n      vec4<f32>(0.0, 1.0, 0.0, 0.0),\n      vec4<f32>(-sin(rotationAngle), 0.0, cos(rotationAngle), 0.0),\n      vec4<f32>(0.0, 0.0, 0.0, 1.0)\n  );\n\n  // Translate the object back to its original position\n  let translateBack: mat4x4<f32> = mat4x4<f32>(\n      vec4<f32>(1.0, 0.0, 0.0, objectCenter.x),\n      vec4<f32>(0.0, 1.0, 0.0, objectCenter.y),\n      vec4<f32>(0.0, 0.0, 1.0, objectCenter.z),\n      vec4<f32>(0.0, 0.0, 0.0, 1.0)\n  );\n\n  // Combine the translation, rotation, and translation matrices\n  objectTransformMatrix = translateBack * rotationMatrix * translateToOrigin * objectTransformMatrix;\n\n  var boxSize = vec3<f32>(BOUNDS_SIZE);\n\n  var colour = sample_sky(rayDirection);\n\n  // Transform the ray using the combined matrix\n  rayOrigin = (objectTransformMatrix * vec4<f32>(rayOrigin, 1.0)).xyz;\n  rayDirection = (objectTransformMatrix * vec4<f32>(rayDirection, 0.0)).xyz;\n\n  let intersect = boxIntersection(rayOrigin, rayDirection, boxSize * 0.5);\n\n  let tNear = intersect.tNear;\n  let boundingBoxSurfacePosition = rayOrigin + (tNear + EPSILON)  * rayDirection;\n  let isStartingInBounds = all(boundingBoxSurfacePosition > vec3(0.0)) && all(boundingBoxSurfacePosition < vec3(BOUNDS_SIZE / voxelSize));\n  if(tNear > 0.0 || isStartingInBounds){\n    var pos = boundingBoxSurfacePosition;\n    var normal = vec3(0.0);\n    var stepsTaken = 0;\n    var voxelStep = sign(rayDirection);\n    var tIntersection = 0.0;\n    var tDelta = vec3(voxelSize / abs(rayDirection));\n    var scaledStartingPoint = pos / voxelSize;\n    var scaledRayOrigin = vec3<f32>(rayOrigin) / voxelSize;\n    var currentIndex = floor(scaledStartingPoint);\n    var voxelOriginDifference = vec3<f32>(currentIndex) - scaledRayOrigin;\n    var clampedVoxelBoundary = (voxelStep * 0.5) + 0.5; // 0 if <= 0, 1 if > 0\n    var tMax = (voxelStep * voxelOriginDifference + clampedVoxelBoundary) * tDelta + EPSILON;\n    var occlusion = false;\n\n    while(stepsTaken <= MAX_RAY_STEPS)\n    {\n      tIntersection = min(min(tMax.x, tMax.y), tMax.z);\n      let mask = vec3(\n          select(0.0, 1.0, tMax.x == tIntersection),\n          select(0.0, 1.0, tMax.y == tIntersection),\n          select(0.0, 1.0, tMax.z == tIntersection)\n      );\n      tMax += mask * tDelta;\n      currentIndex += mask * voxelStep;\n      normal = vec3(mask * -voxelStep);\n      pos = rayOrigin + rayDirection * tIntersection;\n      stepsTaken ++;\n      let isInBounds = all(currentIndex > vec3(0.0)) && all(currentIndex < vec3(BOUNDS_SIZE / voxelSize));\n      if(!isInBounds){\n          break;\n      }\n      if(sampleVoxel(currentIndex)){\n          occlusion = true;\n          break;\n      }\n    }\n\n//    if(occlusion){\n      colour = normal;\n      colour = addVoxelBorderColour(colour, pos);\n//    }\n    colour = addBoundsBorderColour(colour, boundingBoxSurfacePosition);\n\n  }\n  textureStore(outputTex, GlobalInvocationID.xy, vec4(colour,1));\n}\n"}),entryPoint:"main"}})},render:({commandEncoder:t,timeBuffer:n,resolutionBuffer:i,outputTextureView:s})=>{const a=(e=>{const t=f.x/f.y,n=e.fieldOfView/2,r=Math.tan(n),i=o.up.cross(e.direction).normalize(),s=e.direction.cross(i).normalize().mul(r);return[e.direction.add(s).add(i.mul(-t*r)),e.direction.add(s).add(i.mul(t*r)),e.direction.subtract(s).add(i.mul(-t*r)),e.direction.subtract(s).add(i.mul(t*r))]})(y).flatMap((e=>[...e.toArray(),0])),c=r(a,"frustum corner directions"),u=r(y.position.toArray(),"camera position"),d=t.beginComputePass();d.setPipeline(e);const m=l.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:s},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:c}},{binding:4,resource:{buffer:u}}]});d.setBindGroup(0,m),d.dispatchWorkgroups(Math.ceil(f.x/8),Math.ceil(f.y/8)),d.end()}}})();((e,r)=>{let s,l,b,w,B,z,I;d=document.getElementById("webgpu-canvas"),d.addEventListener("click",(async()=>{d.requestPointerLock()})),document.addEventListener("pointerlockchange",(()=>{z=null!==document.pointerLockElement})),u=d.getContext("webgpu");const E=navigator.gpu.getPreferredCanvasFormat();u.configure({device:e,format:E,usage:GPUTextureUsage.RENDER_ATTACHMENT});const S=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n}\n\n@vertex\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}\n\n@fragment\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\n//    return vec4(sin(f32(time) * 0.001), 0, 0, 1);\n    return textureSample(myTexture, mySampler, fragUV);\n}\n"}),D=e.createRenderPipeline({layout:"auto",vertex:{module:S,entryPoint:"vertex_main"},fragment:{module:S,entryPoint:"fragment_main",targets:[{format:E}]}}),O=()=>{cancelAnimationFrame(b),P()},P=()=>{const{clientWidth:e,clientHeight:t}=d.parentElement;f=new i(e*window.devicePixelRatio,t*window.devicePixelRatio),I=f.mul(1/m),d.width=f.x,d.height=f.y,d.style.transform=`scale(${1/window.devicePixelRatio})`,r.forEach((e=>{e.start()})),b=requestAnimationFrame(T)},T=async()=>{const i=performance.now()-x;h=i-v,v=i,z&&(()=>{if(y.rotateY(.001*c.velocity.x),y.rotateX(.001*c.velocity.y),!document.hasFocus())return;let e=o.zero;a.pressed.a&&(e=e.add(y.left)),a.pressed.d&&(e=e.add(y.right)),a.pressed.w&&(e=e.add(y.direction)),a.pressed.s&&(e=e.subtract(y.direction)),a.pressed[" "]&&(e=e.add(y.up)),a.pressed.Control&&(e=e.add(y.down)),e=e.normalize(),y.velocity=y.velocity.add(e.mul(.01))})(),y.update(),p.log(`Position: ${y.position.toString()}\n    Resolution: ${I.x.toFixed(0)}x${I.y.toFixed(0)}\n    FPS: ${(1e3/h).toFixed(1)}\n    `);const d=e.createCommandEncoder();w?t(w,[v]):w=n([v]),B?t(B,[I.x,I.y]):B=n([I.x,I.y]);const f=(l&&l.destroy(),l=e.createTexture({size:[I.x,I.y,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING}),l.createView());r.forEach((e=>{e.render({commandEncoder:d,timeBuffer:w,resolutionBuffer:B,outputTextureView:f})})),(({commandEncoder:t,outputTextureView:n})=>{const r=t.beginRenderPass({colorAttachments:[{view:u.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]});s=e.createBindGroup({layout:D.getBindGroupLayout(0),entries:[{binding:0,resource:e.createSampler({magFilter:"linear",minFilter:"linear"})},{binding:1,resource:n}]}),r.setPipeline(D),r.setBindGroup(0,s),r.draw(6),r.end()})({commandEncoder:d,outputTextureView:f}),e.queue.submit([d.finish()]),b=requestAnimationFrame(T)},_=new ResizeObserver(O);g=e=>{m=e.detail,O()},window.addEventListener("changeDownscale",g),_.observe(d.parentElement)})(l,[s])}))})):console.error("WebGPU not supported")})();