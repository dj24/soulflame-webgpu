(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};e.d({},{nS:()=>p,JQ:()=>l,sL:()=>h,Uh:()=>c,ZU:()=>d});const t=(e,t)=>{const r=new Uint32Array(t);c.queue.writeBuffer(e,0,r.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},r=(e,r)=>{const n=new Uint32Array(e),i=c.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:r});return t(i,e),i},n=(e,t)=>{const r=new Float32Array(e),n=c.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return((e,t)=>{const r=new Float32Array(t);c.queue.writeBuffer(e,0,r.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)})(n,e),n};class i{x;y;constructor(e,t){this.x=e,this.y=t}get uniformBuffer(){return r([this.x,this.y])}static zero=new i(0,0);static one=new i(1,1);static up=new i(0,1);static down=new i(0,-1);static left=new i(-1,0);static right=new i(1,1);toArray(){return[this.x,this.y]}mul(e){if(e instanceof i)return new i(this.x*e.x,this.y*e.y);if("number"==typeof e)return new i(this.x*e,this.y*e);throw new Error("Can only multiply Vector2 by Vector2 or Number")}add(e){return new i(this.x+e.x,this.y+e.y)}subtract(e){return new i(this.x-e.x,this.y-e.y)}normalize(){const e=Math.sqrt(this.x**2+this.y**2);return new i(this.x/e,this.y/e)}negate(){return new i(-this.x,-this.y)}}class o{x;y;z;constructor(e,t,r){this.x=e,this.y=t,this.z=r}get uniformBuffer(){return r([this.x,this.y,this.z])}static zero=new o(0,0,0);static one=new o(1,1,1);static up=new o(0,1,0);static down=new o(0,-1,0);static left=new o(-1,0,0);static right=new o(1,0,0);toArray(){return[this.x,this.y,this.z]}mul(e){if(e instanceof o)return new o(this.x*e.x,this.y*e.y,this.z*e.z);if("number"==typeof e)return new o(this.x*e,this.y*e,this.z*e);throw new Error("Can only multiply Vector3 by Vector3 or Number")}add(e){return new o(this.x+e.x,this.y+e.y,this.z+e.z)}subtract(e){return new o(this.x-e.x,this.y-e.y,this.z-e.z)}cross(e){return new o(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}normalize(){const e=Math.sqrt(this.x**2+this.y**2+this.z**2);return new o(this.x/e,this.y/e,this.z/e)}negate(){return new o(-this.x,-this.y,-this.z)}rotateAroundAxis(e,t){const r=Math.cos(t),n=Math.sin(t),i=this.x*(r+(1-r)*e.x*e.x)+this.y*((1-r)*e.x*e.y-n*e.z)+this.z*((1-r)*e.x*e.z+n*e.y),s=this.x*((1-r)*e.y*e.x+n*e.z)+this.y*(r+(1-r)*e.y*e.y)+this.z*((1-r)*e.y*e.z-n*e.x),a=this.x*((1-r)*e.z*e.x-n*e.y)+this.y*((1-r)*e.z*e.y+n*e.x)+this.z*(r+(1-r)*e.z*e.z);return new o(i,s,a)}}const s=new class{pressed={w:!1,a:!1,s:!1,d:!1," ":!1,Control:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1}))}},a=new class{velocity=i.zero;animationFrame;constructor(){window.addEventListener("mousemove",(e=>{cancelAnimationFrame(this.animationFrame),this.velocity=new i(e.movementX,e.movementY),this.animationFrame=requestAnimationFrame((()=>{this.velocity=i.zero}))}))}};let c,u,l,d=new i(0,0);const f=performance.now();let m=f,h=0,p=new class{position;fieldOfView;direction;constructor(e){this.position=new o(0,0,-5),this.fieldOfView=e.fieldOfView,this.direction=new o(0,0,1)}reset(e){this.position=new o(0,0,-5),this.fieldOfView=e.fieldOfView,this.direction=new o(0,0,1)}get right(){return o.up.cross(this.direction).normalize()}get left(){return this.direction.cross(o.up).normalize()}get up(){return this.direction.cross(this.right).normalize()}get down(){return this.up.negate()}rotateX(e){this.direction=this.direction.rotateAroundAxis(this.right,e)}rotateY(e){this.direction=this.direction.rotateAroundAxis(o.up,e)}}({fieldOfView:90});new class{constructor(){document.getElementById("reset").addEventListener("click",(e=>{p.reset({fieldOfView:90}),document.getElementById("captures").innerHTML=""})),document.getElementById("capture").addEventListener("click",(e=>{const t=new Image;t.id=performance.now().toString(),t.src=l.toDataURL(),document.getElementById("captures").appendChild(t).addEventListener("click",(e=>{e.target,console.log(e.target)}))}))}};void 0!==navigator.gpu?navigator.gpu.requestAdapter().then((e=>{e.requestDevice().then((e=>{c=e;const y=(()=>{let e;return{start:()=>{e=c.createComputePipeline({layout:"auto",compute:{module:c.createShaderModule({code:"\n          // Function to mimic the ease_out_expo function\r\nfn ease_out_expo(x: f32) -> f32 {\r\n    let t: f32 = x;\r\n    let b: f32 = 0.0;\r\n    let c: f32 = 1.0;\r\n    let d: f32 = 1.0; // Set the duration within the function\r\n\r\n    let intermediate_result: f32 = c * (-pow(2.0, -10.0 * t / d) + 1.0) + b;\r\n\r\n    return select(intermediate_result, b + c, t == d);\r\n\r\n}\r\n\r\nfn sample_sky(rayDirection: vec3<f32>) -> vec3<f32> {\r\n    //TODO: add this to uniforms\r\n    let lightDirection = normalize(vec3(1.0,1.0,0.));\r\n    let y = clamp(ease_out_expo(rayDirection.y * 0.66), 0.0, 1.0);\r\n//    let y = rayDirection.y;\r\n    let sunHeight = clamp(lightDirection.y, 0.0, 1.0);\r\n    let horizon = mix(vec3<f32>(0.95, 0.5, 0.4), vec3<f32>(0.6, 0.8, 1.0), sunHeight);\r\n    let sky = mix(vec3<f32>(0.55, 0.7, 0.7), vec3<f32>(0.3, 0.6, 0.95), sunHeight);\r\n    let sunFalloff = 0.8;\r\n    let sunAmount = 1.0 - ease_out_expo(length(lightDirection - rayDirection) * sunFalloff);\r\n//    let sunAmount = 1.0 - length(lightDirection - rayDirection) * sunFalloff;\r\n    let skyColour = mix(horizon, sky, y);\r\n    let sunColour = mix(vec3<f32>(1.8, 1.6, 1.1), vec3<f32>(1.6, 1.6, 1.4), sunHeight);\r\n\r\n    let intensity = clamp(sunHeight, 0.75, 1.0);\r\n    return mix(skyColour, sunColour, clamp(sunAmount, 0.0, 1.0)) * intensity;\r\n}struct FrustumCornerDirections {\r\n  topLeft : vec3<f32>,\r\n  topRight : vec3<f32>,\r\n  bottomLeft : vec3<f32>,\r\n  bottomRight : vec3<f32>\r\n}\r\n\r\nfn calculateRayDirection(uv: vec2<f32>, directions: FrustumCornerDirections) -> vec3<f32> {\r\n  let topInterpolated = mix(directions.topLeft, directions.topRight, uv.x);\r\n  let bottomInterpolated = mix(directions.bottomLeft, directions.bottomRight, uv.x);\r\n  let finalInterpolated = mix(bottomInterpolated, topInterpolated, uv.y);\r\n  return normalize(finalInterpolated);\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> vec4<f32> {\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * ro;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n\r\n    if (tN > tF || tF < 0.0) {\r\n        return vec4<f32>(-1.0);\r\n    }\r\n\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n\r\n    normal *= -sign(rd);\r\n\r\n    return vec4<f32>(tN, normal);\r\n}\r\n\r\n@group(0) @binding(0) var outputTex : texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> time : u32;\r\n@group(0) @binding(2) var<uniform> resolution : vec2<u32>;\r\n@group(0) @binding(3) var<uniform> frustumCornerDirections : FrustumCornerDirections;\r\n@group(0) @binding(4) var<uniform> cameraPosition : vec3<f32>;\r\n\r\nconst EPSILON = 0.0001;\r\n\r\n@compute @workgroup_size(1, 1, 1)\r\nfn main(\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>\r\n) {\r\nlet timeOffset = (sin(f32(time) * 0.001) * 0.5 + 0.5) * 2.0;\r\n  let pixel = vec2<f32>(f32(WorkGroupID.x), f32(resolution.y - WorkGroupID.y));\r\n  let uv = pixel / vec2<f32>(resolution);\r\n  let rayOrigin = cameraPosition;\r\n  var rayDirection = calculateRayDirection(uv,frustumCornerDirections);\r\n  var boxSize = vec3<f32>(1.0);\r\n  let intersect = boxIntersection(rayOrigin, rayDirection, boxSize);\r\n  var colour = sample_sky(rayDirection);\r\n  let tNear = intersect.x;\r\n  if(tNear > 0.0){\r\n      let pos = rayOrigin + (intersect.x +EPSILON)  * rayDirection;\r\n      let normal = intersect.yzw;\r\n      colour = fract(pos);\r\n  }\r\n\r\n  textureStore(outputTex, WorkGroupID.xy, vec4(colour,1));\r\n}\r\n"}),entryPoint:"main"}})},render:({commandEncoder:t,timeBuffer:r,resolutionBuffer:i,outputTextureView:s})=>{const a=(e=>{const t=d.x/d.y,r=e.fieldOfView/2,n=Math.tan(r),i=o.up.cross(e.direction).normalize(),s=e.direction.cross(i).normalize().mul(n);return[e.direction.add(s).add(i.mul(-t*n)),e.direction.add(s).add(i.mul(t*n)),e.direction.subtract(s).add(i.mul(-t*n)),e.direction.subtract(s).add(i.mul(t*n))]})(p).flatMap((e=>[...e.toArray(),0])),u=n(a,"frustum corner directions"),l=n(p.position.toArray(),"camera position"),f=t.beginComputePass();f.setPipeline(e);const m=c.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:s},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:u}},{binding:4,resource:{buffer:l}}]});f.setBindGroup(0,m),f.dispatchWorkgroups(d.x,d.y),f.end()}}})();((e,n)=>{let o,c,y,x,g,v;l=document.getElementById("webgpu-canvas"),l.addEventListener("click",(async()=>{l.requestPointerLock()})),document.addEventListener("pointerlockchange",(()=>{v=null!==document.pointerLockElement})),u=l.getContext("webgpu");const w=navigator.gpu.getPreferredCanvasFormat();u.configure({device:e,format:w,usage:GPUTextureUsage.RENDER_ATTACHMENT});const b=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n//    return vec4(sin(f32(time) * 0.001), 0, 0, 1);\r\n    return textureSample(myTexture, mySampler, fragUV);\r\n}\r\n"}),z=e.createRenderPipeline({layout:"auto",vertex:{module:b,entryPoint:"vertex_main"},fragment:{module:b,entryPoint:"fragment_main",targets:[{format:w}]}}),E=async()=>{const i=performance.now()-f;h=i-m,m=i,v&&(()=>{if(!document.hasFocus())return;const e=.005,t=5e-4;p.rotateY(a.velocity.x*h*t),p.rotateX(a.velocity.y*h*t),s.pressed.a&&(p.position=p.position=p.position.add(p.left.mul(h*e))),s.pressed.d&&(p.position=p.position.add(p.right.mul(h*e))),s.pressed.w&&(p.position=p.position.add(p.direction.mul(h*e))),s.pressed.s&&(p.position=p.position.subtract(p.direction.mul(h*e))),s.pressed[" "]&&(p.position.y+=h*e),s.pressed.Control&&(p.position.y-=h*e)})();const l=e.createCommandEncoder();x?t(x,[m]):x=r([m]),g?t(g,[d.x,d.y]):g=r([d.x,d.y]);const w=(c&&c.destroy(),c=e.createTexture({size:[d.x,d.y,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING}),c.createView());n.forEach((e=>{e.render({commandEncoder:l,timeBuffer:x,resolutionBuffer:g,outputTextureView:w})})),(({commandEncoder:t,outputTextureView:r})=>{const n=t.beginRenderPass({colorAttachments:[{view:u.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]});o=e.createBindGroup({layout:z.getBindGroupLayout(0),entries:[{binding:0,resource:e.createSampler({magFilter:"linear",minFilter:"linear"})},{binding:1,resource:r}]}),n.setPipeline(z),n.setBindGroup(0,o),n.draw(6),n.end()})({commandEncoder:l,outputTextureView:w}),e.queue.submit([l.finish()]),y=requestAnimationFrame(E)};new ResizeObserver((()=>{cancelAnimationFrame(y),(()=>{const{clientWidth:e,clientHeight:t}=l.parentElement;d=new i(e,t),l.width=d.x,l.height=d.y,n.forEach((e=>{e.start()})),y=requestAnimationFrame(E)})()})).observe(l.parentElement)})(c,[y])}))})):console.error("WebGPU not supported")})();