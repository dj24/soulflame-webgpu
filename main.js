(()=>{"use strict";var e={d:(r,t)=>{for(var n in t)e.o(t,n)&&!e.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:t[n]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r)};e.d({},{nS:()=>m,sL:()=>d,Uh:()=>o,P9:()=>l,br:()=>f,ZU:()=>a});const r=(e,r)=>{const t=new Uint32Array(e),n=o.createBuffer({size:t.byteLength,mappedAtCreation:!0,usage:GPUBufferUsage.UNIFORM,label:r}),i=new Uint32Array(n.getMappedRange());return e.forEach(((e,r)=>{i[r]=e})),n.unmap(),n},t=(e,r)=>{const t=new Float32Array(e),n=o.createBuffer({size:t.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return o.queue.writeBuffer(n,0,t.buffer,0,e.length*Float32Array.BYTES_PER_ELEMENT),n};class n{x;y;constructor(e,r){this.x=e,this.y=r}get uniformBuffer(){return r([this.x,this.y])}static zero=new n(0,0);static one=new n(1,1);static up=new n(0,1);static down=new n(0,-1);static left=new n(-1,0);static right=new n(1,1);toArray(){return[this.x,this.y]}mul(e){if(e instanceof n)return new n(this.x*e.x,this.y*e.y);if("number"==typeof e)return new n(this.x*e,this.y*e);throw new Error("Can only multiply Vector2 by Vector2 or Number")}add(e){return new n(this.x+e.x,this.y+e.y)}subtract(e){return new n(this.x-e.x,this.y-e.y)}normalize(){const e=Math.sqrt(this.x**2+this.y**2);return new n(this.x/e,this.y/e)}negate(){return new n(-this.x,-this.y)}}class i{x;y;z;constructor(e,r,t){this.x=e,this.y=r,this.z=t}get uniformBuffer(){return r([this.x,this.y,this.z])}static zero=new i(0,0,0);static one=new i(1,1,1);static up=new i(0,1,0);static down=new i(0,-1,0);static left=new i(-1,0,0);static right=new i(1,0,0);toArray(){return[this.x,this.y,this.z]}mul(e){if(e instanceof i)return new i(this.x*e.x,this.y*e.y,this.z*e.z);if("number"==typeof e)return new i(this.x*e,this.y*e,this.z*e);throw new Error("Can only multiply Vector3 by Vector3 or Number")}add(e){return new i(this.x+e.x,this.y+e.y,this.z+e.z)}subtract(e){return new i(this.x-e.x,this.y-e.y,this.z-e.z)}cross(e){return new i(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}normalize(){const e=Math.sqrt(this.x**2+this.y**2+this.z**2);return new i(this.x/e,this.y/e,this.z/e)}negate(){return new i(-this.x,-this.y,-this.z)}rotateAroundAxis(e,r){const t=Math.cos(r),n=Math.sin(r),o=this.x*(t+(1-t)*e.x*e.x)+this.y*((1-t)*e.x*e.y-n*e.z)+this.z*((1-t)*e.x*e.z+n*e.y),s=this.x*((1-t)*e.y*e.x+n*e.z)+this.y*(t+(1-t)*e.y*e.y)+this.z*((1-t)*e.y*e.z-n*e.x),a=this.x*((1-t)*e.z*e.x-n*e.y)+this.y*((1-t)*e.z*e.y+n*e.x)+this.z*(t+(1-t)*e.z*e.z);return new i(o,s,a)}}let o,s,a=new n(0,0);const c=performance.now();let u=c,d=0;const l=new class{pressed={w:!1,a:!1,s:!1,d:!1," ":!1,Control:!1};constructor(){window.addEventListener("keydown",(e=>{const r=e.key.toLowerCase();r in this.pressed&&(this.pressed[r]=!0)})),window.addEventListener("keyup",(e=>{const r=e.key.toLowerCase();r in this.pressed&&(this.pressed[r]=!1)}))}},f=new class{velocity=n.zero;animationFrame;constructor(){window.addEventListener("mousemove",(e=>{cancelAnimationFrame(this.animationFrame),this.velocity=new n(e.movementX,e.movementY),this.animationFrame=requestAnimationFrame((()=>{this.velocity=n.zero}))}))}};let m=new class{position;fieldOfView;direction;constructor(e){this.position=new i(0,0,-5),this.fieldOfView=e,this.direction=new i(0,0,1)}get right(){return i.up.cross(this.direction).normalize()}get left(){return this.direction.cross(i.up).normalize()}get up(){return this.direction.cross(this.right).normalize()}get down(){return this.up.negate()}rotateX(e){this.direction=this.direction.rotateAroundAxis(this.right,e)}rotateY(e){this.direction=this.direction.rotateAroundAxis(i.up,e)}}(90);void 0!==navigator.gpu?navigator.gpu.requestAdapter().then((e=>{e.requestDevice().then((e=>{o=e;const p=(()=>{let e;return{start:()=>{e=o.createComputePipeline({layout:"auto",compute:{module:o.createShaderModule({code:"struct FrustumCornerDirections {\r\n  topLeft : vec3<f32>,\r\n  topRight : vec3<f32>,\r\n  bottomLeft : vec3<f32>,\r\n  bottomRight : vec3<f32>\r\n}\r\n\r\nfn calculateRayDirection(uv: vec2<f32>, directions: FrustumCornerDirections) -> vec3<f32> {\r\n  let topInterpolated = mix(directions.topLeft, directions.topRight, uv.x);\r\n  let bottomInterpolated = mix(directions.bottomLeft, directions.bottomRight, uv.x);\r\n  let finalInterpolated = mix(bottomInterpolated, topInterpolated, uv.y);\r\n  return normalize(finalInterpolated);\r\n}\r\n\r\nfn sphNormal(pos: vec3<f32>, ce: vec3<f32>) -> vec3<f32>\r\n{\r\n  return normalize(pos-ce.xyz);\r\n}\r\n\r\nfn sphIntersect(ro: vec3<f32>, rd: vec3<f32>, ce: vec3<f32>, ra: f32) -> vec2<f32> {\r\n  let oc: vec3<f32> = ro - ce;\r\n  let b: f32 = dot(oc, rd);\r\n  let c: f32 = dot(oc, oc) - ra * ra;\r\n  var h: f32 = b * b - c;\r\n\r\n  if (h < 0.0) {\r\n      return vec2<f32>(-1.0); // no intersection\r\n  }\r\n\r\n  h = sqrt(h);\r\n\r\n  return vec2<f32>(-b - h, -b + h);\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> vec4<f32> {\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * ro;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n\r\n    if (tN > tF || tF < 0.0) {\r\n        return vec4<f32>(-1.0);\r\n    }\r\n\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n\r\n    normal *= -sign(rd);\r\n\r\n    return vec4<f32>(tN, normal);\r\n}\r\n\r\n@group(0) @binding(0) var outputTex : texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> time : u32;\r\n@group(0) @binding(2) var<uniform> resolution : vec2<u32>;\r\n@group(0) @binding(3) var<uniform> frustumCornerDirections : FrustumCornerDirections;\r\n@group(0) @binding(4) var<uniform> cameraPosition : vec3<f32>;\r\n\r\n@compute @workgroup_size(1, 1, 1)\r\nfn main(\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>\r\n) {\r\nlet timeOffset = (sin(f32(time) * 0.001) * 0.5 + 0.5) * 2.0;\r\n  let pixel = vec2<f32>(f32(WorkGroupID.x), f32(resolution.y - WorkGroupID.y));\r\n  let uv = pixel / vec2<f32>(resolution);\r\n  let p = (2.0*pixel-vec2<f32>(resolution)) / vec2<f32>(resolution).y;\r\n//  let rayOrigin = vec3(timeOffset * 0.5,timeOffset,5.0);\r\n  let rayOrigin = cameraPosition;\r\n  var rayDirection = calculateRayDirection(uv,frustumCornerDirections);\r\n//  rayDirection = normalize( vec3(p,-2.0) );\r\n  \r\n  let spherePos = vec3(0,timeOffset - 1.0,2.0);\r\n  var boxSize = vec3<f32>(0.5);\r\n  //  let intersect = sphIntersect(rayOrigin, rayDirection, spherePos, 0.5);\r\n  let intersect = boxIntersection(rayOrigin, rayDirection, boxSize);\r\n  var green = rayDirection.y;\r\n  var blue = rayDirection.z;\r\n  var red = rayDirection.x;\r\n  if(intersect.x > 0.0){\r\n      let pos = rayOrigin + intersect.y * rayDirection;\r\n      let normal = intersect.yzw;\r\n      red = normal.r;\r\n      green = normal.g;\r\n      blue = normal.b;\r\n  }\r\n\r\n  textureStore(outputTex, WorkGroupID.xy, vec4(red,green,blue,1));\r\n}\r\n"}),entryPoint:"main"}})},render:({commandEncoder:r,timeBuffer:n,resolutionBuffer:s,outputTextureView:c})=>{const u=(e=>{const r=a.x/a.y,t=e.fieldOfView/2,n=Math.tan(t),o=i.up.cross(e.direction).normalize(),s=e.direction.cross(o).normalize().mul(n);return[e.direction.add(s).add(o.mul(-r*n)),e.direction.add(s).add(o.mul(r*n)),e.direction.subtract(s).add(o.mul(-r*n)),e.direction.subtract(s).add(o.mul(r*n))]})(m).flatMap((e=>[...e.toArray(),0])),d=t(u),l=t(m.position.toArray()),f=r.beginComputePass();f.setPipeline(e);const p=o.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:c},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:s}},{binding:3,resource:{buffer:d}},{binding:4,resource:{buffer:l}}]});f.setBindGroup(0,p),f.dispatchWorkgroups(a.x,a.y),f.end()}}})();((e,t)=>{let i,o,p;const h=document.getElementById("webgpu-canvas");h.addEventListener("click",(async()=>{await h.requestPointerLock()})),s=h.getContext("webgpu");const y=navigator.gpu.getPreferredCanvasFormat();s.configure({device:e,format:y,usage:GPUTextureUsage.RENDER_ATTACHMENT});const v=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n//    return vec4(sin(f32(time) * 0.001), 0, 0, 1);\r\n    return textureSample(myTexture, mySampler, fragUV);\r\n}\r\n"}),x=e.createRenderPipeline({layout:"auto",vertex:{module:v,entryPoint:"vertex_main"},fragment:{module:v,entryPoint:"fragment_main",targets:[{format:y}]}}),g=async()=>{const n=performance.now()-c;d=n-u,u=n,(()=>{const e=.005,r=1e-4;m.rotateY(f.velocity.x*d*r),m.rotateX(f.velocity.y*d*r),l.pressed.a&&(m.position=m.position=m.position.add(m.left.mul(d*e))),l.pressed.d&&(m.position=m.position.add(m.right.mul(d*e))),l.pressed.w&&(m.position=m.position.add(m.direction.mul(d*e))),l.pressed.s&&(m.position=m.position.subtract(m.direction.mul(d*e))),l.pressed[" "]&&(m.position.y+=d*e),l.pressed.Control&&(m.position.y-=d*e)})();const h=e.createCommandEncoder(),y=r([u]),v=r([a.x,a.y]),w=(o=e.createTexture({size:[a.x,a.y,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING}),o.createView());t.forEach((e=>{e.render({commandEncoder:h,timeBuffer:y,resolutionBuffer:v,outputTextureView:w})})),(({commandEncoder:r,outputTextureView:t})=>{const n=r.beginRenderPass({colorAttachments:[{view:s.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]});i=e.createBindGroup({layout:x.getBindGroupLayout(0),entries:[{binding:0,resource:e.createSampler({magFilter:"linear",minFilter:"linear"})},{binding:1,resource:t}]}),n.setPipeline(x),n.setBindGroup(0,i),n.draw(6),n.end()})({commandEncoder:h,outputTextureView:w}),e.queue.submit([h.finish()]),p=requestAnimationFrame(g)};new ResizeObserver((()=>{cancelAnimationFrame(p),(()=>{const{clientWidth:e,clientHeight:r}=h.parentElement;a=new n(e,r),h.width=a.x,h.height=a.y,t.forEach((e=>{e.start()})),p=requestAnimationFrame(g)})()})).observe(h.parentElement)})(o,[p])}))})):console.error("WebGPU not supported")})();