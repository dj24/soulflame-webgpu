/*! For license information please see main.js.LICENSE.txt */
(()=>{"use strict";class e{}class t{ecs}class n{map=new Map;add(e){this.map.set(e.constructor,e)}get(e){return this.map.get(e)}has(e){return this.map.has(e)}hasAll(e){for(let t of e)if(!this.map.has(t))return!1;return!0}delete(e){this.map.delete(e)}}let r=1e-6,i=Float32Array;function s(e=0,t=0){const n=new i(2);return void 0!==e&&(n[0]=e,void 0!==t&&(n[1]=t)),n}let o=Float32Array;function a(e,t,n){const r=new o(3);return void 0!==e&&(r[0]=e,void 0!==t&&(r[1]=t,void 0!==n&&(r[2]=n))),r}const l=s;function c(e,t,n){return(n=n||new i(2))[0]=e[0]-t[0],n[1]=e[1]-t[1],n}const u=c;function h(e,t,n){return(n=n||new i(2))[0]=e[0]*t,n[1]=e[1]*t,n}const d=h;function p(e,t){return(t=t||new i(2))[0]=1/e[0],t[1]=1/e[1],t}const f=p;function m(e,t){return e[0]*t[0]+e[1]*t[1]}function g(e){const t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}const v=g;function y(e){const t=e[0],n=e[1];return t*t+n*n}const x=y;function w(e,t){const n=e[0]-t[0],r=e[1]-t[1];return Math.sqrt(n*n+r*r)}const b=w;function _(e,t){const n=e[0]-t[0],r=e[1]-t[1];return n*n+r*r}const k=_;function S(e,t){return(t=t||new i(2))[0]=e[0],t[1]=e[1],t}const A=S;function E(e,t,n){return(n=n||new i(2))[0]=e[0]*t[0],n[1]=e[1]*t[1],n}const T=E;function P(e,t,n){return(n=n||new i(2))[0]=e[0]/t[0],n[1]=e[1]/t[1],n}const M=P;var C=Object.freeze({__proto__:null,create:s,setDefaultType:function(e){const t=i;return i=e,t},fromValues:l,set:function(e,t,n){return(n=n||new i(2))[0]=e,n[1]=t,n},ceil:function(e,t){return(t=t||new i(2))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},floor:function(e,t){return(t=t||new i(2))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},round:function(e,t){return(t=t||new i(2))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},clamp:function(e,t=0,n=1,r){return(r=r||new i(2))[0]=Math.min(n,Math.max(t,e[0])),r[1]=Math.min(n,Math.max(t,e[1])),r},add:function(e,t,n){return(n=n||new i(2))[0]=e[0]+t[0],n[1]=e[1]+t[1],n},addScaled:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},angle:function(e,t){const n=e[0],r=e[1],i=e[0],s=e[1],o=Math.sqrt(n*n+r*r)*Math.sqrt(i*i+s*s),a=o&&m(e,t)/o;return Math.acos(a)},subtract:c,sub:u,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r},lerpV:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+n[0]*(t[0]-e[0]),r[1]=e[1]+n[1]*(t[1]-e[1]),r},max:function(e,t,n){return(n=n||new i(2))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n},min:function(e,t,n){return(n=n||new i(2))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n},mulScalar:h,scale:d,divScalar:function(e,t,n){return(n=n||new i(2))[0]=e[0]/t,n[1]=e[1]/t,n},inverse:p,invert:f,cross:function(e,t,n){n=n||new o(3);const r=e[0]*t[1]-e[1]*t[0];return n[0]=0,n[1]=0,n[2]=r,n},dot:m,length:g,len:v,lengthSq:y,lenSq:x,distance:w,dist:b,distanceSq:_,distSq:k,normalize:function(e,t){t=t||new i(2);const n=e[0],r=e[1],s=Math.sqrt(n*n+r*r);return s>1e-5?(t[0]=n/s,t[1]=r/s):(t[0]=0,t[1]=0),t},negate:function(e,t){return(t=t||new i(2))[0]=-e[0],t[1]=-e[1],t},copy:S,clone:A,multiply:E,mul:T,divide:P,div:M,random:function(e=1,t){t=t||new i(2);const n=2*Math.random()*Math.PI;return t[0]=Math.cos(n)*e,t[1]=Math.sin(n)*e,t},zero:function(e){return(e=e||new i(2))[0]=0,e[1]=0,e},transformMat4:function(e,t,n){n=n||new i(2);const r=e[0],s=e[1];return n[0]=r*t[0]+s*t[4]+t[12],n[1]=r*t[1]+s*t[5]+t[13],n},transformMat3:function(e,t,n){n=n||new i(2);const r=e[0],s=e[1];return n[0]=t[0]*r+t[4]*s+t[8],n[1]=t[1]*r+t[5]*s+t[9],n}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);const z=a;function I(e,t,n){return(n=n||new o(3))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}const B=I;function O(e,t,n){return(n=n||new o(3))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n}const N=O;function U(e,t){return(t=t||new o(3))[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}const R=U;function D(e,t,n){n=n||new o(3);const r=e[2]*t[0]-e[0]*t[2],i=e[0]*t[1]-e[1]*t[0];return n[0]=e[1]*t[2]-e[2]*t[1],n[1]=r,n[2]=i,n}function F(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function L(e){const t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)}const q=L;function j(e){const t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r}const V=j;function G(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return Math.sqrt(n*n+r*r+i*i)}const $=G;function W(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return n*n+r*r+i*i}const H=W;function Y(e,t){t=t||new o(3);const n=e[0],r=e[1],i=e[2],s=Math.sqrt(n*n+r*r+i*i);return s>1e-5?(t[0]=n/s,t[1]=r/s,t[2]=i/s):(t[0]=0,t[1]=0,t[2]=0),t}function X(e,t){return(t=t||new o(3))[0]=e[0],t[1]=e[1],t[2]=e[2],t}const Z=X;function K(e,t,n){return(n=n||new o(3))[0]=e[0]*t[0],n[1]=e[1]*t[1],n[2]=e[2]*t[2],n}const Q=K;function J(e,t,n){return(n=n||new o(3))[0]=e[0]/t[0],n[1]=e[1]/t[1],n[2]=e[2]/t[2],n}const ee=J;var te=Object.freeze({__proto__:null,create:a,setDefaultType:function(e){const t=o;return o=e,t},fromValues:z,set:function(e,t,n,r){return(r=r||new o(3))[0]=e,r[1]=t,r[2]=n,r},ceil:function(e,t){return(t=t||new o(3))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},floor:function(e,t){return(t=t||new o(3))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},round:function(e,t){return(t=t||new o(3))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},clamp:function(e,t=0,n=1,r){return(r=r||new o(3))[0]=Math.min(n,Math.max(t,e[0])),r[1]=Math.min(n,Math.max(t,e[1])),r[2]=Math.min(n,Math.max(t,e[2])),r},add:function(e,t,n){return(n=n||new o(3))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n},addScaled:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r},angle:function(e,t){const n=e[0],r=e[1],i=e[2],s=e[0],o=e[1],a=e[2],l=Math.sqrt(n*n+r*r+i*i)*Math.sqrt(s*s+o*o+a*a),c=l&&F(e,t)/l;return Math.acos(c)},subtract:I,sub:B,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r[2]=e[2]+n*(t[2]-e[2]),r},lerpV:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+n[0]*(t[0]-e[0]),r[1]=e[1]+n[1]*(t[1]-e[1]),r[2]=e[2]+n[2]*(t[2]-e[2]),r},max:function(e,t,n){return(n=n||new o(3))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n[2]=Math.max(e[2],t[2]),n},min:function(e,t,n){return(n=n||new o(3))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n},mulScalar:O,scale:N,divScalar:function(e,t,n){return(n=n||new o(3))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n},inverse:U,invert:R,cross:D,dot:F,length:L,len:q,lengthSq:j,lenSq:V,distance:G,dist:$,distanceSq:W,distSq:H,normalize:Y,negate:function(e,t){return(t=t||new o(3))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},copy:X,clone:Z,multiply:K,mul:Q,divide:J,div:ee,random:function(e=1,t){t=t||new o(3);const n=2*Math.random()*Math.PI,r=2*Math.random()-1,i=Math.sqrt(1-r*r)*e;return t[0]=Math.cos(n)*i,t[1]=Math.sin(n)*i,t[2]=r*e,t},zero:function(e){return(e=e||new o(3))[0]=0,e[1]=0,e[2]=0,e},transformMat4:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2],a=t[3]*r+t[7]*i+t[11]*s+t[15]||1;return n[0]=(t[0]*r+t[4]*i+t[8]*s+t[12])/a,n[1]=(t[1]*r+t[5]*i+t[9]*s+t[13])/a,n[2]=(t[2]*r+t[6]*i+t[10]*s+t[14])/a,n},transformMat4Upper3x3:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2];return n[0]=r*t[0]+i*t[4]+s*t[8],n[1]=r*t[1]+i*t[5]+s*t[9],n[2]=r*t[2]+i*t[6]+s*t[10],n},transformMat3:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2];return n[0]=r*t[0]+i*t[4]+s*t[8],n[1]=r*t[1]+i*t[5]+s*t[9],n[2]=r*t[2]+i*t[6]+s*t[10],n},transformQuat:function(e,t,n){n=n||new o(3);const r=t[0],i=t[1],s=t[2],a=2*t[3],l=e[0],c=e[1],u=e[2],h=i*u-s*c,d=s*l-r*u,p=r*c-i*l;return n[0]=l+h*a+2*(i*p-s*d),n[1]=c+d*a+2*(s*h-r*p),n[2]=u+p*a+2*(r*d-i*h),n},getTranslation:function(e,t){return(t=t||new o(3))[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const r=4*t;return(n=n||new o(3))[0]=e[r+0],n[1]=e[r+1],n[2]=e[r+2],n},getScaling:function(e,t){t=t||new o(3);const n=e[0],r=e[1],i=e[2],s=e[4],a=e[5],l=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+r*r+i*i),t[1]=Math.sqrt(s*s+a*a+l*l),t[2]=Math.sqrt(c*c+u*u+h*h),t}});let ne=Float32Array;function re(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}const ie=re;function se(e){return(e=e||new ne(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function oe(e,t){t=t||new ne(16);const n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15],y=d*v,x=g*p,w=l*v,b=g*c,_=l*p,k=d*c,S=i*v,A=g*s,E=i*p,T=d*s,P=i*c,M=l*s,C=u*m,z=f*h,I=o*m,B=f*a,O=o*h,N=u*a,U=n*m,R=f*r,D=n*h,F=u*r,L=n*a,q=o*r,j=y*a+b*h+_*m-(x*a+w*h+k*m),V=x*r+S*h+T*m-(y*r+A*h+E*m),G=w*r+A*a+P*m-(b*r+S*a+M*m),$=k*r+E*a+M*h-(_*r+T*a+P*h),W=1/(n*j+o*V+u*G+f*$);return t[0]=W*j,t[1]=W*V,t[2]=W*G,t[3]=W*$,t[4]=W*(x*o+w*u+k*f-(y*o+b*u+_*f)),t[5]=W*(y*n+A*u+E*f-(x*n+S*u+T*f)),t[6]=W*(b*n+S*o+M*f-(w*n+A*o+P*f)),t[7]=W*(_*n+T*o+P*u-(k*n+E*o+M*u)),t[8]=W*(C*c+B*p+O*v-(z*c+I*p+N*v)),t[9]=W*(z*s+U*p+F*v-(C*s+R*p+D*v)),t[10]=W*(I*s+R*c+L*v-(B*s+U*c+q*v)),t[11]=W*(N*s+D*c+q*p-(O*s+F*c+L*p)),t[12]=W*(I*d+N*g+z*l-(O*g+C*l+B*d)),t[13]=W*(D*g+C*i+R*d-(U*d+F*g+z*i)),t[14]=W*(U*l+q*g+B*i-(L*g+I*i+R*l)),t[15]=W*(L*d+O*i+F*l-(D*l+q*d+N*i)),t}const ae=oe;function le(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=e[8],d=e[9],p=e[10],f=e[11],m=e[12],g=e[13],v=e[14],y=e[15],x=t[0],w=t[1],b=t[2],_=t[3],k=t[4],S=t[5],A=t[6],E=t[7],T=t[8],P=t[9],M=t[10],C=t[11],z=t[12],I=t[13],B=t[14],O=t[15];return n[0]=r*x+a*w+h*b+m*_,n[1]=i*x+l*w+d*b+g*_,n[2]=s*x+c*w+p*b+v*_,n[3]=o*x+u*w+f*b+y*_,n[4]=r*k+a*S+h*A+m*E,n[5]=i*k+l*S+d*A+g*E,n[6]=s*k+c*S+p*A+v*E,n[7]=o*k+u*S+f*A+y*E,n[8]=r*T+a*P+h*M+m*C,n[9]=i*T+l*P+d*M+g*C,n[10]=s*T+c*P+p*M+v*C,n[11]=o*T+u*P+f*M+y*C,n[12]=r*z+a*I+h*B+m*O,n[13]=i*z+l*I+d*B+g*O,n[14]=s*z+c*I+p*B+v*O,n[15]=o*z+u*I+f*B+y*O,n}const ce=le;let ue,he,de;function pe(e,t,n){n=n||new ne(16);let r=e[0],i=e[1],s=e[2];const o=Math.sqrt(r*r+i*i+s*s);r/=o,i/=o,s/=o;const a=r*r,l=i*i,c=s*s,u=Math.cos(t),h=Math.sin(t),d=1-u;return n[0]=a+(1-a)*u,n[1]=r*i*d+s*h,n[2]=r*s*d-i*h,n[3]=0,n[4]=r*i*d-s*h,n[5]=l+(1-l)*u,n[6]=i*s*d+r*h,n[7]=0,n[8]=r*s*d+i*h,n[9]=i*s*d-r*h,n[10]=c+(1-c)*u,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}const fe=pe;function me(e,t,n,r){r=r||new ne(16);let i=t[0],s=t[1],o=t[2];const a=Math.sqrt(i*i+s*s+o*o);i/=a,s/=a,o/=a;const l=i*i,c=s*s,u=o*o,h=Math.cos(n),d=Math.sin(n),p=1-h,f=l+(1-l)*h,m=i*s*p+o*d,g=i*o*p-s*d,v=i*s*p-o*d,y=c+(1-c)*h,x=s*o*p+i*d,w=i*o*p+s*d,b=s*o*p-i*d,_=u+(1-u)*h,k=e[0],S=e[1],A=e[2],E=e[3],T=e[4],P=e[5],M=e[6],C=e[7],z=e[8],I=e[9],B=e[10],O=e[11];return r[0]=f*k+m*T+g*z,r[1]=f*S+m*P+g*I,r[2]=f*A+m*M+g*B,r[3]=f*E+m*C+g*O,r[4]=v*k+y*T+x*z,r[5]=v*S+y*P+x*I,r[6]=v*A+y*M+x*B,r[7]=v*E+y*C+x*O,r[8]=w*k+b*T+_*z,r[9]=w*S+b*P+_*I,r[10]=w*A+b*M+_*B,r[11]=w*E+b*C+_*O,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r}const ge=me;var ve=Object.freeze({__proto__:null,setDefaultType:function(e){const t=ne;return ne=e,t},create:function(e,t,n,r,i,s,o,a,l,c,u,h,d,p,f,m){const g=new ne(16);return void 0!==e&&(g[0]=e,void 0!==t&&(g[1]=t,void 0!==n&&(g[2]=n,void 0!==r&&(g[3]=r,void 0!==i&&(g[4]=i,void 0!==s&&(g[5]=s,void 0!==o&&(g[6]=o,void 0!==a&&(g[7]=a,void 0!==l&&(g[8]=l,void 0!==c&&(g[9]=c,void 0!==u&&(g[10]=u,void 0!==h&&(g[11]=h,void 0!==d&&(g[12]=d,void 0!==p&&(g[13]=p,void 0!==f&&(g[14]=f,void 0!==m&&(g[15]=m)))))))))))))))),g},set:function(e,t,n,r,i,s,o,a,l,c,u,h,d,p,f,m,g){return(g=g||new ne(16))[0]=e,g[1]=t,g[2]=n,g[3]=r,g[4]=i,g[5]=s,g[6]=o,g[7]=a,g[8]=l,g[9]=c,g[10]=u,g[11]=h,g[12]=d,g[13]=p,g[14]=f,g[15]=m,g},fromMat3:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=0,t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=0,t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromQuat:function(e,t){t=t||new ne(16);const n=e[0],r=e[1],i=e[2],s=e[3],o=n+n,a=r+r,l=i+i,c=n*o,u=r*o,h=r*a,d=i*o,p=i*a,f=i*l,m=s*o,g=s*a,v=s*l;return t[0]=1-h-f,t[1]=u+v,t[2]=d-g,t[3]=0,t[4]=u-v,t[5]=1-c-f,t[6]=p+m,t[7]=0,t[8]=d+g,t[9]=p-m,t[10]=1-c-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},negate:function(e,t){return(t=t||new ne(16))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t[9]=-e[9],t[10]=-e[10],t[11]=-e[11],t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=-e[15],t},copy:re,clone:ie,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r&&Math.abs(e[4]-t[4])<r&&Math.abs(e[5]-t[5])<r&&Math.abs(e[6]-t[6])<r&&Math.abs(e[7]-t[7])<r&&Math.abs(e[8]-t[8])<r&&Math.abs(e[9]-t[9])<r&&Math.abs(e[10]-t[10])<r&&Math.abs(e[11]-t[11])<r&&Math.abs(e[12]-t[12])<r&&Math.abs(e[13]-t[13])<r&&Math.abs(e[14]-t[14])<r&&Math.abs(e[15]-t[15])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},identity:se,transpose:function(e,t){if((t=t||new ne(16))===e){let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,t}const n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15];return t[0]=n,t[1]=o,t[2]=u,t[3]=f,t[4]=r,t[5]=a,t[6]=h,t[7]=m,t[8]=i,t[9]=l,t[10]=d,t[11]=g,t[12]=s,t[13]=c,t[14]=p,t[15]=v,t},inverse:oe,determinant:function(e){const t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],a=e[6],l=e[7],c=e[8],u=e[9],h=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],v=h*g,y=m*d,x=a*g,w=m*l,b=a*d,_=h*l,k=r*g,S=m*i,A=r*d,E=h*i,T=r*l,P=a*i;return t*(v*o+w*u+b*f-(y*o+x*u+_*f))+s*(y*n+k*u+E*f-(v*n+S*u+A*f))+c*(x*n+S*o+T*f-(w*n+k*o+P*f))+p*(_*n+A*o+P*u-(b*n+E*o+T*u))},invert:ae,multiply:le,mul:ce,setTranslation:function(e,t,n){return e!==(n=n||se())&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11]),n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},getTranslation:function(e,t){return(t=t||a())[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const r=4*t;return(n=n||a())[0]=e[r+0],n[1]=e[r+1],n[2]=e[r+2],n},setAxis:function(e,t,n,r){r!==e&&(r=re(e,r));const i=4*n;return r[i+0]=t[0],r[i+1]=t[1],r[i+2]=t[2],r},getScaling:function(e,t){t=t||a();const n=e[0],r=e[1],i=e[2],s=e[4],o=e[5],l=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+r*r+i*i),t[1]=Math.sqrt(s*s+o*o+l*l),t[2]=Math.sqrt(c*c+u*u+h*h),t},perspective:function(e,t,n,r,i){i=i||new ne(16);const s=Math.tan(.5*Math.PI-.5*e);if(i[0]=s/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=s,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,r===1/0)i[10]=-1,i[14]=-n;else{const e=1/(n-r);i[10]=r*e,i[14]=r*n*e}return i},ortho:function(e,t,n,r,i,s,o){return(o=o||new ne(16))[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(r-n),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(i-s),o[11]=0,o[12]=(t+e)/(e-t),o[13]=(r+n)/(n-r),o[14]=i/(i-s),o[15]=1,o},frustum:function(e,t,n,r,i,s,o){const a=t-e,l=r-n,c=i-s;return(o=o||new ne(16))[0]=2*i/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*i/l,o[6]=0,o[7]=0,o[8]=(e+t)/a,o[9]=(r+n)/l,o[10]=s/c,o[11]=-1,o[12]=0,o[13]=0,o[14]=i*s/c,o[15]=0,o},aim:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(t,e,de),de),Y(D(n,de,ue),ue),Y(D(de,ue,he),he),r[0]=ue[0],r[1]=ue[1],r[2]=ue[2],r[3]=0,r[4]=he[0],r[5]=he[1],r[6]=he[2],r[7]=0,r[8]=de[0],r[9]=de[1],r[10]=de[2],r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r},cameraAim:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(e,t,de),de),Y(D(n,de,ue),ue),Y(D(de,ue,he),he),r[0]=ue[0],r[1]=ue[1],r[2]=ue[2],r[3]=0,r[4]=he[0],r[5]=he[1],r[6]=he[2],r[7]=0,r[8]=de[0],r[9]=de[1],r[10]=de[2],r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r},lookAt:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(e,t,de),de),Y(D(n,de,ue),ue),Y(D(de,ue,he),he),r[0]=ue[0],r[1]=he[0],r[2]=de[0],r[3]=0,r[4]=ue[1],r[5]=he[1],r[6]=de[1],r[7]=0,r[8]=ue[2],r[9]=he[2],r[10]=de[2],r[11]=0,r[12]=-(ue[0]*e[0]+ue[1]*e[1]+ue[2]*e[2]),r[13]=-(he[0]*e[0]+he[1]*e[1]+he[2]*e[2]),r[14]=-(de[0]*e[0]+de[1]*e[1]+de[2]*e[2]),r[15]=1,r},translation:function(e,t){return(t=t||new ne(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},translate:function(e,t,n){n=n||new ne(16);const r=t[0],i=t[1],s=t[2],o=e[0],a=e[1],l=e[2],c=e[3],u=e[4],h=e[5],d=e[6],p=e[7],f=e[8],m=e[9],g=e[10],v=e[11],y=e[12],x=e[13],w=e[14],b=e[15];return e!==n&&(n[0]=o,n[1]=a,n[2]=l,n[3]=c,n[4]=u,n[5]=h,n[6]=d,n[7]=p,n[8]=f,n[9]=m,n[10]=g,n[11]=v),n[12]=o*r+u*i+f*s+y,n[13]=a*r+h*i+m*s+x,n[14]=l*r+d*i+g*s+w,n[15]=c*r+p*i+v*s+b,n},rotationX:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateX:function(e,t,n){n=n||new ne(16);const r=e[4],i=e[5],s=e[6],o=e[7],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[4]=h*r+d*a,n[5]=h*i+d*l,n[6]=h*s+d*c,n[7]=h*o+d*u,n[8]=h*a-d*r,n[9]=h*l-d*i,n[10]=h*c-d*s,n[11]=h*u-d*o,e!==n&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationY:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=n,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateY:function(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[0]=h*r-d*a,n[1]=h*i-d*l,n[2]=h*s-d*c,n[3]=h*o-d*u,n[8]=h*a+d*r,n[9]=h*l+d*i,n[10]=h*c+d*s,n[11]=h*u+d*o,e!==n&&(n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationZ:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateZ:function(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=Math.cos(t),d=Math.sin(t);return n[0]=h*r+d*a,n[1]=h*i+d*l,n[2]=h*s+d*c,n[3]=h*o+d*u,n[4]=h*a-d*r,n[5]=h*l-d*i,n[6]=h*c-d*s,n[7]=h*u-d*o,e!==n&&(n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},axisRotation:pe,rotation:fe,axisRotate:me,rotate:ge,scaling:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},scale:function(e,t,n){n=n||new ne(16);const r=t[0],i=t[1],s=t[2];return n[0]=r*e[0],n[1]=r*e[1],n[2]=r*e[2],n[3]=r*e[3],n[4]=i*e[4],n[5]=i*e[5],n[6]=i*e[6],n[7]=i*e[7],n[8]=s*e[8],n[9]=s*e[9],n[10]=s*e[10],n[11]=s*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},uniformScaling:function(e,t){return(t=t||new ne(16))[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},uniformScale:function(e,t,n){return(n=n||new ne(16))[0]=t*e[0],n[1]=t*e[1],n[2]=t*e[2],n[3]=t*e[3],n[4]=t*e[4],n[5]=t*e[5],n[6]=t*e[6],n[7]=t*e[7],n[8]=t*e[8],n[9]=t*e[9],n[10]=t*e[10],n[11]=t*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n}});let ye=Float32Array;function xe(e,t,n,r){const i=new ye(4);return void 0!==e&&(i[0]=e,void 0!==t&&(i[1]=t,void 0!==n&&(i[2]=n,void 0!==r&&(i[3]=r)))),i}const we=xe;function be(e,t,n){n=n||new ye(4);const r=.5*t,i=Math.sin(r);return n[0]=i*e[0],n[1]=i*e[1],n[2]=i*e[2],n[3]=Math.cos(r),n}function _e(e,t,n){n=n||new ye(4);const r=e[0],i=e[1],s=e[2],o=e[3],a=t[0],l=t[1],c=t[2],u=t[3];return n[0]=r*u+o*a+i*c-s*l,n[1]=i*u+o*l+s*a-r*c,n[2]=s*u+o*c+r*l-i*a,n[3]=o*u-r*a-i*l-s*c,n}const ke=_e;function Se(e,t,n,i){i=i||new ye(4);const s=e[0],o=e[1],a=e[2],l=e[3];let c,u,h=t[0],d=t[1],p=t[2],f=t[3],m=s*h+o*d+a*p+l*f;if(m<0&&(m=-m,h=-h,d=-d,p=-p,f=-f),1-m>r){const e=Math.acos(m),t=Math.sin(e);c=Math.sin((1-n)*e)/t,u=Math.sin(n*e)/t}else c=1-n,u=n;return i[0]=c*s+u*h,i[1]=c*o+u*d,i[2]=c*a+u*p,i[3]=c*l+u*f,i}function Ae(e,t){return(t=t||new ye(4))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}const Ee=Ae;function Te(e,t,n){return(n=n||new ye(4))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n}const Pe=Te;function Me(e,t,n){return(n=n||new ye(4))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n}const Ce=Me;function ze(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Ie(e){const t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)}const Be=Ie;function Oe(e){const t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i}const Ne=Oe;function Ue(e,t){t=t||new ye(4);const n=e[0],r=e[1],i=e[2],s=e[3],o=Math.sqrt(n*n+r*r+i*i+s*s);return o>1e-5?(t[0]=n/o,t[1]=r/o,t[2]=i/o,t[3]=s/o):(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}let Re,De,Fe,Le,qe;var je=Object.freeze({__proto__:null,create:xe,setDefaultType:function(e){const t=ye;return ye=e,t},fromValues:we,set:function(e,t,n,r,i){return(i=i||new ye(4))[0]=e,i[1]=t,i[2]=n,i[3]=r,i},fromAxisAngle:be,toAxisAngle:function(e,t){t=t||a(4);const n=2*Math.acos(e[3]),i=Math.sin(.5*n);return i>r?(t[0]=e[0]/i,t[1]=e[1]/i,t[2]=e[2]/i):(t[0]=1,t[1]=0,t[2]=0),{angle:n,axis:t}},angle:function(e,t){const n=ze(e,t);return Math.acos(2*n*n-1)},multiply:_e,mul:ke,rotateX:function(e,t,n){n=n||new ye(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(r),c=Math.cos(r);return n[0]=i*c+a*l,n[1]=s*c+o*l,n[2]=o*c-s*l,n[3]=a*c-i*l,n},rotateY:function(e,t,n){n=n||new ye(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(r),c=Math.cos(r);return n[0]=i*c-o*l,n[1]=s*c+a*l,n[2]=o*c+i*l,n[3]=a*c-s*l,n},rotateZ:function(e,t,n){n=n||new ye(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(r),c=Math.cos(r);return n[0]=i*c+s*l,n[1]=s*c-i*l,n[2]=o*c+a*l,n[3]=a*c-o*l,n},slerp:Se,inverse:function(e,t){t=t||new ye(4);const n=e[0],r=e[1],i=e[2],s=e[3],o=n*n+r*r+i*i+s*s,a=o?1/o:0;return t[0]=-n*a,t[1]=-r*a,t[2]=-i*a,t[3]=s*a,t},conjugate:function(e,t){return(t=t||new ye(4))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},fromMat:function(e,t){t=t||new ye(4);const n=e[0]+e[5]+e[10];if(n>0){const r=Math.sqrt(n+1);t[3]=.5*r;const i=.5/r;t[0]=(e[6]-e[9])*i,t[1]=(e[8]-e[2])*i,t[2]=(e[1]-e[4])*i}else{let n=0;e[5]>e[0]&&(n=1),e[10]>e[4*n+n]&&(n=2);const r=(n+1)%3,i=(n+2)%3,s=Math.sqrt(e[4*n+n]-e[4*r+r]-e[4*i+i]+1);t[n]=.5*s;const o=.5/s;t[3]=(e[4*r+i]-e[4*i+r])*o,t[r]=(e[4*r+n]+e[4*n+r])*o,t[i]=(e[4*i+n]+e[4*n+i])*o}return t},fromEuler:function(e,t,n,r,i){i=i||new ye(4);const s=.5*e,o=.5*t,a=.5*n,l=Math.sin(s),c=Math.cos(s),u=Math.sin(o),h=Math.cos(o),d=Math.sin(a),p=Math.cos(a);switch(r){case"xyz":i[0]=l*h*p+c*u*d,i[1]=c*u*p-l*h*d,i[2]=c*h*d+l*u*p,i[3]=c*h*p-l*u*d;break;case"xzy":i[0]=l*h*p-c*u*d,i[1]=c*u*p-l*h*d,i[2]=c*h*d+l*u*p,i[3]=c*h*p+l*u*d;break;case"yxz":i[0]=l*h*p+c*u*d,i[1]=c*u*p-l*h*d,i[2]=c*h*d-l*u*p,i[3]=c*h*p+l*u*d;break;case"yzx":i[0]=l*h*p+c*u*d,i[1]=c*u*p+l*h*d,i[2]=c*h*d-l*u*p,i[3]=c*h*p-l*u*d;break;case"zxy":i[0]=l*h*p-c*u*d,i[1]=c*u*p+l*h*d,i[2]=c*h*d+l*u*p,i[3]=c*h*p-l*u*d;break;case"zyx":i[0]=l*h*p-c*u*d,i[1]=c*u*p+l*h*d,i[2]=c*h*d-l*u*p,i[3]=c*h*p+l*u*d;break;default:throw new Error(`Unknown rotation order: ${r}`)}return i},copy:Ae,clone:Ee,add:function(e,t,n){return(n=n||new ye(4))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n},subtract:Te,sub:Pe,mulScalar:Me,scale:Ce,divScalar:function(e,t,n){return(n=n||new ye(4))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n[3]=e[3]/t,n},dot:ze,lerp:function(e,t,n,r){return(r=r||new ye(4))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r[2]=e[2]+n*(t[2]-e[2]),r[3]=e[3]+n*(t[3]-e[3]),r},length:Ie,len:Be,lengthSq:Oe,lenSq:Ne,normalize:Ue,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(e){return(e=e||new ye(4))[0]=0,e[1]=0,e[2]=0,e[3]=1,e},rotationTo:function(e,t,n){n=n||new ye(4),Re=Re||a(),De=De||a(1,0,0),Fe=Fe||a(0,1,0);const r=F(e,t);return r<-.999999?(D(De,e,Re),q(Re)<1e-6&&D(Fe,e,Re),Y(Re,Re),be(Re,Math.PI,n),n):r>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(D(e,t,Re),n[0]=Re[0],n[1]=Re[1],n[2]=Re[2],n[3]=1+r,Ue(n,n))},sqlerp:function(e,t,n,r,i,s){return s=s||new ye(4),Le=Le||new ye(4),qe=qe||new ye(4),Se(e,r,i,Le),Se(t,n,i,qe),Se(Le,qe,2*i*(1-i),s),s}});Float32Array;const Ve=(e,t)=>{const n=new Uint32Array(t);Ms.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},Ge=(e,t)=>{const n=new Uint32Array(e),r=Ms.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return Ve(r,e),r},$e=(e,t)=>{if(t instanceof Float32Array)Ms.queue.writeBuffer(e,0,t.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT);else{const n=new Float32Array(t);Ms.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)}},We="// Constants\r\nconst infinity : f32 = 99999999.0;\r\n\r\n// Utility functions\r\nfn degreesToRadians(degrees : f32) -> f32 {\r\n    return degrees * (3.1415926535897932385 / 180.0);\r\n}\r\n\r\nfn unitVector(v : vec3<f32>) -> vec3<f32> {\r\n    return v / length(v);\r\n}\r\n\r\nfn lengthSquared(v : vec3<f32>) -> f32 {\r\n    return v.x * v.x + v.y * v.y + v.z * v.z;\r\n}\r\n\r\nfn random(co : vec2<f32>) -> f32 {\r\n    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nfn randomMinMax(co : vec2<f32>, min : f32, max : f32) -> f32 {\r\n    return min + (max - min) * random(co);\r\n}\r\n\r\nfn randomFloat3(co : vec2<f32>) -> vec3<f32> {\r\n    return vec3<f32>(random(co), random(co * 2.0), random(co * 3.0));\r\n}\r\n\r\nfn randomFloat3MinMax(co : vec2<f32>, min : f32, max : f32) -> vec3<f32> {\r\n    return vec3<f32>(randomMinMax(co, min, max), randomMinMax(co * 2.0, min, max), randomMinMax(co * 3.0, min, max));\r\n}\r\n\r\nfn randomInUnitSphere(co : vec2<f32>) -> vec3<f32> {\r\n    var p : vec3<f32> = randomFloat3MinMax(co, -1.0, 1.0);\r\n    while (lengthSquared(p) < 1.0) {\r\n        p = randomFloat3MinMax(co, -1.0, 1.0);\r\n    }\r\n    return p;\r\n}\r\n\r\nfn randomInUnitDisk(seed : vec2<f32>) -> vec2<f32> {\r\n    let r = sqrt(random(seed));\r\n    let theta = 2.0 * 3.14159265359 * random(vec2<f32>(seed.y, seed.x));\r\n    return vec2<f32>(cos(theta), sin(theta)) * r;\r\n}\r\n\r\nfn randomInPlanarUnitDisk(seed : vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let disk = randomInUnitDisk(seed);\r\n    var diskNormal = cross(normal, vec3<f32>(0.0, 1.0, 0.0));\r\n    if (length(diskNormal) < 0.01) {\r\n        diskNormal = cross(normal, vec3<f32>(1.0, 0.0, 0.0));\r\n    }\r\n    diskNormal = normalize(diskNormal);\r\n    let diskTangent = cross(diskNormal, normal);\r\n    return disk.x * diskTangent + disk.y * diskNormal;\r\n}\r\n\r\nfn reflect(v : vec3<f32>, n : vec3<f32>) -> vec3<f32> {\r\n    return v - 2.0 * dot(v, n) * n;\r\n}\r\n\r\nfn randomUnitVector(co : vec2<f32>) -> vec3<f32> {\r\n    return unitVector(randomInUnitSphere(co));\r\n}\r\n\r\nfn nearZero(e : vec3<f32>) -> bool {\r\n    const s : f32 = 1e-8;\r\n    return (abs(e.x) < s) && (abs(e.y) < s) && (abs(e.z) < s);\r\n}\r\n\r\nfn randomInHemisphere(co : vec2<f32>, normal : vec3<f32>) -> vec3<f32> {\r\n    let inUnitSphere = randomUnitVector(co);\r\n    if (dot(inUnitSphere, normal) > 0.0) {\r\n        return inUnitSphere;\r\n    }\r\n    return -inUnitSphere;\r\n}\r\n\r\nfn randomAlongVector(co : vec2<f32>, direction : vec3<f32>) -> vec3<f32> {\r\n    return normalize(direction) * random(co);\r\n}\r\n\r\n// Function to perturb the normal vector within the hemisphere\r\nfn perturbDirection(normal: vec3<f32>, scatterAmount: f32, co: vec2<f32>) -> vec3<f32> {\r\n    // Generate a random vector in a hemisphere\r\n    let hemisphereVector : vec3<f32> = randomInHemisphere(co, normal);\r\n\r\n    // Combine the perturbation with the original normal\r\n    let perturbedDir : vec3<f32> = normalize(normal + scatterAmount * hemisphereVector);\r\n\r\n    return perturbedDir;\r\n}\r\n\r\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\r\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\r\nfn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\n\r\nfn perlinNoise3(P: vec3<f32>) -> f32 {\r\n    var Pi0 : vec3<f32> = floor(P); // Integer part for indexing\r\n    var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1\r\n    Pi0 = Pi0 % vec3<f32>(289.);\r\n    Pi1 = Pi1 % vec3<f32>(289.);\r\n    let Pf0 = fract(P); // Fractional part for interpolation\r\n    let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.\r\n    let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    let iy = vec4<f32>(Pi0.yy, Pi1.yy);\r\n    let iz0 = Pi0.zzzz;\r\n    let iz1 = Pi1.zzzz;\r\n\r\n    let ixy = permute4(permute4(ix) + iy);\r\n    let ixy0 = permute4(ixy + iz0);\r\n    let ixy1 = permute4(ixy + iz1);\r\n\r\n    var gx0: vec4<f32> = ixy0 / 7.;\r\n    var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;\r\n    gx0 = fract(gx0);\r\n    var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\r\n    var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));\r\n    gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);\r\n    gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);\r\n\r\n    var gx1: vec4<f32> = ixy1 / 7.;\r\n    var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;\r\n    gx1 = fract(gx1);\r\n    var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\r\n    var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));\r\n    gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);\r\n    gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);\r\n\r\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\r\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\r\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\r\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\r\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\r\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\r\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\r\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\r\n\r\n    let norm0 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 = g000 * norm0.x;\r\n    g010 = g010 * norm0.y;\r\n    g100 = g100 * norm0.z;\r\n    g110 = g110 * norm0.w;\r\n    let norm1 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 = g001 * norm1.x;\r\n    g011 = g011 * norm1.y;\r\n    g101 = g101 * norm1.z;\r\n    g111 = g111 * norm1.w;\r\n\r\n    let n000 = dot(g000, Pf0);\r\n    let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\r\n    let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\r\n    let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\r\n    let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\r\n    let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\r\n    let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\r\n    let n111 = dot(g111, Pf1);\r\n\r\n    var fade_xyz: vec3<f32> = fade3(Pf0);\r\n    let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix\r\n    let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);\r\n    let n_yz = mix(n_z.xy, n_z.zw, vec2f(f32(fade_xyz.y))); // simplify after chrome bug fix\r\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 2.2 * n_xyz;\r\n}",He="fn calculateRayDirection(uv: vec2<f32>, inverseProjection: mat4x4<f32>) -> vec3<f32> {\r\n  let clipSpace = vec2(1.0 - uv.x, 1.0 - uv.y) * 2.0 - 1.0;\r\n  let viewRay = vec3<f32>(clipSpace, 1.0);\r\n  let viewRayView = inverseProjection * vec4(viewRay, 1.0);\r\n  return normalize(viewRayView.xyz);\r\n}\r\n\r\nfn normaliseValue(min: f32, max: f32, value: f32) -> f32 {\r\n  return (value - min) / (max - min);\r\n}",Ye="struct BoxIntersectionResult {\r\n    tNear: f32,\r\n    tFar: f32,\r\n    normal: vec3<f32>,\r\n    isHit: bool,\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n    result.isHit = false;\r\n    result.tNear = 0.0;\r\n    result.tFar = 0.0;\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n    if (tN > tF || tF < 0.0) {\r\n        return result;\r\n    }\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n    normal *= -sign(rd);\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        return result;\r\n    }\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n    result.isHit = true;\r\n    return result;\r\n}\r\n\r\nfn get3x3From4x4(m: mat4x4<f32>) -> mat3x3<f32> {\r\n    return mat3x3<f32>(\r\n        m[0].xyz,\r\n        m[1].xyz,\r\n        m[2].xyz,\r\n    );\r\n}\r\n\r\n\r\nfn intersectOBB(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n    boxOrientation: mat3x3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n    result.isHit = false;\r\n    result.tNear = -1.0;\r\n    result.tFar = -1.0;\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n    if (tN > tF || tF < 0.0) {\r\n        return result;\r\n    }\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n    normal *= -sign(rd);\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        return result;\r\n    }\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n    result.isHit = true;\r\n    return result;\r\n}",Xe='const EPSILON = 0.001;\r\nconst MAX_RAY_STEPS = 256;\r\nconst FAR_PLANE = 10000.0;\r\nconst NEAR_PLANE = 0.5;\r\nconst STACK_LEN: u32 = 32u;\r\n\r\n// Function to transform a normal vector from object to world space\r\nfn transformNormal(inverseTransform: mat4x4<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let worldNormal = normalize((vec4<f32>(normal, 0.0) * inverseTransform).xyz);\r\n    return worldNormal;\r\n}\r\n\r\n// Function to transform an object space position to world space\r\nfn transformPosition(transform: mat4x4<f32>, position: vec3<f32>) -> vec3<f32> {\r\n    let worldPosition = (transform * vec4<f32>(position, 1.0)).xyz;\r\n    return worldPosition;\r\n}\r\n\r\n\r\nstruct VoxelObject {\r\n  transform: mat4x4<f32>,\r\n  inverseTransform: mat4x4<f32>,\r\n  previousTransform: mat4x4<f32>,\r\n  previousInverseTransform: mat4x4<f32>,\r\n  size : vec3<f32>,\r\n  atlasLocation : vec3<f32>,\r\n  paletteIndex : f32,\r\n  octreeBufferIndex: u32\r\n}\r\n\r\nstruct RayMarchResult {\r\n  voxelObjectIndex: i32,\r\n  colour: vec3<f32>,\r\n  normal: vec3<f32>,\r\n  hit: bool,\r\n  t: f32,\r\n  iterations: u32,\r\n}\r\n\r\nfn isInBounds(position: vec3<i32>, size: vec3<i32>) -> bool {\r\n  return all(position >= vec3(0)) && all(position <= size - vec3(1));\r\n}\r\n\r\nfn getBit(value: u32, bitIndex: u32) -> bool {\r\n  return (value & (1u << bitIndex)) != 0;\r\n}\r\n\r\nfn getScaleFromMatrix(transform: mat4x4<f32>) -> vec3<f32> {\r\n  return vec3<f32>(length(transform[0].xyz), length(transform[1].xyz), length(transform[2].xyz));\r\n}\r\n\r\nstruct Stack {\r\n  arr: array<i32, STACK_LEN>,\r\n\thead: u32,\r\n}\r\n\r\nfn stack_new() -> Stack {\r\n    var arr: array<i32, STACK_LEN>;\r\n    return Stack(arr, 0u);\r\n}\r\n\r\nfn stack_push(stack: ptr<function, Stack>, val: i32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stack_pop(stack: ptr<function, Stack>) -> i32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\nstruct StackU32 {\r\n  arr: array<u32, STACK_LEN>,\r\n  head: u32,\r\n}\r\n\r\nfn stacku32_new() -> StackU32 {\r\n    var arr: array<u32, STACK_LEN>;\r\n    return StackU32(arr, 0u);\r\n}\r\n\r\nfn stacku32_push(stack: ptr<function, StackU32>, val: u32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stacku32_pop(stack: ptr<function, StackU32>) -> u32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\n\r\nstruct InternalNode {\r\n  firstChildOffset: u32,\r\n  childMask: u32,\r\n  position: vec3<u32>,\r\n  size: u32,\r\n}\r\n\r\nstruct LeafNode {\r\n  colour: vec3<u32>,\r\n  position: vec3<u32>,\r\n  size: u32,\r\n}\r\n\r\nconst mask8 = 0xFFu;\r\nconst mask16 = 0xFFFFu;\r\nconst mask24 = 0xFFFFFFu;\r\n\r\n// if first child offset is 0, then it is a leaf\r\nfn isLeaf(node:vec2<u32>) -> bool {\r\n  return (node[0] & mask8) == 0;\r\n}\r\n\r\n/**\r\n  * Unpacks a leaf node from a 32 bit integer\r\n  * First 8 bits are the leaf flag (0)\r\n  * The next 8 bits are the x position\r\n  * The next 8 bits are the y position\r\n  * The next 8 bits are the z position\r\n  * The next 8 bits are the red component\r\n  * The next 8 bits are the green component\r\n  * The next 8 bits are the blue component\r\n\r\n  */\r\nfn unpackLeaf(node: vec2<u32>) -> LeafNode {\r\n  var output = LeafNode();\r\n  let first4Bytes = node.x;\r\n  let second4Bytes = node.y;\r\n  let x = (first4Bytes >> 8u) & mask8;\r\n  let y = (first4Bytes >> 16u) & mask8;\r\n  let z = (first4Bytes >> 24u) & mask8;\r\n  let r = second4Bytes & mask8;\r\n  let g = (second4Bytes >> 8u) & mask8;\r\n  let b = (second4Bytes >> 16u) & mask8;\r\n  output.colour = vec3<u32>(r, g, b);\r\n  output.position = vec3<u32>(x, y, z);\r\n  output.size = 1u << ((second4Bytes >> 24u) & mask8);\r\n  return output;\r\n}\r\n\r\n/**\r\n  * Unpacks an internal node from a 32 bit integer\r\n  * First 8 bits are the child mask\r\n  * The next 8 bits are the x position\r\n  * The next 8 bits are the y position\r\n  * The next 8 bits are the z position\r\n  * The next 24 bits are the firstChildOffset\r\n  * The next 8 bits are the size\r\n  */\r\nfn unpackInternal(node: vec2<u32>) -> InternalNode {\r\n  var output = InternalNode();\r\n  let first4Bytes = node.x;\r\n  let second4Bytes = node.y;\r\n  output.childMask = first4Bytes & mask8;\r\n  let x = (first4Bytes >> 8u) & mask8;\r\n  let y = (first4Bytes >> 16u) & mask8;\r\n  let z = (first4Bytes >> 24u) & mask8;\r\n  output.firstChildOffset = second4Bytes & mask24;\r\n  output.position = vec3<u32>(x, y, z);\r\n  output.size = 1u << ((second4Bytes >> 24u) & mask8); // 2 raised to the power of the size\r\n  return output;\r\n}\r\n\r\nfn getNodeSizeAtDepth(rootSize: u32, depth: u32) -> u32 {\r\n  return rootSize >> depth;\r\n}\r\n\r\nfn octantIndexToOffset(index: u32) -> vec3<u32> {\r\n  return vec3<u32>(\r\n    select(0u, 1u, (index & 1u) != 0u),\r\n    select(0u, 1u, (index & 2u) != 0u),\r\n    select(0u, 1u, (index & 4u) != 0u)\r\n  );\r\n}\r\n\r\nfn octantOffsetToIndex(offset: vec3<u32>) -> u32 {\r\n  return offset.x + offset.y * 2u + offset.z * 4u;\r\n}\r\n\r\nfn ceilToPowerOfTwo(value: f32) -> f32 {\r\n  return pow(2.0, ceil(log2(value)));\r\n}\r\n\r\nfn max3(value: vec3<f32>) -> f32 {\r\n  return max(value.x, max(value.y, value.z));\r\n}\r\n\r\nfn planeIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, planeNormal: vec3<f32>, planeDistance: f32) -> f32 {\r\n  return -(dot(rayOrigin,planeNormal)+planeDistance)/dot(rayDirection,planeNormal);\r\n}\r\n\r\nstruct PlaneIntersection {\r\n  tNear: f32,\r\n  side: vec3<i32>\r\n}\r\n\r\n\r\nfn sort3Asc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    min(a, min(b, c)),\r\n    min(max(a, b), max(min(a, b), c)),\r\n    max(a, max(b, c))\r\n  );\r\n}\r\n\r\nfn sort3Desc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    max(a, max(b, c)),\r\n    max(min(a, b), min(max(a, b), c)),\r\n    min(a, min(b, c))\r\n  );\r\n}\r\n\r\nfn getPlaneIntersections(rayOrigin: vec3<f32>, rayDirection:vec3<f32>, nodeSize: f32) -> vec3<f32> {\r\n    let boxExtents = nodeSize * 0.5;\r\n\r\n    var yPlaneIntersectionTNear = planeIntersection(rayOrigin, rayDirection, vec3(0.0, -1, 0.0), boxExtents);\r\n    var xPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(-1, 0.0, 0.0), boxExtents);\r\n    var zPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(0.0, 0.0, -1), boxExtents);\r\n\r\n    // If the intersection is outside the bounds of the node, set it to a large value to ignore it\r\n    let yPlaneHitPosition = rayOrigin + rayDirection * yPlaneIntersectionTNear  - EPSILON;\r\n    if(any(yPlaneHitPosition < vec3(0.0)) || any(yPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      yPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n    let xPlaneHitPosition = rayOrigin + rayDirection * xPlaneIntersectionTNear  - EPSILON;\r\n    if(any(xPlaneHitPosition < vec3(0.0)) || any(xPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      xPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n    let zPlaneHitPosition = rayOrigin + rayDirection * zPlaneIntersectionTNear  - EPSILON;\r\n    if(any(zPlaneHitPosition < vec3(0.0)) || any(zPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      zPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n\r\n    return vec3(xPlaneIntersectionTNear, yPlaneIntersectionTNear, zPlaneIntersectionTNear);\r\n}\r\n\r\nconst DISTANCE_THRESHOLDS =\r\n  array<vec2<f32>, 4>(\r\n    vec2<f32>(2.0, 500),\r\n    vec2<f32>(4.0, 1000),\r\n    vec2<f32>(8.0, 1500),\r\n    vec2<f32>(16.0, 2000)\r\n  );\r\n\r\nfn rayMarchOctree(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>, maxDistance: f32) -> RayMarchResult {\r\n    let halfExtents = voxelObject.size * 0.5;\r\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz + halfExtents;\r\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n    var output = RayMarchResult();\r\n\r\n    let distanceToRoot = boxIntersection(objectRayOrigin, objectRayDirection, voxelObject.size * 0.5).tNear;\r\n    if(distanceToRoot > maxDistance){\r\n      return output;\r\n    }\r\n\r\n    // Set the initial t value to the far plane - essentially an out of bounds value\r\n    output.t = FAR_PLANE;\r\n\r\n    // Create a stack to hold the indices of the nodes we need to check\r\n    var stack = stacku32_new();\r\n\r\n    // Push the root node index onto the stack\r\n    stacku32_push(&stack, voxelObject.octreeBufferIndex);\r\n\r\n    // Main loop\r\n    while (stack.head > 0u && output.iterations < MAX_STEPS) {\r\n//      output.colour += vec3(0.02);\r\n      output.iterations += 1u;\r\n      let nodeIndex = stacku32_pop(&stack);\r\n      let node = octreeBuffer[nodeIndex];\r\n\r\n      // Get the current nodes data\r\n      let internalNode = unpackInternal(node);\r\n\r\n      // Get the size of the node to get the center for plane intersections\r\n      let nodeSize = f32(internalNode.size);\r\n\r\n      let nodeOrigin = vec3<f32>(internalNode.position);\r\n      let nodeRayOrigin = objectRayOrigin - nodeOrigin;\r\n\r\n      if(isLeaf(node)){\r\n        // TODO: find out how to get normal without extra intersection\r\n        let leafNode = unpackLeaf(node);\r\n        let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(nodeSize * 0.5));\r\n        output.hit = true;\r\n        output.t = nodeIntersection.tNear;\r\n        output.normal = nodeIntersection.normal;\r\n        output.colour = vec3<f32>(leafNode.colour) / 255.0;\r\n        return output;\r\n      }\r\n\r\n      let centerOfChild = vec3(nodeSize * 0.5);\r\n\r\n      // Use planes to find the "inner" intersections\r\n      let planeIntersections = getPlaneIntersections(nodeRayOrigin, objectRayDirection, nodeSize);\r\n\r\n      // Get the closest plane intersection\r\n      let sortedIntersections = sort3Desc(planeIntersections[0], planeIntersections[1], planeIntersections[2]);\r\n\r\n      // Get the side of the planes that the ray is on\r\n      let sideOfPlanes = vec3<f32>(sign(nodeRayOrigin - centerOfChild));\r\n\r\n      // Push the children onto the stack, furthest first\r\n      for(var i = 0u; i < 3u; i++){\r\n        if(sortedIntersections[i] > maxDistance || sortedIntersections[i] < 0.0){\r\n          continue;\r\n        }\r\n\r\n        var hitPosition = nodeRayOrigin + objectRayDirection * sortedIntersections[i] - sideOfPlanes * EPSILON;\r\n        let hitOctant = vec3<u32>(hitPosition >= centerOfChild);\r\n        let hitIndex = octantOffsetToIndex(hitOctant);\r\n\r\n        // If the child is present, push it onto the stack\r\n        if(getBit(internalNode.childMask, hitIndex)){\r\n           let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\r\n           stacku32_push(&stack, childIndex);\r\n        }\r\n      }\r\n\r\n      // Get octant hit on the surface of the nodes bounding box\r\n      // Check if the ray intersects the node, if not, skip it\r\n      let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(nodeSize * 0.5));\r\n      if(nodeIntersection.tNear > maxDistance || nodeIntersection.tNear < 0.0){\r\n        continue;\r\n      }\r\n      let intersectionPoint = nodeRayOrigin + objectRayDirection * nodeIntersection.tNear;\r\n      let hitOctant = vec3<u32>(intersectionPoint >= centerOfChild);\r\n      let hitIndex = octantOffsetToIndex(vec3<u32>(hitOctant));\r\n\r\n      // If the child is present, push it onto the stack\r\n      if(getBit(internalNode.childMask, hitIndex)){\r\n        let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\r\n        stacku32_push(&stack, childIndex);\r\n      }\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n\r\nconst colours = array<vec3<f32>, 8>(\r\n  vec3<f32>(0.5),\r\n  vec3<f32>(1.0, 0.0, 0.0),\r\n  vec3<f32>(0.0, 1.0, 0.0),\r\n  vec3<f32>(1.0, 1.0, 0.0),\r\n  vec3<f32>(0.0, 0.0, 1.0),\r\n  vec3<f32>(1.0, 0.0, 1.0),\r\n  vec3<f32>(0.0, 1.0, 1.0),\r\n  vec3<f32>(1.0, 1.0, 1.0)\r\n);\r\n\r\nfn debugColourFromIndex(index: i32) -> vec3<f32> {\r\n  return colours[index % 8];\r\n}\r\n',Ze="const BRICK_SIZE = 8;\r\nconst MAX_BVH_STEPS = 64;\r\nconst MAX_STEPS = 256;\r\n\r\n\r\nstruct BVHNode {\r\n  leftIndex: i32,\r\n  rightIndex: i32,\r\n  objectCount: u32,\r\n  AABBMin: vec3<f32>,\r\n  AABBMax: vec3<f32>\r\n}\r\n\r\nfn getDistanceToNode(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, node: BVHNode) -> f32 {\r\n  if(all(rayOrigin >= node.AABBMin) && all(rayOrigin <= node.AABBMax)){\r\n    return 0.0;\r\n  }\r\n  let boxSize = (node.AABBMax - node.AABBMin) / 2;\r\n  let intersection = boxIntersection(rayOrigin - node.AABBMin, rayDirection, boxSize);\r\n  if(intersection.isHit){\r\n    return intersection.tNear;\r\n  }\r\n  return -1.0;\r\n\r\n}\r\n\r\n// Stack-based BVH traversal\r\nfn rayMarchBVH(rayOrigin: vec3<f32>, rayDirection: vec3<f32>) -> RayMarchResult {\r\n  var closestIntersection = RayMarchResult();\r\n closestIntersection.t = FAR_PLANE;\r\n\r\n  // Create a stack to store the nodes to visit\r\n  var stack = stack_new();\r\n  stack_push(&stack, 0);\r\n\r\n  var iterations = 0;\r\n  var closestRayMarchDistance = FAR_PLANE;\r\n\r\n  while (stack.head > 0u && iterations < MAX_BVH_STEPS) {\r\n    let nodeIndex = stack_pop(&stack);\r\n    let node = bvhNodes[nodeIndex];\r\n    if(node.objectCount > 1){\r\n      let leftNode = bvhNodes[node.leftIndex];\r\n      let rightNode = bvhNodes[node.rightIndex];\r\n      let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\r\n      let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\r\n      let hitLeft = leftDist >= 0.0 && leftDist < closestIntersection.t;\r\n      let hitRight = rightDist >= 0.0 && rightDist < closestIntersection.t;\r\n      if(hitLeft && hitRight){\r\n        if(leftDist < rightDist){\r\n          // left is closer, push right to stack\r\n          stack_push(&stack, node.rightIndex);\r\n          stack_push(&stack, node.leftIndex);\r\n        } else {\r\n          // right is closer, push left to stack\r\n          stack_push(&stack, node.leftIndex);\r\n          stack_push(&stack, node.rightIndex);\r\n        }\r\n      }\r\n      // We only hit the right Node\r\n      else if(hitRight){\r\n        stack_push(&stack, node.rightIndex);\r\n      }\r\n      else if(hitLeft){\r\n        stack_push(&stack, node.leftIndex);\r\n      }\r\n    }\r\n    // valid leaf, raymarch it\r\n    else if(node.objectCount == 1){\r\n        let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\r\n        if(distanceToLeaf > closestIntersection.t){\r\n          continue;\r\n        }\r\n        let voxelObject = voxelObjects[node.leftIndex];\r\n        var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, rayOrigin, 9999.0);\r\n        if(rayMarchResult.hit && rayMarchResult.t < closestIntersection.t){\r\n           closestIntersection = rayMarchResult;\r\n        }\r\n    }\r\n    iterations += 1;\r\n//    closestIntersection.colour += vec3<f32>(0.05);\r\n  }\r\n\r\n  return closestIntersection;\r\n}\r\n\r\nconst MAX_SHADOW_BVH_VISITS = 32;\r\nconst MAX_SHADOW_DISTANCE = 9999.0;\r\n\r\nfn rayMarchBVHShadows(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, mipLevel: u32) -> RayMarchResult {\r\n   var closestIntersection = RayMarchResult();\r\n   closestIntersection.t = FAR_PLANE;\r\n\r\n   // Create a stack to store the nodes to visit\r\n   var stack = stack_new();\r\n   stack_push(&stack, 0);\r\n\r\n   var iterations = 0;\r\n   var nodeIndex = 0;\r\n\r\n   while (stack.head > 0u && iterations < MAX_SHADOW_BVH_VISITS) {\r\n     let node = bvhNodes[nodeIndex];\r\n     if(node.objectCount > 1){\r\n       let leftNode = bvhNodes[node.leftIndex];\r\n       let rightNode = bvhNodes[node.rightIndex];\r\n       let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\r\n       let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\r\n       let hitLeft = leftDist >= 0.0 && leftDist < MAX_SHADOW_DISTANCE;\r\n       let hitRight = rightDist >= 0.0 && rightDist < MAX_SHADOW_DISTANCE;\r\n       if(hitLeft){\r\n         var nearIndex = node.leftIndex;\r\n         // We hit both left and right, choose the closest one\r\n         if(hitRight){\r\n           if(leftDist < rightDist){\r\n             // left is closer, push right to stack\r\n             stack_push(&stack, node.rightIndex);\r\n           } else {\r\n             // right is closer, push left to stack\r\n             stack_push(&stack, node.leftIndex);\r\n             nearIndex = node.rightIndex;\r\n           }\r\n         }\r\n         nodeIndex = nearIndex;\r\n       }\r\n       // We only hit the right Node\r\n       else if(hitRight){\r\n         nodeIndex = node.rightIndex;\r\n       }\r\n       // We didn't hit any node, pop the stack\r\n       else{\r\n         nodeIndex = stack_pop(&stack);\r\n       }\r\n     }\r\n     // valid leaf, raymarch it\r\n     else if(node.objectCount == 1){\r\n         let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\r\n         if(distanceToLeaf < 0.0){\r\n           nodeIndex = stack_pop(&stack);\r\n           continue;\r\n         }\r\n         let voxelObject = voxelObjects[node.leftIndex];\r\n         var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, rayOrigin, MAX_SHADOW_DISTANCE);\r\n         if(rayMarchResult.hit){\r\n           return rayMarchResult;\r\n         }\r\n\r\n         nodeIndex = stack_pop(&stack);\r\n     }\r\n\r\n     iterations += 1;\r\n   }\r\n\r\n   return closestIntersection;\r\n }",Ke="// TODO: actually make linear\r\nfn distanceToReversedLinearDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n  return (far - cameraDistance) / (far - near);//Reversed\r\n}\r\n\r\nfn reversedLinearDepthToDistance(linearDepth: f32, near: f32, far: f32) -> f32 {\r\n    return far - linearDepth * (far - near); //Reversed\r\n}\r\n\r\nfn distanceToLogarithmicDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n    return log2(cameraDistance / near + 1.0) / log2(far / near + 1.0);\r\n}\r\n\r\nfn logarithmicDepthToDistance(logDepth: f32, near: f32, far: f32) -> f32 {\r\n    let base = far / near + 1.0;\r\n    return near * (pow(base, logDepth) - 1.0);\r\n}",Qe=Symbol(),Je=e=>new Proxy(e,{construct:(e,t,n)=>e.prototype!==n.prototype?Reflect.construct(e,t,n):(e[Qe]||(e[Qe]=Reflect.construct(e,t,n)),e[Qe])}),et="rgba16float";const tt=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,nt=(e,t,n=tt)=>{let r=class{#e;#t;#n;#r;#i=t;#s=n;#o=e;constructor(r,i,s){this.#e=r.createTexture({label:e,size:[i,s,1],format:t,usage:n}),this.#t=this.#e.createView({label:e}),this.#n=i,this.#r=s}get texture(){return this.#e}get view(){return this.#t}get width(){return this.#n}get height(){return this.#r}get format(){return this.#i}get usage(){return this.#s}get label(){return this.#o}};return r=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o}([Je],r),r},rt=nt("albedo","rgba16float"),it=nt("normal","rgba16float"),st=nt("depth","r32float",GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST),ot=nt("velocity","rgba16float"),at=nt("world position","rgba32float"),lt=nt("output",et),ct=async()=>{const e=await(async()=>{const e={binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},t={binding:9,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},n={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},r={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},i={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},s={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba32float",viewDimension:"2d"}},a={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},l=(GPUShaderStage.COMPUTE,{binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),c=Ms.createBindGroupLayout({label:"raymarch g-buffer",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},e,{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},a,n,r,i,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s,l,o,t]}),u=await Ms.createComputePipelineAsync({label:"raymarch g-buffer",layout:Ms.createPipelineLayout({bindGroupLayouts:[c]}),compute:{module:Ms.createShaderModule({code:`\n          struct Time {\n            frame: u32,\n            deltaTime: f32\n          };\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> time : Time;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(6) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(9) var blueNoiseTex : texture_2d<f32>;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${We}\n          ${He}\n          ${Ye}\n          ${Xe}\n          ${Ze}\n          ${Ke}\n          struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>,\r\n  viewMatrix : mat4x4<f32>,\r\n};\r\n\r\n\r\nfn plainIntersect(ro: vec3<f32>, rd: vec3<f32>, p: vec4<f32>) -> f32 {\r\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\r\n}\r\n\r\nfn getVelocityStatic(worldPos: vec3<f32>, viewProjections:ViewProjectionMatrices) -> vec2<f32>{\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  let clipSpace = vp * vec4(worldPos.xyz, 1.0);\r\n  let previousClipSpace = previousVp * vec4(worldPos.xyz, 1.0);\r\n\r\n  let ndc = clipSpace.xyz / clipSpace.w;\r\n  let previousNdc = previousClipSpace.xyz / previousClipSpace.w;\r\n\r\n  var uv = ndc.xy * 0.5 + 0.5;\r\n  var previousUv = previousNdc.xy * 0.5 + 0.5;\r\n\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getVelocity(objectPos: vec3<f32>, modelMatrix: mat4x4<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec2<f32> {\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  // Get current object space position of the current pixel\r\n  let objectClipSpace = vp * modelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let objectNDC = objectClipSpace.xyz / objectClipSpace.w;\r\n\r\n  // Get previous position of the current object space position\r\n  let previousObjectClipSpace = previousVp * previousModelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let previousObjectNDC = previousObjectClipSpace.xyz / previousObjectClipSpace.w;\r\n\r\n  // UV\r\n  var uv = objectNDC.xy * 0.5 + 0.5;\r\n  var previousUv = previousObjectNDC.xy * 0.5 + 0.5;\r\n  uv.y = 1.0 - uv.y;\r\n  previousUv.y = 1.0 - previousUv.y;\r\n\r\n  // Get velocity based on the difference between the current and previous positions\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getLeftChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 1;\r\n}\r\n\r\nfn getRightChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 2;\r\n}\r\n\r\nfn getParentIndex(index: i32) -> i32 {\r\n  return (index - 1) / 2;\r\n}\r\n\r\n\r\nfn dirIsNegative(dir: vec3<f32>, axis: i32) -> bool {\r\n  return dir[axis] < 0.0;\r\n}\r\n\r\nfn getDebugColour(index: i32) -> vec3<f32> {\r\n  let colours = array<vec3<f32>, 6>(\r\n    vec3<f32>(1.0, 0.0, 0.0),\r\n    vec3<f32>(0.0, 1.0, 0.0),\r\n    vec3<f32>(0.0, 0.0, 1.0),\r\n    vec3<f32>(1.0, 1.0, 0.0),\r\n    vec3<f32>(1.0, 0.0, 1.0),\r\n    vec3<f32>(0.0, 1.0, 1.0)\r\n  );\r\n  return colours[index % 6];\r\n}\r\n\r\n\r\nfn customNormalize(value: f32, min: f32, max: f32) -> f32 {\r\n    return (value - min) / (max - min);\r\n}\r\n\r\nconst IDENTITY_MATRIX = mat4x4<f32>(\r\n  vec4<f32>(1.0, 0.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 1.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n);\r\n\r\nfn intersectSphere(origin: vec3<f32>, dir: vec3<f32>, spherePos: vec3<f32>, sphereRad: f32) -> f32\r\n{\r\n\tlet oc = origin - spherePos;\r\n\tlet b = 2.0 * dot(dir, oc);\r\n\tlet c = dot(oc, oc) - sphereRad*sphereRad;\r\n\tlet disc = b * b - 4.0 * c;\r\n\tif (disc < 0.0)\r\n\t{\r\n\t  return -1.0;\r\n\t}\r\n\r\n//    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\r\n  let q = (-b + select(sqrt(disc), -sqrt(disc), b < 0.0)) / 2.0;\r\n\tvar t0 = q;\r\n\tvar t1 = c / q;\r\n\tif (t0 > t1) {\r\n\t\tvar temp = t0;\r\n\t\tt0 = t1;\r\n\t\tt1 = temp;\r\n\t}\r\n\tif (t1 < 0.0){\r\n\t  return -1.0;\r\n\t}\r\n\r\n  return select(t0, t1, t0 < 0.0);\r\n}\r\n\r\nfn skyDomeIntersection(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\r\n    return intersectSphere(ro, rd, vec3<f32>(0.0, 0.0, 0.0), FAR_PLANE);\r\n}\r\n\r\nconst BLUE_NOISE_SIZE = 511;\r\n\r\nfn tracePixel(pixel: vec2<u32>){\r\n   let resolution = textureDimensions(albedoTex);\r\n   var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\r\n   var rayDirection = calculateRayDirection(uv,viewProjections.inverseViewProjection);\r\n\r\n    // DOF\r\n    let blueNoiseOffset = vec2<u32>(0);\r\n    var blueNoisePixel = pixel;\r\n    blueNoisePixel.x += time.frame * 32;\r\n    blueNoisePixel.y += time.frame * 16;\r\n    blueNoisePixel = (blueNoisePixel + blueNoiseOffset) % BLUE_NOISE_SIZE;\r\n    if(time.frame % 2 == 0){\r\n      blueNoisePixel.y = BLUE_NOISE_SIZE - blueNoisePixel.y;\r\n    }\r\n    if(time.frame % 3 == 0){\r\n      blueNoisePixel.x = BLUE_NOISE_SIZE - blueNoisePixel.x;\r\n    }\r\n    var r = textureLoad(blueNoiseTex, blueNoisePixel, 0).rg;\r\n    let aperture = 0.15;\r\n    let focalDistance = 100.0;\r\n    let randomOffset = randomInUnitDisk(r) * aperture;\r\n    let cameraRight = vec3(viewProjections.viewMatrix[0].x, viewProjections.viewMatrix[1].x, viewProjections.viewMatrix[2].x);\r\n    let cameraUp = vec3(viewProjections.viewMatrix[0].y, viewProjections.viewMatrix[1].y, viewProjections.viewMatrix[2].y);\r\n    let rayOrigin = cameraPosition + randomOffset.x * cameraRight + randomOffset.y * cameraUp;\r\n    let focalPoint = cameraPosition + normalize(rayDirection) * focalDistance;\r\n    rayDirection = normalize(focalPoint - rayOrigin);\r\n\r\n    var closestIntersection = RayMarchResult();\r\n    var worldPos = vec3(0.0);\r\n    var normal = vec3(0.0);\r\n    var albedo = vec3(0.0);\r\n    var velocity = vec2(0.0);\r\n    let bvhResult = rayMarchBVH(rayOrigin, rayDirection);\r\n//    if(bvhResult.hit){\r\n      let voxelObject = voxelObjects[bvhResult.voxelObjectIndex];\r\n      albedo = bvhResult.colour;\r\n      normal = transformNormal(voxelObject.inverseTransform,vec3<f32>(bvhResult.normal));\r\n      worldPos = rayOrigin + rayDirection * bvhResult.t;\r\n//    }\r\n//    else{\r\n//      albedo = vec3(0.0);\r\n//      worldPos = rayOrigin + skyDomeIntersection(rayOrigin, rayDirection) * rayDirection;\r\n//    }\r\n    velocity = getVelocityStatic(worldPos, viewProjections);\r\n\r\n    textureStore(albedoTex, pixel, vec4(albedo, 1));\r\n    textureStore(normalTex, pixel, vec4(normal,1));\r\n    textureStore(velocityTex, pixel, vec4(velocity,0,f32(bvhResult.voxelObjectIndex)));\r\n    textureStore(worldPosTex, pixel, vec4(worldPos,0));\r\n}\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn main(\r\n   @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  tracePixel(pixel);\r\n}\r\n\r\n@group(1) @binding(0) var<storage, read> screenRayBuffer : array<vec2<u32>>;\r\n\r\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\r\n  vec2<u32>(0,1),\r\n  vec2<u32>(1,0),\r\n  vec2<u32>(1,1),\r\n  vec2<u32>(2,0),\r\n  vec2<u32>(2,1),\r\n  vec2<u32>(0,2),\r\n  vec2<u32>(1,2),\r\n  vec2<u32>(2,2)\r\n);\r\n\r\n@compute @workgroup_size(64, 1, 1)\r\nfn bufferMarch(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n) {\r\n  let bufferIndex = GlobalInvocationID.x / 8;\r\n  let localRayIndex = GlobalInvocationID.x % 8;\r\n  let pixel = screenRayBuffer[bufferIndex];\r\n  let offsetPixel = pixel + REMAINING_RAY_OFFSETS[localRayIndex];\r\n\r\n  tracePixel(offsetPixel);\r\n//  textureStore(depthWrite, offsetPixel, vec4(0,0,0,0));\r\n//   textureStore(albedoTex, offsetPixel, vec4(1,0,0,1));\r\n}`}),entryPoint:"main"}});let h;return(e,t)=>{h=(e=>Ms.createBindGroup({layout:c,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:1,resource:{buffer:e.timeBuffer}},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.worldPositionTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:9,resource:e.blueNoiseTextureView},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),e.setPipeline(u),e.setBindGroup(0,h),e.dispatchWorkgroups(Math.ceil(Cs[0]/16),Math.ceil(Cs[1]/8))}})();let t,n,r,i={albedoTexture:null,velocityTexture:null,depthTexture:null,normalTexture:null};return{render:s=>{if(!n){n=Ms.createBuffer({size:12,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),t=Ms.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const e=new Uint32Array(3);e[0]=1,e[1]=1,e[2]=1,Ms.queue.writeBuffer(n,0,e,0,e.length);const{width:i,height:a}=s.outputTextures.finalTexture,l=(o=i/3*(a/3)*4,4,4*Math.ceil(o/4));r=Ms.createBuffer({size:l,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}var o;Object.keys(i).forEach((e=>{const t=s.outputTextures[e];null===i[e]&&(i[e]=((e,t)=>new(nt(`${t.label}-copy`,t.format,t.usage))(e,t.width,t.height))(Ms,t))}));const{commandEncoder:a,timestampWrites:l}=s;a.clearBuffer(n,0,4),a.clearBuffer(t,0,4),a.clearBuffer(r);let c=a.beginComputePass({timestampWrites:l});e(c,s),c.end()},label:"primary rays",timestampLabels:["full raymarch"]}};class ut{constructor(e,t,n,r,i="div"){this.parent=e,this.object=t,this.property=n,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(i),this.domElement.classList.add("controller"),this.domElement.classList.add(r),this.$name=document.createElement("div"),this.$name.classList.add("name"),ut.nextNameID=ut.nextNameID||0,this.$name.id="lil-gui-name-"+ ++ut.nextNameID,this.$widget=document.createElement("div"),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.domElement.addEventListener("keydown",(e=>e.stopPropagation())),this.domElement.addEventListener("keyup",(e=>e.stopPropagation())),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(n)}name(e){return this._name=e,this.$name.textContent=e,this}onChange(e){return this._onChange=e,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(e=!0){return this.disable(!e)}disable(e=!0){return e===this._disabled||(this._disabled=e,this.domElement.classList.toggle("disabled",e),this.$disable.toggleAttribute("disabled",e)),this}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(e){const t=this.parent.add(this.object,this.property,e);return t.name(this._name),this.destroy(),t}min(e){return this}max(e){return this}step(e){return this}decimals(e){return this}listen(e=!0){return this._listening=e,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const e=this.save();e!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=e}getValue(){return this.object[this.property]}setValue(e){return this.getValue()!==e&&(this.object[this.property]=e,this._callOnChange(),this.updateDisplay()),this}updateDisplay(){return this}load(e){return this.setValue(e),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class ht extends ut{constructor(e,t,n){super(e,t,n,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",(()=>{this.setValue(this.$input.checked),this._callOnFinishChange()})),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function dt(e){let t,n;return(t=e.match(/(#|0x)?([a-f0-9]{6})/i))?n=t[2]:(t=e.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?n=parseInt(t[1]).toString(16).padStart(2,0)+parseInt(t[2]).toString(16).padStart(2,0)+parseInt(t[3]).toString(16).padStart(2,0):(t=e.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(n=t[1]+t[1]+t[2]+t[2]+t[3]+t[3]),!!n&&"#"+n}const pt={isPrimitive:!0,match:e=>"number"==typeof e,fromHexString:e=>parseInt(e.substring(1),16),toHexString:e=>"#"+e.toString(16).padStart(6,0)},ft={isPrimitive:!1,match:e=>Array.isArray(e),fromHexString(e,t,n=1){const r=pt.fromHexString(e);t[0]=(r>>16&255)/255*n,t[1]=(r>>8&255)/255*n,t[2]=(255&r)/255*n},toHexString:([e,t,n],r=1)=>pt.toHexString(e*(r=255/r)<<16^t*r<<8^n*r<<0)},mt={isPrimitive:!1,match:e=>Object(e)===e,fromHexString(e,t,n=1){const r=pt.fromHexString(e);t.r=(r>>16&255)/255*n,t.g=(r>>8&255)/255*n,t.b=(255&r)/255*n},toHexString:({r:e,g:t,b:n},r=1)=>pt.toHexString(e*(r=255/r)<<16^t*r<<8^n*r<<0)},gt=[{isPrimitive:!0,match:e=>"string"==typeof e,fromHexString:dt,toHexString:dt},pt,ft,mt];class vt extends ut{constructor(e,t,n,r){var i;super(e,t,n,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(i=this.initialValue,gt.find((e=>e.match(i)))),this._rgbScale=r,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",(()=>{this._setValueFromHexString(this.$input.value)})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$text.addEventListener("input",(()=>{const e=dt(this.$text.value);e&&this._setValueFromHexString(e)})),this.$text.addEventListener("focus",(()=>{this._textFocused=!0,this.$text.select()})),this.$text.addEventListener("blur",(()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()})),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(e){if(this._format.isPrimitive){const t=this._format.fromHexString(e);this.setValue(t)}else this._format.fromHexString(e,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(e){return this._setValueFromHexString(e),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class yt extends ut{constructor(e,t,n){super(e,t,n,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",(e=>{e.preventDefault(),this.getValue().call(this.object),this._callOnChange()})),this.$button.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$disable=this.$button}}class xt extends ut{constructor(e,t,n,r,i,s){super(e,t,n,"number"),this._initInput(),this.min(r),this.max(i);const o=void 0!==s;this.step(o?s:this._getImplicitStep(),o),this.updateDisplay()}decimals(e){return this._decimals=e,this.updateDisplay(),this}min(e){return this._min=e,this._onUpdateMinMax(),this}max(e){return this._max=e,this._onUpdateMinMax(),this}step(e,t=!0){return this._step=e,this._stepExplicit=t,this}updateDisplay(){const e=this.getValue();if(this._hasSlider){let t=(e-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=100*t+"%"}return this._inputFocused||(this.$input.value=void 0===this._decimals?e:e.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),window.matchMedia("(pointer: coarse)").matches&&(this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any")),this.$widget.appendChild(this.$input),this.$disable=this.$input;const e=e=>{const t=parseFloat(this.$input.value);isNaN(t)||(this._snapClampSetValue(t+e),this.$input.value=this.getValue())};let t,n,r,i,s,o=!1;const a=e=>{if(o){const r=e.clientX-t,i=e.clientY-n;Math.abs(i)>5?(e.preventDefault(),this.$input.blur(),o=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(r)>5&&l()}if(!o){const t=e.clientY-r;s-=t*this._step*this._arrowKeyMultiplier(e),i+s>this._max?s=this._max-i:i+s<this._min&&(s=this._min-i),this._snapClampSetValue(i+s)}r=e.clientY},l=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",a),window.removeEventListener("mouseup",l)};this.$input.addEventListener("input",(()=>{let e=parseFloat(this.$input.value);isNaN(e)||(this._stepExplicit&&(e=this._snap(e)),this.setValue(this._clamp(e)))})),this.$input.addEventListener("keydown",(t=>{"Enter"===t.key&&this.$input.blur(),"ArrowUp"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t))),"ArrowDown"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t)*-1))})),this.$input.addEventListener("wheel",(t=>{this._inputFocused&&(t.preventDefault(),e(this._step*this._normalizeMouseWheel(t)))}),{passive:!1}),this.$input.addEventListener("mousedown",(e=>{t=e.clientX,n=r=e.clientY,o=!0,i=this.getValue(),s=0,window.addEventListener("mousemove",a),window.addEventListener("mouseup",l)})),this.$input.addEventListener("focus",(()=>{this._inputFocused=!0})),this.$input.addEventListener("blur",(()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()}))}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const e=e=>{const t=this.$slider.getBoundingClientRect();let n=((e,t,n,r,i)=>(e-t)/(n-t)*(this._max-r)+r)(e,t.left,t.right,this._min);this._snapClampSetValue(n)},t=t=>{e(t.clientX)},n=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",t),window.removeEventListener("mouseup",n)};let r,i,s=!1;const o=t=>{t.preventDefault(),this._setDraggingStyle(!0),e(t.touches[0].clientX),s=!1},a=t=>{if(s){const e=t.touches[0].clientX-r,n=t.touches[0].clientY-i;Math.abs(e)>Math.abs(n)?o(t):(window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l))}else t.preventDefault(),e(t.touches[0].clientX)},l=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l)},c=this._callOnFinishChange.bind(this);let u;this.$slider.addEventListener("mousedown",(r=>{this._setDraggingStyle(!0),e(r.clientX),window.addEventListener("mousemove",t),window.addEventListener("mouseup",n)})),this.$slider.addEventListener("touchstart",(e=>{e.touches.length>1||(this._hasScrollBar?(r=e.touches[0].clientX,i=e.touches[0].clientY,s=!0):o(e),window.addEventListener("touchmove",a,{passive:!1}),window.addEventListener("touchend",l))}),{passive:!1}),this.$slider.addEventListener("wheel",(e=>{if(Math.abs(e.deltaX)<Math.abs(e.deltaY)&&this._hasScrollBar)return;e.preventDefault();const t=this._normalizeMouseWheel(e)*this._step;this._snapClampSetValue(this.getValue()+t),this.$input.value=this.getValue(),clearTimeout(u),u=setTimeout(c,400)}),{passive:!1})}_setDraggingStyle(e,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",e),document.body.classList.toggle("lil-gui-dragging",e),document.body.classList.toggle(`lil-gui-${t}`,e)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(e){let{deltaX:t,deltaY:n}=e;return Math.floor(e.deltaY)!==e.deltaY&&e.wheelDelta&&(t=0,n=-e.wheelDelta/120,n*=this._stepExplicit?1:10),t+-n}_arrowKeyMultiplier(e){let t=this._stepExplicit?1:10;return e.shiftKey?t*=10:e.altKey&&(t/=10),t}_snap(e){const t=Math.round(e/this._step)*this._step;return parseFloat(t.toPrecision(15))}_clamp(e){return e<this._min&&(e=this._min),e>this._max&&(e=this._max),e}_snapClampSetValue(e){this.setValue(this._clamp(this._snap(e)))}get _hasScrollBar(){const e=this.parent.root.$children;return e.scrollHeight>e.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class wt extends ut{constructor(e,t,n,r){super(e,t,n,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$select.addEventListener("change",(()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()})),this.$select.addEventListener("focus",(()=>{this.$display.classList.add("focus")})),this.$select.addEventListener("blur",(()=>{this.$display.classList.remove("focus")})),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.options(r)}options(e){return this._values=Array.isArray(e)?e:Object.values(e),this._names=Array.isArray(e)?e:Object.keys(e),this.$select.replaceChildren(),this._names.forEach((e=>{const t=document.createElement("option");t.textContent=e,this.$select.appendChild(t)})),this.updateDisplay(),this}updateDisplay(){const e=this.getValue(),t=this._values.indexOf(e);return this.$select.selectedIndex=t,this.$display.textContent=-1===t?e:this._names[t],this}}class bt extends ut{constructor(e,t,n){super(e,t,n,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("spellcheck","false"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",(()=>{this.setValue(this.$input.value)})),this.$input.addEventListener("keydown",(e=>{"Enter"===e.code&&this.$input.blur()})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let _t=!1;class kt{constructor({parent:e,autoPlace:t=void 0===e,container:n,width:r,title:i="Controls",closeFolders:s=!1,injectStyles:o=!0,touchStyles:a=!0}={}){if(this.parent=e,this.root=e?e.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",(()=>this.openAnimated(this._closed))),this.$title.addEventListener("keydown",(e=>{"Enter"!==e.code&&"Space"!==e.code||(e.preventDefault(),this.$title.click())})),this.$title.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(i),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add("root"),a&&this.domElement.classList.add("allow-touch-styles"),!_t&&o&&(function(e){const t=document.createElement("style");t.innerHTML='.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;\n  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n  background: var(--background-color);\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller > .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: " ";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: "lil-gui";\n  content: "↕";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-dragging .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-dragging * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui-dragging.lil-gui-vertical * {\n  cursor: ns-resize !important;\n}\n\n.lil-gui .title {\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: "lil-gui";\n  content: "▾";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  body:not(.lil-gui-dragging) .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: "▸";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: "Empty";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui label, .lil-gui input, .lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n}\n.lil-gui input {\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input:disabled {\n  opacity: 1;\n}\n.lil-gui input[type=text],\n.lil-gui input[type=number] {\n  padding: var(--widget-padding);\n  -moz-appearance: textfield;\n}\n.lil-gui input[type=text]:focus,\n.lil-gui input[type=number]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  width: var(--checkbox-size);\n  height: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n  cursor: pointer;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: "lil-gui";\n  content: "✓";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: none;\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: "lil-gui";\n  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");\n}';const n=document.querySelector("head link[rel=stylesheet], head style");n?document.head.insertBefore(t,n):document.head.appendChild(t)}(),_t=!0),n?n.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),r&&this.domElement.style.setProperty("--width",r+"px"),this._closeFolders=s}add(e,t,n,r,i){if(Object(n)===n)return new wt(this,e,t,n);const s=e[t];switch(typeof s){case"number":return new xt(this,e,t,n,r,i);case"boolean":return new ht(this,e,t);case"string":return new bt(this,e,t);case"function":return new yt(this,e,t)}console.error("gui.add failed\n\tproperty:",t,"\n\tobject:",e,"\n\tvalue:",s)}addColor(e,t,n=1){return new vt(this,e,t,n)}addFolder(e){const t=new kt({parent:this,title:e});return this.root._closeFolders&&t.close(),t}load(e,t=!0){return e.controllers&&this.controllers.forEach((t=>{t instanceof yt||t._name in e.controllers&&t.load(e.controllers[t._name])})),t&&e.folders&&this.folders.forEach((t=>{t._title in e.folders&&t.load(e.folders[t._title])})),this}save(e=!0){const t={controllers:{},folders:{}};return this.controllers.forEach((e=>{if(!(e instanceof yt)){if(e._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${e._name}"`);t.controllers[e._name]=e.save()}})),e&&this.folders.forEach((e=>{if(e._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${e._title}"`);t.folders[e._title]=e.save()})),t}open(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(e){this._closed!==e&&(this._closed=e,this._callOnOpenClose(this))}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame((()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const n=e=>{e.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",n))};this.$children.addEventListener("transitionend",n);const r=e?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!e),requestAnimationFrame((()=>{this.$children.style.height=r+"px"}))})),this}title(e){return this._title=e,this.$title.textContent=e,this}reset(e=!0){return(e?this.controllersRecursive():this.controllers).forEach((e=>e.reset())),this}onChange(e){return this._onChange=e,this}_callOnChange(e){this.parent&&this.parent._callOnChange(e),void 0!==this._onChange&&this._onChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(e){this.parent&&this.parent._callOnFinishChange(e),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onOpenClose(e){return this._onOpenClose=e,this}_callOnOpenClose(e){this.parent&&this.parent._callOnOpenClose(e),void 0!==this._onOpenClose&&this._onOpenClose.call(this,e)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach((e=>e.destroy()))}controllersRecursive(){let e=Array.from(this.controllers);return this.folders.forEach((t=>{e=e.concat(t.controllersRecursive())})),e}foldersRecursive(){let e=Array.from(this.folders);return this.folders.forEach((t=>{e=e.concat(t.foldersRecursive())})),e}}const St=kt,At=async e=>{const t=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n//@group(0) @binding(2) var debugTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\nfn get_debug_colour(index : i32) -> vec4<f32> {\r\n  if(index < 0){\r\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\r\n  }\r\n\r\n  let colours = array(\r\n    vec4<f32>(1.0, 0.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(1.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\r\n  );\r\n  return colours[index % 8];\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n    let pixel = fragUV * vec2<f32>(textureDimensions(myTexture));\r\n    var colour = textureLoad(myTexture, vec2<u32>(pixel),0);\r\n    return colour;\r\n//    return colour;\r\n//    return abs(colour) % 8.0 * 0.125;\r\n//    return colour.gggg * 0.5;\r\n//    return (colour.rrrr * 500.0 % 1.0);\r\n//    return get_debug_colour(i32(colour.a));\r\n}\r\n"}),n=e.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vertex_main"},fragment:{module:t,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]}});return{render:t=>{const r=t.commandEncoder.beginRenderPass({timestampWrites:t.timestampWrites,colorAttachments:[{view:Es.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]}),i=e.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:1,resource:t.outputTextures.finalTexture.view}]});r.setPipeline(n),r.setBindGroup(0,i),r.draw(6),r.end()},label:"fullscreen quad"}};var Et;!function(e){const t=[];e.updateAll=e=>{for(const n of t)n.update(e)},e.register=e=>class extends e{constructor(...e){super(...e),t.push(this)}}}(Et||(Et={}));const Tt={duration:.3,delay:0,endDelay:0,repeat:0,easing:"ease"},Pt=e=>1e3*e,Mt=e=>e/1e3,Ct=()=>{},zt=e=>e;function It(e,t=!0){if(e&&"finished"!==e.playState)try{e.stop?e.stop():(t&&e.commitStyles(),e.cancel())}catch(e){}}const Bt=e=>e(),Ot=(e,t,n=Tt.duration)=>new Proxy({animations:e.map(Bt).filter(Boolean),duration:n,options:t},Nt),Nt={get:(e,t)=>{const n=e.animations[0];switch(t){case"duration":return e.duration;case"currentTime":return Mt((null==n?void 0:n[t])||0);case"playbackRate":case"playState":return null==n?void 0:n[t];case"finished":return e.finished||(e.finished=Promise.all(e.animations.map(Ut)).catch(Ct)),e.finished;case"stop":return()=>{e.animations.forEach((e=>It(e)))};case"forEachNative":return t=>{e.animations.forEach((n=>t(n,e)))};default:return void 0===(null==n?void 0:n[t])?void 0:()=>e.animations.forEach((e=>e[t]()))}},set:(e,t,n)=>{switch(t){case"currentTime":n=Pt(n);case"playbackRate":for(let r=0;r<e.animations.length;r++)e.animations[r][t]=n;return!0}return!1}},Ut=e=>e.finished,Rt=e=>"object"==typeof e&&Boolean(e.createAnimation),Dt=e=>"number"==typeof e,Ft=e=>Array.isArray(e)&&!Dt(e[0]),Lt=(e,t,n)=>-n*e+n*t+e,qt=(e,t,n)=>t-e==0?1:(n-e)/(t-e);function jt(e,t){const n=e[e.length-1];for(let r=1;r<=t;r++){const i=qt(0,t,r);e.push(Lt(n,1,i))}}const Vt=(e,t,n)=>Math.min(Math.max(n,e),t);const Gt=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e,$t=1e-7,Wt=12;function Ht(e,t,n,r){if(e===t&&n===r)return zt;return i=>0===i||1===i?i:Gt(function(e,t,n,r,i){let s,o,a=0;do{o=t+(n-t)/2,s=Gt(o,r,i)-e,s>0?n=o:t=o}while(Math.abs(s)>$t&&++a<Wt);return o}(i,0,1,e,n),t,r)}const Yt=e=>"function"==typeof e,Xt=e=>Array.isArray(e)&&Dt(e[0]),Zt={ease:Ht(.25,.1,.25,1),"ease-in":Ht(.42,0,1,1),"ease-in-out":Ht(.42,0,.58,1),"ease-out":Ht(0,0,.58,1)},Kt=/\((.*?)\)/;function Qt(e){if(Yt(e))return e;if(Xt(e))return Ht(...e);if(Zt[e])return Zt[e];if(e.startsWith("steps")){const t=Kt.exec(e);if(t){const e=t[1].split(",");return((e,t="end")=>n=>{const r=(n="end"===t?Math.min(n,.999):Math.max(n,.001))*e,i="end"===t?Math.floor(r):Math.ceil(r);return Vt(0,1,i/e)})(parseFloat(e[0]),e[1].trim())}}return zt}class Jt{constructor(e,t=[0,1],{easing:n,duration:r=Tt.duration,delay:i=Tt.delay,endDelay:s=Tt.endDelay,repeat:o=Tt.repeat,offset:a,direction:l="normal",autoplay:c=!0}={}){if(this.startTime=null,this.rate=1,this.t=0,this.cancelTimestamp=null,this.easing=zt,this.duration=0,this.totalDuration=0,this.repeat=0,this.playState="idle",this.finished=new Promise(((e,t)=>{this.resolve=e,this.reject=t})),n=n||Tt.easing,Rt(n)){const e=n.createAnimation(t);n=e.easing,t=e.keyframes||t,r=e.duration||r}this.repeat=o,this.easing=Ft(n)?zt:Qt(n),this.updateDuration(r);const u=function(e,t=function(e){const t=[0];return jt(t,e-1),t}(e.length),n=zt){const r=e.length,i=r-t.length;return i>0&&jt(t,i),i=>{let s=0;for(;s<r-2&&!(i<t[s+1]);s++);let o=Vt(0,1,qt(t[s],t[s+1],i));const a=function(e,t){return Ft(e)?e[((e,t,n)=>{const r=t-e;return((n-e)%r+r)%r+e})(0,e.length,t)]:e}(n,s);return o=a(o),Lt(e[s],e[s+1],o)}}(t,a,Ft(n)?n.map(Qt):zt);this.tick=t=>{var n;let r=0;r=void 0!==this.pauseTime?this.pauseTime:(t-this.startTime)*this.rate,this.t=r,r/=1e3,r=Math.max(r-i,0),"finished"===this.playState&&void 0===this.pauseTime&&(r=this.totalDuration);const o=r/this.duration;let a=Math.floor(o),c=o%1;!c&&o>=1&&(c=1),1===c&&a--;const h=a%2;("reverse"===l||"alternate"===l&&h||"alternate-reverse"===l&&!h)&&(c=1-c);const d=r>=this.totalDuration?1:Math.min(c,1),p=u(this.easing(d));e(p),void 0===this.pauseTime&&("finished"===this.playState||r>=this.totalDuration+s)?(this.playState="finished",null===(n=this.resolve)||void 0===n||n.call(this,p)):"idle"!==this.playState&&(this.frameRequestId=requestAnimationFrame(this.tick))},c&&this.play()}play(){const e=performance.now();this.playState="running",void 0!==this.pauseTime?this.startTime=e-this.pauseTime:this.startTime||(this.startTime=e),this.cancelTimestamp=this.startTime,this.pauseTime=void 0,this.frameRequestId=requestAnimationFrame(this.tick)}pause(){this.playState="paused",this.pauseTime=this.t}finish(){this.playState="finished",this.tick(0)}stop(){var e;this.playState="idle",void 0!==this.frameRequestId&&cancelAnimationFrame(this.frameRequestId),null===(e=this.reject)||void 0===e||e.call(this,!1)}cancel(){this.stop(),this.tick(this.cancelTimestamp)}reverse(){this.rate*=-1}commitStyles(){}updateDuration(e){this.duration=e,this.totalDuration=e*(this.repeat+1)}get currentTime(){return this.t}set currentTime(e){void 0!==this.pauseTime||0===this.rate?this.pauseTime=e:this.startTime=performance.now()-e/this.rate}get playbackRate(){return this.rate}set playbackRate(e){this.rate=e}}class en{setAnimation(e){this.animation=e,null==e||e.finished.then((()=>this.clearAnimation())).catch((()=>{}))}clearAnimation(){this.animation=this.generator=void 0}}const tn=new WeakMap;function nn(e){return tn.has(e)||tn.set(e,{transforms:[],values:new Map}),tn.get(e)}const rn=["","X","Y","Z"],sn={x:"translateX",y:"translateY",z:"translateZ"},on={syntax:"<angle>",initialValue:"0deg",toDefaultUnit:e=>e+"deg"},an={translate:{syntax:"<length-percentage>",initialValue:"0px",toDefaultUnit:e=>e+"px"},rotate:on,scale:{syntax:"<number>",initialValue:1,toDefaultUnit:zt},skew:on},ln=new Map,cn=e=>`--motion-${e}`,un=["x","y","z"];["translate","scale","rotate","skew"].forEach((e=>{rn.forEach((t=>{un.push(e+t),ln.set(cn(e+t),an[e])}))}));const hn=(e,t)=>un.indexOf(e)-un.indexOf(t),dn=new Set(un),pn=e=>dn.has(e),fn=e=>e.sort(hn).reduce(mn,"").trim(),mn=(e,t)=>`${e} ${t}(var(${cn(t)}))`,gn=e=>e.startsWith("--"),vn=new Set,yn=(e,t)=>document.createElement("div").animate(e,t),xn={cssRegisterProperty:()=>"undefined"!=typeof CSS&&Object.hasOwnProperty.call(CSS,"registerProperty"),waapi:()=>Object.hasOwnProperty.call(Element.prototype,"animate"),partialKeyframes:()=>{try{yn({opacity:[1]})}catch(e){return!1}return!0},finished:()=>Boolean(yn({opacity:[0,1]},{duration:.001}).finished),linearEasing:()=>{try{yn({opacity:0},{easing:"linear(0, 1)"})}catch(e){return!1}return!0}},wn={},bn={};for(const e in xn)bn[e]=()=>(void 0===wn[e]&&(wn[e]=xn[e]()),wn[e]);const _n=(e,t)=>Yt(e)?bn.linearEasing()?`linear(${((e,t)=>{let n="";const r=Math.round(t/.015);for(let t=0;t<r;t++)n+=e(qt(0,r-1,t))+", ";return n.substring(0,n.length-2)})(e,t)})`:Tt.easing:Xt(e)?kn(e):e,kn=([e,t,n,r])=>`cubic-bezier(${e}, ${t}, ${n}, ${r})`;function Sn(e){return sn[e]&&(e=sn[e]),pn(e)?cn(e):e}const An=(e,t)=>{t=Sn(t);let n=gn(t)?e.style.getPropertyValue(t):getComputedStyle(e)[t];if(!n&&0!==n){const e=ln.get(t);e&&(n=e.initialValue)}return n},En=(e,t,n)=>{t=Sn(t),gn(t)?e.style.setProperty(t,n):e.style[t]=n},Tn=e=>"string"==typeof e;function Pn(e,t){var n;let r=(null==t?void 0:t.toDefaultUnit)||zt;const i=e[e.length-1];if(Tn(i)){const e=(null===(n=i.match(/(-?[\d.]+)([a-z%]*)/))||void 0===n?void 0:n[2])||"";e&&(r=t=>t+e)}return r}function Mn(e,t,n,r={},i){const s=window.__MOTION_DEV_TOOLS_RECORD,o=!1!==r.record&&s;let a,{duration:l=Tt.duration,delay:c=Tt.delay,endDelay:u=Tt.endDelay,repeat:h=Tt.repeat,easing:d=Tt.easing,persist:p=!1,direction:f,offset:m,allowWebkitAcceleration:g=!1,autoplay:v=!0}=r;const y=nn(e),x=pn(t);let w=bn.waapi();x&&((e,t)=>{sn[t]&&(t=sn[t]);const{transforms:n}=nn(e);var r,i;i=t,-1===(r=n).indexOf(i)&&r.push(i),e.style.transform=fn(n)})(e,t);const b=Sn(t),_=function(e,t){return e.has(t)||e.set(t,new en),e.get(t)}(y.values,b),k=ln.get(b);return It(_.animation,!(Rt(d)&&_.generator)&&!1!==r.record),()=>{const y=()=>{var t,n;return null!==(n=null!==(t=An(e,b))&&void 0!==t?t:null==k?void 0:k.initialValue)&&void 0!==n?n:0};let S=function(e,t){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=n?e[n-1]:t());return e}((e=>Array.isArray(e)?e:[e])(n),y);const A=Pn(S,k);if(Rt(d)){const e=d.createAnimation(S,"opacity"!==t,y,b,_);d=e.easing,S=e.keyframes||S,l=e.duration||l}if(gn(b)&&(bn.cssRegisterProperty()?function(e){if(!vn.has(e)){vn.add(e);try{const{syntax:t,initialValue:n}=ln.has(e)?ln.get(e):{};CSS.registerProperty({name:e,inherits:!1,syntax:t,initialValue:n})}catch(e){}}}(b):w=!1),x&&!bn.linearEasing()&&(Yt(d)||Ft(d)&&d.some(Yt))&&(w=!1),w){k&&(S=S.map((e=>Dt(e)?k.toDefaultUnit(e):e))),1!==S.length||bn.partialKeyframes()&&!o||S.unshift(y());const t={delay:Pt(c),duration:Pt(l),endDelay:Pt(u),easing:Ft(d)?void 0:_n(d,l),direction:f,iterations:h+1,fill:"both"};a=e.animate({[b]:S,offset:m,easing:Ft(d)?d.map((e=>_n(e,l))):void 0},t),a.finished||(a.finished=new Promise(((e,t)=>{a.onfinish=e,a.oncancel=t})));const n=S[S.length-1];a.finished.then((()=>{p||(En(e,b,n),a.cancel())})).catch(Ct),g||(a.playbackRate=1.000001)}else if(i&&x)S=S.map((e=>"string"==typeof e?parseFloat(e):e)),1===S.length&&S.unshift(parseFloat(y())),a=new i((t=>{En(e,b,A?A(t):t)}),S,Object.assign(Object.assign({},r),{duration:l,easing:d}));else{const t=S[S.length-1];En(e,b,k&&Dt(t)?k.toDefaultUnit(t):t)}return o&&s(e,t,S,{duration:l,delay:c,easing:d,repeat:h,offset:m},"motion-one"),_.setAnimation(a),a&&!v&&a.pause(),a}}const Cn=(e,t)=>e[t]?Object.assign(Object.assign({},e),e[t]):Object.assign({},e);function zn(e,t,n){return Yt(e)?e(t,n):e}const In=(Bn=Jt,function(e,t,n={}){const r=(e=function(e,t){return"string"==typeof e?e=document.querySelectorAll(e):e instanceof Element&&(e=[e]),Array.from(e||[])}(e)).length;Boolean(r),Boolean(t);const i=[];for(let s=0;s<r;s++){const o=e[s];for(const e in t){const a=Cn(n,e);a.delay=zn(a.delay,s,r);const l=Mn(o,e,t[e],a,Bn);i.push(l)}}return Ot(i,n,n.duration)});var Bn;function On(e,t={}){return Ot([()=>{const n=new Jt(e,[0,1],t);return n.finished.catch((()=>{})),n}],t,t.duration)}function Nn(e,t,n){return(Yt(e)?On:In)(e,t,n)}function Un(e,t,n){const r=Math.max(t-5,0);return i=n-e(r),(s=t-r)?i*(1e3/s):0;var i,s}function Rn(e){return Dt(e)&&!isNaN(e)}function Dn(e){return Tn(e)?parseFloat(e):e}const Fn=function(e){const t=new WeakMap;return(e={})=>{const n=new Map,r=(t=0,r=100,i=0,s=!1)=>{const o=`${t}-${r}-${i}-${s}`;return n.has(o)||n.set(o,(({from:e=0,velocity:t=0,power:n=.8,decay:r=.325,bounceDamping:i,bounceStiffness:s,changeTarget:o,min:a,max:l,restDistance:c=.5,restSpeed:u})=>{r=Pt(r);const h={hasReachedTarget:!1,done:!1,current:e,target:e},d=e=>void 0===a?l:void 0===l||Math.abs(a-e)<Math.abs(l-e)?a:l;let p=n*t;const f=e+p,m=void 0===o?f:o(f);h.target=m,m!==f&&(p=m-e);const g=e=>-p*Math.exp(-e/r),v=e=>m+g(e),y=e=>{const t=g(e),n=v(e);h.done=Math.abs(t)<=c,h.current=h.done?m:n};let x,w;const b=e=>{var t;t=h.current,(void 0!==a&&t<a||void 0!==l&&t>l)&&(x=e,w=(({stiffness:e=100,damping:t=10,mass:n=1,from:r=0,to:i=1,velocity:s=0,restSpeed:o,restDistance:a}={})=>{s=s?Mt(s):0;const l={done:!1,hasReachedTarget:!1,current:r,target:i},c=i-r,u=Math.sqrt(e/n)/1e3,h=((e=100,t=10,n=1)=>t/(2*Math.sqrt(e*n)))(e,t,n),d=Math.abs(c)<5;let p;if(o||(o=d?.01:2),a||(a=d?.005:.5),h<1){const e=u*Math.sqrt(1-h*h);p=t=>i-Math.exp(-h*u*t)*((h*u*c-s)/e*Math.sin(e*t)+c*Math.cos(e*t))}else p=e=>i-Math.exp(-u*e)*(c+(u*c-s)*e);return e=>{l.current=p(e);const t=0===e?s:Un(p,e,l.current),n=Math.abs(t)<=o,c=Math.abs(i-l.current)<=a;var u,h,d;return l.done=n&&c,l.hasReachedTarget=(u=r,h=i,d=l.current,u<h&&d>=h||u>h&&d<=h),l}})({from:h.current,to:d(h.current),velocity:Un(v,e,h.current),damping:i,stiffness:s,restDistance:c,restSpeed:u}))};return b(0),e=>{let t=!1;return w||void 0!==x||(t=!0,y(e),b(e)),void 0!==x&&e>x?(h.hasReachedTarget=!0,w(e-x)):(h.hasReachedTarget=!1,!t&&y(e),h)}})(Object.assign({from:t,to:r,velocity:i},e))),n.get(o)},i=(e,n)=>(t.has(e)||t.set(e,function(e,t=zt){let n,r=10,i=e(0);const s=[t(i.current)];for(;!i.done&&r<1e4;)i=e(r),s.push(t(i.done?i.target:i.current)),void 0===n&&i.hasReachedTarget&&(n=r),r+=10;const o=r-10;return 1===s.length&&s.push(i.current),{keyframes:s,duration:o/1e3,overshootDuration:(null!=n?n:o)/1e3}}(e,n)),t.get(e));return{createAnimation:(e,t=!0,n,s,o)=>{let a,l,c,u=0,h=zt;const d=e.length;if(t)if(h=Pn(e,s?ln.get(Sn(s)):void 0),c=Dn(e[d-1]),d>1&&null!==e[0])l=Dn(e[0]);else{const e=null==o?void 0:o.generator;if(e){const{animation:t,generatorStartTime:n}=o,r=(null==t?void 0:t.startTime)||n||0,i=(null==t?void 0:t.currentTime)||performance.now()-r,s=e(i).current;l=s,u=Un((t=>e(t).current),i,s)}else n&&(l=Dn(n()))}if(Rn(l)&&Rn(c)){const e=r(l,c,u,null==s?void 0:s.includes("scale"));a=Object.assign(Object.assign({},i(e,h)),{easing:"linear"}),o&&(o.generator=e,o.generatorStartTime=performance.now())}return a||(a={easing:"ease",duration:i(r(0,100)).overshootDuration}),a}}}}();var Ln=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};let qn=class{value;target;constructor(e){this.value=e,this.target=e}update(){Nn((e=>{this.value=te.lerp(this.value,this.target,e)}),{easing:Fn({velocity:2e-4*Bs})})}};qn=Ln([Et.register],qn);let jn=class{value;target;constructor(e){this.value=e,this.target=e}update(){Nn((e=>{this.value=this.value+(this.target-this.value)*e}),{easing:Fn({velocity:2e-4*Bs})})}};jn=Ln([Et.register],jn);let Vn=class{value;target;constructor(e){this.value=e,this.target=e}update(){Nn((e=>{this.value=je.slerp(this.value,this.target,e)}),{easing:Fn({velocity:2e-4*Bs})})}};Vn=Ln([Et.register],Vn);const Gn=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength,$n={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array},bool:{numElements:0,align:1,size:0,type:"bool",View:Uint32Array}},Wn={...$n,"atomic<i32>":$n.i32,"atomic<u32>":$n.u32,"vec2<i32>":$n.vec2i,"vec2<u32>":$n.vec2u,"vec2<f32>":$n.vec2f,"vec2<f16>":$n.vec2h,"vec3<i32>":$n.vec3i,"vec3<u32>":$n.vec3u,"vec3<f32>":$n.vec3f,"vec3<f16>":$n.vec3h,"vec4<i32>":$n.vec4i,"vec4<u32>":$n.vec4u,"vec4<f32>":$n.vec4f,"vec4<f16>":$n.vec4h,"mat2x2<f32>":$n.mat2x2f,"mat2x2<f16>":$n.mat2x2h,"mat3x2<f32>":$n.mat3x2f,"mat3x2<f16>":$n.mat3x2h,"mat4x2<f32>":$n.mat4x2f,"mat4x2<f16>":$n.mat4x2h,"mat2x3<f32>":$n.mat2x3f,"mat2x3<f16>":$n.mat2x3h,"mat3x3<f32>":$n.mat3x3f,"mat3x3<f16>":$n.mat3x3h,"mat4x3<f32>":$n.mat4x3f,"mat4x3<f16>":$n.mat4x3h,"mat2x4<f32>":$n.mat2x4f,"mat2x4<f16>":$n.mat2x4h,"mat3x4<f32>":$n.mat3x4f,"mat3x4<f16>":$n.mat3x4h,"mat4x4<f32>":$n.mat4x4f,"mat4x4<f16>":$n.mat4x4h},Hn=(Yn=Wn,Object.keys(Yn));var Yn,Xn,Zn,Kn,Qn,Jn;!function(e=[],t){const n=new Set;for(const r of Hn){const i=Wn[r];n.has(i)||(n.add(i),i.flatten=e.includes(r)?t:!t)}}(),new WeakMap;class er{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class tr{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(nr.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(rr.instance)}}}class nr extends tr{}nr.instance=new nr;class rr extends tr{}rr.instance=new rr;class ir extends tr{constructor(){super()}}class sr extends ir{constructor(e,t,n,r){super(),this.name=e,this.args=t,this.returnType=n,this.body=r}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}}class or extends ir{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class ar extends ir{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class lr extends ir{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class cr extends ir{constructor(e,t,n,r){super(),this.init=e,this.condition=t,this.increment=n,this.body=r}get astNodeType(){return"for"}search(e){var t,n,r;null===(t=this.init)||void 0===t||t.search(e),null===(n=this.condition)||void 0===n||n.search(e),null===(r=this.increment)||void 0===r||r.search(e),this.searchBlock(this.body,e)}}class ur extends ir{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class hr extends ir{constructor(e,t,n){super(),this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class dr extends ir{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"let"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class pr extends ir{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}!function(e){e.increment="++",e.decrement="--"}(Xn||(Xn={})),function(e){e.parse=function(t){const n=t;if("parse"==n)throw new Error("Invalid value for IncrementOperator");return e[n]}}(Xn||(Xn={}));class fr extends ir{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(Zn||(Zn={})),function(e){e.parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t}}(Zn||(Zn={}));class mr extends ir{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.value.search(e)}}class gr extends ir{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}}class vr extends ir{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class yr extends ir{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class xr extends ir{constructor(e,t,n,r){super(),this.condition=e,this.body=t,this.elseif=n,this.else=r}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class wr extends ir{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class br extends ir{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class _r extends ir{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class kr extends ir{constructor(){super()}get astNodeType(){return"discard"}}class Sr extends ir{constructor(){super()}get astNodeType(){return"break"}}class Ar extends ir{constructor(){super()}get astNodeType(){return"continue"}}class Er extends ir{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class Tr extends Er{constructor(e,t){super(e),this.members=t}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class Pr extends Er{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}}class Mr extends Er{constructor(e,t,n,r){super(e),this.storage=t,this.type=n,this.access=r}get astNodeType(){return"pointer"}}class Cr extends Er{constructor(e,t,n,r){super(e),this.attributes=t,this.format=n,this.count=r}get astNodeType(){return"array"}get isArray(){return!0}}class zr extends Er{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}}class Ir extends tr{constructor(){super()}}class Br extends Ir{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class Or extends Ir{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}}class Nr extends Ir{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class Ur extends Ir{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this)}}class Rr extends Ir{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,n;if(this.initializer instanceof Or){const r=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),i=null===(n=this.initializer.type)||void 0===n?void 0:n.name,s=e.structs.get(i),o=null==s?void 0:s.getMemberIndex(r);if(-1!=o)return this.initializer.args[o].evaluate(e);console.log(o)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class Dr extends Ir{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class Fr extends Ir{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class Lr extends Ir{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}}class qr extends Ir{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class jr extends Ir{constructor(){super()}}class Vr extends jr{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}}class Gr extends jr{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class $r extends tr{constructor(){super()}}class Wr extends $r{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class Hr extends $r{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class Yr extends tr{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}}class Xr extends tr{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Zr extends tr{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}}class Kr extends tr{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(Qn||(Qn={}));class Qr{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class Jr{}Kn=Jr,Jr.none=new Qr("",Qn.reserved,""),Jr.eof=new Qr("EOF",Qn.token,""),Jr.reserved={asm:new Qr("asm",Qn.reserved,"asm"),bf16:new Qr("bf16",Qn.reserved,"bf16"),do:new Qr("do",Qn.reserved,"do"),enum:new Qr("enum",Qn.reserved,"enum"),f16:new Qr("f16",Qn.reserved,"f16"),f64:new Qr("f64",Qn.reserved,"f64"),handle:new Qr("handle",Qn.reserved,"handle"),i8:new Qr("i8",Qn.reserved,"i8"),i16:new Qr("i16",Qn.reserved,"i16"),i64:new Qr("i64",Qn.reserved,"i64"),mat:new Qr("mat",Qn.reserved,"mat"),premerge:new Qr("premerge",Qn.reserved,"premerge"),regardless:new Qr("regardless",Qn.reserved,"regardless"),typedef:new Qr("typedef",Qn.reserved,"typedef"),u8:new Qr("u8",Qn.reserved,"u8"),u16:new Qr("u16",Qn.reserved,"u16"),u64:new Qr("u64",Qn.reserved,"u64"),unless:new Qr("unless",Qn.reserved,"unless"),using:new Qr("using",Qn.reserved,"using"),vec:new Qr("vec",Qn.reserved,"vec"),void:new Qr("void",Qn.reserved,"void")},Jr.keywords={array:new Qr("array",Qn.keyword,"array"),atomic:new Qr("atomic",Qn.keyword,"atomic"),bool:new Qr("bool",Qn.keyword,"bool"),f32:new Qr("f32",Qn.keyword,"f32"),i32:new Qr("i32",Qn.keyword,"i32"),mat2x2:new Qr("mat2x2",Qn.keyword,"mat2x2"),mat2x3:new Qr("mat2x3",Qn.keyword,"mat2x3"),mat2x4:new Qr("mat2x4",Qn.keyword,"mat2x4"),mat3x2:new Qr("mat3x2",Qn.keyword,"mat3x2"),mat3x3:new Qr("mat3x3",Qn.keyword,"mat3x3"),mat3x4:new Qr("mat3x4",Qn.keyword,"mat3x4"),mat4x2:new Qr("mat4x2",Qn.keyword,"mat4x2"),mat4x3:new Qr("mat4x3",Qn.keyword,"mat4x3"),mat4x4:new Qr("mat4x4",Qn.keyword,"mat4x4"),ptr:new Qr("ptr",Qn.keyword,"ptr"),sampler:new Qr("sampler",Qn.keyword,"sampler"),sampler_comparison:new Qr("sampler_comparison",Qn.keyword,"sampler_comparison"),struct:new Qr("struct",Qn.keyword,"struct"),texture_1d:new Qr("texture_1d",Qn.keyword,"texture_1d"),texture_2d:new Qr("texture_2d",Qn.keyword,"texture_2d"),texture_2d_array:new Qr("texture_2d_array",Qn.keyword,"texture_2d_array"),texture_3d:new Qr("texture_3d",Qn.keyword,"texture_3d"),texture_cube:new Qr("texture_cube",Qn.keyword,"texture_cube"),texture_cube_array:new Qr("texture_cube_array",Qn.keyword,"texture_cube_array"),texture_multisampled_2d:new Qr("texture_multisampled_2d",Qn.keyword,"texture_multisampled_2d"),texture_storage_1d:new Qr("texture_storage_1d",Qn.keyword,"texture_storage_1d"),texture_storage_2d:new Qr("texture_storage_2d",Qn.keyword,"texture_storage_2d"),texture_storage_2d_array:new Qr("texture_storage_2d_array",Qn.keyword,"texture_storage_2d_array"),texture_storage_3d:new Qr("texture_storage_3d",Qn.keyword,"texture_storage_3d"),texture_depth_2d:new Qr("texture_depth_2d",Qn.keyword,"texture_depth_2d"),texture_depth_2d_array:new Qr("texture_depth_2d_array",Qn.keyword,"texture_depth_2d_array"),texture_depth_cube:new Qr("texture_depth_cube",Qn.keyword,"texture_depth_cube"),texture_depth_cube_array:new Qr("texture_depth_cube_array",Qn.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new Qr("texture_depth_multisampled_2d",Qn.keyword,"texture_depth_multisampled_2d"),texture_external:new Qr("texture_external",Qn.keyword,"texture_external"),u32:new Qr("u32",Qn.keyword,"u32"),vec2:new Qr("vec2",Qn.keyword,"vec2"),vec3:new Qr("vec3",Qn.keyword,"vec3"),vec4:new Qr("vec4",Qn.keyword,"vec4"),bitcast:new Qr("bitcast",Qn.keyword,"bitcast"),block:new Qr("block",Qn.keyword,"block"),break:new Qr("break",Qn.keyword,"break"),case:new Qr("case",Qn.keyword,"case"),continue:new Qr("continue",Qn.keyword,"continue"),continuing:new Qr("continuing",Qn.keyword,"continuing"),default:new Qr("default",Qn.keyword,"default"),discard:new Qr("discard",Qn.keyword,"discard"),else:new Qr("else",Qn.keyword,"else"),enable:new Qr("enable",Qn.keyword,"enable"),fallthrough:new Qr("fallthrough",Qn.keyword,"fallthrough"),false:new Qr("false",Qn.keyword,"false"),fn:new Qr("fn",Qn.keyword,"fn"),for:new Qr("for",Qn.keyword,"for"),function:new Qr("function",Qn.keyword,"function"),if:new Qr("if",Qn.keyword,"if"),let:new Qr("let",Qn.keyword,"let"),const:new Qr("const",Qn.keyword,"const"),loop:new Qr("loop",Qn.keyword,"loop"),while:new Qr("while",Qn.keyword,"while"),private:new Qr("private",Qn.keyword,"private"),read:new Qr("read",Qn.keyword,"read"),read_write:new Qr("read_write",Qn.keyword,"read_write"),return:new Qr("return",Qn.keyword,"return"),storage:new Qr("storage",Qn.keyword,"storage"),switch:new Qr("switch",Qn.keyword,"switch"),true:new Qr("true",Qn.keyword,"true"),alias:new Qr("alias",Qn.keyword,"alias"),type:new Qr("type",Qn.keyword,"type"),uniform:new Qr("uniform",Qn.keyword,"uniform"),var:new Qr("var",Qn.keyword,"var"),override:new Qr("override",Qn.keyword,"override"),workgroup:new Qr("workgroup",Qn.keyword,"workgroup"),write:new Qr("write",Qn.keyword,"write"),r8unorm:new Qr("r8unorm",Qn.keyword,"r8unorm"),r8snorm:new Qr("r8snorm",Qn.keyword,"r8snorm"),r8uint:new Qr("r8uint",Qn.keyword,"r8uint"),r8sint:new Qr("r8sint",Qn.keyword,"r8sint"),r16uint:new Qr("r16uint",Qn.keyword,"r16uint"),r16sint:new Qr("r16sint",Qn.keyword,"r16sint"),r16float:new Qr("r16float",Qn.keyword,"r16float"),rg8unorm:new Qr("rg8unorm",Qn.keyword,"rg8unorm"),rg8snorm:new Qr("rg8snorm",Qn.keyword,"rg8snorm"),rg8uint:new Qr("rg8uint",Qn.keyword,"rg8uint"),rg8sint:new Qr("rg8sint",Qn.keyword,"rg8sint"),r32uint:new Qr("r32uint",Qn.keyword,"r32uint"),r32sint:new Qr("r32sint",Qn.keyword,"r32sint"),r32float:new Qr("r32float",Qn.keyword,"r32float"),rg16uint:new Qr("rg16uint",Qn.keyword,"rg16uint"),rg16sint:new Qr("rg16sint",Qn.keyword,"rg16sint"),rg16float:new Qr("rg16float",Qn.keyword,"rg16float"),rgba8unorm:new Qr("rgba8unorm",Qn.keyword,"rgba8unorm"),rgba8unorm_srgb:new Qr("rgba8unorm_srgb",Qn.keyword,"rgba8unorm_srgb"),rgba8snorm:new Qr("rgba8snorm",Qn.keyword,"rgba8snorm"),rgba8uint:new Qr("rgba8uint",Qn.keyword,"rgba8uint"),rgba8sint:new Qr("rgba8sint",Qn.keyword,"rgba8sint"),bgra8unorm:new Qr("bgra8unorm",Qn.keyword,"bgra8unorm"),bgra8unorm_srgb:new Qr("bgra8unorm_srgb",Qn.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new Qr("rgb10a2unorm",Qn.keyword,"rgb10a2unorm"),rg11b10float:new Qr("rg11b10float",Qn.keyword,"rg11b10float"),rg32uint:new Qr("rg32uint",Qn.keyword,"rg32uint"),rg32sint:new Qr("rg32sint",Qn.keyword,"rg32sint"),rg32float:new Qr("rg32float",Qn.keyword,"rg32float"),rgba16uint:new Qr("rgba16uint",Qn.keyword,"rgba16uint"),rgba16sint:new Qr("rgba16sint",Qn.keyword,"rgba16sint"),rgba16float:new Qr("rgba16float",Qn.keyword,"rgba16float"),rgba32uint:new Qr("rgba32uint",Qn.keyword,"rgba32uint"),rgba32sint:new Qr("rgba32sint",Qn.keyword,"rgba32sint"),rgba32float:new Qr("rgba32float",Qn.keyword,"rgba32float"),static_assert:new Qr("static_assert",Qn.keyword,"static_assert")},Jr.tokens={decimal_float_literal:new Qr("decimal_float_literal",Qn.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new Qr("hex_float_literal",Qn.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new Qr("int_literal",Qn.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new Qr("uint_literal",Qn.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new Qr("ident",Qn.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new Qr("and",Qn.token,"&"),and_and:new Qr("and_and",Qn.token,"&&"),arrow:new Qr("arrow ",Qn.token,"->"),attr:new Qr("attr",Qn.token,"@"),attr_left:new Qr("attr_left",Qn.token,"[["),attr_right:new Qr("attr_right",Qn.token,"]]"),forward_slash:new Qr("forward_slash",Qn.token,"/"),bang:new Qr("bang",Qn.token,"!"),bracket_left:new Qr("bracket_left",Qn.token,"["),bracket_right:new Qr("bracket_right",Qn.token,"]"),brace_left:new Qr("brace_left",Qn.token,"{"),brace_right:new Qr("brace_right",Qn.token,"}"),colon:new Qr("colon",Qn.token,":"),comma:new Qr("comma",Qn.token,","),equal:new Qr("equal",Qn.token,"="),equal_equal:new Qr("equal_equal",Qn.token,"=="),not_equal:new Qr("not_equal",Qn.token,"!="),greater_than:new Qr("greater_than",Qn.token,">"),greater_than_equal:new Qr("greater_than_equal",Qn.token,">="),shift_right:new Qr("shift_right",Qn.token,">>"),less_than:new Qr("less_than",Qn.token,"<"),less_than_equal:new Qr("less_than_equal",Qn.token,"<="),shift_left:new Qr("shift_left",Qn.token,"<<"),modulo:new Qr("modulo",Qn.token,"%"),minus:new Qr("minus",Qn.token,"-"),minus_minus:new Qr("minus_minus",Qn.token,"--"),period:new Qr("period",Qn.token,"."),plus:new Qr("plus",Qn.token,"+"),plus_plus:new Qr("plus_plus",Qn.token,"++"),or:new Qr("or",Qn.token,"|"),or_or:new Qr("or_or",Qn.token,"||"),paren_left:new Qr("paren_left",Qn.token,"("),paren_right:new Qr("paren_right",Qn.token,")"),semicolon:new Qr("semicolon",Qn.token,";"),star:new Qr("star",Qn.token,"*"),tilde:new Qr("tilde",Qn.token,"~"),underscore:new Qr("underscore",Qn.token,"_"),xor:new Qr("xor",Qn.token,"^"),plus_equal:new Qr("plus_equal",Qn.token,"+="),minus_equal:new Qr("minus_equal",Qn.token,"-="),times_equal:new Qr("times_equal",Qn.token,"*="),division_equal:new Qr("division_equal",Qn.token,"/="),modulo_equal:new Qr("modulo_equal",Qn.token,"%="),and_equal:new Qr("and_equal",Qn.token,"&="),or_equal:new Qr("or_equal",Qn.token,"|="),xor_equal:new Qr("xor_equal",Qn.token,"^="),shift_right_equal:new Qr("shift_right_equal",Qn.token,">>="),shift_left_equal:new Qr("shift_left_equal",Qn.token,"<<=")},Jr.storage_class=[Kn.keywords.function,Kn.keywords.private,Kn.keywords.workgroup,Kn.keywords.uniform,Kn.keywords.storage],Jr.access_mode=[Kn.keywords.read,Kn.keywords.write,Kn.keywords.read_write],Jr.sampler_type=[Kn.keywords.sampler,Kn.keywords.sampler_comparison],Jr.sampled_texture_type=[Kn.keywords.texture_1d,Kn.keywords.texture_2d,Kn.keywords.texture_2d_array,Kn.keywords.texture_3d,Kn.keywords.texture_cube,Kn.keywords.texture_cube_array],Jr.multisampled_texture_type=[Kn.keywords.texture_multisampled_2d],Jr.storage_texture_type=[Kn.keywords.texture_storage_1d,Kn.keywords.texture_storage_2d,Kn.keywords.texture_storage_2d_array,Kn.keywords.texture_storage_3d],Jr.depth_texture_type=[Kn.keywords.texture_depth_2d,Kn.keywords.texture_depth_2d_array,Kn.keywords.texture_depth_cube,Kn.keywords.texture_depth_cube_array,Kn.keywords.texture_depth_multisampled_2d],Jr.texture_external_type=[Kn.keywords.texture_external],Jr.any_texture_type=[...Kn.sampled_texture_type,...Kn.multisampled_texture_type,...Kn.storage_texture_type,...Kn.depth_texture_type,...Kn.texture_external_type],Jr.texel_format=[Kn.keywords.r8unorm,Kn.keywords.r8snorm,Kn.keywords.r8uint,Kn.keywords.r8sint,Kn.keywords.r16uint,Kn.keywords.r16sint,Kn.keywords.r16float,Kn.keywords.rg8unorm,Kn.keywords.rg8snorm,Kn.keywords.rg8uint,Kn.keywords.rg8sint,Kn.keywords.r32uint,Kn.keywords.r32sint,Kn.keywords.r32float,Kn.keywords.rg16uint,Kn.keywords.rg16sint,Kn.keywords.rg16float,Kn.keywords.rgba8unorm,Kn.keywords.rgba8unorm_srgb,Kn.keywords.rgba8snorm,Kn.keywords.rgba8uint,Kn.keywords.rgba8sint,Kn.keywords.bgra8unorm,Kn.keywords.bgra8unorm_srgb,Kn.keywords.rgb10a2unorm,Kn.keywords.rg11b10float,Kn.keywords.rg32uint,Kn.keywords.rg32sint,Kn.keywords.rg32float,Kn.keywords.rgba16uint,Kn.keywords.rgba16sint,Kn.keywords.rgba16float,Kn.keywords.rgba32uint,Kn.keywords.rgba32sint,Kn.keywords.rgba32float],Jr.const_literal=[Kn.tokens.int_literal,Kn.tokens.uint_literal,Kn.tokens.decimal_float_literal,Kn.tokens.hex_float_literal,Kn.keywords.true,Kn.keywords.false],Jr.literal_or_ident=[Kn.tokens.ident,Kn.tokens.int_literal,Kn.tokens.uint_literal,Kn.tokens.decimal_float_literal,Kn.tokens.hex_float_literal],Jr.element_count_expression=[Kn.tokens.int_literal,Kn.tokens.uint_literal,Kn.tokens.ident],Jr.template_types=[Kn.keywords.vec2,Kn.keywords.vec3,Kn.keywords.vec4,Kn.keywords.mat2x2,Kn.keywords.mat2x3,Kn.keywords.mat2x4,Kn.keywords.mat3x2,Kn.keywords.mat3x3,Kn.keywords.mat3x4,Kn.keywords.mat4x2,Kn.keywords.mat4x3,Kn.keywords.mat4x4,Kn.keywords.atomic,Kn.keywords.bitcast,...Kn.any_texture_type],Jr.attribute_name=[Kn.tokens.ident,Kn.keywords.block],Jr.assignment_operators=[Kn.tokens.equal,Kn.tokens.plus_equal,Kn.tokens.minus_equal,Kn.tokens.times_equal,Kn.tokens.division_equal,Kn.tokens.modulo_equal,Kn.tokens.and_equal,Kn.tokens.or_equal,Kn.tokens.xor_equal,Kn.tokens.shift_right_equal,Kn.tokens.shift_left_equal],Jr.increment_operators=[Kn.tokens.plus_plus,Kn.tokens.minus_minus];class ei{constructor(e,t,n){this.type=e,this.lexeme=t,this.line=n}toString(){return this.lexeme}isTemplateType(){return-1!=Jr.template_types.indexOf(this.type)}isArrayType(){return this.type==Jr.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class ti{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new ei(Jr.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}let t=Jr.none;for(;;){let n=this._findType(e);const r=this._peekAhead();if(">"==e&&(">"==r||"="==r)){let e=!1,t=this._tokens.length-1;for(let n=0;n<5&&t>=0;++n,--t)if(this._tokens[t].type===Jr.tokens.less_than){t>0&&this._tokens[t-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(n),!0}if(n===Jr.none){let r=e,i=0;const s=2;for(let e=0;e<s;++e)if(r+=this._peekAhead(e),n=this._findType(r),n!==Jr.none){i=e;break}if(n===Jr.none)return t!==Jr.none&&(this._current--,this._addToken(t),!0);e=r,this._current+=i+1}if(t=n,this._isAtEnd())break;e+=this._advance()}return t!==Jr.none&&(this._addToken(t),!0)}_findType(e){for(const t in Jr.keywords){const n=Jr.keywords[t];if(this._match(e,n.rule))return n}for(const t in Jr.tokens){const n=Jr.tokens[t];if(this._match(e,n.rule))return n}return Jr.none}_match(e,t){if("string"==typeof t){if(t==e)return!0}else{const n=t.exec(e);if(n&&0==n.index&&n[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new ei(e,t,this._line))}}class ni{constructor(){this._tokens=[],this._current=0,this._context=new er}parse(e){this._initialize(e);let t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}return t}_initialize(e){if(e)if("string"==typeof e){const t=new ti(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return console.error(e,t),{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==Jr.eof}_match(e){if(e instanceof Qr)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const n=e[t];if(this._check(n))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){let n=t.type;return-1!=e.indexOf(n)}return t.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(Jr.tokens.semicolon)&&!this._isAtEnd(););if(this._match(Jr.keywords.alias)){const e=this._type_alias();return this._consume(Jr.tokens.semicolon,"Expected ';'"),e}if(this._match(Jr.keywords.enable)){const e=this._enable_directive();return this._consume(Jr.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(Jr.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(Jr.tokens.semicolon,"Expected ';'."),t}if(this._check(Jr.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(Jr.tokens.semicolon,"Expected ';'."),t}if(this._check(Jr.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(Jr.tokens.semicolon,"Expected ';'."),t}if(this._check(Jr.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(Jr.tokens.semicolon,"Expected ';'."),t}if(this._check(Jr.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(Jr.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(Jr.keywords.fn))return null;const e=this._consume(Jr.tokens.ident,"Expected function name.").toString();this._consume(Jr.tokens.paren_left,"Expected '(' for function arguments.");const t=[];if(!this._check(Jr.tokens.paren_right))do{if(this._check(Jr.tokens.paren_right))break;const e=this._attribute(),n=this._consume(Jr.tokens.ident,"Expected argument name.").toString();this._consume(Jr.tokens.colon,"Expected ':' for argument type.");const r=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=r,t.push(new Yr(n,i,e)))}while(this._match(Jr.tokens.comma));this._consume(Jr.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(Jr.tokens.arrow)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}const r=this._compound_statement();return new sr(e,t,n,r)}_compound_statement(){const e=[];for(this._consume(Jr.tokens.brace_left,"Expected '{' for block.");!this._check(Jr.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(Jr.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(Jr.tokens.semicolon)&&!this._isAtEnd(););if(this._check(Jr.keywords.if))return this._if_statement();if(this._check(Jr.keywords.switch))return this._switch_statement();if(this._check(Jr.keywords.loop))return this._loop_statement();if(this._check(Jr.keywords.for))return this._for_statement();if(this._check(Jr.keywords.while))return this._while_statement();if(this._check(Jr.keywords.continuing))return this._continuing_statement();if(this._check(Jr.keywords.static_assert))return this._static_assert_statement();if(this._check(Jr.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(Jr.keywords.return)?this._return_statement():this._check([Jr.keywords.var,Jr.keywords.let,Jr.keywords.const])?this._variable_statement():this._match(Jr.keywords.discard)?new kr:this._match(Jr.keywords.break)?new Sr:this._match(Jr.keywords.continue)?new Ar:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(Jr.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(Jr.keywords.static_assert))return null;let e=this._optional_paren_expression();return new or(e)}_while_statement(){if(!this._match(Jr.keywords.while))return null;let e=this._optional_paren_expression();const t=this._compound_statement();return new ar(e,t)}_continuing_statement(){if(!this._match(Jr.keywords.continuing))return null;const e=this._compound_statement();return new lr(e)}_for_statement(){if(!this._match(Jr.keywords.for))return null;this._consume(Jr.tokens.paren_left,"Expected '('.");const e=this._check(Jr.tokens.semicolon)?null:this._for_init();this._consume(Jr.tokens.semicolon,"Expected ';'.");const t=this._check(Jr.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(Jr.tokens.semicolon,"Expected ';'.");const n=this._check(Jr.tokens.paren_right)?null:this._for_increment();this._consume(Jr.tokens.paren_right,"Expected ')'.");const r=this._compound_statement();return new cr(e,t,n,r)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(Jr.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(Jr.tokens.equal)&&(t=this._short_circuit_or_expression()),new ur(e.name,e.type,e.storage,e.access,t)}if(this._match(Jr.keywords.let)){const e=this._consume(Jr.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(Jr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Jr.tokens.equal,"Expected '=' for let.");const n=this._short_circuit_or_expression();return new dr(e,t,null,null,n)}if(this._match(Jr.keywords.const)){const e=this._consume(Jr.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(Jr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Jr.tokens.equal,"Expected '=' for const.");const n=this._short_circuit_or_expression();return new pr(e,t,null,null,n)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(Jr.increment_operators))return this._current=e,null;const n=this._consume(Jr.increment_operators,"Expected increment operator");return new fr(n.type===Jr.tokens.plus_plus?Xn.increment:Xn.decrement,t)}_assignment_statement(){let e=null;if(this._check(Jr.tokens.brace_right))return null;let t=this._match(Jr.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const n=this._consume(Jr.assignment_operators,"Expected assignment operator."),r=this._short_circuit_or_expression();return new mr(Zn.parse(n.lexeme),e,r)}_func_call_statement(){if(!this._check(Jr.tokens.ident))return null;const e=this._current,t=this._consume(Jr.tokens.ident,"Expected function name."),n=this._argument_expression_list();return null===n?(this._current=e,null):new gr(t.lexeme,n)}_loop_statement(){if(!this._match(Jr.keywords.loop))return null;this._consume(Jr.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let n of t)e.push(n);else e.push(t);t=this._statement()}let n=null;return this._match(Jr.keywords.continuing)&&(n=this._compound_statement()),this._consume(Jr.tokens.brace_right,"Expected '}' for loop."),new vr(e,n)}_switch_statement(){if(!this._match(Jr.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(Jr.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(Jr.tokens.brace_right,"Expected '}' for switch."),new yr(e,t)}_switch_body(){const e=[];if(this._match(Jr.keywords.case)){const t=this._case_selectors();this._match(Jr.tokens.colon),this._consume(Jr.tokens.brace_left,"Exected '{' for switch case.");const n=this._case_body();this._consume(Jr.tokens.brace_right,"Exected '}' for switch case."),e.push(new Wr(t,n))}if(this._match(Jr.keywords.default)){this._match(Jr.tokens.colon),this._consume(Jr.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(Jr.tokens.brace_right,"Exected '}' for switch default."),e.push(new Hr(t))}if(this._check([Jr.keywords.default,Jr.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){var e,t,n,r;const i=[null!==(t=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==t?t:""];for(;this._match(Jr.tokens.comma);)i.push(null!==(r=null===(n=this._shift_expression())||void 0===n?void 0:n.evaluate(this._context).toString())&&void 0!==r?r:"");return i}_case_body(){if(this._match(Jr.keywords.fallthrough))return this._consume(Jr.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(Jr.keywords.if))return null;const e=this._optional_paren_expression(),t=this._compound_statement();let n=[];this._match_elseif()&&(n=this._elseif_statement(n));let r=null;return this._match(Jr.keywords.else)&&(r=this._compound_statement()),new xr(e,t,n,r)}_match_elseif(){return this._tokens[this._current].type===Jr.keywords.else&&this._tokens[this._current+1].type===Jr.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(new Xr(t,n)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(Jr.keywords.return))return null;const e=this._short_circuit_or_expression();return new wr(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(Jr.tokens.or_or);)e=new Gr(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(Jr.tokens.and_and);)e=new Gr(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(Jr.tokens.or);)e=new Gr(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(Jr.tokens.xor);)e=new Gr(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(Jr.tokens.and);)e=new Gr(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([Jr.tokens.equal_equal,Jr.tokens.not_equal])?new Gr(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([Jr.tokens.less_than,Jr.tokens.greater_than,Jr.tokens.less_than_equal,Jr.tokens.greater_than_equal]);)e=new Gr(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([Jr.tokens.shift_left,Jr.tokens.shift_right]);)e=new Gr(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([Jr.tokens.plus,Jr.tokens.minus]);)e=new Gr(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([Jr.tokens.star,Jr.tokens.forward_slash,Jr.tokens.modulo]);)e=new Gr(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([Jr.tokens.minus,Jr.tokens.bang,Jr.tokens.tilde,Jr.tokens.star,Jr.tokens.and])?new Vr(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(Jr.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(Jr.tokens.bracket_right,"Expected ']'.");const t=this._postfix_expression();return t&&(e.postfix=t),e}if(this._match(Jr.tokens.period)){const e=this._consume(Jr.tokens.ident,"Expected member name."),t=this._postfix_expression(),n=new Br(e.lexeme);return t&&(n.postfix=t),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(Jr.tokens.ident)){const e=this._previous().toString();if(this._check(Jr.tokens.paren_left)){const t=this._argument_expression_list(),n=this._getStruct(e);return null!=n?new Or(n,t):new Nr(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new Rr(e,t.value)}return new Ur(e)}if(this._match(Jr.const_literal))return new Dr(parseFloat(this._previous().toString()));if(this._check(Jr.tokens.paren_left))return this._paren_expression();if(this._match(Jr.keywords.bitcast)){this._consume(Jr.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(Jr.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new Fr(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new Lr(e,t)}_argument_expression_list(){if(!this._match(Jr.tokens.paren_left))return null;const e=[];do{if(this._check(Jr.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(Jr.tokens.comma));return this._consume(Jr.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(Jr.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(Jr.tokens.paren_right),new qr([e])}_paren_expression(){this._consume(Jr.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(Jr.tokens.paren_right,"Expected ')'."),new qr([e])}_struct_decl(){if(!this._match(Jr.keywords.struct))return null;const e=this._consume(Jr.tokens.ident,"Expected name for struct.").toString();this._consume(Jr.tokens.brace_left,"Expected '{' for struct body.");const t=[];for(;!this._check(Jr.tokens.brace_right);){const e=this._attribute(),n=this._consume(Jr.tokens.ident,"Expected variable name.").toString();this._consume(Jr.tokens.colon,"Expected ':' for struct member type.");const r=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=r),this._check(Jr.tokens.brace_right)?this._match(Jr.tokens.comma):this._consume(Jr.tokens.comma,"Expected ',' for struct member."),t.push(new Zr(n,i,e))}this._consume(Jr.tokens.brace_right,"Expected '}' after struct body.");const n=new Tr(e,t);return this._context.structs.set(e,n),n}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(Jr.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(Jr.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(Jr.keywords.const))return null;const e=this._consume(Jr.tokens.ident,"Expected variable name");let t=null;if(this._match(Jr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;if(this._match(Jr.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof Or)n=e;else if(e instanceof Rr&&e.initializer instanceof Or)n=e.initializer;else try{const t=e.evaluate(this._context);n=new Dr(t)}catch(t){n=e}}const r=new pr(e.toString(),t,"","",n);return this._context.constants.set(r.name,r),r}_global_let_decl(){if(!this._match(Jr.keywords.let))return null;const e=this._consume(Jr.tokens.ident,"Expected variable name");let t=null;if(this._match(Jr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;return this._match(Jr.tokens.equal)&&(n=this._const_expression()),new dr(e.toString(),t,"","",n)}_const_expression(){if(this._match(Jr.const_literal))return new Br(this._previous().toString());const e=this._type_decl();this._consume(Jr.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(Jr.tokens.paren_right)&&(t.push(this._const_expression()),this._check(Jr.tokens.comma));)this._advance();return this._consume(Jr.tokens.paren_right,"Expected ')'."),new Or(e,t)}_variable_decl(){if(!this._match(Jr.keywords.var))return null;let e="",t="";this._match(Jr.tokens.less_than)&&(e=this._consume(Jr.storage_class,"Expected storage_class.").toString(),this._match(Jr.tokens.comma)&&(t=this._consume(Jr.access_mode,"Expected access_mode.").toString()),this._consume(Jr.tokens.greater_than,"Expected '>'."));const n=this._consume(Jr.tokens.ident,"Expected variable name");let r=null;if(this._match(Jr.tokens.colon)){const e=this._attribute();r=this._type_decl(),null!=r&&(r.attributes=e)}return new ur(n.toString(),r,e,t,null)}_override_decl(){if(!this._match(Jr.keywords.override))return null;const e=this._consume(Jr.tokens.ident,"Expected variable name");let t=null;if(this._match(Jr.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new hr(e.toString(),t,null)}_enable_directive(){const e=this._consume(Jr.tokens.ident,"identity expected.");return new br(e.toString())}_type_alias(){const e=this._consume(Jr.tokens.ident,"identity expected.");this._consume(Jr.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=new _r(e.toString(),t);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([Jr.tokens.ident,...Jr.texel_format,Jr.keywords.bool,Jr.keywords.f32,Jr.keywords.i32,Jr.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new Er(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(Jr.template_types)){let e=this._advance().toString(),t=null,n=null;return this._match(Jr.tokens.less_than)&&(t=this._type_decl(),n=null,this._match(Jr.tokens.comma)&&(n=this._consume(Jr.access_mode,"Expected access_mode for pointer").toString()),this._consume(Jr.tokens.greater_than,"Expected '>' for type.")),new Pr(e,t,n)}if(this._match(Jr.keywords.ptr)){let e=this._previous().toString();this._consume(Jr.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(Jr.storage_class,"Expected storage_class for pointer");this._consume(Jr.tokens.comma,"Expected ',' for pointer.");const n=this._type_decl();let r=null;return this._match(Jr.tokens.comma)&&(r=this._consume(Jr.access_mode,"Expected access_mode for pointer").toString()),this._consume(Jr.tokens.greater_than,"Expected '>' for pointer."),new Mr(e,t.toString(),n,r)}const t=this._attribute();if(this._match(Jr.keywords.array)){let e=null,n=-1;const r=this._previous();if(this._match(Jr.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";this._match(Jr.tokens.comma)&&(t=this._shift_expression().evaluate(this._context).toString()),this._consume(Jr.tokens.greater_than,"Expected '>' for array."),n=t?parseInt(t):0}return new Cr(r.toString(),t,e,n)}return null}_texture_sampler_types(){if(this._match(Jr.sampler_type))return new zr(this._previous().toString(),null,null);if(this._match(Jr.depth_texture_type))return new zr(this._previous().toString(),null,null);if(this._match(Jr.sampled_texture_type)||this._match(Jr.multisampled_texture_type)){const e=this._previous();this._consume(Jr.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(Jr.tokens.greater_than,"Expected '>' for sampler type."),new zr(e.toString(),t,null)}if(this._match(Jr.storage_texture_type)){const e=this._previous();this._consume(Jr.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(Jr.texel_format,"Invalid texel format.").toString();this._consume(Jr.tokens.comma,"Expected ',' after texel format.");const n=this._consume(Jr.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(Jr.tokens.greater_than,"Expected '>' for sampler type."),new zr(e.toString(),t,n)}return null}_attribute(){let e=[];for(;this._match(Jr.tokens.attr);){const t=this._consume(Jr.attribute_name,"Expected attribute name"),n=new Kr(t.toString(),null);if(this._match(Jr.tokens.paren_left)){if(n.value=this._consume(Jr.literal_or_ident,"Expected attribute value").toString(),this._check(Jr.tokens.comma)){this._advance();do{const e=this._consume(Jr.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(e)}while(this._match(Jr.tokens.comma))}this._consume(Jr.tokens.paren_right,"Expected ')'")}e.push(n)}for(;this._match(Jr.tokens.attr_left);){if(!this._check(Jr.tokens.attr_right))do{const t=this._consume(Jr.attribute_name,"Expected attribute name"),n=new Kr(t.toString(),null);if(this._match(Jr.tokens.paren_left)){if(n.value=[this._consume(Jr.literal_or_ident,"Expected attribute value").toString()],this._check(Jr.tokens.comma)){this._advance();do{const e=this._consume(Jr.literal_or_ident,"Expected attribute value").toString();n.value.push(e)}while(this._match(Jr.tokens.comma))}this._consume(Jr.tokens.paren_right,"Expected ')'")}e.push(n)}while(this._match(Jr.tokens.comma));this._consume(Jr.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class ri{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class ii{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class si extends ri{constructor(e,t){super(e,t),this.members=[],this.align=0}get isStruct(){return!0}}class oi extends ri{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class ai extends ri{constructor(e,t,n,r){super(e,n),this.format=t,this.access=r}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(Jn||(Jn={}));class li{constructor(e,t,n,r,i,s,o){this.name=e,this.type=t,this.group=n,this.binding=r,this.attributes=i,this.resourceType=s,this.access=o}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class ci{constructor(e,t){this.name=e,this.type=t}}class ui{constructor(e,t){this.align=e,this.size=t}}class hi{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r,this.interpolation=null}}class di{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r}}class pi{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.name=e,this.stage=t}}class fi{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class mi{constructor(e,t,n,r){this.name=e,this.type=t,this.attributes=n,this.id=r}}class gi{constructor(e){this.resources=null,this.node=e}}class vi{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new fi,this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new ni).parse(e);for(const e of t)e instanceof sr&&this._functions.set(e.name,new gi(e));for(const e of t)if(e instanceof Tr){const t=this._getTypeInfo(e,null);t instanceof si&&this.structs.push(t)}else if(e instanceof _r)this.aliases.push(this._getAliasInfo(e));else if(e instanceof hr){const t=e,n=this._getAttributeNum(t.attributes,"id",0),r=null!=t.type?this._getTypeInfo(t.type,t.attributes):null;this.overrides.push(new mi(t.name,r,t.attributes,n))}else if(this._isUniformVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new li(t.name,i,n,r,t.attributes,Jn.Uniform,t.access);this.uniforms.push(s)}else if(this._isStorageVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new li(t.name,i,n,r,t.attributes,s?Jn.StorageTexture:Jn.Storage,t.access);this.storage.push(o)}else if(this._isTextureVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new li(t.name,i,n,r,t.attributes,s?Jn.StorageTexture:Jn.Texture,t.access);s?this.storage.push(o):this.textures.push(o)}else if(this._isSamplerVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new li(t.name,i,n,r,t.attributes,Jn.Sampler,t.access);this.samplers.push(s)}else if(e instanceof sr){const t=this._getAttribute(e,"vertex"),n=this._getAttribute(e,"fragment"),r=this._getAttribute(e,"compute"),i=t||n||r;if(i){const t=new pi(e.name,null==i?void 0:i.name);t.inputs=this._getInputs(e.args),t.outputs=this._getOutputs(e.returnType),t.resources=this._findResources(e),this.entry[i.name].push(t)}}}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_findResources(e){const t=[],n=this,r=[];return e.search((e=>{if(e instanceof nr)r.push({});else if(e instanceof rr)r.pop();else if(e instanceof ur){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof dr){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof Ur){const i=e;if(r.length>0&&r[r.length-1][i.name])return;const s=n._findResource(i.name);s&&t.push(s)}else if(e instanceof Nr){const r=e,i=n._functions.get(r.name);i&&(null===i.resources&&(i.resources=n._findResources(i.node)),t.push(...i.resources))}})),[...new Map(t.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,n){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),n>=e[t].length&&(e[t].length=n+1)}for(const n of this.uniforms)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.storage)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.textures)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.samplers)t(n.group,n.binding),e[n.group][n.binding]=n;return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof Tr)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);null!==n&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof Tr)this._getStructOutputs(n.type,t);else{const e=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(null!==e){const r=this._getTypeInfo(n.type,n.type.attributes),i=this._parseInt(e.value),s=new di(n.name,r,e.name,i);t.push(s)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getTypeInfo(e,e.attributes),r=this._parseInt(t.value);return new di("",n,t.name,r)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const n of e)if(n.type instanceof Tr)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof Tr)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getAttribute(e,"interpolation"),r=this._getTypeInfo(e.type,e.attributes),i=this._parseInt(t.value),s=new hi(e.name,r,t.name,i);return null!==n&&(s.interpolation=this._parseString(n.value)),s}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new ci(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof Cr){const n=e,r=this._getTypeInfo(n.format,n.attributes),i=new oi(n.name,t);return i.format=r,i.count=n.count,this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof Tr){const n=e,r=new si(n.name,t);for(const e of n.members){const t=this._getTypeInfo(e.type,e.attributes);r.members.push(new ii(e.name,t,e.attributes))}return this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof zr){const n=e,r=n.format instanceof Er,i=n.format?r?this._getTypeInfo(n.format,null):new ri(n.format,null):null,s=new ai(n.name,i,t,n.access);return this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof Pr){const n=e,r=n.format?this._getTypeInfo(n.format,null):null,i=new ai(n.name,r,t,n.access);return this._types.set(e,i),this._updateTypeInfo(i),i}const n=new ri(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n;const r=this._getTypeSize(e);if(e.size=null!==(t=null==r?void 0:r.size)&&void 0!==t?t:0,e instanceof oi){const t=this._getTypeSize(e.format);e.stride=null!==(n=null==t?void 0:t.size)&&void 0!==n?n:0,this._updateTypeInfo(e.format)}e instanceof si&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,r=0,i=0,s=0;for(let o=0,a=e.members.length;o<a;++o){const a=e.members[o],l=this._getTypeSize(a);if(!l)continue;null!==(t=this._getAlias(a.type.name))&&void 0!==t||a.type;const c=l.align,u=l.size;n=this._roundUp(c,n+r),r=u,i=n,s=Math.max(s,c),a.offset=n,a.size=u,this._updateTypeInfo(a.type)}e.size=this._roundUp(s,i+r),e.align=s}_getTypeSize(e){var t;if(null==e)return null;const n=this._getAttributeNum(e.attributes,"size",0),r=this._getAttributeNum(e.attributes,"align",0);if(e instanceof ii&&(e=e.type),e instanceof ri){const t=this._getAlias(e.name);null!==t&&(e=t)}{const t=vi._typeInfo[e.name];if(void 0!==t){const i="f16"===e.format?2:1;return new ui(Math.max(r,t.align/i),Math.max(n,t.size/i))}}{const t=vi._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const i="h"===e.name[e.name.length-1]?2:1;return new ui(Math.max(r,t.align/i),Math.max(n,t.size/i))}}if(e instanceof oi){let i=e,s=8,o=8;const a=this._getTypeSize(i.format);return null!==a&&(o=a.size,s=a.align),o=i.count*this._getAttributeNum(null!==(t=null==e?void 0:e.attributes)&&void 0!==t?t:null,"stride",this._roundUp(s,o)),n&&(o=n),new ui(Math.max(r,s),Math.max(n,o))}if(e instanceof si){let t=0,i=0,s=0,o=0,a=0;for(const n of e.members){const e=this._getTypeSize(n.type);null!==e&&(t=Math.max(e.align,t),s=this._roundUp(e.align,s+o),o=e.size,a=s)}return i=this._roundUp(t,a+o),new ui(Math.max(r,t),Math.max(n,i))}return null}_isUniformVar(e){return e instanceof ur&&"uniform"==e.storage}_isStorageVar(e){return e instanceof ur&&"storage"==e.storage}_isTextureVar(e){return e instanceof ur&&null!==e.type&&-1!=vi._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof ur&&null!==e.type&&-1!=vi._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const r=n.attributes;for(let e of r)if(e.name==t)return e;return null}_getAttributeNum(e,t,n){if(null===e)return n;for(let r of e)if(r.name==t){let e=null!==r&&null!==r.value?r.value:n;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}function yi(e,t){const n=function(e){return Array.isArray(e)||Gn(e)?[...e,1,1].slice(0,3):function(e){return[e.width,e.height||1,e.depthOrArrayLayers||1]}(e)}(e),r=Math.max(...n.slice(0,"3d"===t?3:2));return 1+Math.log2(r)|0}vi._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},vi._textureTypes=Jr.any_texture_type.map((e=>e.name)),vi._samplerTypes=Jr.sampler_type.map((e=>e.name));const xi=new WeakMap;const wi=new Map([[Int8Array,{formats:["sint8","snorm8"],defaultForType:1}],[Uint8Array,{formats:["uint8","unorm8"],defaultForType:1}],[Int16Array,{formats:["sint16","snorm16"],defaultForType:1}],[Uint16Array,{formats:["uint16","unorm16"],defaultForType:1}],[Int32Array,{formats:["sint32","snorm32"],defaultForType:0}],[Uint32Array,{formats:["uint32","unorm32"],defaultForType:0}],[Float32Array,{formats:["float32","float32"],defaultForType:0}]]);function bi(e){return Gn(e)||Array.isArray(e)||function(e){const t=e;return Gn(t.data)||Array.isArray(t.data)}(e)}function _i(e){switch(e){case"1d":return"1d";case"3d":return"3d";default:return"2d"}}new Map([...wi.entries()].map((([e,{formats:[t,n]}])=>[[t,e],[n,e]])).flat());const ki={"8snorm":Int8Array,"8unorm":Uint8Array,"8sint":Int8Array,"8uint":Uint8Array,"16snorm":Int16Array,"16unorm":Uint16Array,"16sint":Int16Array,"16uint":Uint16Array,"32snorm":Int32Array,"32unorm":Uint32Array,"32sint":Int32Array,"32uint":Uint32Array,"16float":Uint16Array,"32float":Float32Array},Si=/([a-z]+)(\d+)([a-z]+)/;function Ai(e){const[,t,n,r]=Si.exec(e),i=t.length,s=parseInt(n)/8;return{channels:t,numChannels:i,bytesPerChannel:s,bytesPerElement:i*s,Type:ki[`${n}${r}`]}}function Ei(e,t,n,r={}){n.forEach(((n,i)=>{const s=[0,0,i+(r.baseArrayLayer||0)];if(bi(n))!function(e,t,n,r){const i=function(e,t){if(Gn(e))return e;const{Type:n}=Ai(t);return new n(e)}(n.data||n,t.format),s=function(e,t){return[e.width,e.height,e.depthOrArrayLayers].map((e=>Math.max(1,Math.floor(e/1))))}(t),{bytesPerElement:o}=Ai(t.format),a=r.origin||[0,0,0];e.queue.writeTexture({texture:t,origin:a},i,{bytesPerRow:o*s[0],rowsPerImage:s[1]},s)}(e,t,n,{origin:s});else{const i=n,{flipY:o,premultipliedAlpha:a,colorSpace:l}=r;e.queue.copyExternalImageToTexture({source:i,flipY:o},{texture:t,premultipliedAlpha:a,colorSpace:l,origin:s},Ti(i,r))}})),t.mipLevelCount>1&&function(e,t,n){let r=xi.get(e);r||(r={pipelineByFormatAndView:{},moduleByViewType:{}},xi.set(e,r));let{sampler:i,uniformBuffer:s,uniformValues:o}=r;const{pipelineByFormatAndView:a,moduleByViewType:l}=r;n=n||function(e){switch(e.dimension){case"1d":return"1d";case"3d":return"3d";default:return e.depthOrArrayLayers>1?"2d-array":"2d"}}(t);let c=l[n];if(!c){const t=function(e){let t,n;switch(e){case"2d":t="texture_2d<f32>",n="textureSample(ourTexture, ourSampler, fsInput.texcoord)";break;case"2d-array":t="texture_2d_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              fsInput.texcoord,\n              uni.layer)";break;case"cube":t="texture_cube<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1))";break;case"cube-array":t="texture_cube_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1), uni.layer)";break;default:throw new Error(`unsupported view: ${e}`)}return`\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n          var pos = array<vec2f, 3>(\n            vec2f(-1.0, -1.0),\n            vec2f(-1.0,  3.0),\n            vec2f( 3.0, -1.0),\n          );\n\n          var vsOutput: VSOutput;\n          let xy = pos[vertexIndex];\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n          return vsOutput;\n        }\n\n        struct Uniforms {\n          layer: u32,\n        };\n\n        @group(0) @binding(0) var ourSampler: sampler;\n        @group(0) @binding(1) var ourTexture: ${t};\n        @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni.layer; // make sure this is used so all pipelines have the same bindings\n          return ${n};\n        }\n      `}(n);c=e.createShaderModule({label:`mip level generation for ${n}`,code:t}),l[n]=c}i||(i=e.createSampler({minFilter:"linear",magFilter:"linear"}),s=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=new Uint32Array(1),Object.assign(r,{sampler:i,uniformBuffer:s,uniformValues:o}));const u=`${t.format}.${n}`;a[u]||(a[u]=e.createRenderPipeline({label:`mip level generator pipeline for ${n}`,layout:"auto",vertex:{module:c,entryPoint:"vs"},fragment:{module:c,entryPoint:"fs",targets:[{format:t.format}]}}));const h=a[u];for(let r=1;r<t.mipLevelCount;++r)for(let a=0;a<t.depthOrArrayLayers;++a){o[0]=a,e.queue.writeBuffer(s,0,o);const l=e.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:i},{binding:1,resource:t.createView({dimension:n,baseMipLevel:r-1,mipLevelCount:1})},{binding:2,resource:{buffer:s}}]}),c={label:"mip gen renderPass",colorAttachments:[{view:t.createView({dimension:"2d",baseMipLevel:r,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},u=e.createCommandEncoder({label:"mip gen encoder"}),d=u.beginRenderPass(c);d.setPipeline(h),d.setBindGroup(0,l),d.draw(3),d.end();const p=u.finish();e.queue.submit([p])}}(e,t)}function Ti(e,t){if(e instanceof HTMLVideoElement)return[e.videoWidth,e.videoHeight,1];{const n=e,{width:r,height:i}=n;if(r>0&&i>0&&!bi(e))return[r,i,1];const s=t.format||"rgba8unorm",{bytesPerElement:o,bytesPerChannel:a}=Ai(s),l=Gn(e)||Array.isArray(e)?e:e.data;return function(e,t,n,r="2d"){if(n%1!=0)throw new Error("can't guess dimensions");if(e||t){if(t){if(!e&&(e=n/t)%1)throw new Error("can't guess dimensions")}else if((t=n/e)%1)throw new Error("can't guess dimensions")}else{const i=Math.sqrt(n/("cube"===r?6:1));i%1==0?(e=i,t=i):(e=n,t=1)}const i=n/e/t;if(i%1)throw new Error("can't guess dimensions");return[e,t,i]}(r,i,(Gn(l)?l.byteLength:l.length*a)/o)}}async function Pi(e,t,n={}){const r=await Promise.all(t.map((e=>async function(e,t={}){const n=await fetch(e),r=await n.blob(),i={...t,...void 0!==t.colorSpaceConversion&&{colorSpaceConversion:"none"}};return await createImageBitmap(r,i)}(e))));return function(e,t,n={}){const r=Ti(t[0],n);r[2]=r[2]>1?r[2]:t.length;const i=e.createTexture({dimension:_i(n.dimension),format:n.format||"rgba8unorm",mipLevelCount:n.mipLevelCount?n.mipLevelCount:n.mips?yi(r):1,size:r,usage:(n.usage??0)|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return Ei(e,i,t,n),i}(e,r,n)}const Mi=e=>{let t=te.create(1/0,1/0,1/0),n=te.create(-1/0,-1/0,-1/0);for(const{AABB:r}of e)t=te.min(r.min,t),n=te.max(r.max,n);return{min:t,max:n}},Ci=e=>{const t=Mi(e),n=(t.max[0]-t.min[0])*(t.max[1]-t.min[1])*(t.max[2]-t.min[2]);return e.length*n},zi=(44,16,16*Math.ceil(2.75));class Ii{#a;#l;#c;#u;#h;constructor(e,t){this.#a=e,this.#c=t.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#l=[],this.#d(this.#c,0),this.#p()}get gpuBuffer(){if(!this.#h){const e=this.#a.createBuffer({size:this.#h.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),t=this.#a.createCommandEncoder();t.copyBufferToBuffer(this.#h,0,e,0,this.#h.size),this.#a.queue.submit([t.finish()]),e.mapAsync(GPUMapMode.READ).then((()=>{new Float32Array(e.getMappedRange())}))}return this.#h}update(e){this.#c=e.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#l=[],this.#d(this.#c,0),this.#p()}#d(e,t){if(0===this.#c.length)return;if(1===e.length)return void(this.#l[t]={leftChildIndex:this.#c.indexOf(e[0]),rightChildIndex:-1,objectCount:1,AABBMax:e[0].AABB.max,AABBMin:e[0].AABB.min});const n=Mi(e);let r=-1,i=-1;const{left:s,right:o}=(e=>{let t=1/0,n=-1;const r=Math.floor(e.length/2);for(let i=1;i<e.length;i++){const s=e.slice(0,i),o=e.slice(i),a=Ci(s)+Ci(o),l=1*Math.abs(i-r)+1*a;l<t&&(t=l,n=i)}return{left:e.slice(0,n),right:e.slice(n)}})(e);s.length>0&&(r=++this.#u,this.#d(s,r)),o.length>0&&(i=++this.#u,this.#d(o,i)),this.#l[t]={leftChildIndex:r,rightChildIndex:i,objectCount:e.length,AABBMax:n.max,AABBMin:n.min}}#p(){return this.#h=this.#a.createBuffer({size:Math.max(this.#l.length,1)*zi,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1,label:"bvh buffer"}),this.#l.forEach(((e,t)=>{const n=t*zi,r=new ArrayBuffer(zi),i=new DataView(r);i.setInt32(0,e.leftChildIndex,!0),i.setInt32(4,e.rightChildIndex,!0),i.setUint32(8,e.objectCount,!0),i.setFloat32(16,e.AABBMin[0],!0),i.setFloat32(20,e.AABBMin[1],!0),i.setFloat32(24,e.AABBMin[2],!0),i.setFloat32(32,e.AABBMax[0],!0),i.setFloat32(36,e.AABBMax[1],!0),i.setFloat32(40,e.AABBMax[2],!0),this.#a.queue.writeBuffer(this.#h,n,r,0,zi)})),this.#h}}const Bi="clear",Oi=async()=>{const e=Ms.createShaderModule({code:"\n    struct VertexOutput {\n      @builtin(position) position : vec4f,\n    }\n    @vertex\n    fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n      var output : VertexOutput;\n      return output;\n    }\n    @fragment\n    fn fragment_main(@builtin(position) position : vec4f) -> @location(0) vec4<f32> {\n        return vec4(0.0);\n    }"}),t=Ms.createRenderPipeline({label:Bi,layout:"auto",vertex:{module:e,entryPoint:"vertex_main"},fragment:{module:e,entryPoint:"fragment_main",targets:[{format:et}]}});return{render:e=>{const n=e.commandEncoder.beginRenderPass({label:Bi,timestampWrites:e.timestampWrites,colorAttachments:[{view:e.outputTextures.finalTexture.view,loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});n.setPipeline(t),n.draw(6),n.end()},label:Bi}};function Ni(e,t){let n=0,r=1/t,i=e;for(;i>0;)n+=r*(i%t),i=Math.floor(i/t),r/=t;return n}let Ui,Ri=!1;class Di extends e{position;rotation;scale;#f;constructor(e,t,n){super(),this.position=e,this.rotation=t,this.scale=n,this.#f=ve.identity()}get transform(){let e=ve.identity();return ve.translate(e,this.position,e),ve.multiply(e,ve.fromQuat(this.rotation),e),ve.scale(e,this.scale,e),e}get previousTransform(){return this.#f}set previousTransform(e){this.#f=e}get direction(){return te.transformQuat(te.create(0,0,1),this.rotation)}get right(){return te.transformQuat(te.create(1,0,0),this.rotation)}get left(){return te.transformQuat(te.create(-1,0,0),this.rotation)}get up(){return te.transformQuat(te.create(0,1,0),this.rotation)}get down(){return te.transformQuat(te.create(0,-1,0),this.rotation)}}class Fi extends e{size;atlasLocation;paletteIndex;octreeBufferIndex;name;constructor({size:e,atlasLocation:t,paletteIndex:n,octreeBufferIndex:r,name:i}){super(),this.size=e,this.atlasLocation=t,this.paletteIndex=n,this.octreeBufferIndex=r,this.name=i}}const Li="const MAX_COARSE_RAY_STEPS = 64;\r\n\r\nfn rayMarchCoarse(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>) -> bool {\r\n    let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\r\n    var voxelSize = vec3<f32>(1.0);\r\n    var objectPos = objectRayOrigin;\r\n    var currentIndex = vec3<i32>(round(objectPos));\r\n    var tDelta = voxelSize / abs(objectRayDirection);\r\n    var tIncrement = min(tDelta.x, min(tDelta.y, tDelta.z));\r\n\r\n    for(var i = 0; i < MAX_COARSE_RAY_STEPS; i++)\r\n    {\r\n      let samplePosition = objectPos + voxelObject.atlasLocation;\r\n      let uv = samplePosition / vec3<f32>(textureDimensions(voxels));\r\n      let mipSample0 = textureSampleLevel(voxels, nearestSampler, uv, 0.0);\r\n\r\n      if(mipSample0.a > 0.0){\r\n          return true;\r\n      }\r\n\r\n      objectPos += objectRayDirection * tIncrement;\r\n      currentIndex = vec3<i32>(round(objectPos));\r\n//      if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n//          break;\r\n//      }\r\n    }\r\n    return false;\r\n}\r\n\r\nfn rayMarchTransformedCoarse(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> bool {\r\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz;\r\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n    return rayMarchCoarse(voxelObject, objectRayDirection, objectRayOrigin);\r\n}\r\n\r\n// Used for shadows, return first hit\r\nfn rayMarchBVHCoarse(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxDistance: f32) -> bool {\r\n  // Create a stack to store the nodes to visit\r\n      var stack = stack_new();\r\n      stack_push(&stack, 0);\r\n\r\n      var iterations = 0;\r\n      var nodeIndex = 0;\r\n\r\n      while (stack.head > 0u && iterations < 32) {\r\n        let node = bvhNodes[nodeIndex];\r\n        if(node.objectCount == 0){\r\n          nodeIndex = stack_pop(&stack);\r\n        }\r\n        // valid leaf, raymarch it\r\n        else if(node.objectCount == 1){\r\n            // Raymarch the voxel object if it's a leaf node\r\n            let voxelObject = voxelObjects[node.leftIndex]; // left index represents the voxel object index for leaf nodes\r\n            let AABBDist = getDistanceToNode(rayOrigin, rayDirection, node);\r\n            if(rayMarchTransformedCoarse(voxelObject, rayDirection, rayOrigin + rayDirection * AABBDist)){\r\n              return true;\r\n            }\r\n            // Pop the stack and continue\r\n            nodeIndex = stack_pop(&stack);\r\n        }\r\n        else{\r\n          let leftDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.leftIndex]);\r\n          let rightDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.rightIndex]);\r\n          let hitLeft = leftDist >= 0.0 && leftDist < maxDistance;\r\n          let hitRight = rightDist >= 0.0 && rightDist < maxDistance;\r\n          if(hitLeft){\r\n            var nearIndex = node.leftIndex;\r\n            // We hit both left and right, choose the closest one\r\n            if(hitRight){\r\n              if(leftDist < rightDist){\r\n                // left is closer, push right to stack\r\n                stack_push(&stack, node.rightIndex);\r\n              } else {\r\n                // right is closer, push left to stack\r\n                stack_push(&stack, node.leftIndex);\r\n                nearIndex = node.rightIndex;\r\n              }\r\n            }\r\n            nodeIndex = nearIndex;\r\n          }\r\n          // We only hit the right Node\r\n          else if(hitRight){\r\n            nodeIndex = node.rightIndex;\r\n          }\r\n          // We didn't hit any node, pop the stack\r\n          else{\r\n            nodeIndex = stack_pop(&stack);\r\n          }\r\n        }\r\n\r\n        iterations += 1;\r\n      }\r\n\r\n      return false;\r\n}",qi="struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};",ji={binding:9,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Vi={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},Gi={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},$i={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:et}},Wi={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Hi={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},Yi={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Xi={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},Zi={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Ki={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},Qi={binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Ji={binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},es={binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},ts={binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},ns={binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},rs={binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},is={binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},ss={binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},os={binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},as={binding:19,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},ls="diffuse",cs=[Vi,Gi,$i,Wi,Hi,Yi,Xi,Zi,Ki,Qi,Ji,es,ts,ns,rs,is,ss,os,as],us=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32,\n  elapsed: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${et}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(9) var intermediaryTexture : texture_2d<f32>;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\n\nconst DOWNSCALE = 1;\n${qi}\n${We}\n${He}\n${Ye}\n${Xe}\n${Ze}\n${Li}\n${Ke}\nconst SUN_COLOR = vec3(0.6,0.5,0.4) * 20.0;\r\nconst MOON_COLOR = vec3<f32>(0.5, 0.5, 1.0);\r\nconst MIN_RADIANCE = 0.0;\r\nconst SUBPIXEL_SAMPLE_POSITIONS: array<vec2<f32>, 8> = array<vec2<f32>, 8>(\r\n  vec2<f32>(0.25, 0.25),\r\n  vec2<f32>(0.75, 0.25),\r\n  vec2<f32>(0.25, 0.75),\r\n  vec2<f32>(0.75, 0.75),\r\n  vec2<f32>(0.125, 0.125),\r\n  vec2<f32>(0.375, 0.125),\r\n  vec2<f32>(0.625, 0.125),\r\n  vec2<f32>(0.875, 0.125)\r\n);\r\nconst BLUE_NOISE_SIZE = 511;\r\nconst SUN_DIRECTION: vec3<f32> = vec3<f32>(1.0,-1.0,-1.0);\r\nconst SHADOW_ACNE_OFFSET: f32 = 0.01;\r\nconst SCATTER_AMOUNT: f32 = 0.1;\r\nconst POSITION_SCATTER_AMOUNT: f32 = 0.00;\r\n\r\n// TODO: offset in object space instead of world space to scale with object size\r\nfn diffuseRay(worldPos: vec3<f32>, shadowRayDirection: vec3<f32>, normal: vec3<f32>, voxelObjectSize: f32) -> bool {\r\n  let rayOrigin = worldPos;\r\n  return rayMarchBVHShadows(rayOrigin, shadowRayDirection, 0).hit;\r\n}\r\n\r\nfn calculateNDC(worldPos: vec3<f32>, viewProjection: mat4x4<f32>) -> vec3<f32> {\r\n  let clipPos = viewProjection * vec4(worldPos, 1.0);\r\n  return clipPos.xyz / clipPos.w;\r\n}\r\n\r\nfn calculateNDCDirection(worldDirection: vec3<f32>, viewProjection: mat4x4<f32>) -> vec3<f32> {\r\n  let clipDirection = viewProjection * vec4(worldDirection, 0.0);\r\n  return clipDirection.xyz / clipDirection.w;\r\n}\r\n\r\nfn shadowRay(worldPos: vec3<f32>, shadowRayDirection: vec3<f32>, normal: vec3<f32>) -> bool {\r\n  let rayOrigin = worldPos + normal * SHADOW_ACNE_OFFSET;\r\n  return rayMarchBVHShadows(rayOrigin, shadowRayDirection,0).hit;\r\n}\r\n\r\nstruct Light {\r\n  direction: vec3<f32>,\r\n  colour: vec3<f32>,\r\n};\r\n\r\nstruct BufferRay {\r\n  pixel : vec2<u32>,\r\n  direction : vec3<f32>,\r\n  origin : vec3<f32>,\r\n  lightColour : vec3<f32>,\r\n};\r\n\r\nfn randomInCosineWeightedHemisphere(r: vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n  let r1 = 2.0 * PI * r.x;\r\n  let r2 = r.y;\r\n  let r2s = sqrt(r2);\r\n  let w = normal;\r\n  let u = normalize(cross((select(vec3<f32>(1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0),abs(w.x) > 0.1)), w));\r\n  let v = cross(w, u);\r\n  return normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.0 - r2));\r\n}\r\n\r\nconst SAMPLES_PER_PIXEL = 1u;\r\nconst SAMPLE_OFFSETS: array<vec2<i32>, 4> = array<vec2<i32>, 4>(\r\n  vec2<i32>(0, 0),\r\n  vec2<i32>(1, 1),\r\n  vec2<i32>(0, 1),\r\n  vec2<i32>(1, 0),\r\n);\r\n\r\nfn tracePixel(outputPixel:vec2<i32>, downscaleFactor: i32, blueNoiseOffset: vec2<i32>) -> vec3<f32>{\r\n  let pixel = outputPixel * downscaleFactor;\r\n  let albedoRef = textureLoad(albedoTex, pixel, 0);\r\n  var normalSample = textureLoad(normalTex, pixel, 0).rgb;\r\n  let worldPosSample = textureLoad(worldPosTex, pixel, 0);\r\n  let uv = vec2<f32>(pixel) / vec2<f32>(textureDimensions(outputTex));\r\n\r\n  let distanceToSurface = length(worldPosSample.rgb - cameraPosition);\r\n  var worldPos = worldPosSample.rgb;\r\n\r\n  var samplePixel = pixel;\r\n  samplePixel.x += i32(time.frame) * 32;\r\n  samplePixel.y += i32(time.frame) * 16;\r\n  var blueNoisePixel = ((samplePixel / downscaleFactor) + blueNoiseOffset) % BLUE_NOISE_SIZE;\r\n  if(time.frame % 2 == 0){\r\n    blueNoisePixel.y = BLUE_NOISE_SIZE - blueNoisePixel.y;\r\n  }\r\n  if(time.frame % 3 == 0){\r\n    blueNoisePixel.x = BLUE_NOISE_SIZE - blueNoisePixel.x;\r\n  }\r\n  var r = textureLoad(blueNoiseTex, blueNoisePixel, 0).rg;\r\n\r\n  let maxSunIntensity = vec3(128.0);\r\n  // TODO: push to buffer instead and evaluate in a separate pass\r\n\r\n  let shadowRayDirection = normalize(sunDirection + randomInCosineWeightedHemisphere(r, sunDirection) * SCATTER_AMOUNT);\r\n\r\n  let isInShadow = shadowRay(worldPos, shadowRayDirection, normalSample);\r\n\r\n  let inputRef = textureLoad(inputTex, pixel, 0);\r\n\r\n  if(isInShadow){\r\n    return inputRef.rgb;\r\n  }\r\n\r\n  return SUN_COLOR;\r\n}\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\r\n  let result = tracePixel(pixel, 1, vec2(0));\r\n  textureStore(outputTex, pixel, vec4(result, 1.0));\r\n}\r\n\r\n\r\n@group(1) @binding(0) var<storage, read_write> shadowRayBuffer : array<vec2<u32>>;\r\n\r\n// 2x2 grid of offsets\r\nconst RAY_OFFSETS = array<vec2<u32>, 4>(\r\n  vec2<u32>(0,0),\r\n  vec2<u32>(1, 0),\r\n  vec2<u32>(0, 1),\r\n  vec2<u32>(1, 1)\r\n);\r\n\r\n@compute @workgroup_size(128, 1, 1)\r\nfn bufferMarch(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n) {\r\n  let bufferIndex = GlobalInvocationID.x / 4;\r\n  let localRayIndex = GlobalInvocationID.x % 4;\r\n  let pixel = shadowRayBuffer[bufferIndex];\r\n  let offsetPixel = pixel + RAY_OFFSETS[localRayIndex];\r\n  let result = tracePixel(vec2<i32>(offsetPixel), 1, vec2(0));\r\n  textureStore(outputTex, offsetPixel, vec4(result, 1.0));\r\n}\r\n\r\nconst PI = 3.1415926535897932384626433832795;\r\n\r\nfn polarToCartesian(angle: f32, radius: f32) -> vec2<f32> {\r\n  let radians = angle * PI / 180.0;\r\n  let x = radius * cos(radians);\r\n  let y = radius * sin(radians);\r\n  return vec2<f32>(x, y);\r\n}\r\n\r\nfn calculateVariance(neighborhood: array<vec3<f32>, 9>) -> f32 {\r\n    var mean: vec3<f32> = vec3<f32>(0.0);\r\n    var variance: f32 = 0.0;\r\n    // Calculate the mean\r\n    for (var i = 0; i < 9; i = i + 1) {\r\n        mean = mean + neighborhood[i];\r\n    }\r\n    mean = mean / 9.0;\r\n    // Calculate the variance\r\n    for (var i = 0; i < 9; i = i + 1) {\r\n        var diff = length(neighborhood[i] - mean);\r\n        variance = variance + diff * diff;\r\n    }\r\n\r\n    return variance / 9.0;\r\n}\r\n\r\n\r\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\r\n    vec2<i32>(-1, -1),\r\n    vec2<i32>(0, -1),\r\n    vec2<i32>(1, -1),\r\n    vec2<i32>(-1, 0),\r\n    vec2<i32>(1, 0),\r\n    vec2<i32>(-1, 1),\r\n    vec2<i32>(0, 1),\r\n    vec2<i32>(1, 1)\r\n);\r\n\r\nconst DEPTH_SENSITIVITY = 10000.0;\r\nconst BLUR_RADIUS = 2.0;\r\nconst GOLDEN_RATIO = 1.61803398875;\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn composite(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\r\n  let shadowRef = textureLoad(intermediaryTexture, pixel, 0);\r\n  let albedoRef = textureLoad(albedoTex, pixel, 0);\r\n  let inputRef = textureLoad(inputTex, pixel, 0);\r\n\r\n  textureStore(outputTex, pixel, shadowRef * albedoRef + inputRef);\r\n}\r\n`,hs=async()=>{const e=Ms.createBindGroupLayout({entries:cs}),t=Ms.createComputePipeline({label:ls,layout:Ms.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:Ms.createShaderModule({code:us}),entryPoint:"main"}});let n,r,i,s,o,a,l,c,u,h,d=Ms.createSampler({magFilter:"nearest",minFilter:"nearest"}),p=Ms.createSampler({magFilter:"linear",minFilter:"linear"});const f=await(async()=>{const e=Ms.createBindGroupLayout({entries:[...cs,ji]}),t=await Ms.createComputePipelineAsync({label:"diffuse - composite",layout:Ms.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:Ms.createShaderModule({code:us}),entryPoint:"composite"}});let n;return(r,i,s,o,a)=>{n||(n=((t,n,r)=>Ms.createBindGroup({layout:e,entries:[...t,{binding:2,resource:n},{binding:9,resource:r}]}))(i,o,a)),r.setPipeline(t),r.setBindGroup(0,n),r.dispatchWorkgroups(Math.ceil(s.width/16),Math.ceil(s.height/8))}})();return{render:m=>{const{outputTextures:g,timestampWrites:v,viewProjectionMatricesBuffer:y,volumeAtlas:x,cameraPositionBuffer:w,transformationMatrixBuffer:b,sunDirectionBuffer:_,blueNoiseTextureView:k,timeBuffer:S,bvhBuffer:A,commandEncoder:E}=m;if(n||(n=Ms.createTexture({size:[g.finalTexture.width,g.finalTexture.height,1],format:g.finalTexture.format,usage:g.finalTexture.usage}),r=n.createView()),!i){const e={size:[g.finalTexture.width,g.finalTexture.height,1],mipLevelCount:2,format:g.finalTexture.format,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST};i=Ms.createTexture(e),a=Ms.createTexture(e),u=Ms.createTexture(e),l=a.createView({baseMipLevel:0,mipLevelCount:1}),s=i.createView({baseMipLevel:0,mipLevelCount:1}),h=u.createView({baseMipLevel:0,mipLevelCount:1}),o=i.createView({baseMipLevel:1,mipLevelCount:1}),c=a.createView({baseMipLevel:1,mipLevelCount:1})}E.copyTextureToTexture({texture:g.finalTexture.texture},{texture:n},{width:g.finalTexture.width,height:g.finalTexture.height,depthOrArrayLayers:1});const T=[{binding:0,resource:g.depthTexture.view},{binding:1,resource:r},{binding:3,resource:{buffer:y}},{binding:4,resource:x.atlasTextureView},{binding:5,resource:{buffer:w}},{binding:6,resource:{buffer:b}},{binding:7,resource:{buffer:_}},{binding:8,resource:p},{binding:10,resource:g.normalTexture.view},{binding:11,resource:k},{binding:12,resource:{buffer:S}},{binding:13,resource:d},{binding:14,resource:g.velocityTexture.view},{binding:15,resource:{buffer:A}},{binding:16,resource:g.worldPositionTexture.view},{binding:17,resource:g.albedoTexture.view},{binding:18,resource:g.skyTexture.createView({dimension:"cube"})},{binding:19,resource:{buffer:x.octreeBuffer}}],P={layout:e,entries:[...T,{binding:2,resource:s}]};let M=E.beginComputePass({label:"shadow trace",timestampWrites:v});const C=Ms.createBindGroup(P);M.setPipeline(t),M.setBindGroup(0,C);const z=Math.ceil(g.finalTexture.width/16),I=Math.ceil(g.finalTexture.height/8);M.dispatchWorkgroups(z,I),M.end(),M=E.beginComputePass({label:"shadow composite",timestampWrites:{querySet:v.querySet,beginningOfPassWriteIndex:v.beginningOfPassWriteIndex+2,endOfPassWriteIndex:v.endOfPassWriteIndex+2}}),f(M,T,g.finalTexture.texture,g.finalTexture.view,s),M.end()},label:ls,timestampLabels:["shadow trace","shadow composite"]}},ds=async()=>{let e,t,n;const r=Ms.createComputePipeline({layout:"auto",compute:{module:Ms.createShaderModule({code:"// Helper function to compute luminance\r\nfn Luminance(color: vec3<f32>) -> f32 {\r\n    return dot(color, vec3<f32>(0.299, 0.587, 0.114));\r\n}\r\n\r\nfn rcp(x: f32) -> f32 {\r\n    return 1.0 / x;\r\n}\r\n\r\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\r\n\r\n//fn calculateWorldDisplacementFromVelocity(velocity: vec2<f32>, depth: f32) -> vec3<f32> {\r\n//    let worldDisplacement = vec3<f32>(velocity, depth);\r\n//    return worldDisplacement;\r\n//}\r\n\r\nfn calculateUvFromWorldPostion(worldPos: vec3<f32>, matrices: ViewProjectionMatrices) -> vec2<f32> {\r\n  let clipPos = matrices.viewProjection * vec4<f32>(worldPos, 1.0);\r\n  let uv = (matrices.inverseProjection * clipPos).xy;\r\n  return uv * 0.5 + 0.5;\r\n}\r\n\r\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\r\n    vec2<i32>(-1, -1),\r\n    vec2<i32>(0, -1),\r\n    vec2<i32>(1, -1),\r\n    vec2<i32>(-1, 0),\r\n    vec2<i32>(1, 0),\r\n    vec2<i32>(-1, 1),\r\n    vec2<i32>(0, 1),\r\n    vec2<i32>(1, 1)\r\n);\r\n\r\n@group(0) @binding(0) var CurrentColor : texture_2d<f32>;\r\n@group(0) @binding(1) var Velocity : texture_2d<f32>;\r\n@group(0) @binding(2) var HistoryWrite : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(3) var HistoryRead : texture_2d<f32>;\r\n@group(0) @binding(5) var Depth : texture_2d<f32>;\r\n@group(0) @binding(6) var linearSampler : sampler;\r\n@group(0) @binding(7) var nearestSampler : sampler;\r\n@group(0) @binding(8) var worldPosTex : texture_2d<f32>;\r\n//@group(0) @binding(9) var<uniform> viewProjectionMatrices : ViewProjectionMatrices;\r\n\r\nconst DEPTH_THRESHOLD : f32 = 4.0;\r\nconst MIN_SOURCE_BLEND = 0.075;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n    @builtin(global_invocation_id) id : vec3<u32>\r\n) {\r\n    let texSize = vec2<f32>(textureDimensions(CurrentColor));\r\n    let uv = (vec2<f32>(id.xy) + vec2(0.5)) / texSize;\r\n    let depthSample: f32 = textureLoad(Depth, id.xy, 0).r;\r\n\r\n    // Get velocity from pixel with closest depth value in 3x3 neighborhood\r\n    var closestDepthPixel = vec2<i32>(id.xy);\r\n    var closestDepth = 999999999.0;\r\n    for (var i = 0; i < 8; i = i + 1) {\r\n        let neighbourPixel = clamp(vec2<i32>(id.xy) + NEIGHBORHOOD_SAMPLE_POSITIONS[i], vec2<i32>(0), vec2<i32>(texSize - 1));\r\n        let neighbourDepth = textureLoad(Depth, neighbourPixel, 0).r;\r\n        if (abs(neighbourDepth - depthSample) < abs(closestDepth - depthSample)) {\r\n            closestDepth = neighbourDepth;\r\n            closestDepthPixel = neighbourPixel;\r\n        }\r\n    }\r\n\r\n    let velocity = textureLoad(Velocity, closestDepthPixel, 0).xy;\r\n    let pixelVelocity: vec2<f32> = velocity * texSize;\r\n    let previousPixel: vec2<i32> = vec2<i32>(id.xy) -  vec2<i32>(pixelVelocity);\r\n    let previousUv = uv - velocity;\r\n\r\n    let worldPos = textureLoad(worldPosTex, id.xy, 0).xyz;\r\n    let worldPosPrev = textureLoad(worldPosTex, previousPixel, 0).xyz;\r\n\r\n    var depthAtPreviousPixel: f32 = textureLoad(Depth, previousPixel, 0).r;\r\n\r\n    var sourceSample: vec3<f32> = textureSampleLevel(CurrentColor, nearestSampler, uv, 0).rgb;\r\n    var historySample: vec3<f32> = textureSampleLevel(HistoryRead, linearSampler, previousUv, 0).rgb;\r\n\r\n    // Calculate depth difference between source and history samples\r\n    let depthDifference: f32 = abs(depthSample - depthAtPreviousPixel);\r\n\r\n    // Apply depth clamping\r\n    if (depthDifference > DEPTH_THRESHOLD) {\r\n        return;\r\n    }\r\n//\r\n    // Clamp the history sample to the min and max of the 3x3 neighborhood\r\n    var minCol: vec3<f32> = sourceSample;\r\n    var maxCol: vec3<f32> = sourceSample;\r\n    for (var x: i32 = -1; x <= 1; x = x + 1) {\r\n        for (var y: i32 = -1; y <= 1; y = y + 1) {\r\n            let neighbourPixel = clamp(vec2(i32(id.x) + x, i32(id.y) + y), vec2(0), vec2(i32(texSize.x - 1), i32(texSize.y - 1)));\r\n            let s: vec3<f32> = textureLoad(CurrentColor, neighbourPixel, 0).rgb;\r\n            minCol = min(minCol, s);\r\n            maxCol = max(maxCol, s);\r\n        }\r\n    }\r\n    historySample = clamp(historySample, minCol, maxCol);\r\n\r\n    var sourceWeight: f32 = clamp(length(velocity), MIN_SOURCE_BLEND, 1.0);\r\n    var historyWeight: f32 = 1.0 - sourceWeight;\r\n    let compressedSource: vec3<f32> = sourceSample * rcp(max(max(sourceSample.r, sourceSample.g), sourceSample.b) + 1.0);\r\n    let compressedHistory: vec3<f32> = historySample * rcp(max(max(historySample.r, historySample.g), historySample.b) + 1.0);\r\n    let luminanceSource: f32 = Luminance(compressedSource);\r\n    let luminanceHistory: f32 = Luminance(compressedHistory);\r\n    sourceWeight *= 1.0 / (1.0 + luminanceSource);\r\n    historyWeight *= 1.0 / (1.0 + luminanceHistory);\r\n    let result: vec3<f32> = (sourceSample * sourceWeight + historySample * historyWeight) / max(sourceWeight + historyWeight, 0.0001);\r\n\r\n    textureStore(HistoryWrite, id.xy, vec4<f32>(result, 1.0));\r\n}\r\n"}),entryPoint:"main"}});let i;return{render:({commandEncoder:s,timestampWrites:o,outputTextures:a,viewProjectionMatricesBuffer:l})=>{e||(e=Ms.createTexture({label:"TAA History Texture",size:[Cs[0],Cs[1],1],format:et,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),i=e.createView()),t||(t=Ms.createTexture({size:[Cs[0],Cs[1],1],format:et,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),n=t.createView()),s.copyTextureToTexture({texture:a.finalTexture.texture},{texture:t},{width:t.width,height:t.height,depthOrArrayLayers:1});const c=s.beginComputePass({timestampWrites:o});c.setPipeline(r);const u=Ms.createBindGroup({layout:r.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:a.velocityTexture.view},{binding:2,resource:a.finalTexture.view},{binding:3,resource:i},{binding:5,resource:a.depthTexture.view},{binding:6,resource:Ms.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})},{binding:7,resource:Ms.createSampler({magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest"})},{binding:8,resource:a.worldPositionTexture.view}]});c.setBindGroup(0,u),c.dispatchWorkgroups(Cs[0]/8,Cs[1]/8),c.end(),s.copyTextureToTexture({texture:a.finalTexture.texture},{texture:e},{width:e.width,height:e.height,depthOrArrayLayers:1})},label:"taa"}},ps={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},fs={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},ms={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:et}},gs={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},vs={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},ys={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},xs={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},ws={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},bs={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},_s=(GPUShaderStage.COMPUTE,[ps,fs,ms,gs,vs,ys,xs,ws,bs,{binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},{binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},{binding:19,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]),ks=async({shaderCode:e,entryPoint:t,label:n})=>{const r=Ms.createBindGroupLayout({entries:_s}),i=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${et}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\n${qi}\n${We}\n${He}\n${Ye}\n${Xe}\n${Ze}\n${Li}\n${e}`,s=Ms.createComputePipeline({layout:Ms.createPipelineLayout({bindGroupLayouts:[r]}),compute:{module:Ms.createShaderModule({code:i}),entryPoint:t}});let o,a,l,c=Ms.createSampler({magFilter:"nearest",minFilter:"nearest"}),u=Ms.createSampler({magFilter:"linear",minFilter:"linear"});return{render:({commandEncoder:e,outputTextures:t,timestampWrites:n,viewProjectionMatricesBuffer:i,volumeAtlas:h,cameraPositionBuffer:d,transformationMatrixBuffer:p,sunDirectionBuffer:f,blueNoiseTextureView:m,timeBuffer:g,bvhBuffer:v})=>{if(o||(o=Ms.createTexture({size:[t.finalTexture.width,t.finalTexture.height,1],format:t.finalTexture.format,usage:t.finalTexture.usage}),a=o.createView()),e.copyTextureToTexture({texture:t.finalTexture.texture},{texture:o},{width:t.finalTexture.width,height:t.finalTexture.height,depthOrArrayLayers:1}),!l){const e=[{binding:0,resource:t.depthTexture.view},{binding:1,resource:a},{binding:2,resource:t.finalTexture.view},{binding:3,resource:{buffer:i}},{binding:4,resource:h.atlasTextureView},{binding:5,resource:{buffer:d}},{binding:6,resource:{buffer:p}},{binding:7,resource:{buffer:f}},{binding:8,resource:u},{binding:10,resource:t.normalTexture.view},{binding:11,resource:m},{binding:12,resource:{buffer:g}},{binding:13,resource:c},{binding:14,resource:t.velocityTexture.view},{binding:15,resource:{buffer:v}},{binding:16,resource:t.worldPositionTexture.view},{binding:17,resource:t.albedoTexture.view},{binding:18,resource:t.skyTexture.createView({dimension:"cube"})},{binding:19,resource:{buffer:h.octreeBuffer}}],n={layout:r,entries:e};l=Ms.createBindGroup(n)}const y=e.beginComputePass({timestampWrites:n});y.setPipeline(s),y.setBindGroup(0,l),y.dispatchWorkgroups(Math.ceil(t.finalTexture.width/8),Math.ceil(t.finalTexture.height/8)),y.end()},label:n}},Ss=async()=>ks({shaderCode:"const TARGET_DELTA_TIME: f32 = 16.66;\r\nconst MAX_SAMPLES: i32 = 8;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  var velocity = textureLoad(velocityAndWaterTex, pixel, 0).xy;\r\n  let resolution = textureDimensions(inputTex);\r\n  let centerOfPixel = vec2<f32>(GlobalInvocationID.xy) + vec2<f32>(0.5);\r\n  var uv = centerOfPixel / vec2<f32>(resolution);\r\n  let blurScale = (TARGET_DELTA_TIME / time.deltaTime); // less blur when framerate is high\r\n  let scaledVelocity = velocity * blurScale;\r\n  var samples = MAX_SAMPLES;\r\n  var validSamples = 0.0;\r\n  var result = vec4<f32>(0.0);\r\n  for (var i = 0; i < samples; i++) {\r\n    var offset = scaledVelocity * (f32(i) / f32(samples - 1) - 0.5);\r\n    let offsetUv = uv + offset;\r\n    let textureSample = textureSampleLevel(inputTex, nearestSampler, offsetUv, 0.0);\r\n    result += textureSample;\r\n    validSamples += 1.0;\r\n  }\r\n  result /= validSamples;\r\n  textureStore(outputTex, pixel, result);\r\n}",entryPoint:"main",label:"motion blur"}),As=async()=>ks({shaderCode:"fn uncharted2_tonemap_partial(x: vec3<f32>) -> vec3<f32>\r\n{\r\n    let A = 0.15f;\r\n    let B = 0.50f;\r\n    let C = 0.10f;\r\n    let D = 0.20f;\r\n    let E = 0.02f;\r\n    let F = 0.30f;\r\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\r\n}\r\n\r\nfn luminance(v: vec3<f32>) -> f32\r\n{\r\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn reverse_aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(v*(c-e)-b))/(a-v*(d-e)), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn uncharted2_filmic(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let exposure_bias = 0.3f;\r\n    let curr = uncharted2_tonemap_partial(v * exposure_bias);\r\n    let W = vec3(11.2f);\r\n    let white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\r\n    return curr * white_scale;\r\n}\r\n\r\nfn reinhard_jodie(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let l = luminance(v);\r\n    let tv = v / (1.0f + v);\r\n    return mix(v / (1.0f + l), tv, tv);\r\n}\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  let inputSample = textureLoad(inputTex, pixel, 0);\r\n  let toneMapped = uncharted2_filmic(inputSample.rgb);\r\n//  let gammaCorrected = pow(toneMapped, vec3(1.0f / 0.3f));\r\n  textureStore(outputTex,pixel,vec4(toneMapped,1));\r\n}",entryPoint:"main",label:"tonemap"});new class{#m;#g;#v;#y;constructor(){this.#m=new jn(1),this.#g=new jn(0),this.#v=new jn(0),this.#y=new jn(.8)}set targetScale(e){this.#m.target=e}set targetTranslateX(e){this.#g.target=e}set targetRotateY(e){this.#v.target=e}set targetSunRotateY(e){this.#y.target=e}get targetScale(){return this.#m.target}get targetTranslateX(){return this.#g.target}get targetRotateY(){return this.#v.target}get targetSunRotateY(){return this.#y.target}get sunRotateY(){return this.#y.value}get scale(){return this.#m.value}get translateX(){return this.#g.value}};let Es,Ts,Ps,Ms,Cs=C.create(4,4),zs=0,Is=zs,Bs=0,Os=0;const Ns=new class{gui;timingsFolder;passesFolder;constructor(){this.gui=new St,this.timingsFolder=this.gui.addFolder("timings"),this.passesFolder=this.gui.addFolder("passes")}log(e){Object.keys(e).forEach((t=>{const n=this.timingsFolder.controllers.find((e=>e.property===t));n?n.setValue(e[t].toFixed(2)):this.timingsFolder.add(e,t)}))}setupDebugControls(e){const t=e.reduce(((e,t)=>(e[t.label]=!0,e)),{});e.forEach((e=>{this.passesFolder.add(t,e.label)}))}},Us=(()=>{let e={};const t=t=>{const n=e[t];return n?n.reduce(((e,t)=>e+t))/n.length:0};return{addSample:(t,n)=>{e[t]||(e[t]=[]),e[t].push(n)>50&&e[t].shift()},clearEntry:t=>{e[t]&&(e[t]=[0])},toString:()=>Object.keys(e).map((e=>`${e}: ${t(e).toFixed(2)}ms`)).join("\n"),toHTML:()=>Object.keys(e).map((e=>`<div class="debug-row">\n                    <div>\n                        ${e}\n                    </div>\n                   <div>${t(e).toFixed(2)}ms</div>\n                </div>`)).join("\n"),getAverages:()=>Object.keys(e).reduce(((e,n)=>(e[n]=t(n),e)),{})}})();Us.addSample("frame time",0);let Rs,Ds,Fs,Ls,qs,js,Vs,Gs,$s,Ws,Hs,Ys,Xs,Zs,Ks,Qs,Js,eo,to,no,ro,io,so,oo=ve.create();Ds=Array.from({length:200}).map((()=>({position:[-80*Math.random(),50*Math.random(),-200*Math.random()],size:4,color:te.normalize(te.create(Math.random(),Math.random(),Math.random()))})));const ao=async(e,t,n,r)=>{if(Ms=e,Ps=t,!navigator.gpu)throw new Error("WebGPU not supported");co=((e,t,n)=>{const r=new Float32Array(t),i=e.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"camera position"});return $e(i,t),i})(Ms,[0,0,0,0]),lo(Ms),eo=new Ii(Ms,[]),Rs=Ms.createTexture({label:"sky texture",dimension:"2d",size:[640,640,6],format:"rgba16float",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),Fs=await Promise.all([Oi(),ct(),(async()=>({label:"copy albedo",render:e=>{((e,t,n)=>{if(t.width!==n.width||t.height!==n.height)throw new Error("Source and destination textures must have the same dimensions");e.copyTextureToTexture({texture:t.texture},{texture:n.texture},{width:t.texture.width,height:t.texture.height,depthOrArrayLayers:1})})(e.commandEncoder,e.outputTextures.albedoTexture,e.outputTextures.finalTexture)}}))(),hs(),ds(),As(),Ss(),At(Ms)]),so=Fs.reduce(((e,t)=>t.timestampLabels?e.concat(t.timestampLabels):e.concat(t.label)),[]),Ns.setupDebugControls(Fs),Ts=document.getElementById("webgpu-canvas"),Ts.style.imageRendering="pixelated",Es=Ts.getContext("webgpu"),Es.configure({device:Ms,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT}),ro=Ms.createSampler({magFilter:"linear",minFilter:"linear"}),io=Ms.createSampler({magFilter:"nearest",minFilter:"nearest"}),Ms.features.has("timestamp-query")&&(to=Ms.createQuerySet({type:"timestamp",count:1e3}),no=Ms.createBuffer({label:"timestamp query",size:8*to.count,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}));const{clientWidth:i,clientHeight:s}=Ts.parentElement,o=C.create(1*i,1*s);Cs=C.mulScalar(o,1),Ts.width=o[0],Ts.height=o[1],Ts.style.transform="scale(1)"},lo=async e=>{const t=await async function(e,t,n={}){return Pi(e,[t],n)}(e,"blue-noise-rg.png",{usage:GPUTextureUsage.COPY_SRC});Ws=t.createView()};let co;setInterval((()=>{Ns.log(Us.getAverages())}),500);let uo=0;const ho=(e,t,n,r,i)=>{if(!Ms||!Fs||!Ps)return;const s=Ms.createCommandEncoder();0===zs&&(zs=e),s.pushDebugGroup("frame");const o=e-zs;Bs=o-Is,Us.addSample("frame time",Bs),Is=o,Os++,((e,t)=>{const n=function(e,t,n,r,i,s){const o=2*Math.tan(r/2)*s,a=o*i,l=1/t,c=1/n;return[(Ni(e,2)-.5)*l*a,(Ni(e,3)-.5)*c*o]}(Os,Cs[0],Cs[1],"fieldOfView"in e.config?e.config.fieldOfView:90,Cs[0]/Cs[1],"near"in e.config?e.config.near:.1),r=function(e,t){const n=new Float32Array(e);return n[8]+=t[0],n[9]+=t[1],n}(e.projectionMatrix,n),i=(e=>{const t=e.position;return ve.lookAt(t,te.add(t,e.direction),e.up)})(t),s=ve.mul(r,i);Qs=new Float32Array([...s,...oo,...ve.invert(s),...ve.invert(oo),...r,...ve.invert(r),...i]),Zs||(Zs=Ms.createBuffer({size:Qs.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"view matrices buffer"})),Ms.queue.writeBuffer(Zs,0,Qs.buffer,0,Qs.length*Float32Array.BYTES_PER_ELEMENT);const o=ve.mul((a=r,ve.invert(a)),s);var a;const l=ve.invert(o);Js=new Float32Array(ve.getTranslation(l)),Ms.queue.writeBuffer(co,0,Js.buffer,0,Js.length*Float32Array.BYTES_PER_ELEMENT),oo=s})(n,r),((e,t,n)=>{const r=76*n.length;Xs&&r===Xs.size||(Xs=e.createBuffer({size:r*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"voxel objects buffer"})),n.forEach(((n,r)=>{const i=((e,t)=>{const n=((e,t)=>[...t.transform,...ve.invert(t.transform),...t.previousTransform,...ve.invert(t.previousTransform),...e.size,0,...e.atlasLocation,e.paletteIndex])(e,t),r=4*(n.length+1),i=new DataView(new ArrayBuffer(r));for(let e=0;e<n.length-1;e++)i.setFloat32(4*e,n[e],!0);return i.setUint32(r-4,e.octreeBufferIndex,!0),i})(t.getComponents(n).get(Fi),t.getComponents(n).get(Di)).buffer;e.queue.writeBuffer(Xs,76*r*Float32Array.BYTES_PER_ELEMENT,i,0,i.byteLength)}))})(Ms,t,i),Hs||(Hs=Ge([Os,0,0],"time buffer")),Ms.queue.writeBuffer(Hs,4,new Float32Array([Bs])),Ms.queue.writeBuffer(Hs,0,new Uint32Array([Os])),Ms.queue.writeBuffer(Hs,8,new Float32Array([Is/1e3])),Ys?Ve(Ys,[Cs[0],Cs[1]]):Ys=Ge([Cs[0],Cs[1]]),(()=>{let e=Math.cos(Is/5e3),t=Math.sin(Is/5e3);const n=te.create(e,1,t);Ks?$e(Ks,[n[0],n[1],n[2]]):Ks=Ge([n[0],n[1],n[2]],"sun buffer")})(),uo!==i.length&&eo.update(i.map((e=>((e,t)=>{const n=te.create(e.size[0]/2,e.size[1]/2,e.size[2]/2);return(e=>{let t=te.create(1/0,1/0,1/0),n=te.create(-1/0,-1/0,-1/0);for(const r of e)t=te.min(t,r),n=te.max(n,r);return{min:t,max:n}})([te.create(-n[0],-n[1],-n[2]),te.create(-n[0],-n[1],n[2]),te.create(-n[0],n[1],-n[2]),te.create(-n[0],n[1],n[2]),te.create(n[0],-n[1],-n[2]),te.create(n[0],-n[1],n[2]),te.create(n[0],n[1],-n[2]),te.create(n[0],n[1],n[2])].map((e=>te.transformMat4(e,t.transform))))})(t.getComponents(e).get(Fi),t.getComponents(e).get(Di))))),uo=i.length,qs=new rt(Ms,Cs[0],Cs[1]),Ls=new it(Ms,Cs[0],Cs[1]),Vs=new st(Ms,Cs[0],Cs[1]),Gs=new ot(Ms,Cs[0],Cs[1]),js=new lt(Ms,Cs[0],Cs[1]),$s=new at(Ms,Cs[0],Cs[1]);let a=0;Fs.forEach(((e,o)=>{const{render:l,label:c}=e;if(!1===Ns.passesFolder.controllers.find((e=>e.property===c))?.getValue())return;let u;Ms.features.has("timestamp-query")&&s.clearBuffer(no),Ms.features.has("timestamp-query")&&(u={querySet:to,beginningOfPassWriteIndex:a,endOfPassWriteIndex:a+1}),c&&s.pushDebugGroup(c),l({enabled:document.getElementById(`flag-${c}`)?.checked,commandEncoder:s,resolutionBuffer:Ys,timeBuffer:Hs,outputTextures:{finalTexture:js,albedoTexture:qs,normalTexture:Ls,depthTexture:Vs,skyTexture:Rs,velocityTexture:Gs,worldPositionTexture:$s},cameraPositionBuffer:co,volumeAtlas:Ps,transformationMatrixBuffer:Xs,viewProjectionMatricesArray:Qs,viewProjectionMatricesBuffer:Zs,timestampWrites:u,sunDirectionBuffer:Ks,blueNoiseTextureView:Ws,bvhBuffer:eo.gpuBuffer,lights:Ds,linearSampler:ro,nearestSampler:io,camera:n,cameraTransform:r,renderableEntities:i,ecs:t,device:Ms}),e.timestampLabels?.length>0?a+=2*e.timestampLabels.length:a+=2,c&&s.popDebugGroup()})),s.popDebugGroup(),Ms.features.has("timestamp-query")&&(async(e,t,n)=>{const r=n.size;Ui||(Ui=Ms.createBuffer({size:r,label:"gpu read buffer",usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}));const i=Ms.createCommandEncoder();if(Ri)return;Ri=!0,i.resolveQuerySet(t,0,t.count,n,0),i.copyBufferToBuffer(n,0,Ui,0,r),Ms.queue.submit([i.finish()]),await Ms.queue.onSubmittedWorkDone(),await Ui.mapAsync(GPUMapMode.READ).finally((()=>{Ri=!1}));const s=Ui.getMappedRange(),o=new BigInt64Array(s),a=[];o.forEach((e=>{a.push(Number(e)/1e6)})),a.reduce(((e,t,n)=>(n%2==0&&e.push(a[n+1]-t),e)),[]).forEach(((t,n)=>{Us.addSample(e[n],t)})),Ui.unmap()})(so,to,no),Ms.queue.submit([s.finish()])};class po extends e{config;constructor(e){super(),this.config=e}get projectionMatrix(){return"size"in this.config?ve.ortho(-Cs[0]/this.config.size,Cs[0]/this.config.size,-Cs[1]/this.config.size,Cs[1]/this.config.size,this.config.size,-this.config.size):ve.perspective(this.config.fieldOfView,Cs[0]/Cs[1],this.config.near,this.config.far)}}class fo{index;dataView;constructor(e){this.dataView=new DataView(e),this.index=0}readUint8(){const e=this.dataView.getUint8(this.index);return this.index++,e}readUint32(){const e=this.dataView.getUint32(this.index,!0);return this.index+=4,e}readFloat32(){const e=this.dataView.getFloat32(this.index,!0);return this.index+=4,e}skip(e){this.index+=e}}const mo=e=>0===e,go=e=>[1&e?1:0,2&e?1:0,4&e?1:0];let vo=0;class yo{nodes;#x;#w;constructor(e){var t;this.nodes=[],this.#x=0,this.#w=(t=e.SIZE,Math.ceil(Math.log2(Math.max(...t)))),this.#d(e,0,[0,0,0],0),vo/=this.nodes.length,console.log(`Average first child index: ${vo}`),console.log(this.nodes.slice(0,10))}#b(e=8){return this.#x+=e,this.#x-(e-1)}#d(e,t,n,r){if(1===e.SIZE[0]){const r=e.XYZI[0].c;return void(this.nodes[t]={red:e.RGBA[r].r,green:e.RGBA[r].g,blue:e.RGBA[r].b,x:n[0],y:n[1],z:n[2],size:e.SIZE[0]})}const i=Array.from({length:8},(()=>null)),s=r+1,o=(e=>Math.pow(2,Math.ceil(Math.log2(e))))(Math.max(...e.SIZE)),a=o/2;for(let t=0;t<8;t++){const r=go(t),s=n[0]+r[0]*a,o=n[1]+r[1]*a,l=n[2]+r[2]*a,c=e.XYZI.filter((e=>e.x>=s&&e.x<s+a&&e.y>=o&&e.y<o+a&&e.z>=l&&e.z<l+a));c.length>0&&(i[t]={SIZE:[a,a,a],XYZI:c,RGBA:e.RGBA,VOX:c.length})}let l=0;const c=i.reduce(((e,t,n)=>t?(l=n+1,e|1<<n):e),0),u=this.#b(l),h=u-t;i.forEach(((e,t)=>{if(e){const r=u+t,i=go(t),o=n[0]+i[0]*a,l=n[1]+i[1]*a,c=n[2]+i[2]*a;this.#d(e,r,[o,l,c],s)}})),vo+=u,this.nodes[t]={firstChildIndex:h,childMask:c,voxels:{...e,SIZE:[o,o,o]},x:n[0],y:n[1],z:n[2],size:o,leafMask:0}}get totalSize(){return 8*this.nodes.length}}const xo=async(e,t,n)=>{console.time(`Fetch ${e}`);const r=await fetch(e);console.timeEnd(`Fetch ${e}`);const i=(e=>{console.time("convert vxm");const t=new fo(e);let n,r=[],i="",s=[];if(i=String.fromCodePoint(t.readUint8(),t.readUint8(),t.readUint8(),t.readUint8()),"VXMC"!==i&&"VXMA"!==i)throw new Error(`Incorrect magic: ${i}`);if(i[3].charCodeAt(0)>="0".charCodeAt(0)&&i[3].charCodeAt(0)<="9".charCodeAt(0))n=i[3].charCodeAt(0)-"0".charCodeAt(0);else{if(!(i[3].charCodeAt(0)>="A".charCodeAt(0)&&i[3].charCodeAt(0)<="C".charCodeAt(0)))throw new Error("Unsupported version found");n=10+i[3].charCodeAt(0)-"A".charCodeAt(0)}if(n<11||n>12)throw new Error(`Could not load vxm file: Unsupported version found (${n})`);let o=[0,0,0];o[0]=t.readUint32(),o[1]=t.readUint32(),o[2]=t.readUint32();let a=[.5,0,.5];if(a[0]=t.readFloat32(),a[1]=t.readFloat32(),a[2]=t.readFloat32(),t.readUint8()>0){let e=0,n=0;t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),e=t.readUint32(),n=t.readUint32();let r=e*n;t.skip(4*r)}n>=8&&t.skip(16);let l=t.readUint32();for(let e=0;e<l;++e){let e=t.readUint32(),n=t.readUint32();if(e>2048||n>2048)throw new Error("Size of texture exceeds the max allowed value");let r=t.readUint32();t.skip(r);for(let e=0;e<6;++e){let e=t.readUint32();e>262144&&console.warn(`Size of quads exceeds the max allowed value: ${e}`);let n=4*e*20;t.skip(n)}}t.skip(1024),t.skip(1024);let c=t.readUint8();for(let e=0;e<c;++e)t.skip(1024),t.readUint8(),t.readUint8();let u=t.readUint8();for(let e=0;e<u;++e){let n=t.readUint8(),i=t.readUint8(),s=t.readUint8(),o=t.readUint8();o=1===t.readUint8()?2:255,r[e]={r:s,g:i,b:n,a:o}}let h=1;n>=12&&(h=t.readUint8());let d={min:te.create(9999,9999,9999),max:te.create(0,0,0)};for(let e=0;e<h;++e){let r=0,i=!0,a="";if(n>=12){for(;;){const e=t.readUint8();if(mo(e))break;a=`${a}${String.fromCharCode(e)}`}i=t.readUint8()>0}else a=`Layer ${e}`;for(;;){let e=t.readUint8();if(0===e)break;let n=t.readUint8();if(255!==n)if(n>=u)r+=e;else{for(let t=r;t<r+e;t++){let e=Math.floor(t/(o[1]*o[2])),r=Math.floor(t/o[2]%o[1]),i=Math.floor(t%o[2]);d.min=te.min(d.min,[e,r,i]),d.max=te.max(d.max,[e,r,i]),s.push({x:e,y:r,z:i,c:n})}r+=e}else r+=e}}s=s.map((({x:e,y:t,z:n,c:r})=>({x:e-d.min[0],y:t-d.min[1],z:n-d.min[2],c:r})));const p=te.sub(d.max,d.min);return console.timeEnd("convert vxm"),{VOX:s.length,SIZE:[p[0]+1,p[1]+1,p[2]+1],XYZI:s,RGBA:r}})(await r.arrayBuffer());console.time(`Create octree for ${e}`);const s=(e=>{const t=new ArrayBuffer(e.totalSize+8),n=new DataView(t);return e.nodes.forEach(((e,t)=>{"red"in e?((e,t,n)=>{e.setUint8(8*t,0),e.setUint8(8*t+1,n.x),e.setUint8(8*t+2,n.y),e.setUint8(8*t+3,n.z),e.setUint8(8*t+4,n.red),e.setUint8(8*t+5,n.green),e.setUint8(8*t+6,n.blue),e.setUint8(8*t+7,Math.log2(n.size))})(n,t,e):((e,t,n)=>{console.assert(n.firstChildIndex<2**24-1,`First child index of ${n.firstChildIndex} is too large to fit in 3 bytes`),console.assert(n.x<256,`X position of ${n.x} is too large to fit in 1 byte`),console.assert(n.y<256,`Y position of ${n.y} is too large to fit in 1 byte`),console.assert(n.z<256,`Z position of ${n.z} is too large to fit in 1 byte`),e.setUint8(8*t,n.childMask),e.setUint8(8*t+1,n.x),e.setUint8(8*t+2,n.y),e.setUint8(8*t+3,n.z),e.setUint32(8*t+4,n.firstChildIndex,!0),e.setUint8(8*t+7,Math.log2(n.size))})(n,t,e)})),console.debug(`Created ${e.nodes.length} node octree of size ${(e.totalSize/1048576).toFixed(3)} MB`),t})(new yo(i));console.timeEnd(`Create octree for ${e}`),await n.addVolume(e,i.SIZE,s)},wo=async(e,t,n)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const r=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const n=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:t.mipLevelCount}),r=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let i=0;i<t.depthOrArrayLayers>>e;i++)r.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:i}},{texture:n,mipLevel:e,origin:{x:0,y:0,z:i}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([r.finish()]),await e.queue.onSubmittedWorkDone(),n})(e,t),i=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),s=e.createBuffer({size:256*t.depthOrArrayLayers,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.UNIFORM,label:"z indices buffer"}),o=Array.from({length:t.depthOrArrayLayers},((e,t)=>t));for(let t=0;t<o.length;t++)e.queue.writeBuffer(s,256*t,new Uint32Array([o[t]]).buffer);const a=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[i]}),vertex:{module:e.createShaderModule({code:"\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n          }\n          const pos = array(\n              vec2( 1.0,  1.0),\n              vec2( 1.0, -1.0),\n              vec2(-1.0, -1.0),\n              vec2( 1.0,  1.0),\n              vec2(-1.0, -1.0),\n              vec2(-1.0,  1.0),\n            );\n          @vertex\n          fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            var output : VertexOutput;\n            output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n            return output;\n          }"}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:"\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> zIndex: u32;\n          @fragment\r\nfn fragment_main(@builtin(position) position : vec4<f32>) -> @location(0) vec4<f32> {\r\n  let srcTexel = vec3(vec2<u32>(position.xy),zIndex);\r\n  var colours = array<f32, 8>();\r\n  var isOctantEmpty = true;\r\n  for(var x = u32(0); x < 2; x++){\r\n    for(var y = u32(0); y < 2; y++){\r\n      for(var z = u32(0); z < 2; z++){\r\n        let voxelX = srcTexel.x * 2 + x;\r\n        let voxelY = srcTexel.y * 2 + y;\r\n        let voxelZ = srcTexel.z * 2 + z;\r\n        var voxelId = vec3<u32>(voxelX,voxelY,voxelZ);\r\n        var voxel = textureLoad(voxels,voxelId,0).r;\r\n        if(voxel > 0){\r\n          var index = x + y * 2 + z * 4;\r\n          colours[index] = voxel;\r\n          isOctantEmpty = false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // If all voxels in the octant are empty, keep it blank\r\n  if(isOctantEmpty){\r\n    discard;\r\n  }\r\n\r\n  // Get the most common colour in the octant\r\n  var mostCommonColour = f32(0);\r\n  var mostCommonColourCount = u32(0);\r\n  for(var i = u32(0); i < 8; i = i + 1u){\r\n    var colour = colours[i];\r\n    var count = u32(0);\r\n    for(var j = u32(0); j < 8; j = j + 1u){\r\n      if(colour > 0 && colour == colours[j]){\r\n        count++;\r\n      }\r\n    }\r\n    if(count > mostCommonColourCount){\r\n      mostCommonColour = colour;\r\n      mostCommonColourCount = count;\r\n    }\r\n  }\r\n\r\n  return vec4(mostCommonColour, 0,0,0);\r\n}\r\n\r\n\n        "}),entryPoint:"fragment_main",targets:[{format:t.format}]}}),l=e.createCommandEncoder(),c=Math.max(1,t.depthOrArrayLayers>>n);for(let o=0;o<c;o++){const c=e.createBindGroup({layout:i,entries:[{binding:0,resource:t.createView({label:`${n} mip level of volume texture`,dimension:"3d",baseMipLevel:n-1,mipLevelCount:1})},{binding:1,resource:{buffer:s,offset:256*o,size:4}}]}),u=l.beginRenderPass({colorAttachments:[{view:r.createView({label:"volume slice for rendering mips",baseArrayLayer:o,arrayLayerCount:1,baseMipLevel:n,mipLevelCount:1,dimension:"2d-array"}),loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});u.setPipeline(a),u.setBindGroup(0,c),u.draw(6),u.end()}return e.queue.submit([l.finish()]),await e.queue.onSubmittedWorkDone(),await(async(e,t)=>{if("2d"!==t.dimension)throw new Error("Input texture should be a 2D texture");const n=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d",mipLevelCount:t.mipLevelCount}),r=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let i=0;i<t.depthOrArrayLayers>>e;i++)r.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:i}},{texture:n,mipLevel:e,origin:{x:0,y:0,z:i}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([r.finish()]),await e.queue.onSubmittedWorkDone(),n})(e,r)},bo={format:"r8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d"},_o=Math.pow(2,3),ko=(e,t)=>{if(4!==t.length)throw new Error("Sequence must be exactly 4 characters long");const n=new Uint8Array(4);for(let e=0;e<4;e++)n[e]=t.charCodeAt(e);const r=[];for(let t=0;t<=e.length-4;t++)e[t]===n[0]&&e[t+1]===n[1]&&e[t+2]===n[2]&&e[t+3]===n[3]&&r.push(t);return r};class So{#_={};#k;#S;#a;#A;#E;#T;constructor(e){this.#a=e,this.#k=e.createTexture({size:{width:_o,height:_o,depthOrArrayLayers:_o},...bo,label:"Volume atlas containing ",mipLevelCount:4}),this.#S=e.createTexture({size:{width:256,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1}),this.#A=this.#k.createView(),this.#E=this.#S.createView(),this.#T=e.createBuffer({size:0,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,label:"Octree buffer"})}get dictionary(){return this.#_}addVolume=async(e,t,n)=>{if(this.#_[e])throw new Error(`Error adding volume to atlas: volume with label ${e} already exists`);const r=this.#a.createCommandEncoder(),[i,s,o]=t,a=this.#T.size/8;this.#_[e]={location:[0,0,0],size:[i,s,o],paletteIndex:0,octreeOffset:a,octreeSizeBytes:n.byteLength,textureSizeBytes:i*s*o};const l=this.#a.createBuffer({label:"Octree buffer",size:this.#T.size+n.byteLength,usage:this.#T.usage});r.copyBufferToBuffer(this.#T,0,l,0,this.#T.size),this.#a.queue.submit([r.finish()]),console.log(`writing ${e} at byte offset ${this.#T.size}, index ${a}`),this.#a.queue.writeBuffer(l,this.#T.size,n),await this.#a.queue.onSubmittedWorkDone();const c=this.#a.createCommandEncoder(),u=this.#a.createBuffer({size:l.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1});c.copyBufferToBuffer(l,0,u,0,l.size),this.#a.queue.submit([c.finish()]),u.mapAsync(GPUMapMode.READ).then((()=>{const e=new Uint8Array(u.getMappedRange());console.log({magicIndices:ko(e,"OCTR")}),console.log({length:e.length/4})})),this.#T=l,this.#T.unmap(),this.#k=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");let n=t;for(let r=1;r<t.mipLevelCount;r++)n=await wo(e,n,r);return n})(this.#a,this.#k),this.#A=this.#k.createView(),this.#E=this.#S.createView()};get atlasTextureView(){return this.#A}get paletteTextureView(){return this.#E}get octreeBuffer(){return this.#T}}class Ao extends e{device;volumeAtlas}class Eo{pressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1," ":!1,shift:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1})),window.addEventListener("blur",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))})),window.addEventListener("contextmenu",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))}))}}class To extends e{speed=.05;rotationSpeed=.002}class Po{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new Co);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new Co);const n=this.elements,r=e.x,i=e.y,s=e.z;return t.x=n[0]*r+n[1]*i+n[2]*s,t.y=n[3]*r+n[4]*i+n[5]*s,t.z=n[6]*r+n[7]*i+n[8]*s,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new Po);const n=this.elements,r=e.elements,i=t.elements,s=n[0],o=n[1],a=n[2],l=n[3],c=n[4],u=n[5],h=n[6],d=n[7],p=n[8],f=r[0],m=r[1],g=r[2],v=r[3],y=r[4],x=r[5],w=r[6],b=r[7],_=r[8];return i[0]=s*f+o*v+a*w,i[1]=s*m+o*y+a*b,i[2]=s*g+o*x+a*_,i[3]=l*f+c*v+u*w,i[4]=l*m+c*y+u*b,i[5]=l*g+c*x+u*_,i[6]=h*f+d*v+p*w,i[7]=h*m+d*y+p*b,i[8]=h*g+d*x+p*_,t}scale(e,t){void 0===t&&(t=new Po);const n=this.elements,r=t.elements;for(let t=0;3!==t;t++)r[3*t+0]=e.x*n[3*t+0],r[3*t+1]=e.y*n[3*t+1],r[3*t+2]=e.z*n[3*t+2];return t}solve(e,t){void 0===t&&(t=new Co);const n=[];let r,i;for(r=0;r<12;r++)n.push(0);for(r=0;r<3;r++)for(i=0;i<3;i++)n[r+4*i]=this.elements[r+3*i];n[3]=e.x,n[7]=e.y,n[11]=e.z;let s=3;const o=s;let a,l;do{if(r=o-s,0===n[r+4*r])for(i=r+1;i<o;i++)if(0!==n[r+4*i]){a=4;do{l=4-a,n[l+4*r]+=n[l+4*i]}while(--a);break}if(0!==n[r+4*r])for(i=r+1;i<o;i++){const e=n[r+4*i]/n[r+4*r];a=4;do{l=4-a,n[l+4*i]=l<=r?0:n[l+4*i]-n[l+4*r]*e}while(--a)}}while(--s);if(t.z=n[11]/n[10],t.y=(n[7]-n[6]*t.z)/n[5],t.x=(n[3]-n[2]*t.z-n[1]*t.y)/n[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(void 0===n)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new Po);const t=Mo;let n,r;for(n=0;n<3;n++)for(r=0;r<3;r++)t[n+6*r]=this.elements[n+3*r];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let i=3;const s=i;let o,a;do{if(n=s-i,0===t[n+6*n])for(r=n+1;r<s;r++)if(0!==t[n+6*r]){o=6;do{a=6-o,t[a+6*n]+=t[a+6*r]}while(--o);break}if(0!==t[n+6*n])for(r=n+1;r<s;r++){const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=a<=n?0:t[a+6*r]-t[a+6*n]*e}while(--o)}}while(--i);n=2;do{r=n-1;do{const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=t[a+6*r]-t[a+6*n]*e}while(--o)}while(r--)}while(--n);n=2;do{const e=1/t[n+6*n];o=6;do{a=6-o,t[a+6*n]=t[a+6*n]*e}while(--o)}while(n--);n=2;do{r=2;do{if(a=t[3+r+6*n],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(n,r,a)}while(r--)}while(n--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,r=e.z,i=e.w,s=t+t,o=n+n,a=r+r,l=t*s,c=t*o,u=t*a,h=n*o,d=n*a,p=r*a,f=i*s,m=i*o,g=i*a,v=this.elements;return v[0]=1-(h+p),v[1]=c-g,v[2]=u+m,v[3]=c+g,v[4]=1-(l+p),v[5]=d-f,v[6]=u-m,v[7]=d+f,v[8]=1-(l+h),this}transpose(e){void 0===e&&(e=new Po);const t=this.elements,n=e.elements;let r;return n[0]=t[0],n[4]=t[4],n[8]=t[8],r=t[1],n[1]=t[3],n[3]=r,r=t[2],n[2]=t[6],n[6]=r,r=t[5],n[5]=t[7],n[7]=r,e}}const Mo=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class Co{constructor(e,t,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){void 0===t&&(t=new Co);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z;return t.x=o*i-a*r,t.y=a*n-s*i,t.z=s*r-o*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new Co(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new Co(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new Po([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,r=Math.sqrt(e*e+t*t+n*n);if(r>0){const e=1/r;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return r}unit(e){void 0===e&&(e=new Co);const t=this.x,n=this.y,r=this.z;let i=Math.sqrt(t*t+n*n+r*r);return i>0?(i=1/i,e.x=t*i,e.y=n*i,e.z=r*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return Math.sqrt((i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r))}distanceSquared(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return(i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r)}scale(e,t){void 0===t&&(t=new Co);const n=this.x,r=this.y,i=this.z;return t.x=e*n,t.y=e*r,t.z=e*i,t}vmul(e,t){return void 0===t&&(t=new Co),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return void 0===n&&(n=new Co),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new Co),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const r=zo,i=1/n;r.set(this.x*i,this.y*i,this.z*i);const s=Io;Math.abs(r.x)<.9?(s.set(1,0,0),r.cross(s,e)):(s.set(0,1,0),r.cross(s,e)),r.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const r=this.x,i=this.y,s=this.z;n.x=r+(e.x-r)*t,n.y=i+(e.y-i)*t,n.z=s+(e.z-s)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(Bo),Bo.almostEquals(e,t)}clone(){return new Co(this.x,this.y,this.z)}}Co.ZERO=new Co(0,0,0),Co.UNIT_X=new Co(1,0,0),Co.UNIT_Y=new Co(0,1,0),Co.UNIT_Z=new Co(0,0,1);const zo=new Co,Io=new Co,Bo=new Co;class Oo{constructor(e){void 0===e&&(e={}),this.lowerBound=new Co,this.upperBound=new Co,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,r){const i=this.lowerBound,s=this.upperBound,o=n;i.copy(e[0]),o&&o.vmult(i,i),s.copy(i);for(let t=1;t<e.length;t++){let n=e[t];o&&(o.vmult(n,No),n=No),n.x>s.x&&(s.x=n.x),n.x<i.x&&(i.x=n.x),n.y>s.y&&(s.y=n.y),n.y<i.y&&(i.y=n.y),n.z>s.z&&(s.z=n.z),n.z<i.z&&(i.z=n.z)}return t&&(t.vadd(i,i),t.vadd(s,s)),r&&(i.x-=r,i.y-=r,i.z-=r,s.x+=r,s.y+=r,s.z+=r),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new Oo).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound,s=r.x<=n.x&&n.x<=i.x||t.x<=i.x&&i.x<=n.x,o=r.y<=n.y&&n.y<=i.y||t.y<=i.y&&i.y<=n.y,a=r.z<=n.z&&n.z<=i.z||t.z<=i.z&&i.z<=n.z;return s&&o&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound;return t.x<=r.x&&n.x>=i.x&&t.y<=r.y&&n.y>=i.y&&t.z<=r.z&&n.z>=i.z}getCorners(e,t,n,r,i,s,o,a){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),n.set(c.x,c.y,l.z),r.set(l.x,c.y,c.z),i.set(c.x,l.y,c.z),s.set(l.x,c.y,l.z),o.set(l.x,l.y,c.z),a.copy(c)}toLocalFrame(e,t){const n=Uo,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(r,i,s,o,a,l,c,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToLocal(r,r)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=Uo,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(r,i,s,o,a,l,c,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToWorld(r,r)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,r=1/t.x,i=1/t.y,s=1/t.z,o=(this.lowerBound.x-n.x)*r,a=(this.upperBound.x-n.x)*r,l=(this.lowerBound.y-n.y)*i,c=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*s,h=(this.upperBound.z-n.z)*s,d=Math.max(Math.max(Math.min(o,a),Math.min(l,c)),Math.min(u,h)),p=Math.min(Math.min(Math.max(o,a),Math.max(l,c)),Math.max(u,h));return!(p<0||d>p)}}const No=new Co,Uo=[new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co];class Ro{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:r}=t;if(r>n){const e=r;r=n,n=e}return this.matrix[(n*(n+1)>>1)+r-1]}set(e,t,n){let{index:r}=e,{index:i}=t;if(i>r){const e=i;i=r,r=e}this.matrix[(r*(r+1)>>1)+i-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class Do{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;return void 0===n[e]&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return!(void 0===n[e]||!n[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const n=this._listeners;if(void 0===n[e])return this;const r=n[e].indexOf(t);return-1!==r&&n[e].splice(r,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let n=0,r=t.length;n<r;n++)t[n].call(this,e)}return this}}class Fo{constructor(e,t,n,r){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===r&&(r=1),this.x=e,this.y=t,this.z=n,this.w=r}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(.5*t);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new Co),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=Lo,n=qo;e.tangents(t,n),this.setFromAxisAngle(t,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new Fo);const n=this.x,r=this.y,i=this.z,s=this.w,o=e.x,a=e.y,l=e.z,c=e.w;return t.x=n*c+s*o+r*l-i*a,t.y=r*c+s*a+i*o-n*l,t.z=i*c+s*l+n*a-r*o,t.w=s*c-n*o-r*a-i*l,t}inverse(e){void 0===e&&(e=new Fo);const t=this.x,n=this.y,r=this.z,i=this.w;this.conjugate(e);const s=1/(t*t+n*n+r*r+i*i);return e.x*=s,e.y*=s,e.z*=s,e.w*=s,e}conjugate(e){return void 0===e&&(e=new Fo),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new Co);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z,l=this.w,c=l*n+o*i-a*r,u=l*r+a*n-s*i,h=l*i+s*r-o*n,d=-s*n-o*r-a*i;return t.x=c*l+d*-s+u*-a-h*-o,t.y=u*l+d*-o+h*-s-c*-a,t.z=h*l+d*-a+c*-o-u*-s,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let n,r,i;void 0===t&&(t="YZX");const s=this.x,o=this.y,a=this.z,l=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=s*o+a*l;if(e>.499&&(n=2*Math.atan2(s,l),r=Math.PI/2,i=0),e<-.499&&(n=-2*Math.atan2(s,l),r=-Math.PI/2,i=0),void 0===n){const t=s*s,c=o*o,u=a*a;n=Math.atan2(2*o*l-2*s*a,1-2*c-2*u),r=Math.asin(2*e),i=Math.atan2(2*s*l-2*o*a,1-2*t-2*u)}}e.y=n,e.z=r,e.x=i}setFromEuler(e,t,n,r){void 0===r&&(r="XYZ");const i=Math.cos(e/2),s=Math.cos(t/2),o=Math.cos(n/2),a=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(n/2);return"XYZ"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o-a*l*c):"YXZ"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o+a*l*c):"ZXY"===r?(this.x=a*s*o-i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o-a*l*c):"ZYX"===r?(this.x=a*s*o-i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o+a*l*c):"YZX"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o-a*l*c):"XZY"===r&&(this.x=a*s*o-i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o+a*l*c),this}clone(){return new Fo(this.x,this.y,this.z,this.w)}slerp(e,t,n){void 0===n&&(n=new Fo);const r=this.x,i=this.y,s=this.z,o=this.w;let a,l,c,u,h,d=e.x,p=e.y,f=e.z,m=e.w;return l=r*d+i*p+s*f+o*m,l<0&&(l=-l,d=-d,p=-p,f=-f,m=-m),1-l>1e-6?(a=Math.acos(l),c=Math.sin(a),u=Math.sin((1-t)*a)/c,h=Math.sin(t*a)/c):(u=1-t,h=t),n.x=u*r+h*d,n.y=u*i+h*p,n.z=u*s+h*f,n.w=u*o+h*m,n}integrate(e,t,n,r){void 0===r&&(r=new Fo);const i=e.x*n.x,s=e.y*n.y,o=e.z*n.z,a=this.x,l=this.y,c=this.z,u=this.w,h=.5*t;return r.x+=h*(i*u+s*c-o*l),r.y+=h*(s*u+o*a-i*c),r.z+=h*(o*u+i*l-s*a),r.w+=h*(-i*a-s*l-o*c),r}}const Lo=new Co,qo=new Co;class jo{constructor(e){void 0===e&&(e={}),this.id=jo.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,n,r){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}jo.idCounter=0,jo.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class Vo{constructor(e){void 0===e&&(e={}),this.position=new Co,this.quaternion=new Fo,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return Vo.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return Vo.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new Co),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,r){return void 0===r&&(r=new Co),n.vsub(e,r),t.conjugate(Go),Go.vmult(r,r),r}static pointToWorldFrame(e,t,n,r){return void 0===r&&(r=new Co),t.vmult(n,r),r.vadd(e,r),r}static vectorToWorldFrame(e,t,n){return void 0===n&&(n=new Co),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,r){return void 0===r&&(r=new Co),t.w*=-1,t.vmult(n,r),t.w*=-1,r}}const Go=new Fo;class $o extends jo{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:n=[],normals:r=[],axes:i,boundingSphereRadius:s}=e;super({type:jo.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=r,0===this.faceNormals.length&&this.computeNormals(),s?this.boundingSphereRadius=s:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const r=new Co;for(let i=0;i!==e.length;i++){const s=e[i],o=s.length;for(let e=0;e!==o;e++){const i=(e+1)%o;t[s[e]].vsub(t[s[i]],r),r.normalize();let a=!1;for(let e=0;e!==n.length;e++)if(n[e].almostEquals(r)||n[e].almostEquals(r)){a=!0;break}a||n.push(r.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new Co;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],r=this.vertices[n[0]],i=this.vertices[n[1]],s=this.vertices[n[2]];$o.computeNormal(r,i,s,t)}static computeNormal(e,t,n,r){const i=new Co,s=new Co;t.vsub(e,s),n.vsub(t,i),i.cross(s,r),r.isZero()||r.normalize()}clipAgainstHull(e,t,n,r,i,s,o,a,l){const c=new Co;let u=-1,h=-Number.MAX_VALUE;for(let e=0;e<n.faces.length;e++){c.copy(n.faceNormals[e]),i.vmult(c,c);const t=c.dot(s);t>h&&(h=t,u=e)}const d=[];for(let e=0;e<n.faces[u].length;e++){const t=n.vertices[n.faces[u][e]],s=new Co;s.copy(t),i.vmult(s,s),r.vadd(s,s),d.push(s)}u>=0&&this.clipFaceAgainstHull(s,e,t,d,o,a,l)}findSeparatingAxis(e,t,n,r,i,s,o,a){const l=new Co,c=new Co,u=new Co,h=new Co,d=new Co,p=new Co;let f=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let o=0;o!==m.uniqueAxes.length;o++){n.vmult(m.uniqueAxes[o],l);const a=m.testSepAxis(l,e,t,n,r,i);if(!1===a)return!1;a<f&&(f=a,s.copy(l))}else{const a=o?o.length:m.faces.length;for(let c=0;c<a;c++){const a=o?o[c]:c;l.copy(m.faceNormals[a]),n.vmult(l,l);const u=m.testSepAxis(l,e,t,n,r,i);if(!1===u)return!1;u<f&&(f=u,s.copy(l))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){i.vmult(e.uniqueAxes[o],c);const a=m.testSepAxis(c,e,t,n,r,i);if(!1===a)return!1;a<f&&(f=a,s.copy(c))}else{const o=a?a.length:e.faces.length;for(let l=0;l<o;l++){const o=a?a[l]:l;c.copy(e.faceNormals[o]),i.vmult(c,c);const u=m.testSepAxis(c,e,t,n,r,i);if(!1===u)return!1;u<f&&(f=u,s.copy(c))}}for(let o=0;o!==m.uniqueEdges.length;o++){n.vmult(m.uniqueEdges[o],h);for(let o=0;o!==e.uniqueEdges.length;o++)if(i.vmult(e.uniqueEdges[o],d),h.cross(d,p),!p.almostZero()){p.normalize();const o=m.testSepAxis(p,e,t,n,r,i);if(!1===o)return!1;o<f&&(f=o,s.copy(p))}}return r.vsub(t,u),u.dot(s)>0&&s.negate(s),!0}testSepAxis(e,t,n,r,i,s){$o.project(this,e,n,r,Wo),$o.project(t,e,i,s,Ho);const o=Wo[0],a=Wo[1],l=Ho[0],c=Ho[1];if(o<c||l<a)return!1;const u=o-c,h=l-a;return u<h?u:h}calculateLocalInertia(e,t){const n=new Co,r=new Co;this.computeLocalAABB(r,n);const i=n.x-r.x,s=n.y-r.y,o=n.z-r.z;t.x=1/12*e*(2*s*2*s+2*o*2*o),t.y=1/12*e*(2*i*2*i+2*o*2*o),t.z=1/12*e*(2*s*2*s+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],r=this.vertices[t[0]];return-n.dot(r)}clipFaceAgainstHull(e,t,n,r,i,s,o){const a=new Co,l=new Co,c=new Co,u=new Co,h=new Co,d=new Co,p=new Co,f=new Co,m=this,g=r,v=[];let y=-1,x=Number.MAX_VALUE;for(let t=0;t<m.faces.length;t++){a.copy(m.faceNormals[t]),n.vmult(a,a);const r=a.dot(e);r<x&&(x=r,y=t)}if(y<0)return;const w=m.faces[y];w.connectedFaces=[];for(let e=0;e<m.faces.length;e++)for(let t=0;t<m.faces[e].length;t++)-1!==w.indexOf(m.faces[e][t])&&e!==y&&-1===w.connectedFaces.indexOf(e)&&w.connectedFaces.push(e);const b=w.length;for(let e=0;e<b;e++){const r=m.vertices[w[e]],i=m.vertices[w[(e+1)%b]];r.vsub(i,l),c.copy(l),n.vmult(c,c),t.vadd(c,c),u.copy(this.faceNormals[y]),n.vmult(u,u),t.vadd(u,u),c.cross(u,h),h.negate(h),d.copy(r),n.vmult(d,d),t.vadd(d,d);const s=w.connectedFaces[e];p.copy(this.faceNormals[s]);const o=this.getPlaneConstantOfFace(s);f.copy(p),n.vmult(f,f);const a=o-f.dot(t);for(this.clipFaceAgainstPlane(g,v,f,a);g.length;)g.shift();for(;v.length;)g.push(v.shift())}p.copy(this.faceNormals[y]);const _=this.getPlaneConstantOfFace(y);f.copy(p),n.vmult(f,f);const k=_-f.dot(t);for(let e=0;e<g.length;e++){let t=f.dot(g[e])+k;if(t<=i&&(console.log(`clamped: depth=${t} to minDist=${i}`),t=i),t<=s){const n=g[e];if(t<=1e-6){const e={point:n,normal:f,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,n,r){let i,s;const o=e.length;if(o<2)return t;let a=e[e.length-1],l=e[0];i=n.dot(a)+r;for(let c=0;c<o;c++){if(l=e[c],s=n.dot(l)+r,i<0)if(s<0){const e=new Co;e.copy(l),t.push(e)}else{const e=new Co;a.lerp(l,i/(i-s),e),t.push(e)}else if(s<0){const e=new Co;a.lerp(l,i/(i-s),e),t.push(e),t.push(l)}a=l,i=s}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new Co);const n=this.vertices,r=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(n[i],r[i]),e.vadd(r[i],r[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let r=0;r<this.vertices.length;r++){const i=n[r];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new Co);const n=this.faceNormals,r=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(n[i],r[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const r=t[n].lengthSquared();r>e&&(e=r)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,r){const i=this.vertices;let s,o,a,l,c,u,h=new Co;for(let n=0;n<i.length;n++){h.copy(i[n]),t.vmult(h,h),e.vadd(h,h);const r=h;(void 0===s||r.x<s)&&(s=r.x),(void 0===l||r.x>l)&&(l=r.x),(void 0===o||r.y<o)&&(o=r.y),(void 0===c||r.y>c)&&(c=r.y),(void 0===a||r.z<a)&&(a=r.z),(void 0===u||r.z>u)&&(u=r.z)}n.set(s,o,a),r.set(l,c,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new Co);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,r=this.vertices;if(t){for(let e=0;e<n;e++){const n=r[e];t.vmult(n,n)}for(let e=0;e<this.faceNormals.length;e++){const n=this.faceNormals[e];t.vmult(n,n)}}if(e)for(let t=0;t<n;t++){const n=r[t];n.vadd(e,n)}}pointIsInside(e){const t=this.vertices,n=this.faces,r=this.faceNormals,i=new Co;this.getAveragePointLocal(i);for(let s=0;s<this.faces.length;s++){let o=r[s];const a=t[n[s][0]],l=new Co;e.vsub(a,l);const c=o.dot(l),u=new Co;i.vsub(a,u);const h=o.dot(u);if(c<0&&h>0||c>0&&h<0)return!1}return-1}static project(e,t,n,r,i){const s=e.vertices.length,o=Yo;let a=0,l=0;const c=Xo,u=e.vertices;c.setZero(),Vo.vectorToLocalFrame(n,r,t,o),Vo.pointToLocalFrame(n,r,c,c);const h=c.dot(o);l=a=u[0].dot(o);for(let e=1;e<s;e++){const t=u[e].dot(o);t>a&&(a=t),t<l&&(l=t)}if(l-=h,a-=h,l>a){const e=l;l=a,a=e}i[0]=a,i[1]=l}}const Wo=[],Ho=[],Yo=(new Co,new Co),Xo=new Co;class Zo extends jo{constructor(e){super({type:jo.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,r=Co,i=[new r(-e,-t,-n),new r(e,-t,-n),new r(e,t,-n),new r(-e,t,-n),new r(-e,-t,n),new r(e,-t,n),new r(e,t,n),new r(-e,t,n)],s=[new r(0,0,1),new r(0,1,0),new r(1,0,0)],o=new $o({vertices:i,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:s});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new Co),Zo.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const r=e;n.x=1/12*t*(2*r.y*2*r.y+2*r.z*2*r.z),n.y=1/12*t*(2*r.x*2*r.x+2*r.z*2*r.z),n.z=1/12*t*(2*r.y*2*r.y+2*r.x*2*r.x)}getSideNormals(e,t){const n=e,r=this.halfExtents;if(n[0].set(r.x,0,0),n[1].set(0,r.y,0),n[2].set(0,0,r.z),n[3].set(-r.x,0,0),n[4].set(0,-r.y,0),n[5].set(0,0,-r.z),void 0!==t)for(let e=0;e!==n.length;e++)t.vmult(n[e],n[e]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const r=this.halfExtents,i=[[r.x,r.y,r.z],[-r.x,r.y,r.z],[-r.x,-r.y,r.z],[-r.x,-r.y,-r.z],[r.x,-r.y,-r.z],[r.x,r.y,-r.z],[-r.x,r.y,-r.z],[r.x,-r.y,r.z]];for(let r=0;r<i.length;r++)Ko.set(i[r][0],i[r][1],i[r][2]),t.vmult(Ko,Ko),e.vadd(Ko,Ko),n(Ko.x,Ko.y,Ko.z)}calculateWorldAABB(e,t,n,r){const i=this.halfExtents;Qo[0].set(i.x,i.y,i.z),Qo[1].set(-i.x,i.y,i.z),Qo[2].set(-i.x,-i.y,i.z),Qo[3].set(-i.x,-i.y,-i.z),Qo[4].set(i.x,-i.y,-i.z),Qo[5].set(i.x,i.y,-i.z),Qo[6].set(-i.x,i.y,-i.z),Qo[7].set(i.x,-i.y,i.z);const s=Qo[0];t.vmult(s,s),e.vadd(s,s),r.copy(s),n.copy(s);for(let i=1;i<8;i++){const s=Qo[i];t.vmult(s,s),e.vadd(s,s);const o=s.x,a=s.y,l=s.z;o>r.x&&(r.x=o),a>r.y&&(r.y=a),l>r.z&&(r.z=l),o<n.x&&(n.x=o),a<n.y&&(n.y=a),l<n.z&&(n.z=l)}}}const Ko=new Co,Qo=[new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co];class Jo extends Do{constructor(e){void 0===e&&(e={}),super(),this.id=Jo.idCounter++,this.index=-1,this.world=null,this.vlambda=new Co,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new Co,this.previousPosition=new Co,this.interpolatedPosition=new Co,this.initPosition=new Co,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new Co,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new Co,this.force=new Co;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Jo.STATIC:Jo.DYNAMIC,typeof e.type==typeof Jo.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Jo.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new Co,this.quaternion=new Fo,this.initQuaternion=new Fo,this.previousQuaternion=new Fo,this.interpolatedQuaternion=new Fo,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new Co,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new Co,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new Co,this.invInertia=new Co,this.invInertiaWorld=new Po,this.invMassSolve=0,this.invInertiaSolve=new Co,this.invInertiaWorldSolve=new Po,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new Co(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new Co(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new Oo,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new Co,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=Jo.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Jo.SLEEPING&&this.dispatchEvent(Jo.wakeupEvent)}sleep(){this.sleepState=Jo.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),r=this.sleepSpeedLimit**2;t===Jo.AWAKE&&n<r?(this.sleepState=Jo.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Jo.sleepyEvent)):t===Jo.SLEEPY&&n>r?this.wakeUp():t===Jo.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Jo.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Jo.SLEEPING||this.type===Jo.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new Co),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new Co),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new Co),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new Co),this.quaternion.vmult(e,t),t}addShape(e,t,n){const r=new Co,i=new Fo;return t&&r.copy(t),n&&i.copy(n),this.shapes.push(e),this.shapeOffsets.push(r),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let r=0;for(let i=0;i!==n;i++){const n=e[i];n.updateBoundingSphereRadius();const s=t[i].length(),o=n.boundingSphereRadius;s+o>r&&(r=s+o)}this.boundingRadius=r}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,r=e.length,i=ea,s=ta,o=this.quaternion,a=this.aabb,l=na;for(let c=0;c!==r;c++){const r=e[c];o.vmult(t[c],i),i.vadd(this.position,i),o.mult(n[c],s),r.calculateWorldAABB(i,s,l.lowerBound,l.upperBound),0===c?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=ra,n=ia;e.setRotationFromQuaternion(this.quaternion),e.transpose(n),e.scale(t,e),e.mmult(n,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new Co),this.type!==Jo.DYNAMIC)return;this.sleepState===Jo.SLEEPING&&this.wakeUp();const n=sa;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new Co),this.type!==Jo.DYNAMIC)return;const n=oa,r=aa;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyForce(n,r)}applyTorque(e){this.type===Jo.DYNAMIC&&(this.sleepState===Jo.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new Co),this.type!==Jo.DYNAMIC)return;this.sleepState===Jo.SLEEPING&&this.wakeUp();const n=t,r=la;r.copy(e),r.scale(this.invMass,r),this.velocity.vadd(r,this.velocity);const i=ca;n.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new Co),this.type!==Jo.DYNAMIC)return;const n=ua,r=ha;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyImpulse(n,r)}updateMassProperties(){const e=da;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Zo.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new Co;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Jo.DYNAMIC&&this.type!==Jo.KINEMATIC||this.sleepState===Jo.SLEEPING)return;const r=this.velocity,i=this.angularVelocity,s=this.position,o=this.force,a=this.torque,l=this.quaternion,c=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,d=c*e;r.x+=o.x*d*h.x,r.y+=o.y*d*h.y,r.z+=o.z*d*h.z;const p=u.elements,f=this.angularFactor,m=a.x*f.x,g=a.y*f.y,v=a.z*f.z;i.x+=e*(p[0]*m+p[1]*g+p[2]*v),i.y+=e*(p[3]*m+p[4]*g+p[5]*v),i.z+=e*(p[6]*m+p[7]*g+p[8]*v),s.x+=r.x*e,s.y+=r.y*e,s.z+=r.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(n?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Jo.idCounter=0,Jo.COLLIDE_EVENT_NAME="collide",Jo.DYNAMIC=1,Jo.STATIC=2,Jo.KINEMATIC=4,Jo.AWAKE=0,Jo.SLEEPY=1,Jo.SLEEPING=2,Jo.wakeupEvent={type:"wakeup"},Jo.sleepyEvent={type:"sleepy"},Jo.sleepEvent={type:"sleep"};const ea=new Co,ta=new Fo,na=new Oo,ra=new Po,ia=new Po,sa=(new Po,new Co),oa=new Co,aa=new Co,la=new Co,ca=new Co,ua=new Co,ha=new Co,da=new Co;class pa{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&Jo.STATIC)&&e.sleepState!==Jo.SLEEPING||0==(t.type&Jo.STATIC)&&t.sleepState!==Jo.SLEEPING)}intersectionTest(e,t,n,r){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,r):this.doBoundingSphereBroadphase(e,t,n,r)}doBoundingSphereBroadphase(e,t,n,r){const i=fa;t.position.vsub(e.position,i);const s=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<s&&(n.push(e),r.push(t))}doBoundingBoxBroadphase(e,t,n,r){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),r.push(t))}makePairsUnique(e,t){const n=ma,r=ga,i=va,s=e.length;for(let n=0;n!==s;n++)r[n]=e[n],i[n]=t[n];e.length=0,t.length=0;for(let e=0;e!==s;e++){const t=r[e].id,s=i[e].id,o=t<s?`${t},${s}`:`${s},${t}`;n[o]=e,n.keys.push(o)}for(let s=0;s!==n.keys.length;s++){const s=n.keys.pop(),o=n[s];e.push(r[o]),t.push(i[o]),delete n[s]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new Co;e.position.vsub(t.position,n);const r=e.shapes[0],i=t.shapes[0];return Math.pow(r.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const fa=new Co;new Co,new Fo,new Co;const ma={keys:[]},ga=[],va=[];new Co,new Co,new Co;class ya extends pa{constructor(){super()}collisionPairs(e,t,n){const r=e.bodies,i=r.length;let s,o;for(let e=0;e!==i;e++)for(let i=0;i!==e;i++)s=r[e],o=r[i],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,t,n)}aabbQuery(e,t,n){void 0===n&&(n=[]);for(let r=0;r<e.bodies.length;r++){const i=e.bodies[r];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&n.push(i)}return n}}class xa{constructor(){this.rayFromWorld=new Co,this.rayToWorld=new Co,this.hitNormalWorld=new Co,this.hitPointWorld=new Co,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,r,i,s,o){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(r),this.shape=i,this.body=s,this.distance=o}}let wa,ba,_a,ka,Sa,Aa,Ea;wa=jo.types.SPHERE,ba=jo.types.PLANE,_a=jo.types.BOX,ka=jo.types.CYLINDER,Sa=jo.types.CONVEXPOLYHEDRON,Aa=jo.types.HEIGHTFIELD,Ea=jo.types.TRIMESH;class Ta{get[wa](){return this._intersectSphere}get[ba](){return this._intersectPlane}get[_a](){return this._intersectBox}get[ka](){return this._intersectConvex}get[Sa](){return this._intersectConvex}get[Aa](){return this._intersectHeightfield}get[Ea](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new Co),void 0===t&&(t=new Co),this.from=e.clone(),this.to=t.clone(),this.direction=new Co,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Ta.ANY,this.result=new xa,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||Ta.ANY,this.result=t.result||new xa,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(Pa),Ma.length=0,e.broadphase.aabbQuery(e,Pa,Ma),this.intersectBodies(Ma),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const r=Ia,i=Ba;for(let t=0,s=e.shapes.length;t<s;t++){const s=e.shapes[t];if((!n||s.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],i),e.quaternion.vmult(e.shapeOffsets[t],r),r.vadd(e.position,r),this.intersectShape(s,i,r,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,n=e.length;!this.result.shouldStop&&t<n;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,r){const i=function(e,t,n){n.vsub(e,el);const r=el.dot(t);t.scale(r,tl),tl.vadd(e,tl);return n.distanceTo(tl)}(this.from,this.direction,n);if(i>e.boundingSphereRadius)return;const s=this[e.type];s&&s.call(this,e,t,n,r,e)}_intersectBox(e,t,n,r,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,r,i)}_intersectPlane(e,t,n,r,i){const s=this.from,o=this.to,a=this.direction,l=new Co(0,0,1);t.vmult(l,l);const c=new Co;s.vsub(n,c);const u=c.dot(l);if(o.vsub(n,c),u*c.dot(l)>0)return;if(s.distanceTo(o)<u)return;const h=l.dot(a);if(Math.abs(h)<this.precision)return;const d=new Co,p=new Co,f=new Co;s.vsub(n,d);const m=-l.dot(d)/h;a.scale(m,p),s.vadd(p,f),this.reportIntersection(l,f,i,r,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,r=this.to,i=this.from;t.x=Math.min(r.x,i.x),t.y=Math.min(r.y,i.y),t.z=Math.min(r.z,i.z),n.x=Math.max(r.x,i.x),n.y=Math.max(r.y,i.y),n.z=Math.max(r.z,i.z)}_intersectHeightfield(e,t,n,r,i){e.data,e.elementSize;const s=La;s.from.copy(this.from),s.to.copy(this.to),Vo.pointToLocalFrame(n,t,s.from,s.from),Vo.pointToLocalFrame(n,t,s.to,s.to),s.updateDirection();const o=qa;let a,l,c,u;a=l=0,c=u=e.data.length-1;const h=new Oo;s.getAABB(h),e.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,o,!0),a=Math.max(a,o[0]),l=Math.max(l,o[1]),e.getIndexOfPosition(h.upperBound.x,h.upperBound.y,o,!0),c=Math.min(c,o[0]+1),u=Math.min(u,o[1]+1);for(let o=a;o<c;o++)for(let a=l;a<u;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(o,a,h),h.overlapsRay(s)){if(e.getConvexTrianglePillar(o,a,!1),Vo.pointToWorldFrame(n,t,e.pillarOffset,Fa),this._intersectConvex(e.pillarConvex,t,Fa,r,i,Da),this.result.shouldStop)return;e.getConvexTrianglePillar(o,a,!0),Vo.pointToWorldFrame(n,t,e.pillarOffset,Fa),this._intersectConvex(e.pillarConvex,t,Fa,r,i,Da)}}}_intersectSphere(e,t,n,r,i){const s=this.from,o=this.to,a=e.radius,l=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2,c=2*((o.x-s.x)*(s.x-n.x)+(o.y-s.y)*(s.y-n.y)+(o.z-s.z)*(s.z-n.z)),u=c**2-4*l*((s.x-n.x)**2+(s.y-n.y)**2+(s.z-n.z)**2-a**2),h=ja,d=Va;if(!(u<0))if(0===u)s.lerp(o,u,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1);else{const e=(-c-Math.sqrt(u))/(2*l),t=(-c+Math.sqrt(u))/(2*l);if(e>=0&&e<=1&&(s.lerp(o,e,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(s.lerp(o,t,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1))}}_intersectConvex(e,t,n,r,i,s){const o=Ga,a=$a,l=s&&s.faceList||null,c=e.faces,u=e.vertices,h=e.faceNormals,d=this.direction,p=this.from,f=this.to,m=p.distanceTo(f),g=l?l.length:c.length,v=this.result;for(let e=0;!v.shouldStop&&e<g;e++){const s=l?l[e]:e,f=c[s],g=h[s],y=t,x=n;a.copy(u[f[0]]),y.vmult(a,a),a.vadd(x,a),a.vsub(p,a),y.vmult(g,o);const w=d.dot(o);if(Math.abs(w)<this.precision)continue;const b=o.dot(a)/w;if(!(b<0)){d.scale(b,Oa),Oa.vadd(p,Oa),Na.copy(u[f[0]]),y.vmult(Na,Na),x.vadd(Na,Na);for(let e=1;!v.shouldStop&&e<f.length-1;e++){Ua.copy(u[f[e]]),Ra.copy(u[f[e+1]]),y.vmult(Ua,Ua),y.vmult(Ra,Ra),x.vadd(Ua,Ua),x.vadd(Ra,Ra);const t=Oa.distanceTo(p);!Ta.pointInTriangle(Oa,Na,Ua,Ra)&&!Ta.pointInTriangle(Oa,Ua,Na,Ra)||t>m||this.reportIntersection(o,Oa,i,r,s)}}}}_intersectTrimesh(e,t,n,r,i,s){const o=Wa,a=Qa,l=Ja,c=$a,u=Ha,h=Ya,d=Xa,p=Ka,f=Za,m=e.indices;e.vertices;const g=this.from,v=this.to,y=this.direction;l.position.copy(n),l.quaternion.copy(t),Vo.vectorToLocalFrame(n,t,y,u),Vo.pointToLocalFrame(n,t,g,h),Vo.pointToLocalFrame(n,t,v,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,d.vsub(h,u),u.normalize();const x=h.distanceSquared(d);e.tree.rayQuery(this,l,a);for(let s=0,l=a.length;!this.result.shouldStop&&s!==l;s++){const l=a[s];e.getNormal(l,o),e.getVertex(m[3*l],Na),Na.vsub(h,c);const d=u.dot(o),g=o.dot(c)/d;if(g<0)continue;u.scale(g,Oa),Oa.vadd(h,Oa),e.getVertex(m[3*l+1],Ua),e.getVertex(m[3*l+2],Ra);const v=Oa.distanceSquared(h);!Ta.pointInTriangle(Oa,Ua,Na,Ra)&&!Ta.pointInTriangle(Oa,Na,Ua,Ra)||v>x||(Vo.vectorToWorldFrame(t,o,f),Vo.pointToWorldFrame(n,t,Oa,p),this.reportIntersection(f,p,i,r,l))}a.length=0}reportIntersection(e,t,n,r,i){const s=this.from,o=this.to,a=s.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==i?i:-1,this.mode){case Ta.ALL:this.hasHit=!0,l.set(s,o,e,t,n,r,a),l.hasHit=!0,this.callback(l);break;case Ta.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,r,a));break;case Ta.ANY:this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,r,a),l.shouldStop=!0}}static pointInTriangle(e,t,n,r){r.vsub(t,el),n.vsub(t,Ca),e.vsub(t,za);const i=el.dot(el),s=el.dot(Ca),o=el.dot(za),a=Ca.dot(Ca),l=Ca.dot(za);let c,u;return(c=a*o-s*l)>=0&&(u=i*l-s*o)>=0&&c+u<i*a-s*s}}Ta.CLOSEST=1,Ta.ANY=2,Ta.ALL=4;const Pa=new Oo,Ma=[],Ca=new Co,za=new Co,Ia=new Co,Ba=new Fo,Oa=new Co,Na=new Co,Ua=new Co,Ra=new Co;new Co,new xa;const Da={faceList:[0]},Fa=new Co,La=new Ta,qa=[],ja=new Co,Va=new Co,Ga=new Co,$a=(new Co,new Co,new Co),Wa=new Co,Ha=new Co,Ya=new Co,Xa=new Co,Za=new Co,Ka=new Co;new Oo;const Qa=[],Ja=new Vo,el=new Co,tl=new Co;class nl{static defaults(e,t){void 0===e&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class rl{constructor(e,t,n){void 0===n&&(n={}),n=nl.defaults(n,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=rl.idCounter++,this.collideConnected=n.collideConnected,n.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}rl.idCounter=0;class il{constructor(){this.spatial=new Co,this.rotational=new Co}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class sl{constructor(e,t,n,r){void 0===n&&(n=-1e6),void 0===r&&(r=1e6),this.id=sl.idCounter++,this.minForce=n,this.maxForce=r,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new il,this.jacobianElementB=new il,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const r=t,i=e,s=n;this.a=4/(s*(1+4*r)),this.b=4*r/(1+4*r),this.eps=4/(s*s*i*(1+4*r))}computeB(e,t,n){const r=this.computeGW();return-this.computeGq()*e-r*t-this.computeGiMf()*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.position,s=r.position;return e.spatial.dot(i)+t.spatial.dot(s)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.velocity,s=r.velocity,o=n.angularVelocity,a=r.angularVelocity;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.vlambda,s=r.vlambda,o=n.wlambda,a=r.wlambda;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.force,s=n.torque,o=r.force,a=r.torque,l=n.invMassSolve,c=r.invMassSolve;return i.scale(l,ol),o.scale(c,al),n.invInertiaWorldSolve.vmult(s,ll),r.invInertiaWorldSolve.vmult(a,cl),e.multiplyVectors(ol,ll)+t.multiplyVectors(al,cl)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.invMassSolve,s=r.invMassSolve,o=n.invInertiaWorldSolve,a=r.invInertiaWorldSolve;let l=i+s;return o.vmult(e.rotational,ul),l+=ul.dot(e.rotational),a.vmult(t.rotational,ul),l+=ul.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,r=this.bi,i=this.bj,s=hl;r.vlambda.addScaledVector(r.invMassSolve*e,t.spatial,r.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,n.spatial,i.vlambda),r.invInertiaWorldSolve.vmult(t.rotational,s),r.wlambda.addScaledVector(e,s,r.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,s),i.wlambda.addScaledVector(e,s,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}sl.idCounter=0;const ol=new Co,al=new Co,ll=new Co,cl=new Co,ul=new Co,hl=new Co;class dl extends sl{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new Co,this.rj=new Co,this.ni=new Co}computeB(e){const t=this.a,n=this.b,r=this.bi,i=this.bj,s=this.ri,o=this.rj,a=pl,l=fl,c=r.velocity,u=r.angularVelocity;r.force,r.torque;const h=i.velocity,d=i.angularVelocity;i.force,i.torque;const p=ml,f=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;s.cross(g,a),o.cross(g,l),g.negate(f.spatial),a.negate(f.rotational),m.spatial.copy(g),m.rotational.copy(l),p.copy(i.position),p.vadd(o,p),p.vsub(r.position,p),p.vsub(s,p);const v=g.dot(p),y=this.restitution+1;return-v*t-(y*h.dot(g)-y*c.dot(g)+d.dot(l)-u.dot(a))*n-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=gl,t=vl,n=yl,r=xl,i=wl;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,r),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(r,t),e.vsub(t,i),this.ni.dot(i)}}const pl=new Co,fl=new Co,ml=new Co,gl=new Co,vl=new Co,yl=new Co,xl=new Co,wl=new Co;new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co;class bl extends sl{constructor(e,t,n){super(e,t,-n,n),this.ri=new Co,this.rj=new Co,this.t=new Co}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,r=this.rj,i=_l,s=kl,o=this.t;n.cross(o,i),r.cross(o,s);const a=this.jacobianElementA,l=this.jacobianElementB;return o.negate(a.spatial),i.negate(a.rotational),l.spatial.copy(o),l.rotational.copy(s),-this.computeGW()*t-e*this.computeGiMf()}}const _l=new Co,kl=new Co;class Sl{constructor(e,t,n){n=nl.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Sl.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}Sl.idCounter=0;class Al{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=Al.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}Al.idCounter=0,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Ta,new Co,new Co,new Co,new Co(1,0,0),new Co(0,1,0),new Co(0,0,1),new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Oo,new Co,new Oo,new Co,new Co,new Co,new Co,new Co,new Co,new Co,new Oo,new Co,new Vo,new Oo;class El{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);-1!==n&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class Tl extends El{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const r=this.iterations,i=this.tolerance*this.tolerance,s=this.equations,o=s.length,a=t.bodies,l=a.length,c=e;let u,h,d,p,f,m;if(0!==o)for(let e=0;e!==l;e++)a[e].updateSolveMassProperties();const g=Ml,v=Cl,y=Pl;g.length=o,v.length=o,y.length=o;for(let e=0;e!==o;e++){const t=s[e];y[e]=0,v[e]=t.computeB(c),g[e]=1/t.computeC()}if(0!==o){for(let e=0;e!==l;e++){const t=a[e],n=t.vlambda,r=t.wlambda;n.set(0,0,0),r.set(0,0,0)}for(n=0;n!==r;n++){p=0;for(let e=0;e!==o;e++){const t=s[e];u=v[e],h=g[e],m=y[e],f=t.computeGWlambda(),d=h*(u-f-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),y[e]+=d,p+=d>0?d:-d,t.addToWlambda(d)}if(p*p<i)break}for(let e=0;e!==l;e++){const t=a[e],n=t.velocity,r=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),n.vadd(t.vlambda,n),t.wlambda.vmul(t.angularFactor,t.wlambda),r.vadd(t.wlambda,r)}let e=s.length;const t=1/c;for(;e--;)s[e].multiplier=y[e]*t}return n}}const Pl=[],Ml=[],Cl=[];Jo.STATIC;class zl{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class Il extends zl{constructor(){super(...arguments),this.type=Co}constructObject(){return new Co}}const Bl=jo.types.SPHERE,Ol=jo.types.SPHERE|jo.types.PLANE,Nl=jo.types.BOX|jo.types.BOX,Ul=jo.types.SPHERE|jo.types.BOX,Rl=jo.types.PLANE|jo.types.BOX,Dl=jo.types.CONVEXPOLYHEDRON,Fl=jo.types.SPHERE|jo.types.CONVEXPOLYHEDRON,Ll=jo.types.PLANE|jo.types.CONVEXPOLYHEDRON,ql=jo.types.BOX|jo.types.CONVEXPOLYHEDRON,jl=jo.types.SPHERE|jo.types.HEIGHTFIELD,Vl=jo.types.BOX|jo.types.HEIGHTFIELD,Gl=jo.types.CONVEXPOLYHEDRON|jo.types.HEIGHTFIELD,$l=jo.types.PARTICLE|jo.types.SPHERE,Wl=jo.types.PLANE|jo.types.PARTICLE,Hl=jo.types.BOX|jo.types.PARTICLE,Yl=jo.types.PARTICLE|jo.types.CONVEXPOLYHEDRON,Xl=jo.types.CYLINDER,Zl=jo.types.SPHERE|jo.types.CYLINDER,Kl=jo.types.PLANE|jo.types.CYLINDER,Ql=jo.types.BOX|jo.types.CYLINDER,Jl=jo.types.CONVEXPOLYHEDRON|jo.types.CYLINDER,ec=jo.types.HEIGHTFIELD|jo.types.CYLINDER,tc=jo.types.PARTICLE|jo.types.CYLINDER,nc=jo.types.SPHERE|jo.types.TRIMESH,rc=jo.types.PLANE|jo.types.TRIMESH;class ic{get[Bl](){return this.sphereSphere}get[Ol](){return this.spherePlane}get[Nl](){return this.boxBox}get[Ul](){return this.sphereBox}get[Rl](){return this.planeBox}get[Dl](){return this.convexConvex}get[Fl](){return this.sphereConvex}get[Ll](){return this.planeConvex}get[ql](){return this.boxConvex}get[jl](){return this.sphereHeightfield}get[Vl](){return this.boxHeightfield}get[Gl](){return this.convexHeightfield}get[$l](){return this.sphereParticle}get[Wl](){return this.planeParticle}get[Hl](){return this.boxParticle}get[Yl](){return this.convexParticle}get[Xl](){return this.convexConvex}get[Zl](){return this.sphereConvex}get[Kl](){return this.planeConvex}get[Ql](){return this.boxConvex}get[Jl](){return this.convexConvex}get[ec](){return this.heightfieldCylinder}get[tc](){return this.particleCylinder}get[nc](){return this.sphereTrimesh}get[rc](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Il,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,r,i,s){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=e,o.bj=t):o=new dl(e,t),o.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&r.collisionResponse;const a=this.currentContactMaterial;o.restitution=a.restitution,o.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=n.material||e.material,c=r.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(o.restitution=l.restitution*c.restitution),o.si=i||n,o.sj=s||r,o}createFrictionEquationsFromContact(e,t){const n=e.bi,r=e.bj,i=e.si,s=e.sj,o=this.world,a=this.currentContactMaterial;let l=a.friction;const c=i.material||n.material,u=s.material||r.material;if(c&&u&&c.friction>=0&&u.friction>=0&&(l=c.friction*u.friction),l>0){const i=l*(o.frictionGravity||o.gravity).length();let s=n.invMass+r.invMass;s>0&&(s=1/s);const c=this.frictionEquationPool,u=c.length?c.pop():new bl(n,r,i*s),h=c.length?c.pop():new bl(n,r,i*s);return u.bi=h.bi=n,u.bj=h.bj=r,u.minForce=h.minForce=-i*s,u.maxForce=h.maxForce=i*s,u.ri.copy(e.ri),u.rj.copy(e.rj),h.ri.copy(e.ri),h.rj.copy(e.rj),e.ni.tangents(u.t,h.t),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),u.enabled=h.enabled=e.enabled,t.push(u,h),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const n=this.frictionResult[this.frictionResult.length-2],r=this.frictionResult[this.frictionResult.length-1];sc.setZero(),oc.setZero(),ac.setZero();const i=t.bi;t.bj;for(let n=0;n!==e;n++)t=this.result[this.result.length-1-n],t.bi!==i?(sc.vadd(t.ni,sc),oc.vadd(t.ri,oc),ac.vadd(t.rj,ac)):(sc.vsub(t.ni,sc),oc.vadd(t.rj,oc),ac.vadd(t.ri,ac));const s=1/e;oc.scale(s,n.ri),ac.scale(s,n.rj),r.ri.copy(n.ri),r.rj.copy(n.rj),sc.normalize(),sc.tangents(n.t,r.t)}getContacts(e,t,n,r,i,s,o){this.contactPointPool=i,this.frictionEquationPool=o,this.result=r,this.frictionResult=s;const a=uc,l=hc,c=lc,u=cc;for(let r=0,i=e.length;r!==i;r++){const i=e[r],s=t[r];let o=null;i.material&&s.material&&(o=n.getContactMaterial(i.material,s.material)||null);const h=i.type&Jo.KINEMATIC&&s.type&Jo.STATIC||i.type&Jo.STATIC&&s.type&Jo.KINEMATIC||i.type&Jo.KINEMATIC&&s.type&Jo.KINEMATIC;for(let e=0;e<i.shapes.length;e++){i.quaternion.mult(i.shapeOrientations[e],a),i.quaternion.vmult(i.shapeOffsets[e],c),c.vadd(i.position,c);const t=i.shapes[e];for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],l),s.quaternion.vmult(s.shapeOffsets[e],u),u.vadd(s.position,u);const r=s.shapes[e];if(!(t.collisionFilterMask&r.collisionFilterGroup&&r.collisionFilterMask&t.collisionFilterGroup))continue;if(c.distanceTo(u)>t.boundingSphereRadius+r.boundingSphereRadius)continue;let d=null;t.material&&r.material&&(d=n.getContactMaterial(t.material,r.material)||null),this.currentContactMaterial=d||o||n.defaultContactMaterial;const p=this[t.type|r.type];if(p){let e=!1;e=t.type<r.type?p.call(this,t,r,c,u,a,l,i,s,t,r,h):p.call(this,r,t,u,c,l,a,s,i,t,r,h),e&&h&&(n.shapeOverlapKeeper.set(t.id,r.id),n.bodyOverlapKeeper.set(i.id,s.id))}}}}}sphereSphere(e,t,n,r,i,s,o,a,l,c,u){if(u)return n.distanceSquared(r)<(e.radius+t.radius)**2;const h=this.createContactEquation(o,a,e,t,l,c);r.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(o.position,h.ri),h.rj.vadd(r,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,n,r,i,s,o,a,l,c,u){const h=this.createContactEquation(o,a,e,t,l,c);if(h.ni.set(0,0,1),s.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),n.vsub(r,Cc),h.ni.scale(h.ni.dot(Cc),zc),Cc.vsub(zc,h.rj),-Cc.dot(h.ni)<=e.radius){if(u)return!0;const e=h.ri,t=h.rj;e.vadd(n,e),e.vsub(o.position,e),t.vadd(r,t),t.vsub(a.position,t),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,u)}sphereBox(e,t,n,r,i,s,o,a,l,c,u){const h=this.v3pool,d=Lc;n.vsub(r,Uc),t.getSideNormals(d,s);const p=e.radius;let f=!1;const m=jc,g=Vc,v=Gc;let y=null,x=0,w=0,b=0,_=null;for(let e=0,t=d.length;e!==t&&!1===f;e++){const t=Rc;t.copy(d[e]);const n=t.length();t.normalize();const r=Uc.dot(t);if(r<n+p&&r>0){const i=Dc,s=Fc;i.copy(d[(e+1)%3]),s.copy(d[(e+2)%3]);const o=i.length(),a=s.length();i.normalize(),s.normalize();const l=Uc.dot(i),c=Uc.dot(s);if(l<o&&l>-o&&c<a&&c>-a){const e=Math.abs(r-n-p);if((null===_||e<_)&&(_=e,w=l,b=c,y=n,m.copy(t),g.copy(i),v.copy(s),x++,u))return!0}}}if(x){f=!0;const i=this.createContactEquation(o,a,e,t,l,c);m.scale(-p,i.ri),i.ni.copy(m),i.ni.negate(i.ni),m.scale(y,m),g.scale(w,g),m.vadd(g,m),v.scale(b,v),m.vadd(v,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}let k=h.get();const S=qc;for(let i=0;2!==i&&!f;i++)for(let s=0;2!==s&&!f;s++)for(let h=0;2!==h&&!f;h++)if(k.set(0,0,0),i?k.vadd(d[0],k):k.vsub(d[0],k),s?k.vadd(d[1],k):k.vsub(d[1],k),h?k.vadd(d[2],k):k.vsub(d[2],k),r.vadd(k,S),S.vsub(n,S),S.lengthSquared()<p*p){if(u)return!0;f=!0;const i=this.createContactEquation(o,a,e,t,l,c);i.ri.copy(S),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(p,i.ri),i.rj.copy(k),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}h.release(k),k=null;const A=h.get(),E=h.get(),T=h.get(),P=h.get(),M=h.get(),C=d.length;for(let i=0;i!==C&&!f;i++)for(let s=0;s!==C&&!f;s++)if(i%3!=s%3){d[s].cross(d[i],A),A.normalize(),d[i].vadd(d[s],E),T.copy(n),T.vsub(E,T),T.vsub(r,T);const h=T.dot(A);A.scale(h,P);let m=0;for(;m===i%3||m===s%3;)m++;M.copy(n),M.vsub(P,M),M.vsub(E,M),M.vsub(r,M);const g=Math.abs(h),v=M.length();if(g<d[m].length()&&v<p){if(u)return!0;f=!0;const i=this.createContactEquation(o,a,e,t,l,c);E.vadd(P,i.rj),i.rj.copy(i.rj),M.negate(i.ni),i.ni.normalize(),i.ri.copy(i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(n,i.ri),i.ri.normalize(),i.ri.scale(p,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}h.release(A,E,T,P,M)}planeBox(e,t,n,r,i,s,o,a,l,c,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,u)}convexConvex(e,t,n,r,i,s,o,a,l,c,u,h,d){const p=su;if(!(n.distanceTo(r)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,i,r,s,p,h,d)){const h=[],d=ou;e.clipAgainstHull(n,i,t,r,s,p,-100,100,h);let f=0;for(let i=0;i!==h.length;i++){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c),m=s.ri,g=s.rj;p.negate(s.ni),h[i].normal.negate(d),d.scale(h[i].depth,d),h[i].point.vadd(d,m),g.copy(h[i].point),m.vsub(n,m),g.vsub(r,g),m.vadd(n,m),m.vsub(o.position,m),g.vadd(r,g),g.vsub(a.position,g),this.result.push(s),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}}sphereConvex(e,t,n,r,i,s,o,a,l,c,u){const h=this.v3pool;n.vsub(r,$c);const d=t.faceNormals,p=t.faces,f=t.vertices,m=e.radius;let g=!1;for(let i=0;i!==f.length;i++){const h=f[i],d=Xc;s.vmult(h,d),r.vadd(d,d);const p=Yc;if(d.vsub(n,p),p.lengthSquared()<m*m){if(u)return!0;g=!0;const i=this.createContactEquation(o,a,e,t,l,c);return i.ri.copy(p),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(m,i.ri),d.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),void this.createFrictionEquationsFromContact(i,this.frictionResult)}}for(let i=0,v=p.length;i!==v&&!1===g;i++){const v=d[i],y=p[i],x=Zc;s.vmult(v,x);const w=Kc;s.vmult(f[y[0]],w),w.vadd(r,w);const b=Qc;x.scale(-m,b),n.vadd(b,b);const _=Jc;b.vsub(w,_);const k=_.dot(x),S=eu;if(n.vsub(w,S),k<0&&S.dot(x)>0){const i=[];for(let e=0,t=y.length;e!==t;e++){const t=h.get();s.vmult(f[y[e]],t),r.vadd(t,t),i.push(t)}if(Nc(i,x,n)){if(u)return!0;g=!0;const s=this.createContactEquation(o,a,e,t,l,c);x.scale(-m,s.ri),x.negate(s.ni);const d=h.get();x.scale(-k,d);const p=h.get();x.scale(-m,p),n.vsub(r,s.rj),s.rj.vadd(p,s.rj),s.rj.vadd(d,s.rj),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),h.release(d),h.release(p),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return}for(let d=0;d!==y.length;d++){const p=h.get(),g=h.get();s.vmult(f[y[(d+1)%y.length]],p),s.vmult(f[y[(d+2)%y.length]],g),r.vadd(p,p),r.vadd(g,g);const v=Wc;g.vsub(p,v);const x=Hc;v.unit(x);const w=h.get(),b=h.get();n.vsub(p,b);const _=b.dot(x);x.scale(_,w),w.vadd(p,w);const k=h.get();if(w.vsub(n,k),_>0&&_*_<v.lengthSquared()&&k.lengthSquared()<m*m){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c);w.vsub(r,s.rj),w.vsub(n,s.ni),s.ni.normalize(),s.ni.scale(m,s.ri),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return h.release(p),h.release(g),h.release(w),h.release(k),void h.release(b)}h.release(p),h.release(g),h.release(w),h.release(k),h.release(b)}for(let e=0,t=i.length;e!==t;e++)h.release(i[e])}}}planeConvex(e,t,n,r,i,s,o,a,l,c,u){const h=tu,d=nu;d.set(0,0,1),i.vmult(d,d);let p=0;const f=ru;for(let i=0;i!==t.vertices.length;i++)if(h.copy(t.vertices[i]),s.vmult(h,h),r.vadd(h,h),h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const i=this.createContactEquation(o,a,e,t,l,c),s=iu;d.scale(d.dot(f),s),h.vsub(s,s),s.vsub(n,i.ri),i.ni.copy(d),h.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(i,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}sphereHeightfield(e,t,n,r,i,s,o,a,l,c,u){const h=t.data,d=e.radius,p=t.elementSize,f=wu,m=xu;Vo.pointToLocalFrame(r,s,n,m);let g=Math.floor((m.x-d)/p)-1,v=Math.ceil((m.x+d)/p)+1,y=Math.floor((m.y-d)/p)-1,x=Math.ceil((m.y+d)/p)+1;if(v<0||x<0||g>h.length||y>h[0].length)return;g<0&&(g=0),v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),g>=h.length&&(g=h.length-1),v>=h.length&&(v=h.length-1),x>=h[0].length&&(x=h[0].length-1),y>=h[0].length&&(y=h[0].length-1);const w=[];t.getRectMinMax(g,y,v,x,w);const b=w[0],_=w[1];if(m.z-d>_||m.z+d<b)return;const k=this.result;for(let l=g;l<v;l++)for(let c=y;c<x;c++){const h=k.length;let d=!1;if(t.getConvexTrianglePillar(l,c,!1),Vo.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,o,a,e,t,u)),u&&d)return!0;if(t.getConvexTrianglePillar(l,c,!0),Vo.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,o,a,e,t,u)),u&&d)return!0;if(k.length-h>2)return}}boxHeightfield(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}convexHeightfield(e,t,n,r,i,s,o,a,l,c,u){const h=t.data,d=t.elementSize,p=e.boundingSphereRadius,f=vu,m=yu,g=gu;Vo.pointToLocalFrame(r,s,n,g);let v=Math.floor((g.x-p)/d)-1,y=Math.ceil((g.x+p)/d)+1,x=Math.floor((g.y-p)/d)-1,w=Math.ceil((g.y+p)/d)+1;if(y<0||w<0||v>h.length||x>h[0].length)return;v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),w<0&&(w=0),v>=h.length&&(v=h.length-1),y>=h.length&&(y=h.length-1),w>=h[0].length&&(w=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const b=[];t.getRectMinMax(v,x,y,w,b);const _=b[0],k=b[1];if(!(g.z-p>k||g.z+p<_))for(let l=v;l<y;l++)for(let c=x;c<w;c++){let h=!1;if(t.getConvexTrianglePillar(l,c,!1),Vo.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,i,s,o,a,null,null,u,m,null)),u&&h)return!0;if(t.getConvexTrianglePillar(l,c,!0),Vo.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,i,s,o,a,null,null,u,m,null)),u&&h)return!0}}sphereParticle(e,t,n,r,i,s,o,a,l,c,u){const h=uu;if(h.set(0,0,1),r.vsub(n,h),h.lengthSquared()<=e.radius*e.radius){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);h.normalize(),n.rj.copy(h),n.rj.scale(e.radius,n.rj),n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}planeParticle(e,t,n,r,i,s,o,a,l,c,u){const h=au;h.set(0,0,1),o.quaternion.vmult(h,h);const d=lu;if(r.vsub(o.position,d),h.dot(d)<=0){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0);const i=cu;h.scale(h.dot(r),i),r.vsub(i,i),n.rj.copy(i),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}boxParticle(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}convexParticle(e,t,n,r,i,s,o,a,l,c,u){let h=-1;const d=pu,p=mu;let f=null;const m=du;if(m.copy(r),m.vsub(n,m),i.conjugate(hu),hu.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let t=0,n=e.faces.length;t!==n;t++){const n=[e.worldVertices[e.faces[t][0]]],i=e.worldFaceNormals[t];r.vsub(n[0],fu);const s=-i.dot(fu);if(null===f||Math.abs(s)<Math.abs(f)){if(u)return!0;f=s,h=t,d.copy(i)}}if(-1!==h){const i=this.createContactEquation(a,o,t,e,l,c);d.scale(f,p),p.vadd(r,p),p.vsub(n,p),i.rj.copy(p),d.negate(i.ni),i.ri.set(0,0,0);const s=i.ri,u=i.rj;s.vadd(r,s),s.vsub(a.position,s),u.vadd(n,u),u.vsub(o.position,u),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,r,i,s,o,a,l,c,u){return this.convexHeightfield(t,e,r,n,s,i,a,o,l,c,u)}particleCylinder(e,t,n,r,i,s,o,a,l,c,u){return this.convexParticle(t,e,r,n,s,i,a,o,l,c,u)}sphereTrimesh(e,t,n,r,i,s,o,a,l,c,u){const h=xc,d=wc,p=bc,f=_c,m=kc,g=Sc,v=Pc,y=yc,x=gc,w=Mc;Vo.pointToLocalFrame(r,s,n,m);const b=e.radius;v.lowerBound.set(m.x-b,m.y-b,m.z-b),v.upperBound.set(m.x+b,m.y+b,m.z+b),t.getTrianglesInAABB(v,w);const _=vc,k=e.radius*e.radius;for(let i=0;i<w.length;i++)for(let h=0;h<3;h++)if(t.getVertex(t.indices[3*w[i]+h],_),_.vsub(m,x),x.lengthSquared()<=k){if(y.copy(_),Vo.pointToWorldFrame(r,s,y,_),_.vsub(n,x),u)return!0;let i=this.createContactEquation(o,a,e,t,l,c);i.ni.copy(x),i.ni.normalize(),i.ri.copy(i.ni),i.ri.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.copy(_),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}for(let i=0;i<w.length;i++)for(let v=0;v<3;v++){t.getVertex(t.indices[3*w[i]+v],h),t.getVertex(t.indices[3*w[i]+(v+1)%3],d),d.vsub(h,p),m.vsub(d,g);const y=g.dot(p);m.vsub(h,g);let x=g.dot(p);if(x>0&&y<0&&(m.vsub(h,g),f.copy(p),f.normalize(),x=g.dot(f),f.scale(x,g),g.vadd(h,g),g.distanceTo(m)<e.radius)){if(u)return!0;const i=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),Vo.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),Vo.vectorToWorldFrame(s,i.ni,i.ni),Vo.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}const S=Ac,A=Ec,E=Tc,T=mc;for(let i=0,h=w.length;i!==h;i++){t.getTriangleVertices(w[i],S,A,E),t.getNormal(w[i],T),m.vsub(S,g);let h=g.dot(T);if(T.scale(h,g),m.vsub(g,g),h=g.distanceTo(m),Ta.pointInTriangle(g,S,A,E)&&h<e.radius){if(u)return!0;let i=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),Vo.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),Vo.vectorToWorldFrame(s,i.ni,i.ni),Vo.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}w.length=0}planeTrimesh(e,t,n,r,i,s,o,a,l,c,u){const h=new Co,d=dc;d.set(0,0,1),i.vmult(d,d);for(let i=0;i<t.vertices.length/3;i++){t.getVertex(i,h);const p=new Co;p.copy(h),Vo.pointToWorldFrame(r,s,p,h);const f=pc;if(h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const n=this.createContactEquation(o,a,e,t,l,c);n.ni.copy(d);const r=fc;d.scale(f.dot(d),r),h.vsub(r,r),n.ri.copy(r),n.ri.vsub(o.position,n.ri),n.rj.copy(h),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}}const sc=new Co,oc=new Co,ac=new Co,lc=new Co,cc=new Co,uc=new Fo,hc=new Fo,dc=new Co,pc=new Co,fc=new Co,mc=new Co,gc=new Co;new Co;const vc=new Co,yc=new Co,xc=new Co,wc=new Co,bc=new Co,_c=new Co,kc=new Co,Sc=new Co,Ac=new Co,Ec=new Co,Tc=new Co,Pc=new Oo,Mc=[],Cc=new Co,zc=new Co,Ic=new Co,Bc=new Co,Oc=new Co;function Nc(e,t,n){let r=null;const i=e.length;for(let s=0;s!==i;s++){const o=e[s],a=Ic;e[(s+1)%i].vsub(o,a);const l=Bc;a.cross(t,l);const c=Oc;n.vsub(o,c);const u=l.dot(c);if(!(null===r||u>0&&!0===r||u<=0&&!1===r))return!1;null===r&&(r=u>0)}return!0}const Uc=new Co,Rc=new Co,Dc=new Co,Fc=new Co,Lc=[new Co,new Co,new Co,new Co,new Co,new Co],qc=new Co,jc=new Co,Vc=new Co,Gc=new Co,$c=new Co,Wc=new Co,Hc=new Co,Yc=new Co,Xc=new Co,Zc=new Co,Kc=new Co,Qc=new Co,Jc=new Co,eu=new Co;new Co,new Co;const tu=new Co,nu=new Co,ru=new Co,iu=new Co,su=new Co,ou=new Co,au=new Co,lu=new Co,cu=new Co,uu=new Co,hu=new Fo,du=new Co;new Co;const pu=new Co,fu=new Co,mu=new Co,gu=new Co,vu=new Co,yu=[0],xu=new Co,wu=new Co;class bu{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),r=this.current;let i=0;for(;n>r[i];)i++;if(n!==r[i]){for(let e=r.length-1;e>=i;e--)r[e+1]=r[e];r[i]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,r=this.previous,i=n.length,s=r.length;let o=0;for(let t=0;t<i;t++){let i=!1;const s=n[t];for(;s>r[o];)o++;i=s===r[o],i||_u(e,s)}o=0;for(let e=0;e<s;e++){let i=!1;const s=r[e];for(;s>n[o];)o++;i=n[o]===s,i||_u(t,s)}}}function _u(e,t){e.push((4294901760&t)>>16,65535&t)}const ku=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class Su{constructor(){this.data={keys:[]}}get(e,t){const n=ku(e,t);return this.data[n]}set(e,t,n){const r=ku(e,t);this.get(e,t)||this.data.keys.push(r),this.data[r]=n}delete(e,t){const n=ku(e,t),r=this.data.keys.indexOf(n);-1!==r&&this.data.keys.splice(r,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;)delete e[t.pop()]}}class Au extends Do{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new Co,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new Co,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new ya,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new Tl,this.constraints=[],this.narrowphase=new ic(this),this.collisionMatrix=new Ro,this.collisionMatrixPrevious=new Ro,this.bodyOverlapKeeper=new bu,this.shapeOverlapKeeper=new bu,this.contactmaterials=[],this.contactMaterialTable=new Su,this.defaultMaterial=new Al("default"),this.defaultContactMaterial=new Sl(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof xa?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,r){return void 0===n&&(n={}),n.mode=Ta.ALL,n.from=e,n.to=t,n.callback=r,Eu.intersectWorld(this,n)}raycastAny(e,t,n,r){return void 0===n&&(n={}),n.mode=Ta.ANY,n.from=e,n.to=t,n.result=r,Eu.intersectWorld(this,n)}raycastClosest(e,t,n,r){return void 0===n&&(n={}),n.mode=Ta.CLOSEST,n.from=e,n.to=t,n.result=r,Eu.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Jo&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,r=n.indexOf(e);if(-1!==r){n.splice(r,1);for(let e=0;e!==n.length;e++)n[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const r=t[n].shapes;for(let t=0;t<r.length;t++){const n=r[t];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const n=Tu.now()/1e3;if(this.lastCallTime){const r=n-this.lastCallTime;this.step(e,r,t)}else this.step(e,void 0,t);this.lastCallTime=n}step(e,t,n){if(void 0===n&&(n=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const r=Tu.now();let i=0;for(;this.accumulator>=e&&i<n&&(this.internalStep(e),this.accumulator-=e,i++,!(Tu.now()-r>1e3*e)););this.accumulator=this.accumulator%e;const s=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,s,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,s,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=Bu,r=Ou,i=this.bodies.length,s=this.bodies,o=this.solver,a=this.gravity,l=this.doProfiling,c=this.profile,u=Jo.DYNAMIC;let h=-1/0;const d=this.constraints,p=Iu;a.length();const f=a.x,m=a.y,g=a.z;let v=0;for(l&&(h=Tu.now()),v=0;v!==i;v++){const e=s[v];if(e.type===u){const t=e.force,n=e.mass;t.x+=n*f,t.y+=n*m,t.z+=n*g}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(h=Tu.now()),n.length=0,r.length=0,this.broadphase.collisionPairs(this,n,r),l&&(c.broadphase=Tu.now()-h);let y=d.length;for(v=0;v!==y;v++){const e=d[v];if(!e.collideConnected)for(let t=n.length-1;t>=0;t-=1)(e.bodyA===n[t]&&e.bodyB===r[t]||e.bodyB===n[t]&&e.bodyA===r[t])&&(n.splice(t,1),r.splice(t,1))}this.collisionMatrixTick(),l&&(h=Tu.now());const x=zu,w=t.length;for(v=0;v!==w;v++)x.push(t[v]);t.length=0;const b=this.frictionEquations.length;for(v=0;v!==b;v++)p.push(this.frictionEquations[v]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,r,this,t,x,this.frictionEquations,p),l&&(c.narrowphase=Tu.now()-h),l&&(h=Tu.now()),v=0;v<this.frictionEquations.length;v++)o.addEquation(this.frictionEquations[v]);const _=t.length;for(let e=0;e!==_;e++){const n=t[e],r=n.bi,i=n.bj,s=n.si,a=n.sj;let l;l=r.material&&i.material&&this.getContactMaterial(r.material,i.material)||this.defaultContactMaterial,l.friction,r.material&&i.material&&(r.material.friction>=0&&i.material.friction>=0&&(r.material.friction,i.material.friction),r.material.restitution>=0&&i.material.restitution>=0&&(n.restitution=r.material.restitution*i.material.restitution)),o.addEquation(n),r.allowSleep&&r.type===Jo.DYNAMIC&&r.sleepState===Jo.SLEEPING&&i.sleepState===Jo.AWAKE&&i.type!==Jo.STATIC&&i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0),i.allowSleep&&i.type===Jo.DYNAMIC&&i.sleepState===Jo.SLEEPING&&r.sleepState===Jo.AWAKE&&r.type!==Jo.STATIC&&r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(r,i,!0),this.collisionMatrixPrevious.get(r,i)||(Cu.body=i,Cu.contact=n,r.dispatchEvent(Cu),Cu.body=r,i.dispatchEvent(Cu)),this.bodyOverlapKeeper.set(r.id,i.id),this.shapeOverlapKeeper.set(s.id,a.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=Tu.now()-h,h=Tu.now()),v=0;v!==i;v++){const e=s[v];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(y=d.length,v=0;v!==y;v++){const e=d[v];e.update();for(let t=0,n=e.equations.length;t!==n;t++){const n=e.equations[t];o.addEquation(n)}}o.solve(e,this),l&&(c.solve=Tu.now()-h),o.removeAllEquations();const k=Math.pow;for(v=0;v!==i;v++){const t=s[v];if(t.type&u){const n=k(1-t.linearDamping,e),r=t.velocity;r.scale(n,r);const i=t.angularVelocity;if(i){const n=k(1-t.angularDamping,e);i.scale(n,i)}}}this.dispatchEvent(Mu),l&&(h=Tu.now());const S=this.stepnumber%(this.quatNormalizeSkip+1)==0,A=this.quatNormalizeFast;for(v=0;v!==i;v++)s[v].integrate(e,S,A);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=Tu.now()-h),this.stepnumber+=1,this.dispatchEvent(Pu);let E=!0;if(this.allowSleep)for(E=!1,v=0;v!==i;v++){const e=s[v];e.sleepTick(this.time),e.sleepState!==Jo.SLEEPING&&(E=!0)}this.hasActiveBodies=E}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(Nu,Uu),e){for(let e=0,t=Nu.length;e<t;e+=2)Ru.bodyA=this.getBodyById(Nu[e]),Ru.bodyB=this.getBodyById(Nu[e+1]),this.dispatchEvent(Ru);Ru.bodyA=Ru.bodyB=null}if(t){for(let e=0,t=Uu.length;e<t;e+=2)Du.bodyA=this.getBodyById(Uu[e]),Du.bodyB=this.getBodyById(Uu[e+1]),this.dispatchEvent(Du);Du.bodyA=Du.bodyB=null}Nu.length=Uu.length=0;const n=this.hasAnyEventListener("beginShapeContact"),r=this.hasAnyEventListener("endShapeContact");if((n||r)&&this.shapeOverlapKeeper.getDiff(Nu,Uu),n){for(let e=0,t=Nu.length;e<t;e+=2){const t=this.getShapeById(Nu[e]),n=this.getShapeById(Nu[e+1]);Fu.shapeA=t,Fu.shapeB=n,t&&(Fu.bodyA=t.body),n&&(Fu.bodyB=n.body),this.dispatchEvent(Fu)}Fu.bodyA=Fu.bodyB=Fu.shapeA=Fu.shapeB=null}if(r){for(let e=0,t=Uu.length;e<t;e+=2){const t=this.getShapeById(Uu[e]),n=this.getShapeById(Uu[e+1]);Lu.shapeA=t,Lu.shapeB=n,t&&(Lu.bodyA=t.body),n&&(Lu.bodyB=n.body),this.dispatchEvent(Lu)}Lu.bodyA=Lu.bodyB=Lu.shapeA=Lu.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const t=e[n];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new Oo;const Eu=new Ta,Tu=globalThis.performance||{};if(!Tu.now){let e=Date.now();Tu.timing&&Tu.timing.navigationStart&&(e=Tu.timing.navigationStart),Tu.now=()=>Date.now()-e}new Co;const Pu={type:"postStep"},Mu={type:"preStep"},Cu={type:Jo.COLLIDE_EVENT_NAME,body:null,contact:null},zu=[],Iu=[],Bu=[],Ou=[],Nu=[],Uu=[],Ru={type:"beginContact",bodyA:null,bodyB:null},Du={type:"endContact",bodyA:null,bodyB:null},Fu={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Lu={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class qu extends e{world=new Au({gravity:new Co(0,-150,0)});constructor(){super()}}class ju extends e{speed=1;rotationSpeed=.025;player;constructor(e=0,t=1,n=.025){super(),this.player=e,this.speed=t,this.rotationSpeed=n}}class Vu extends e{bodyId;halfExtents;options;constructor(e,t={}){super(),this.halfExtents=new Co(e[0]/2,e[1]/2,e[2]/2),this.options=t}}const Gu=new class{lastTime=0;entities=new Map;systems=new Map;nextEntityID=0;entitiesToDestroy=new Array;addEntity(){let e=this.nextEntityID;return this.nextEntityID++,this.entities.set(e,new n),e}removeEntity(e){this.entitiesToDestroy.push(e)}addComponent(e,t){this.entities.get(e).add(t),this.checkE(e)}addComponents(e,...t){for(let n of t)this.addComponent(e,n)}getComponents(e){return this.entities.get(e)}removeComponent(e,t){this.entities.get(e).delete(t),this.checkE(e)}addSystem(e){if(0==e.componentsRequired.size)return console.warn("System not added: empty Components list."),void console.warn(e);e.ecs=this,this.systems.set(e,new Set);for(let t of this.entities.keys())this.checkES(t,e)}removeSystem(e){this.systems.delete(e)}update(e){let t=e-this.lastTime;for(let[n,r]of this.systems.entries())n.update(r,e,t);for(;this.entitiesToDestroy.length>0;)this.destroyEntity(this.entitiesToDestroy.pop());this.lastTime=e}destroyEntity(e){this.entities.delete(e);for(let t of this.systems.values())t.delete(e)}checkE(e){for(let t of this.systems.keys())this.checkES(e,t)}checkES(e,t){let n=this.entities.get(e),r=t.componentsRequired;n.hasAll(r)?this.systems.get(t).add(e):this.systems.get(t).delete(e)}getEntitiesithComponent(e){let t=new Set;for(let[n,r]of this.entities)r.has(e)&&t.add(n);return t}};Gu.addSystem(new class extends t{keyboardControls=new Eo;componentsRequired=new Set([Di,To]);update(e,t,n){for(const t of e){const e=this.ecs.getComponents(t),r=e.get(Di),i=e.get(To),s=i.speed*n,o=i.rotationSpeed*n;this.keyboardControls.pressed.a&&(r.position=te.add(r.position,te.mulScalar(r.left,s))),this.keyboardControls.pressed.d&&(r.position=te.add(r.position,te.mulScalar(r.right,s))),this.keyboardControls.pressed.w&&(r.position=te.add(r.position,te.mulScalar(r.direction,s))),this.keyboardControls.pressed.s&&(r.position=te.sub(r.position,te.mulScalar(r.direction,s))),this.keyboardControls.pressed.q&&(r.rotation=je.rotateY(r.rotation,-o)),this.keyboardControls.pressed.e&&(r.rotation=je.rotateY(r.rotation,o)),this.keyboardControls.pressed[" "]&&(r.position=te.add(r.position,te.mulScalar(r.up,s))),this.keyboardControls.pressed.shift&&(r.position=te.add(r.position,te.mulScalar(r.down,s)))}}}),Gu.addSystem(new class extends t{componentsRequired=new Set([Fi,Di]);constructor(){super(),(async()=>{const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});let t;console.log(e);try{t=await e.requestDevice({requiredFeatures:["timestamp-query"],requiredLimits:{maxColorAttachmentBytesPerSample:64}})}catch(n){console.warn("Timestamp query or 64 byte colour attachment not supported, falling back"),t=await e.requestDevice()}return t})().then((async e=>{const t=new So(e),n=(e=>{const t=e.getEntitiesithComponent(Ao).values().next().value;return e.getComponents(t).get(Ao)})(this.ecs);n.device=e,n.volumeAtlas=t;const r=await(async(e,t,n,r)=>{t.dictionary[r]||await xo(r,0,t);const{size:i,location:s,paletteIndex:o,octreeOffset:a}=t.dictionary[r];return new Fi({name:n,size:i,atlasLocation:s,paletteIndex:o,octreeBufferIndex:a})})(0,t,"Terrain","./terrain.vxm");for(let e=-2048;e<=2048;e+=256)for(let t=-2048;t<=2048;t+=256){const n=this.ecs.addEntity();this.ecs.addComponent(n,new Fi(r)),this.ecs.addComponent(n,new Di([e,0,t],je.fromEuler(0,0,0,"xyz"),[1,1,1]))}ao(e,t,this.ecs)}))}update(e,t){const n=this.ecs.getEntitiesithComponent(po).values().next().value,r=this.ecs.getComponents(n),i=r.get(po),s=r.get(Di);ho(t,this.ecs,i,s,Array.from(e))}}),Gu.addSystem(new class extends t{componentsRequired=new Set([Vu,Di,ju]);update(e,t,n){const r=this.ecs.getEntitiesithComponent(qu).values().next().value,i=this.ecs.getComponents(r).get(qu).world;for(const t of e){const e=this.ecs.getComponents(t),r=e.get(Vu),s=e.get(Di),o=e.get(ju),a=navigator.getGamepads()[o.player];if(!a)return;const l=te.mulScalar(s.right,a.axes[0]),c=te.mulScalar(s.direction,-a.axes[1]),u=te.add(l,c),h=te.add(s.position,te.mulScalar(u,o.speed)),d=i.getBodyById(r.bodyId);if(!d)continue;d.position.set(h[0],h[1],h[2]);const p=je.rotateY(s.rotation,o.rotationSpeed*a.axes[2]),f=a.buttons[0].pressed,m=a.buttons[1].pressed,g=.001*n;f&&(s.scale=te.add(s.scale,te.create(g,g,g))),m&&(s.scale=te.sub(s.scale,te.create(g,g,g))),i.getBodyById(r.bodyId).quaternion.set(p[0],p[1],p[2],p[3])}}});const $u=Gu.addEntity();Gu.addComponent($u,new Ao),Gu.addComponent($u,new qu);const Wu=Gu.addEntity();Gu.addComponents(Wu,new po({fieldOfView:Math.PI/180*70,near:.5,far:1e4}),new Di(te.create(0,50,-120),je.fromEuler(0,0,0,"xyz"),te.create(1,1,1)),new To);const Hu=Gu.addEntity();Gu.addComponents(Hu,new Di(te.create(0,0,0),je.identity(),te.create(1,1,1)),new To);const Yu=()=>{Gu.update(performance.now()),requestAnimationFrame(Yu)};Yu()})();