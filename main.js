/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={391:(e,t,n)=>{var i=n(180),r=n(181),s=n(31),o=n(67),a=n(833),l=n(717),c=n(801);c.alea=i,c.xor128=r,c.xorwow=s,c.xorshift7=o,c.xor4096=a,c.tychei=l,e.exports=c},180:function(e,t,n){var i;!function(e,r,s){function o(e){var t,n=this,i=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var i=.02519603282416938*(t+=e.charCodeAt(n));i-=t=i>>>0,t=(i*=t)>>>0,t+=4294967296*(i-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=i(" "),n.s1=i(" "),n.s2=i(" "),n.s0-=i(e),n.s0<0&&(n.s0+=1),n.s1-=i(e),n.s1<0&&(n.s1+=1),n.s2-=i(e),n.s2<0&&(n.s2+=1),i=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new o(e),i=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(i=function(){return l}.call(t,n,t,r))||(r.exports=i):this.alea=l}(0,e=n.nmd(e),n.amdD)},717:function(e,t,n){var i;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,i=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-i|0,i=i<<24^i>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-i|0,t.d=i<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var i=0;i<n.length+20;i++)t.b^=0|n.charCodeAt(i),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new o(e),i=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(i=function(){return l}.call(t,n,t,r))||(r.exports=i):this.tychei=l}(0,e=n.nmd(e),n.amdD)},181:function(e,t,n){var i;!function(e,r,s){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var i=0;i<n.length+64;i++)t.x^=0|n.charCodeAt(i),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new o(e),i=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(i=function(){return l}.call(t,n,t,r))||(r.exports=i):this.xor128=l}(0,e=n.nmd(e),n.amdD)},833:function(e,t,n){var i;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,i=t.w,r=t.X,s=t.i;return t.w=i=i+1640531527|0,n=r[s+34&127],e=r[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[s]=n^e,t.i=s,n+(i^i>>>16)|0},function(e,t){var n,i,r,s,o,a=[],l=128;for(t===(0|t)?(i=t,t=null):(t+="\0",i=0,l=Math.max(l,t.length)),r=0,s=-32;s<l;++s)t&&(i^=t.charCodeAt((s+32)%t.length)),0===s&&(o=i),i^=i<<10,i^=i>>>15,i^=i<<4,i^=i>>>13,s>=0&&(o=o+1640531527|0,r=0==(n=a[127&s]^=i+o)?r+1:0);for(r>=128&&(a[127&(t&&t.length||0)]=-1),r=127,s=512;s>0;--s)i=a[r+34&127],n=a[r=r+1&127],i^=i<<13,n^=n<<17,i^=i>>>15,n^=n>>>12,a[r]=i^n;e.w=o,e.X=a,e.i=r}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new o(e),i=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,i&&(i.X&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(i=function(){return l}.call(t,n,t,r))||(r.exports=i):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},67:function(e,t,n){var i;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,i=t.x,r=t.i;return e=i[r],n=(e^=e>>>7)^e<<24,n^=(e=i[r+1&7])^e>>>10,n^=(e=i[r+3&7])^e>>>3,n^=(e=i[r+4&7])^e<<7,e=i[r+7&7],n^=(e^=e<<13)^e<<9,i[r]=n,t.i=r+1&7,n},function(e,t){var n,i=[];if(t===(0|t))i[0]=t;else for(t=""+t,n=0;n<t.length;++n)i[7&n]=i[7&n]<<15^t.charCodeAt(n)+i[n+1&7]<<13;for(;i.length<8;)i.push(0);for(n=0;n<8&&0===i[n];++n);for(8==n?i[7]=-1:i[n],e.x=i,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new o(e),i=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,i&&(i.x&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(i=function(){return l}.call(t,n,t,r))||(r.exports=i):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},31:function(e,t,n){var i;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var i=0;i<n.length+64;i++)t.x^=0|n.charCodeAt(i),i==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new o(e),i=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,i&&("object"==typeof i&&a(i,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=l:n.amdD&&n.amdO?void 0===(i=function(){return l}.call(t,n,t,r))||(r.exports=i):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var i;!function(r,s,o){var a,l=256,c=o.pow(l,6),u=o.pow(2,52),h=2*u,d=l-1;function p(e,t,n){var i=[],d=v(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(s)]:null==e?function(){try{var e;return a&&(e=a.randomBytes)?e=e(l):(e=new Uint8Array(l),(r.crypto||r.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,y(s)]}}():e,3),i),p=new f(i),x=function(){for(var e=p.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,v(y(p.S),s),(t.pass||n||function(e,t,n,i){return i&&(i.S&&m(i,p),e.state=function(){return m(p,{})}),n?(o.random=e,t):e})(x,d,"global"in t?t.global:this==o,t.state)}function f(e){var t,n=e.length,i=this,r=0,s=i.i=i.j=0,o=i.S=[];for(n||(e=[n++]);r<l;)o[r]=r++;for(r=0;r<l;r++)o[r]=o[s=d&s+e[r%n]+(t=o[r])],o[s]=t;(i.g=function(e){for(var t,n=0,r=i.i,s=i.j,o=i.S;e--;)t=o[r=d&r+1],n=n*l+o[d&(o[r]=o[s=d&s+t])+(o[s]=t)];return i.i=r,i.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,i=[],r=typeof e;if(t&&"object"==r)for(n in e)try{i.push(g(e[n],t-1))}catch(e){}return i.length?i:"string"==r?e:e+"\0"}function v(e,t){for(var n,i=e+"",r=0;r<i.length;)t[d&r]=d&(n^=19*t[d&r])+i.charCodeAt(r++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(o.random(),s),e.exports){e.exports=p;try{a=n(234)}catch(e){}}else void 0===(i=function(){return p}.call(t,n,t,e))||(e.exports=i)}("undefined"!=typeof self?self:this,[],Math)},284:(e,t,n)=>{"use strict";n.d(t,{yq:()=>h});var i=n(491),r=n(590),s=n(391),o=n.n(s),a=n(627);const l=o()("crystals"),c=(0,a.Cf)(l);class u{cache;size;noiseFunction;constructor(e,t){this.size=t,this.noiseFunction=e,this.cache=new Int16Array(t[0]*t[1]*t[2])}get([e,t,n]){const i=(r=this.size,(s=[e,t,n])[0]+s[1]*r[0]+s[2]*(r[0]*r[1]));var r,s,o;return 0===this.cache[i]&&(this.cache[i]=(o=this.noiseFunction(e,t,n),Math.floor(32767*o))),(e=>e/32767)(this.cache[i])}}const h=128;let d,p;const f={createOctreeAndReturnBytes:(e,t,n)=>(p=new u(((t,n,i)=>((e,t,n,i=1,r=3,s=.5)=>{let o=0,a=0,l=1;for(let u=0;u<r;u++){const r=1<<u;a+=c(e*r*i,t*r*i,n*r*i)*l,o+=l,l*=s}return a/o})(t+e[0],n+e[1],i+e[2],.001,5)),t),d=new i.xV(((e,t,n)=>((e,t,n)=>{const i=p.get([e,t,n]),r=t/h,s=function(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}((i+1)/2),o=l();return s>r?t>.75*h?{red:255-128*o,green:0,blue:0}:t>.55*h?{red:255-128*o,green:255-128*o,blue:0}:t>.25*h?{red:0,green:255-128*o,blue:0}:{red:64,green:64,blue:255-128*o}:null})(e,t,n)),((e,t,n)=>1),Math.max(...t),n),p=void 0,d.totalSize+i.ps),populateOctreeBuffer:e=>{const t=new DataView(e);d.nodes.forEach(((e,n)=>{"red"in e?(0,i.lx)(t,n,e):(0,i.Ie)(t,n,e)})),d=void 0}};(0,r.p)(f)},491:(e,t,n)=>{"use strict";n.d(t,{ps:()=>i,xV:()=>s,Ie:()=>a,lx:()=>o});const i=8,r=e=>[1&e?1:0,2&e?1:0,4&e?1:0];class s{nodes;#e;#t;#n;#i;constructor(e,t,n,i){this.nodes=[],this.#e=0,this.#i=new DataView(i),this.#t=e,this.#n=t,this.#r(n,0,[0,0,0])}#s(e=8){return this.#e+=e,this.#e-(e-1)}#r(e,t,n){if(e<=this.#n(n[0],n[1],n[2])){const i=this.#t(n[0],n[1],n[2]),{red:r,green:s,blue:a}=i,l={red:r,green:s,blue:a,x:n[0],y:n[1],z:n[2],size:e};return void o(this.#i,t,l)}const i=Array.from({length:8},(()=>0)),s=(l=e,Math.pow(2,Math.ceil(Math.log2(l))));var l;const c=s/2;for(let e=0;e<8;e++){const t=r(e),s=n[0]+t[0]*c,o=n[1]+t[1]*c,a=n[2]+t[2]*c;for(let t=s;t<s+c;t++)for(let n=o;n<o+c;n++)for(let r=a;r<a+c;r++)this.#t(t,n,r)&&i[e]++}let u=0;const h=i.reduce(((e,t,n)=>t>0?(u=n+1,e|1<<n):e),0);if(i.reduce(((e,t)=>e+t),0)===s**3){const i=n.map((e=>e+s/2)),{red:r,green:a,blue:l}=this.#t(i[0],i[1],i[2]),c={red:r,green:a,blue:l,x:n[0],y:n[1],z:n[2],size:e};return void o(this.#i,t,c)}const d=this.#s(u),p=d-t;i.forEach(((e,t)=>{if(e){const e=d+t,i=r(t),s=n[0]+i[0]*c,o=n[1]+i[1]*c,a=n[2]+i[2]*c;this.#r(c,e,[s,o,a])}}));const f={firstChildIndex:p,childMask:h,x:n[0],y:n[1],z:n[2],size:s,leafMask:0};a(this.#i,t,f)}get totalSize(){return this.#e*i}}const o=(e,t,n)=>{e.setUint8(t*i,0),e.setUint8(t*i+1,n.x),e.setUint8(t*i+2,n.y),e.setUint8(t*i+3,n.z),e.setUint8(t*i+4,n.red),e.setUint8(t*i+5,n.green),e.setUint8(t*i+6,n.blue),e.setUint8(t*i+7,Math.log2(n.size))},a=(e,t,n)=>{console.assert(n.firstChildIndex<2**24-1,`First child index of ${n.firstChildIndex} is too large to fit in 3 bytes`),console.assert(n.x<256,`X position of ${n.x} is too large to fit in 1 byte`),console.assert(n.y<256,`Y position of ${n.y} is too large to fit in 1 byte`),console.assert(n.z<256,`Z position of ${n.z} is too large to fit in 1 byte`),e.setUint8(t*i,n.childMask),e.setUint8(t*i+1,n.x),e.setUint8(t*i+2,n.y),e.setUint8(t*i+3,n.z),e.setUint32(t*i+4,n.firstChildIndex,!0),e.setUint8(t*i+7,Math.log2(n.size))}},234:()=>{},590:(e,t,n)=>{"use strict";n.d(t,{LV:()=>d,p:()=>u});const i=Symbol("Comlink.proxy"),r=Symbol("Comlink.endpoint"),s=Symbol("Comlink.releaseProxy"),o=Symbol("Comlink.finalizer"),a=Symbol("Comlink.thrown"),l=e=>"object"==typeof e&&null!==e||"function"==typeof e,c=new Map([["proxy",{canHandle:e=>l(e)&&e[i],serialize(e){const{port1:t,port2:n}=new MessageChannel;return u(e,t),[n,[n]]},deserialize:e=>(e.start(),d(e))}],["throw",{canHandle:e=>l(e)&&a in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function u(e,t=globalThis,n=["*"]){t.addEventListener("message",(function r(s){if(!s||!s.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:l,type:c,path:d}=Object.assign({path:[]},s.data),p=(s.data.argumentList||[]).map(b);let f;try{const t=d.slice(0,-1).reduce(((e,t)=>e[t]),e),n=d.reduce(((e,t)=>e[t]),e);switch(c){case"GET":f=n;break;case"SET":t[d.slice(-1)[0]]=b(s.data.value),f=!0;break;case"APPLY":f=n.apply(t,p);break;case"CONSTRUCT":f=function(e){return Object.assign(e,{[i]:!0})}(new n(...p));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;u(e,n),f=function(e,t){return x.set(e,t),e}(t,[t])}break;case"RELEASE":f=void 0;break;default:return}}catch(e){f={value:e,[a]:0}}Promise.resolve(f).catch((e=>({value:e,[a]:0}))).then((n=>{const[i,s]=w(n);t.postMessage(Object.assign(Object.assign({},i),{id:l}),s),"RELEASE"===c&&(t.removeEventListener("message",r),h(t),o in e&&"function"==typeof e[o]&&e[o]())})).catch((e=>{const[n,i]=w({value:new TypeError("Unserializable return value"),[a]:0});t.postMessage(Object.assign(Object.assign({},n),{id:l}),i)}))})),t.start&&t.start()}function h(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function d(e,t){return v(e,[],t)}function p(e){if(e)throw new Error("Proxy has been released and is not useable")}function f(e){return _(e,{type:"RELEASE"}).then((()=>{h(e)}))}const m=new WeakMap,g="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(m.get(e)||0)-1;m.set(e,t),0===t&&f(e)}));function v(e,t=[],n=function(){}){let i=!1;const o=new Proxy(n,{get(n,r){if(p(i),r===s)return()=>{!function(e){g&&g.unregister(e)}(o),f(e),i=!0};if("then"===r){if(0===t.length)return{then:()=>o};const n=_(e,{type:"GET",path:t.map((e=>e.toString()))}).then(b);return n.then.bind(n)}return v(e,[...t,r])},set(n,r,s){p(i);const[o,a]=w(s);return _(e,{type:"SET",path:[...t,r].map((e=>e.toString())),value:o},a).then(b)},apply(n,s,o){p(i);const a=t[t.length-1];if(a===r)return _(e,{type:"ENDPOINT"}).then(b);if("bind"===a)return v(e,t.slice(0,-1));const[l,c]=y(o);return _(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:l},c).then(b)},construct(n,r){p(i);const[s,o]=y(r);return _(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:s},o).then(b)}});return function(e,t){const n=(m.get(t)||0)+1;m.set(t,n),g&&g.register(e,t,e)}(o,e),o}function y(e){const t=e.map(w);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const x=new WeakMap;function w(e){for(const[t,n]of c)if(n.canHandle(e)){const[i,r]=n.serialize(e);return[{type:"HANDLER",name:t,value:i},r]}return[{type:"RAW",value:e},x.get(e)||[]]}function b(e){switch(e.type){case"HANDLER":return c.get(e.name).deserialize(e.value);case"RAW":return e.value}}function _(e,t,n){return new Promise((i=>{const r=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===r&&(e.removeEventListener("message",t),i(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:r},t),n)}))}},627:(e,t,n)=>{"use strict";n.d(t,{Cf:()=>a});const i=1/3,r=1/6,s=e=>0|Math.floor(e),o=new Float64Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]);function a(e=Math.random){const t=function(e){const t=512,n=new Uint8Array(t);for(let e=0;e<256;e++)n[e]=e;for(let t=0;t<255;t++){const i=t+~~(e()*(256-t)),r=n[t];n[t]=n[i],n[i]=r}for(let e=256;e<t;e++)n[e]=n[e-256];return n}(e),n=new Float64Array(t).map((e=>o[e%12*3])),a=new Float64Array(t).map((e=>o[e%12*3+1])),l=new Float64Array(t).map((e=>o[e%12*3+2]));return function(e,o,c){let u,h,d,p;const f=(e+o+c)*i,m=s(e+f),g=s(o+f),v=s(c+f),y=(m+g+v)*r,x=e-(m-y),w=o-(g-y),b=c-(v-y);let _,k,S,E,A,T;x>=w?w>=b?(_=1,k=0,S=0,E=1,A=1,T=0):x>=b?(_=1,k=0,S=0,E=1,A=0,T=1):(_=0,k=0,S=1,E=1,A=0,T=1):w<b?(_=0,k=0,S=1,E=0,A=1,T=1):x<b?(_=0,k=1,S=0,E=0,A=1,T=1):(_=0,k=1,S=0,E=1,A=1,T=0);const P=x-_+r,M=w-k+r,z=b-S+r,I=x-E+2*r,C=w-A+2*r,B=b-T+2*r,O=x-1+3*r,N=w-1+3*r,R=b-1+3*r,F=255&m,D=255&g,U=255&v;let L=.6-x*x-w*w-b*b;if(L<0)u=0;else{const e=F+t[D+t[U]];L*=L,u=L*L*(n[e]*x+a[e]*w+l[e]*b)}let q=.6-P*P-M*M-z*z;if(q<0)h=0;else{const e=F+_+t[D+k+t[U+S]];q*=q,h=q*q*(n[e]*P+a[e]*M+l[e]*z)}let j=.6-I*I-C*C-B*B;if(j<0)d=0;else{const e=F+E+t[D+A+t[U+T]];j*=j,d=j*j*(n[e]*I+a[e]*C+l[e]*B)}let V=.6-O*O-N*N-R*R;if(V<0)p=0;else{const e=F+1+t[D+1+t[U+1]];V*=V,p=V*V*(n[e]*O+a[e]*N+l[e]*R)}return 32*(u+h+d+p)}}}},t={};function n(i){var r=t[i];if(void 0!==r)return r.exports;var s=t[i]={id:i,loaded:!1,exports:{}};return e[i].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var i in t)n.o(t,i)&&!n.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},n.u=e=>e+".main.js",n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;n.g.importScripts&&(e=n.g.location+"");var t=n.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var i=t.getElementsByTagName("script");if(i.length)for(var r=i.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=i[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),n.p=e})(),n.b=document.baseURI||self.location.href,(()=>{"use strict";class e{}class t{ecs}class i{map=new Map;add(e){this.map.set(e.constructor,e)}get(e){return this.map.get(e)}has(e){return this.map.has(e)}hasAll(e){for(let t of e)if(!this.map.has(t))return!1;return!0}delete(e){this.map.delete(e)}}let r=1e-6,s=Float32Array;function o(e=0,t=0){const n=new s(2);return void 0!==e&&(n[0]=e,void 0!==t&&(n[1]=t)),n}let a=Float32Array;function l(e,t,n){const i=new a(3);return void 0!==e&&(i[0]=e,void 0!==t&&(i[1]=t,void 0!==n&&(i[2]=n))),i}const c=o;function u(e,t,n){return(n=n||new s(2))[0]=e[0]-t[0],n[1]=e[1]-t[1],n}const h=u;function d(e,t,n){return(n=n||new s(2))[0]=e[0]*t,n[1]=e[1]*t,n}const p=d;function f(e,t){return(t=t||new s(2))[0]=1/e[0],t[1]=1/e[1],t}const m=f;function g(e,t){return e[0]*t[0]+e[1]*t[1]}function v(e){const t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}const y=v;function x(e){const t=e[0],n=e[1];return t*t+n*n}const w=x;function b(e,t){const n=e[0]-t[0],i=e[1]-t[1];return Math.sqrt(n*n+i*i)}const _=b;function k(e,t){const n=e[0]-t[0],i=e[1]-t[1];return n*n+i*i}const S=k;function E(e,t){return(t=t||new s(2))[0]=e[0],t[1]=e[1],t}const A=E;function T(e,t,n){return(n=n||new s(2))[0]=e[0]*t[0],n[1]=e[1]*t[1],n}const P=T;function M(e,t,n){return(n=n||new s(2))[0]=e[0]/t[0],n[1]=e[1]/t[1],n}const z=M;var I=Object.freeze({__proto__:null,create:o,setDefaultType:function(e){const t=s;return s=e,t},fromValues:c,set:function(e,t,n){return(n=n||new s(2))[0]=e,n[1]=t,n},ceil:function(e,t){return(t=t||new s(2))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},floor:function(e,t){return(t=t||new s(2))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},round:function(e,t){return(t=t||new s(2))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},clamp:function(e,t=0,n=1,i){return(i=i||new s(2))[0]=Math.min(n,Math.max(t,e[0])),i[1]=Math.min(n,Math.max(t,e[1])),i},add:function(e,t,n){return(n=n||new s(2))[0]=e[0]+t[0],n[1]=e[1]+t[1],n},addScaled:function(e,t,n,i){return(i=i||new s(2))[0]=e[0]+t[0]*n,i[1]=e[1]+t[1]*n,i},angle:function(e,t){const n=e[0],i=e[1],r=e[0],s=e[1],o=Math.sqrt(n*n+i*i)*Math.sqrt(r*r+s*s),a=o&&g(e,t)/o;return Math.acos(a)},subtract:u,sub:h,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:function(e,t,n,i){return(i=i||new s(2))[0]=e[0]+n*(t[0]-e[0]),i[1]=e[1]+n*(t[1]-e[1]),i},lerpV:function(e,t,n,i){return(i=i||new s(2))[0]=e[0]+n[0]*(t[0]-e[0]),i[1]=e[1]+n[1]*(t[1]-e[1]),i},max:function(e,t,n){return(n=n||new s(2))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n},min:function(e,t,n){return(n=n||new s(2))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n},mulScalar:d,scale:p,divScalar:function(e,t,n){return(n=n||new s(2))[0]=e[0]/t,n[1]=e[1]/t,n},inverse:f,invert:m,cross:function(e,t,n){n=n||new a(3);const i=e[0]*t[1]-e[1]*t[0];return n[0]=0,n[1]=0,n[2]=i,n},dot:g,length:v,len:y,lengthSq:x,lenSq:w,distance:b,dist:_,distanceSq:k,distSq:S,normalize:function(e,t){t=t||new s(2);const n=e[0],i=e[1],r=Math.sqrt(n*n+i*i);return r>1e-5?(t[0]=n/r,t[1]=i/r):(t[0]=0,t[1]=0),t},negate:function(e,t){return(t=t||new s(2))[0]=-e[0],t[1]=-e[1],t},copy:E,clone:A,multiply:T,mul:P,divide:M,div:z,random:function(e=1,t){t=t||new s(2);const n=2*Math.random()*Math.PI;return t[0]=Math.cos(n)*e,t[1]=Math.sin(n)*e,t},zero:function(e){return(e=e||new s(2))[0]=0,e[1]=0,e},transformMat4:function(e,t,n){n=n||new s(2);const i=e[0],r=e[1];return n[0]=i*t[0]+r*t[4]+t[12],n[1]=i*t[1]+r*t[5]+t[13],n},transformMat3:function(e,t,n){n=n||new s(2);const i=e[0],r=e[1];return n[0]=t[0]*i+t[4]*r+t[8],n[1]=t[1]*i+t[5]*r+t[9],n}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);const C=l;function B(e,t,n){return(n=n||new a(3))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}const O=B;function N(e,t,n){return(n=n||new a(3))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n}const R=N;function F(e,t){return(t=t||new a(3))[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}const D=F;function U(e,t,n){n=n||new a(3);const i=e[2]*t[0]-e[0]*t[2],r=e[0]*t[1]-e[1]*t[0];return n[0]=e[1]*t[2]-e[2]*t[1],n[1]=i,n[2]=r,n}function L(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function q(e){const t=e[0],n=e[1],i=e[2];return Math.sqrt(t*t+n*n+i*i)}const j=q;function V(e){const t=e[0],n=e[1],i=e[2];return t*t+n*n+i*i}const G=V;function $(e,t){const n=e[0]-t[0],i=e[1]-t[1],r=e[2]-t[2];return Math.sqrt(n*n+i*i+r*r)}const W=$;function H(e,t){const n=e[0]-t[0],i=e[1]-t[1],r=e[2]-t[2];return n*n+i*i+r*r}const Y=H;function X(e,t){t=t||new a(3);const n=e[0],i=e[1],r=e[2],s=Math.sqrt(n*n+i*i+r*r);return s>1e-5?(t[0]=n/s,t[1]=i/s,t[2]=r/s):(t[0]=0,t[1]=0,t[2]=0),t}function Z(e,t){return(t=t||new a(3))[0]=e[0],t[1]=e[1],t[2]=e[2],t}const K=Z;function Q(e,t,n){return(n=n||new a(3))[0]=e[0]*t[0],n[1]=e[1]*t[1],n[2]=e[2]*t[2],n}const J=Q;function ee(e,t,n){return(n=n||new a(3))[0]=e[0]/t[0],n[1]=e[1]/t[1],n[2]=e[2]/t[2],n}const te=ee;var ne=Object.freeze({__proto__:null,create:l,setDefaultType:function(e){const t=a;return a=e,t},fromValues:C,set:function(e,t,n,i){return(i=i||new a(3))[0]=e,i[1]=t,i[2]=n,i},ceil:function(e,t){return(t=t||new a(3))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},floor:function(e,t){return(t=t||new a(3))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},round:function(e,t){return(t=t||new a(3))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},clamp:function(e,t=0,n=1,i){return(i=i||new a(3))[0]=Math.min(n,Math.max(t,e[0])),i[1]=Math.min(n,Math.max(t,e[1])),i[2]=Math.min(n,Math.max(t,e[2])),i},add:function(e,t,n){return(n=n||new a(3))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n},addScaled:function(e,t,n,i){return(i=i||new a(3))[0]=e[0]+t[0]*n,i[1]=e[1]+t[1]*n,i[2]=e[2]+t[2]*n,i},angle:function(e,t){const n=e[0],i=e[1],r=e[2],s=e[0],o=e[1],a=e[2],l=Math.sqrt(n*n+i*i+r*r)*Math.sqrt(s*s+o*o+a*a),c=l&&L(e,t)/l;return Math.acos(c)},subtract:B,sub:O,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:function(e,t,n,i){return(i=i||new a(3))[0]=e[0]+n*(t[0]-e[0]),i[1]=e[1]+n*(t[1]-e[1]),i[2]=e[2]+n*(t[2]-e[2]),i},lerpV:function(e,t,n,i){return(i=i||new a(3))[0]=e[0]+n[0]*(t[0]-e[0]),i[1]=e[1]+n[1]*(t[1]-e[1]),i[2]=e[2]+n[2]*(t[2]-e[2]),i},max:function(e,t,n){return(n=n||new a(3))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n[2]=Math.max(e[2],t[2]),n},min:function(e,t,n){return(n=n||new a(3))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n},mulScalar:N,scale:R,divScalar:function(e,t,n){return(n=n||new a(3))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n},inverse:F,invert:D,cross:U,dot:L,length:q,len:j,lengthSq:V,lenSq:G,distance:$,dist:W,distanceSq:H,distSq:Y,normalize:X,negate:function(e,t){return(t=t||new a(3))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},copy:Z,clone:K,multiply:Q,mul:J,divide:ee,div:te,random:function(e=1,t){t=t||new a(3);const n=2*Math.random()*Math.PI,i=2*Math.random()-1,r=Math.sqrt(1-i*i)*e;return t[0]=Math.cos(n)*r,t[1]=Math.sin(n)*r,t[2]=i*e,t},zero:function(e){return(e=e||new a(3))[0]=0,e[1]=0,e[2]=0,e},transformMat4:function(e,t,n){n=n||new a(3);const i=e[0],r=e[1],s=e[2],o=t[3]*i+t[7]*r+t[11]*s+t[15]||1;return n[0]=(t[0]*i+t[4]*r+t[8]*s+t[12])/o,n[1]=(t[1]*i+t[5]*r+t[9]*s+t[13])/o,n[2]=(t[2]*i+t[6]*r+t[10]*s+t[14])/o,n},transformMat4Upper3x3:function(e,t,n){n=n||new a(3);const i=e[0],r=e[1],s=e[2];return n[0]=i*t[0]+r*t[4]+s*t[8],n[1]=i*t[1]+r*t[5]+s*t[9],n[2]=i*t[2]+r*t[6]+s*t[10],n},transformMat3:function(e,t,n){n=n||new a(3);const i=e[0],r=e[1],s=e[2];return n[0]=i*t[0]+r*t[4]+s*t[8],n[1]=i*t[1]+r*t[5]+s*t[9],n[2]=i*t[2]+r*t[6]+s*t[10],n},transformQuat:function(e,t,n){n=n||new a(3);const i=t[0],r=t[1],s=t[2],o=2*t[3],l=e[0],c=e[1],u=e[2],h=r*u-s*c,d=s*l-i*u,p=i*c-r*l;return n[0]=l+h*o+2*(r*p-s*d),n[1]=c+d*o+2*(s*h-i*p),n[2]=u+p*o+2*(i*d-r*h),n},getTranslation:function(e,t){return(t=t||new a(3))[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const i=4*t;return(n=n||new a(3))[0]=e[i+0],n[1]=e[i+1],n[2]=e[i+2],n},getScaling:function(e,t){t=t||new a(3);const n=e[0],i=e[1],r=e[2],s=e[4],o=e[5],l=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+i*i+r*r),t[1]=Math.sqrt(s*s+o*o+l*l),t[2]=Math.sqrt(c*c+u*u+h*h),t}});let ie=Float32Array;function re(e,t){return(t=t||new ie(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}const se=re;function oe(e){return(e=e||new ie(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function ae(e,t){t=t||new ie(16);const n=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15],y=d*v,x=g*p,w=l*v,b=g*c,_=l*p,k=d*c,S=r*v,E=g*s,A=r*p,T=d*s,P=r*c,M=l*s,z=u*m,I=f*h,C=o*m,B=f*a,O=o*h,N=u*a,R=n*m,F=f*i,D=n*h,U=u*i,L=n*a,q=o*i,j=y*a+b*h+_*m-(x*a+w*h+k*m),V=x*i+S*h+T*m-(y*i+E*h+A*m),G=w*i+E*a+P*m-(b*i+S*a+M*m),$=k*i+A*a+M*h-(_*i+T*a+P*h),W=1/(n*j+o*V+u*G+f*$);return t[0]=W*j,t[1]=W*V,t[2]=W*G,t[3]=W*$,t[4]=W*(x*o+w*u+k*f-(y*o+b*u+_*f)),t[5]=W*(y*n+E*u+A*f-(x*n+S*u+T*f)),t[6]=W*(b*n+S*o+M*f-(w*n+E*o+P*f)),t[7]=W*(_*n+T*o+P*u-(k*n+A*o+M*u)),t[8]=W*(z*c+B*p+O*v-(I*c+C*p+N*v)),t[9]=W*(I*s+R*p+U*v-(z*s+F*p+D*v)),t[10]=W*(C*s+F*c+L*v-(B*s+R*c+q*v)),t[11]=W*(N*s+D*c+q*p-(O*s+U*c+L*p)),t[12]=W*(C*d+N*g+I*l-(O*g+z*l+B*d)),t[13]=W*(D*g+z*r+F*d-(R*d+U*g+I*r)),t[14]=W*(R*l+q*g+B*r-(L*g+C*r+F*l)),t[15]=W*(L*d+O*r+U*l-(D*l+q*d+N*r)),t}const le=ae;function ce(e,t,n){n=n||new ie(16);const i=e[0],r=e[1],s=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=e[8],d=e[9],p=e[10],f=e[11],m=e[12],g=e[13],v=e[14],y=e[15],x=t[0],w=t[1],b=t[2],_=t[3],k=t[4],S=t[5],E=t[6],A=t[7],T=t[8],P=t[9],M=t[10],z=t[11],I=t[12],C=t[13],B=t[14],O=t[15];return n[0]=i*x+a*w+h*b+m*_,n[1]=r*x+l*w+d*b+g*_,n[2]=s*x+c*w+p*b+v*_,n[3]=o*x+u*w+f*b+y*_,n[4]=i*k+a*S+h*E+m*A,n[5]=r*k+l*S+d*E+g*A,n[6]=s*k+c*S+p*E+v*A,n[7]=o*k+u*S+f*E+y*A,n[8]=i*T+a*P+h*M+m*z,n[9]=r*T+l*P+d*M+g*z,n[10]=s*T+c*P+p*M+v*z,n[11]=o*T+u*P+f*M+y*z,n[12]=i*I+a*C+h*B+m*O,n[13]=r*I+l*C+d*B+g*O,n[14]=s*I+c*C+p*B+v*O,n[15]=o*I+u*C+f*B+y*O,n}const ue=ce;let he,de,pe;function fe(e,t,n){n=n||new ie(16);let i=e[0],r=e[1],s=e[2];const o=Math.sqrt(i*i+r*r+s*s);i/=o,r/=o,s/=o;const a=i*i,l=r*r,c=s*s,u=Math.cos(t),h=Math.sin(t),d=1-u;return n[0]=a+(1-a)*u,n[1]=i*r*d+s*h,n[2]=i*s*d-r*h,n[3]=0,n[4]=i*r*d-s*h,n[5]=l+(1-l)*u,n[6]=r*s*d+i*h,n[7]=0,n[8]=i*s*d+r*h,n[9]=r*s*d-i*h,n[10]=c+(1-c)*u,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}const me=fe;function ge(e,t,n,i){i=i||new ie(16);let r=t[0],s=t[1],o=t[2];const a=Math.sqrt(r*r+s*s+o*o);r/=a,s/=a,o/=a;const l=r*r,c=s*s,u=o*o,h=Math.cos(n),d=Math.sin(n),p=1-h,f=l+(1-l)*h,m=r*s*p+o*d,g=r*o*p-s*d,v=r*s*p-o*d,y=c+(1-c)*h,x=s*o*p+r*d,w=r*o*p+s*d,b=s*o*p-r*d,_=u+(1-u)*h,k=e[0],S=e[1],E=e[2],A=e[3],T=e[4],P=e[5],M=e[6],z=e[7],I=e[8],C=e[9],B=e[10],O=e[11];return i[0]=f*k+m*T+g*I,i[1]=f*S+m*P+g*C,i[2]=f*E+m*M+g*B,i[3]=f*A+m*z+g*O,i[4]=v*k+y*T+x*I,i[5]=v*S+y*P+x*C,i[6]=v*E+y*M+x*B,i[7]=v*A+y*z+x*O,i[8]=w*k+b*T+_*I,i[9]=w*S+b*P+_*C,i[10]=w*E+b*M+_*B,i[11]=w*A+b*z+_*O,e!==i&&(i[12]=e[12],i[13]=e[13],i[14]=e[14],i[15]=e[15]),i}const ve=ge;var ye=Object.freeze({__proto__:null,setDefaultType:function(e){const t=ie;return ie=e,t},create:function(e,t,n,i,r,s,o,a,l,c,u,h,d,p,f,m){const g=new ie(16);return void 0!==e&&(g[0]=e,void 0!==t&&(g[1]=t,void 0!==n&&(g[2]=n,void 0!==i&&(g[3]=i,void 0!==r&&(g[4]=r,void 0!==s&&(g[5]=s,void 0!==o&&(g[6]=o,void 0!==a&&(g[7]=a,void 0!==l&&(g[8]=l,void 0!==c&&(g[9]=c,void 0!==u&&(g[10]=u,void 0!==h&&(g[11]=h,void 0!==d&&(g[12]=d,void 0!==p&&(g[13]=p,void 0!==f&&(g[14]=f,void 0!==m&&(g[15]=m)))))))))))))))),g},set:function(e,t,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g){return(g=g||new ie(16))[0]=e,g[1]=t,g[2]=n,g[3]=i,g[4]=r,g[5]=s,g[6]=o,g[7]=a,g[8]=l,g[9]=c,g[10]=u,g[11]=h,g[12]=d,g[13]=p,g[14]=f,g[15]=m,g},fromMat3:function(e,t){return(t=t||new ie(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=0,t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=0,t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromQuat:function(e,t){t=t||new ie(16);const n=e[0],i=e[1],r=e[2],s=e[3],o=n+n,a=i+i,l=r+r,c=n*o,u=i*o,h=i*a,d=r*o,p=r*a,f=r*l,m=s*o,g=s*a,v=s*l;return t[0]=1-h-f,t[1]=u+v,t[2]=d-g,t[3]=0,t[4]=u-v,t[5]=1-c-f,t[6]=p+m,t[7]=0,t[8]=d+g,t[9]=p-m,t[10]=1-c-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},negate:function(e,t){return(t=t||new ie(16))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t[9]=-e[9],t[10]=-e[10],t[11]=-e[11],t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=-e[15],t},copy:re,clone:se,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r&&Math.abs(e[4]-t[4])<r&&Math.abs(e[5]-t[5])<r&&Math.abs(e[6]-t[6])<r&&Math.abs(e[7]-t[7])<r&&Math.abs(e[8]-t[8])<r&&Math.abs(e[9]-t[9])<r&&Math.abs(e[10]-t[10])<r&&Math.abs(e[11]-t[11])<r&&Math.abs(e[12]-t[12])<r&&Math.abs(e[13]-t[13])<r&&Math.abs(e[14]-t[14])<r&&Math.abs(e[15]-t[15])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},identity:oe,transpose:function(e,t){if((t=t||new ie(16))===e){let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,t}const n=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15];return t[0]=n,t[1]=o,t[2]=u,t[3]=f,t[4]=i,t[5]=a,t[6]=h,t[7]=m,t[8]=r,t[9]=l,t[10]=d,t[11]=g,t[12]=s,t[13]=c,t[14]=p,t[15]=v,t},inverse:ae,determinant:function(e){const t=e[0],n=e[1],i=e[2],r=e[3],s=e[4],o=e[5],a=e[6],l=e[7],c=e[8],u=e[9],h=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],v=h*g,y=m*d,x=a*g,w=m*l,b=a*d,_=h*l,k=i*g,S=m*r,E=i*d,A=h*r,T=i*l,P=a*r;return t*(v*o+w*u+b*f-(y*o+x*u+_*f))+s*(y*n+k*u+A*f-(v*n+S*u+E*f))+c*(x*n+S*o+T*f-(w*n+k*o+P*f))+p*(_*n+E*o+P*u-(b*n+A*o+T*u))},invert:le,multiply:ce,mul:ue,setTranslation:function(e,t,n){return e!==(n=n||oe())&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11]),n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},getTranslation:function(e,t){return(t=t||l())[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const i=4*t;return(n=n||l())[0]=e[i+0],n[1]=e[i+1],n[2]=e[i+2],n},setAxis:function(e,t,n,i){i!==e&&(i=re(e,i));const r=4*n;return i[r+0]=t[0],i[r+1]=t[1],i[r+2]=t[2],i},getScaling:function(e,t){t=t||l();const n=e[0],i=e[1],r=e[2],s=e[4],o=e[5],a=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+i*i+r*r),t[1]=Math.sqrt(s*s+o*o+a*a),t[2]=Math.sqrt(c*c+u*u+h*h),t},perspective:function(e,t,n,i,r){r=r||new ie(16);const s=Math.tan(.5*Math.PI-.5*e);if(r[0]=s/t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=s,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i===1/0)r[10]=-1,r[14]=-n;else{const e=1/(n-i);r[10]=i*e,r[14]=i*n*e}return r},ortho:function(e,t,n,i,r,s,o){return(o=o||new ie(16))[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(i-n),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(r-s),o[11]=0,o[12]=(t+e)/(e-t),o[13]=(i+n)/(n-i),o[14]=r/(r-s),o[15]=1,o},frustum:function(e,t,n,i,r,s,o){const a=t-e,l=i-n,c=r-s;return(o=o||new ie(16))[0]=2*r/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*r/l,o[6]=0,o[7]=0,o[8]=(e+t)/a,o[9]=(i+n)/l,o[10]=s/c,o[11]=-1,o[12]=0,o[13]=0,o[14]=r*s/c,o[15]=0,o},aim:function(e,t,n,i){return i=i||new ie(16),he=he||l(),de=de||l(),pe=pe||l(),X(B(t,e,pe),pe),X(U(n,pe,he),he),X(U(pe,he,de),de),i[0]=he[0],i[1]=he[1],i[2]=he[2],i[3]=0,i[4]=de[0],i[5]=de[1],i[6]=de[2],i[7]=0,i[8]=pe[0],i[9]=pe[1],i[10]=pe[2],i[11]=0,i[12]=e[0],i[13]=e[1],i[14]=e[2],i[15]=1,i},cameraAim:function(e,t,n,i){return i=i||new ie(16),he=he||l(),de=de||l(),pe=pe||l(),X(B(e,t,pe),pe),X(U(n,pe,he),he),X(U(pe,he,de),de),i[0]=he[0],i[1]=he[1],i[2]=he[2],i[3]=0,i[4]=de[0],i[5]=de[1],i[6]=de[2],i[7]=0,i[8]=pe[0],i[9]=pe[1],i[10]=pe[2],i[11]=0,i[12]=e[0],i[13]=e[1],i[14]=e[2],i[15]=1,i},lookAt:function(e,t,n,i){return i=i||new ie(16),he=he||l(),de=de||l(),pe=pe||l(),X(B(e,t,pe),pe),X(U(n,pe,he),he),X(U(pe,he,de),de),i[0]=he[0],i[1]=de[0],i[2]=pe[0],i[3]=0,i[4]=he[1],i[5]=de[1],i[6]=pe[1],i[7]=0,i[8]=he[2],i[9]=de[2],i[10]=pe[2],i[11]=0,i[12]=-(he[0]*e[0]+he[1]*e[1]+he[2]*e[2]),i[13]=-(de[0]*e[0]+de[1]*e[1]+de[2]*e[2]),i[14]=-(pe[0]*e[0]+pe[1]*e[1]+pe[2]*e[2]),i[15]=1,i},translation:function(e,t){return(t=t||new ie(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},translate:function(e,t,n){n=n||new ie(16);const i=t[0],r=t[1],s=t[2],o=e[0],a=e[1],l=e[2],c=e[3],u=e[4],h=e[5],d=e[6],p=e[7],f=e[8],m=e[9],g=e[10],v=e[11],y=e[12],x=e[13],w=e[14],b=e[15];return e!==n&&(n[0]=o,n[1]=a,n[2]=l,n[3]=c,n[4]=u,n[5]=h,n[6]=d,n[7]=p,n[8]=f,n[9]=m,n[10]=g,n[11]=v),n[12]=o*i+u*r+f*s+y,n[13]=a*i+h*r+m*s+x,n[14]=l*i+d*r+g*s+w,n[15]=c*i+p*r+v*s+b,n},rotationX:function(e,t){t=t||new ie(16);const n=Math.cos(e),i=Math.sin(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=i,t[7]=0,t[8]=0,t[9]=-i,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateX:function(e,t,n){n=n||new ie(16);const i=e[4],r=e[5],s=e[6],o=e[7],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[4]=h*i+d*a,n[5]=h*r+d*l,n[6]=h*s+d*c,n[7]=h*o+d*u,n[8]=h*a-d*i,n[9]=h*l-d*r,n[10]=h*c-d*s,n[11]=h*u-d*o,e!==n&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationY:function(e,t){t=t||new ie(16);const n=Math.cos(e),i=Math.sin(e);return t[0]=n,t[1]=0,t[2]=-i,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=i,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateY:function(e,t,n){n=n||new ie(16);const i=e[0],r=e[1],s=e[2],o=e[3],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[0]=h*i-d*a,n[1]=h*r-d*l,n[2]=h*s-d*c,n[3]=h*o-d*u,n[8]=h*a+d*i,n[9]=h*l+d*r,n[10]=h*c+d*s,n[11]=h*u+d*o,e!==n&&(n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationZ:function(e,t){t=t||new ie(16);const n=Math.cos(e),i=Math.sin(e);return t[0]=n,t[1]=i,t[2]=0,t[3]=0,t[4]=-i,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateZ:function(e,t,n){n=n||new ie(16);const i=e[0],r=e[1],s=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=Math.cos(t),d=Math.sin(t);return n[0]=h*i+d*a,n[1]=h*r+d*l,n[2]=h*s+d*c,n[3]=h*o+d*u,n[4]=h*a-d*i,n[5]=h*l-d*r,n[6]=h*c-d*s,n[7]=h*u-d*o,e!==n&&(n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},axisRotation:fe,rotation:me,axisRotate:ge,rotate:ve,scaling:function(e,t){return(t=t||new ie(16))[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},scale:function(e,t,n){n=n||new ie(16);const i=t[0],r=t[1],s=t[2];return n[0]=i*e[0],n[1]=i*e[1],n[2]=i*e[2],n[3]=i*e[3],n[4]=r*e[4],n[5]=r*e[5],n[6]=r*e[6],n[7]=r*e[7],n[8]=s*e[8],n[9]=s*e[9],n[10]=s*e[10],n[11]=s*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},uniformScaling:function(e,t){return(t=t||new ie(16))[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},uniformScale:function(e,t,n){return(n=n||new ie(16))[0]=t*e[0],n[1]=t*e[1],n[2]=t*e[2],n[3]=t*e[3],n[4]=t*e[4],n[5]=t*e[5],n[6]=t*e[6],n[7]=t*e[7],n[8]=t*e[8],n[9]=t*e[9],n[10]=t*e[10],n[11]=t*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n}});let xe=Float32Array;function we(e,t,n,i){const r=new xe(4);return void 0!==e&&(r[0]=e,void 0!==t&&(r[1]=t,void 0!==n&&(r[2]=n,void 0!==i&&(r[3]=i)))),r}const be=we;function _e(e,t,n){n=n||new xe(4);const i=.5*t,r=Math.sin(i);return n[0]=r*e[0],n[1]=r*e[1],n[2]=r*e[2],n[3]=Math.cos(i),n}function ke(e,t,n){n=n||new xe(4);const i=e[0],r=e[1],s=e[2],o=e[3],a=t[0],l=t[1],c=t[2],u=t[3];return n[0]=i*u+o*a+r*c-s*l,n[1]=r*u+o*l+s*a-i*c,n[2]=s*u+o*c+i*l-r*a,n[3]=o*u-i*a-r*l-s*c,n}const Se=ke;function Ee(e,t,n,i){i=i||new xe(4);const s=e[0],o=e[1],a=e[2],l=e[3];let c,u,h=t[0],d=t[1],p=t[2],f=t[3],m=s*h+o*d+a*p+l*f;if(m<0&&(m=-m,h=-h,d=-d,p=-p,f=-f),1-m>r){const e=Math.acos(m),t=Math.sin(e);c=Math.sin((1-n)*e)/t,u=Math.sin(n*e)/t}else c=1-n,u=n;return i[0]=c*s+u*h,i[1]=c*o+u*d,i[2]=c*a+u*p,i[3]=c*l+u*f,i}function Ae(e,t){return(t=t||new xe(4))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}const Te=Ae;function Pe(e,t,n){return(n=n||new xe(4))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n}const Me=Pe;function ze(e,t,n){return(n=n||new xe(4))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n}const Ie=ze;function Ce(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Be(e){const t=e[0],n=e[1],i=e[2],r=e[3];return Math.sqrt(t*t+n*n+i*i+r*r)}const Oe=Be;function Ne(e){const t=e[0],n=e[1],i=e[2],r=e[3];return t*t+n*n+i*i+r*r}const Re=Ne;function Fe(e,t){t=t||new xe(4);const n=e[0],i=e[1],r=e[2],s=e[3],o=Math.sqrt(n*n+i*i+r*r+s*s);return o>1e-5?(t[0]=n/o,t[1]=i/o,t[2]=r/o,t[3]=s/o):(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}let De,Ue,Le,qe,je;var Ve=Object.freeze({__proto__:null,create:we,setDefaultType:function(e){const t=xe;return xe=e,t},fromValues:be,set:function(e,t,n,i,r){return(r=r||new xe(4))[0]=e,r[1]=t,r[2]=n,r[3]=i,r},fromAxisAngle:_e,toAxisAngle:function(e,t){t=t||l(4);const n=2*Math.acos(e[3]),i=Math.sin(.5*n);return i>r?(t[0]=e[0]/i,t[1]=e[1]/i,t[2]=e[2]/i):(t[0]=1,t[1]=0,t[2]=0),{angle:n,axis:t}},angle:function(e,t){const n=Ce(e,t);return Math.acos(2*n*n-1)},multiply:ke,mul:Se,rotateX:function(e,t,n){n=n||new xe(4);const i=.5*t,r=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(i),c=Math.cos(i);return n[0]=r*c+a*l,n[1]=s*c+o*l,n[2]=o*c-s*l,n[3]=a*c-r*l,n},rotateY:function(e,t,n){n=n||new xe(4);const i=.5*t,r=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(i),c=Math.cos(i);return n[0]=r*c-o*l,n[1]=s*c+a*l,n[2]=o*c+r*l,n[3]=a*c-s*l,n},rotateZ:function(e,t,n){n=n||new xe(4);const i=.5*t,r=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(i),c=Math.cos(i);return n[0]=r*c+s*l,n[1]=s*c-r*l,n[2]=o*c+a*l,n[3]=a*c-o*l,n},slerp:Ee,inverse:function(e,t){t=t||new xe(4);const n=e[0],i=e[1],r=e[2],s=e[3],o=n*n+i*i+r*r+s*s,a=o?1/o:0;return t[0]=-n*a,t[1]=-i*a,t[2]=-r*a,t[3]=s*a,t},conjugate:function(e,t){return(t=t||new xe(4))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},fromMat:function(e,t){t=t||new xe(4);const n=e[0]+e[5]+e[10];if(n>0){const i=Math.sqrt(n+1);t[3]=.5*i;const r=.5/i;t[0]=(e[6]-e[9])*r,t[1]=(e[8]-e[2])*r,t[2]=(e[1]-e[4])*r}else{let n=0;e[5]>e[0]&&(n=1),e[10]>e[4*n+n]&&(n=2);const i=(n+1)%3,r=(n+2)%3,s=Math.sqrt(e[4*n+n]-e[4*i+i]-e[4*r+r]+1);t[n]=.5*s;const o=.5/s;t[3]=(e[4*i+r]-e[4*r+i])*o,t[i]=(e[4*i+n]+e[4*n+i])*o,t[r]=(e[4*r+n]+e[4*n+r])*o}return t},fromEuler:function(e,t,n,i,r){r=r||new xe(4);const s=.5*e,o=.5*t,a=.5*n,l=Math.sin(s),c=Math.cos(s),u=Math.sin(o),h=Math.cos(o),d=Math.sin(a),p=Math.cos(a);switch(i){case"xyz":r[0]=l*h*p+c*u*d,r[1]=c*u*p-l*h*d,r[2]=c*h*d+l*u*p,r[3]=c*h*p-l*u*d;break;case"xzy":r[0]=l*h*p-c*u*d,r[1]=c*u*p-l*h*d,r[2]=c*h*d+l*u*p,r[3]=c*h*p+l*u*d;break;case"yxz":r[0]=l*h*p+c*u*d,r[1]=c*u*p-l*h*d,r[2]=c*h*d-l*u*p,r[3]=c*h*p+l*u*d;break;case"yzx":r[0]=l*h*p+c*u*d,r[1]=c*u*p+l*h*d,r[2]=c*h*d-l*u*p,r[3]=c*h*p-l*u*d;break;case"zxy":r[0]=l*h*p-c*u*d,r[1]=c*u*p+l*h*d,r[2]=c*h*d+l*u*p,r[3]=c*h*p-l*u*d;break;case"zyx":r[0]=l*h*p-c*u*d,r[1]=c*u*p+l*h*d,r[2]=c*h*d-l*u*p,r[3]=c*h*p+l*u*d;break;default:throw new Error(`Unknown rotation order: ${i}`)}return r},copy:Ae,clone:Te,add:function(e,t,n){return(n=n||new xe(4))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n},subtract:Pe,sub:Me,mulScalar:ze,scale:Ie,divScalar:function(e,t,n){return(n=n||new xe(4))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n[3]=e[3]/t,n},dot:Ce,lerp:function(e,t,n,i){return(i=i||new xe(4))[0]=e[0]+n*(t[0]-e[0]),i[1]=e[1]+n*(t[1]-e[1]),i[2]=e[2]+n*(t[2]-e[2]),i[3]=e[3]+n*(t[3]-e[3]),i},length:Be,len:Oe,lengthSq:Ne,lenSq:Re,normalize:Fe,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(e){return(e=e||new xe(4))[0]=0,e[1]=0,e[2]=0,e[3]=1,e},rotationTo:function(e,t,n){n=n||new xe(4),De=De||l(),Ue=Ue||l(1,0,0),Le=Le||l(0,1,0);const i=L(e,t);return i<-.999999?(U(Ue,e,De),j(De)<1e-6&&U(Le,e,De),X(De,De),_e(De,Math.PI,n),n):i>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(U(e,t,De),n[0]=De[0],n[1]=De[1],n[2]=De[2],n[3]=1+i,Fe(n,n))},sqlerp:function(e,t,n,i,r,s){return s=s||new xe(4),qe=qe||new xe(4),je=je||new xe(4),Ee(e,i,r,qe),Ee(t,n,r,je),Ee(qe,je,2*r*(1-r),s),s}});Float32Array;const Ge=(e,t)=>{const n=new Uint32Array(t);Is.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},$e=(e,t)=>{const n=new Uint32Array(e),i=Is.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return Ge(i,e),i},We=(e,t)=>{if(t instanceof Float32Array)Is.queue.writeBuffer(e,0,t.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT);else{const n=new Float32Array(t);Is.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)}},He="// Constants\nconst infinity : f32 = 99999999.0;\n\n// Utility functions\nfn degreesToRadians(degrees : f32) -> f32 {\n    return degrees * (3.1415926535897932385 / 180.0);\n}\n\nfn unitVector(v : vec3<f32>) -> vec3<f32> {\n    return v / length(v);\n}\n\nfn lengthSquared(v : vec3<f32>) -> f32 {\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nfn random(co : vec2<f32>) -> f32 {\n    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn randomMinMax(co : vec2<f32>, min : f32, max : f32) -> f32 {\n    return min + (max - min) * random(co);\n}\n\nfn randomFloat3(co : vec2<f32>) -> vec3<f32> {\n    return vec3<f32>(random(co), random(co * 2.0), random(co * 3.0));\n}\n\nfn randomFloat3MinMax(co : vec2<f32>, min : f32, max : f32) -> vec3<f32> {\n    return vec3<f32>(randomMinMax(co, min, max), randomMinMax(co * 2.0, min, max), randomMinMax(co * 3.0, min, max));\n}\n\nfn randomInUnitSphere(co : vec2<f32>) -> vec3<f32> {\n    var p : vec3<f32> = randomFloat3MinMax(co, -1.0, 1.0);\n    while (lengthSquared(p) < 1.0) {\n        p = randomFloat3MinMax(co, -1.0, 1.0);\n    }\n    return p;\n}\n\nfn randomInUnitDisk(seed : vec2<f32>) -> vec2<f32> {\n    let r = sqrt(random(seed));\n    let theta = 2.0 * 3.14159265359 * random(vec2<f32>(seed.y, seed.x));\n    return vec2<f32>(cos(theta), sin(theta)) * r;\n}\n\nfn randomInPlanarUnitDisk(seed : vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\n    let disk = randomInUnitDisk(seed);\n    var diskNormal = cross(normal, vec3<f32>(0.0, 1.0, 0.0));\n    if (length(diskNormal) < 0.01) {\n        diskNormal = cross(normal, vec3<f32>(1.0, 0.0, 0.0));\n    }\n    diskNormal = normalize(diskNormal);\n    let diskTangent = cross(diskNormal, normal);\n    return disk.x * diskTangent + disk.y * diskNormal;\n}\n\nfn reflect(v : vec3<f32>, n : vec3<f32>) -> vec3<f32> {\n    return v - 2.0 * dot(v, n) * n;\n}\n\nfn randomUnitVector(co : vec2<f32>) -> vec3<f32> {\n    return unitVector(randomInUnitSphere(co));\n}\n\nfn nearZero(e : vec3<f32>) -> bool {\n    const s : f32 = 1e-8;\n    return (abs(e.x) < s) && (abs(e.y) < s) && (abs(e.z) < s);\n}\n\nfn randomInHemisphere(co : vec2<f32>, normal : vec3<f32>) -> vec3<f32> {\n    let inUnitSphere = randomUnitVector(co);\n    if (dot(inUnitSphere, normal) > 0.0) {\n        return inUnitSphere;\n    }\n    return -inUnitSphere;\n}\n\nfn randomAlongVector(co : vec2<f32>, direction : vec3<f32>) -> vec3<f32> {\n    return normalize(direction) * random(co);\n}\n\n// Function to perturb the normal vector within the hemisphere\nfn perturbDirection(normal: vec3<f32>, scatterAmount: f32, co: vec2<f32>) -> vec3<f32> {\n    // Generate a random vector in a hemisphere\n    let hemisphereVector : vec3<f32> = randomInHemisphere(co, normal);\n\n    // Combine the perturbation with the original normal\n    let perturbedDir : vec3<f32> = normalize(normal + scatterAmount * hemisphereVector);\n\n    return perturbedDir;\n}\n\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\nfn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfn perlinNoise3(P: vec3<f32>) -> f32 {\n    var Pi0 : vec3<f32> = floor(P); // Integer part for indexing\n    var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1\n    Pi0 = Pi0 % vec3<f32>(289.);\n    Pi1 = Pi1 % vec3<f32>(289.);\n    let Pf0 = fract(P); // Fractional part for interpolation\n    let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.\n    let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy = vec4<f32>(Pi0.yy, Pi1.yy);\n    let iz0 = Pi0.zzzz;\n    let iz1 = Pi1.zzzz;\n\n    let ixy = permute4(permute4(ix) + iy);\n    let ixy0 = permute4(ixy + iz0);\n    let ixy1 = permute4(ixy + iz1);\n\n    var gx0: vec4<f32> = ixy0 / 7.;\n    var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;\n    gx0 = fract(gx0);\n    var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\n    var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));\n    gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);\n    gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);\n\n    var gx1: vec4<f32> = ixy1 / 7.;\n    var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;\n    gx1 = fract(gx1);\n    var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\n    var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));\n    gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);\n    gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);\n\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\n\n    let norm0 = taylorInvSqrt4(\n        vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 = g000 * norm0.x;\n    g010 = g010 * norm0.y;\n    g100 = g100 * norm0.z;\n    g110 = g110 * norm0.w;\n    let norm1 = taylorInvSqrt4(\n        vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 = g001 * norm1.x;\n    g011 = g011 * norm1.y;\n    g101 = g101 * norm1.z;\n    g111 = g111 * norm1.w;\n\n    let n000 = dot(g000, Pf0);\n    let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\n    let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\n    let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\n    let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\n    let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\n    let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\n    let n111 = dot(g111, Pf1);\n\n    var fade_xyz: vec3<f32> = fade3(Pf0);\n    let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix\n    let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);\n    let n_yz = mix(n_z.xy, n_z.zw, vec2f(f32(fade_xyz.y))); // simplify after chrome bug fix\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}",Ye="fn calculateRayDirection(uv: vec2<f32>, inverseProjection: mat4x4<f32>) -> vec3<f32> {\n  let clipSpace = vec2(1.0 - uv.x, 1.0 - uv.y) * 2.0 - 1.0;\n  let viewRay = vec3<f32>(clipSpace, 1.0);\n  let viewRayView = inverseProjection * vec4(viewRay, 1.0);\n  return normalize(viewRayView.xyz);\n}\n\nfn normaliseValue(min: f32, max: f32, value: f32) -> f32 {\n  return (value - min) / (max - min);\n}",Xe="struct BoxIntersectionResult {\n    tNear: f32,\n    tFar: f32,\n    normal: vec3<f32>,\n    isHit: bool,\n}\n\nfn boxIntersection(\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n    boxSize: vec3<f32>,\n) -> BoxIntersectionResult {\n    var result = BoxIntersectionResult();\n    result.isHit = false;\n    result.tNear = 0.0;\n    result.tFar = 0.0;\n\n    let offsetRayOrigin = ro - boxSize;\n    let m: vec3<f32> = 1.0 / rd;\n    let n: vec3<f32> = m * offsetRayOrigin;\n    let k: vec3<f32> = abs(m) * boxSize;\n    let t1: vec3<f32> = -n - k;\n    let t2: vec3<f32> = -n + k;\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) {\n        return result;\n    }\n    // Check if the ray starts inside the volume\n    let insideVolume = tN < 0.0;\n    var normal = select(\n        step(vec3<f32>(tN), t1),\n        step(t2, vec3<f32>(tF)),\n        tN < 0.0,\n    );\n    normal *= -sign(rd);\n    // Check if the intersection is in the correct direction, only if inside the volume\n    if (insideVolume && dot(normal, rd) < 0.0) {\n        return result;\n    }\n    result.tNear = tN;\n    result.tFar = tF;\n    result.normal = normal;\n    result.isHit = true;\n    return result;\n}\n\nfn get3x3From4x4(m: mat4x4<f32>) -> mat3x3<f32> {\n    return mat3x3<f32>(\n        m[0].xyz,\n        m[1].xyz,\n        m[2].xyz,\n    );\n}\n\n\nfn intersectOBB(\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n    boxSize: vec3<f32>,\n    boxOrientation: mat3x3<f32>,\n) -> BoxIntersectionResult {\n    var result = BoxIntersectionResult();\n    result.isHit = false;\n    result.tNear = -1.0;\n    result.tFar = -1.0;\n\n    let offsetRayOrigin = ro - boxSize;\n    let m: vec3<f32> = 1.0 / rd;\n    let n: vec3<f32> = m * offsetRayOrigin;\n    let k: vec3<f32> = abs(m) * boxSize;\n    let t1: vec3<f32> = -n - k;\n    let t2: vec3<f32> = -n + k;\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) {\n        return result;\n    }\n    // Check if the ray starts inside the volume\n    let insideVolume = tN < 0.0;\n    var normal = select(\n        step(vec3<f32>(tN), t1),\n        step(t2, vec3<f32>(tF)),\n        tN < 0.0,\n    );\n    normal *= -sign(rd);\n    // Check if the intersection is in the correct direction, only if inside the volume\n    if (insideVolume && dot(normal, rd) < 0.0) {\n        return result;\n    }\n    result.tNear = tN;\n    result.tFar = tF;\n    result.normal = normal;\n    result.isHit = true;\n    return result;\n}",Ze='const EPSILON = 0.001;\nconst MAX_RAY_STEPS = 256;\nconst FAR_PLANE = 10000.0;\nconst NEAR_PLANE = 0.5;\nconst STACK_LEN: u32 = 32u;\n\n// Function to transform a normal vector from object to world space\nfn transformNormal(inverseTransform: mat4x4<f32>, normal: vec3<f32>) -> vec3<f32> {\n    let worldNormal = normalize((vec4<f32>(normal, 0.0) * inverseTransform).xyz);\n    return worldNormal;\n}\n\n// Function to transform an object space position to world space\nfn transformPosition(transform: mat4x4<f32>, position: vec3<f32>) -> vec3<f32> {\n    let worldPosition = (transform * vec4<f32>(position, 1.0)).xyz;\n    return worldPosition;\n}\n\n\nstruct VoxelObject {\n  transform: mat4x4<f32>,\n  inverseTransform: mat4x4<f32>,\n  previousTransform: mat4x4<f32>,\n  previousInverseTransform: mat4x4<f32>,\n  size : vec3<f32>,\n  atlasLocation : vec3<f32>,\n  paletteIndex : f32,\n  octreeBufferIndex: u32\n}\n\nstruct RayMarchResult {\n  voxelObjectIndex: i32,\n  colour: vec3<f32>,\n  normal: vec3<f32>,\n  hit: bool,\n  t: f32,\n  iterations: u32,\n}\n\nfn isInBounds(position: vec3<i32>, size: vec3<i32>) -> bool {\n  return all(position >= vec3(0)) && all(position <= size - vec3(1));\n}\n\nfn getBit(value: u32, bitIndex: u32) -> bool {\n  return (value & (1u << bitIndex)) != 0;\n}\n\nfn getScaleFromMatrix(transform: mat4x4<f32>) -> vec3<f32> {\n  return vec3<f32>(length(transform[0].xyz), length(transform[1].xyz), length(transform[2].xyz));\n}\n\nstruct Stack {\n  arr: array<i32, STACK_LEN>,\n\thead: u32,\n}\n\nfn stack_new() -> Stack {\n    var arr: array<i32, STACK_LEN>;\n    return Stack(arr, 0u);\n}\n\nfn stack_push(stack: ptr<function, Stack>, val: i32) {\n    (*stack).arr[(*stack).head] = val;\n    (*stack).head += 1u;\n}\n\nfn stack_pop(stack: ptr<function, Stack>) -> i32 {\n    (*stack).head -= 1u;\n    return (*stack).arr[(*stack).head];\n}\n\nstruct StackU32 {\n  arr: array<u32, STACK_LEN>,\n  head: u32,\n}\n\nfn stacku32_new() -> StackU32 {\n    var arr: array<u32, STACK_LEN>;\n    return StackU32(arr, 0u);\n}\n\nfn stacku32_push(stack: ptr<function, StackU32>, val: u32) {\n    (*stack).arr[(*stack).head] = val;\n    (*stack).head += 1u;\n}\n\nfn stacku32_pop(stack: ptr<function, StackU32>) -> u32 {\n    (*stack).head -= 1u;\n    return (*stack).arr[(*stack).head];\n}\n\n\nstruct InternalNode {\n  firstChildOffset: u32,\n  childMask: u32,\n  position: vec3<u32>,\n  size: u32,\n}\n\nstruct LeafNode {\n  colour: vec3<u32>,\n  position: vec3<u32>,\n  size: u32,\n}\n\nconst mask8 = 0xFFu;\nconst mask16 = 0xFFFFu;\nconst mask24 = 0xFFFFFFu;\n\n// if first child offset is 0, then it is a leaf\nfn isLeaf(node:vec2<u32>) -> bool {\n  return (node[0] & mask8) == 0;\n}\n\n/**\n  * Unpacks a leaf node from a 32 bit integer\n  * First 8 bits are the leaf flag (0)\n  * The next 8 bits are the x position\n  * The next 8 bits are the y position\n  * The next 8 bits are the z position\n  * The next 8 bits are the red component\n  * The next 8 bits are the green component\n  * The next 8 bits are the blue component\n\n  */\nfn unpackLeaf(node: vec2<u32>) -> LeafNode {\n  var output = LeafNode();\n  let first4Bytes = node.x;\n  let second4Bytes = node.y;\n  let x = (first4Bytes >> 8u) & mask8;\n  let y = (first4Bytes >> 16u) & mask8;\n  let z = (first4Bytes >> 24u) & mask8;\n  let r = second4Bytes & mask8;\n  let g = (second4Bytes >> 8u) & mask8;\n  let b = (second4Bytes >> 16u) & mask8;\n  output.colour = vec3<u32>(r, g, b);\n  output.position = vec3<u32>(x, y, z);\n  output.size = 1u << ((second4Bytes >> 24u) & mask8);\n  return output;\n}\n\n/**\n  * Unpacks an internal node from a 32 bit integer\n  * First 8 bits are the child mask\n  * The next 8 bits are the x position\n  * The next 8 bits are the y position\n  * The next 8 bits are the z position\n  * The next 24 bits are the firstChildOffset\n  * The next 8 bits are the size\n  */\nfn unpackInternal(node: vec2<u32>) -> InternalNode {\n  var output = InternalNode();\n  let first4Bytes = node.x;\n  let second4Bytes = node.y;\n  output.childMask = first4Bytes & mask8;\n  let x = (first4Bytes >> 8u) & mask8;\n  let y = (first4Bytes >> 16u) & mask8;\n  let z = (first4Bytes >> 24u) & mask8;\n  output.firstChildOffset = second4Bytes & mask24;\n  output.position = vec3<u32>(x, y, z);\n  output.size = 1u << ((second4Bytes >> 24u) & mask8); // 2 raised to the power of the size\n  return output;\n}\n\nfn getNodeSizeAtDepth(rootSize: u32, depth: u32) -> u32 {\n  return rootSize >> depth;\n}\n\nfn octantIndexToOffset(index: u32) -> vec3<u32> {\n  return vec3<u32>(\n    select(0u, 1u, (index & 1u) != 0u),\n    select(0u, 1u, (index & 2u) != 0u),\n    select(0u, 1u, (index & 4u) != 0u)\n  );\n}\n\nfn octantOffsetToIndex(offset: vec3<u32>) -> u32 {\n  return offset.x + offset.y * 2u + offset.z * 4u;\n}\n\nfn ceilToPowerOfTwo(value: f32) -> f32 {\n  return pow(2.0, ceil(log2(value)));\n}\n\nfn max3(value: vec3<f32>) -> f32 {\n  return max(value.x, max(value.y, value.z));\n}\n\nfn planeIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, planeNormal: vec3<f32>, planeDistance: f32) -> f32 {\n  return -(dot(rayOrigin,planeNormal)+planeDistance)/dot(rayDirection,planeNormal);\n}\n\nstruct PlaneIntersection {\n  tNear: f32,\n  side: vec3<i32>\n}\n\n\nfn sort3Asc(a: f32, b: f32, c: f32) -> vec3<f32> {\n  return vec3<f32>(\n    min(a, min(b, c)),\n    min(max(a, b), max(min(a, b), c)),\n    max(a, max(b, c))\n  );\n}\n\nfn sort3Desc(a: f32, b: f32, c: f32) -> vec3<f32> {\n  return vec3<f32>(\n    max(a, max(b, c)),\n    max(min(a, b), min(max(a, b), c)),\n    min(a, min(b, c))\n  );\n}\n\nfn getPlaneIntersections(rayOrigin: vec3<f32>, rayDirection:vec3<f32>, nodeSize: f32) -> vec3<f32> {\n    let boxExtents = nodeSize * 0.5;\n\n    var yPlaneIntersectionTNear = planeIntersection(rayOrigin, rayDirection, vec3(0.0, -1, 0.0), boxExtents);\n    var xPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(-1, 0.0, 0.0), boxExtents);\n    var zPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(0.0, 0.0, -1), boxExtents);\n\n    // If the intersection is outside the bounds of the node, set it to a large value to ignore it\n    let yPlaneHitPosition = rayOrigin + rayDirection * yPlaneIntersectionTNear  - EPSILON;\n    if(any(yPlaneHitPosition < vec3(0.0)) || any(yPlaneHitPosition > vec3(f32(nodeSize)))){\n      yPlaneIntersectionTNear  = 10000.0;\n    }\n    let xPlaneHitPosition = rayOrigin + rayDirection * xPlaneIntersectionTNear  - EPSILON;\n    if(any(xPlaneHitPosition < vec3(0.0)) || any(xPlaneHitPosition > vec3(f32(nodeSize)))){\n      xPlaneIntersectionTNear  = 10000.0;\n    }\n    let zPlaneHitPosition = rayOrigin + rayDirection * zPlaneIntersectionTNear  - EPSILON;\n    if(any(zPlaneHitPosition < vec3(0.0)) || any(zPlaneHitPosition > vec3(f32(nodeSize)))){\n      zPlaneIntersectionTNear  = 10000.0;\n    }\n\n    return vec3(xPlaneIntersectionTNear, yPlaneIntersectionTNear, zPlaneIntersectionTNear);\n}\n\nconst DISTANCE_THRESHOLDS =\n  array<vec2<f32>, 4>(\n    vec2<f32>(2.0, 500),\n    vec2<f32>(4.0, 1000),\n    vec2<f32>(8.0, 1500),\n    vec2<f32>(16.0, 2000)\n  );\n\nfn rayMarchOctree(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>, maxDistance: f32) -> RayMarchResult {\n    let halfExtents = voxelObject.size * 0.5;\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz + halfExtents;\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\n    var output = RayMarchResult();\n\n    let distanceToRoot = boxIntersection(objectRayOrigin, objectRayDirection, voxelObject.size * 0.5).tNear;\n    if(distanceToRoot > maxDistance){\n      return output;\n    }\n\n    // Set the initial t value to the far plane - essentially an out of bounds value\n    output.t = FAR_PLANE;\n\n    // Create a stack to hold the indices of the nodes we need to check\n    var stack = stacku32_new();\n\n    // Push the root node index onto the stack\n    stacku32_push(&stack, voxelObject.octreeBufferIndex);\n\n    // Main loop\n    while (stack.head > 0u && output.iterations < MAX_STEPS) {\n      output.iterations += 1u;\n      let nodeIndex = stacku32_pop(&stack);\n      let node = octreeBuffer[nodeIndex];\n\n      // Get the current nodes data\n      let internalNode = unpackInternal(node);\n\n      // Get the size of the node to get the center for plane intersections\n      let nodeSize = f32(internalNode.size);\n\n      let nodeOrigin = vec3<f32>(internalNode.position);\n      let nodeRayOrigin = objectRayOrigin - nodeOrigin;\n\n      if(isLeaf(node) && output.iterations > 1u){\n        // TODO: find out how to get normal without extra intersection\n        let leafNode = unpackLeaf(node);\n        let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(nodeSize * 0.5));\n        output.hit = true;\n        output.t = nodeIntersection.tNear;\n        output.normal = nodeIntersection.normal;\n        output.colour = vec3<f32>(leafNode.colour) / 255.0;\n        return output;\n      }\n\n      let centerOfChild = vec3(nodeSize * 0.5);\n\n      // Use planes to find the "inner" intersections\n      let planeIntersections = getPlaneIntersections(nodeRayOrigin, objectRayDirection, nodeSize);\n\n      // Get the closest plane intersection\n      let sortedIntersections = sort3Desc(planeIntersections[0], planeIntersections[1], planeIntersections[2]);\n\n      // Get the side of the planes that the ray is on\n      let sideOfPlanes = vec3<f32>(sign(nodeRayOrigin - centerOfChild));\n\n      // Push the children onto the stack, furthest first\n      for(var i = 0u; i < 3u; i++){\n        if(sortedIntersections[i] > maxDistance || sortedIntersections[i] < 0.0){\n          continue;\n        }\n\n        var hitPosition = nodeRayOrigin + objectRayDirection * sortedIntersections[i] - sideOfPlanes * EPSILON;\n        let hitOctant = vec3<u32>(hitPosition >= centerOfChild);\n        let hitIndex = octantOffsetToIndex(hitOctant);\n\n        // If the child is present, push it onto the stack\n        if(getBit(internalNode.childMask, hitIndex)){\n           let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\n           stacku32_push(&stack, childIndex);\n        }\n      }\n\n      // Get octant hit on the surface of the nodes bounding box\n      // Check if the ray intersects the node, if not, skip it\n      let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(nodeSize * 0.5));\n      if(nodeIntersection.tNear > maxDistance || nodeIntersection.tNear < 0.0){\n        continue;\n      }\n      let intersectionPoint = nodeRayOrigin + objectRayDirection * nodeIntersection.tNear;\n      let hitOctant = vec3<u32>(intersectionPoint >= centerOfChild);\n      let hitIndex = octantOffsetToIndex(vec3<u32>(hitOctant));\n\n      // If the child is present, push it onto the stack\n      if(getBit(internalNode.childMask, hitIndex)){\n        let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\n        stacku32_push(&stack, childIndex);\n      }\n    }\n\n    return output;\n}\n\n\nconst colours = array<vec3<f32>, 8>(\n  vec3<f32>(0.5),\n  vec3<f32>(1.0, 0.0, 0.0),\n  vec3<f32>(0.0, 1.0, 0.0),\n  vec3<f32>(1.0, 1.0, 0.0),\n  vec3<f32>(0.0, 0.0, 1.0),\n  vec3<f32>(1.0, 0.0, 1.0),\n  vec3<f32>(0.0, 1.0, 1.0),\n  vec3<f32>(1.0, 1.0, 1.0)\n);\n\nfn debugColourFromIndex(index: i32) -> vec3<f32> {\n  return colours[index % 8];\n}\n',Ke="const BRICK_SIZE = 8;\nconst MAX_BVH_STEPS = 256;\nconst MAX_STEPS = 256;\n\n\nstruct BVHNode {\n  leftIndex: i32,\n  rightIndex: i32,\n  objectCount: u32,\n  AABBMin: vec3<f32>,\n  AABBMax: vec3<f32>,\n  parentIndex: i32,\n  siblingIndex: i32,\n}\n\nfn nodeRayIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, node: BVHNode) -> f32 {\n  if(all(rayOrigin >= node.AABBMin) && all(rayOrigin <= node.AABBMax)){\n    return 0.0;\n  }\n  let boxSize = (node.AABBMax - node.AABBMin) / 2;\n  let intersection = boxIntersection(rayOrigin - node.AABBMin, rayDirection, boxSize);\n  if(intersection.isHit){\n    return intersection.tNear;\n  }\n  return -1.0;\n}\n\n// Stack-based BVH traversal\nfn rayMarchBVH(rayOrigin: vec3<f32>, rayDirection: vec3<f32>) -> RayMarchResult {\n  var closestIntersection = RayMarchResult();\n closestIntersection.t = FAR_PLANE;\n\n  // Create a stack to store the nodes to visit\n  var stack = stack_new();\n  stack_push(&stack, 0);\n\n  var iterations = 0;\n  var closestRayMarchDistance = FAR_PLANE;\n\n  while (stack.head > 0u && iterations < MAX_BVH_STEPS) {\n    let nodeIndex = stack_pop(&stack);\n    let node = bvhNodes[nodeIndex];\n    if(node.objectCount > 1){\n      let leftNode = bvhNodes[node.leftIndex];\n      let rightNode = bvhNodes[node.rightIndex];\n      let leftDist = nodeRayIntersection(rayOrigin, rayDirection, leftNode);\n      let rightDist = nodeRayIntersection(rayOrigin, rayDirection, rightNode);\n      let hitLeft = leftDist >= 0.0 && leftDist < closestIntersection.t;\n      let hitRight = rightDist >= 0.0 && rightDist < closestIntersection.t;\n      if(hitLeft && hitRight){\n        if(leftDist < rightDist){\n          // left is closer, push right to stack\n          stack_push(&stack, node.rightIndex);\n          stack_push(&stack, node.leftIndex);\n        } else {\n          // right is closer, push left to stack\n          stack_push(&stack, node.leftIndex);\n          stack_push(&stack, node.rightIndex);\n        }\n      }\n      // We only hit the right Node\n      else if(hitRight){\n        stack_push(&stack, node.rightIndex);\n      }\n      else if(hitLeft){\n        stack_push(&stack, node.leftIndex);\n      }\n    }\n    // valid leaf, raymarch it\n    else if(node.objectCount == 1){\n        let voxelObject = voxelObjects[node.leftIndex];\n        var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, rayOrigin, 9999.0);\n        if(rayMarchResult.hit && rayMarchResult.t < closestIntersection.t){\n           closestIntersection = rayMarchResult;\n        }\n    }\n    iterations += 1;\n//    closestIntersection.colour += vec3<f32>(0.005);\n  }\n\n  return closestIntersection;\n}",Qe="// TODO: actually make linear\nfn distanceToReversedLinearDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\n  return (far - cameraDistance) / (far - near);//Reversed\n}\n\nfn reversedLinearDepthToDistance(linearDepth: f32, near: f32, far: f32) -> f32 {\n    return far - linearDepth * (far - near); //Reversed\n}\n\nfn distanceToLogarithmicDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\n    return log2(cameraDistance / near + 1.0) / log2(far / near + 1.0);\n}\n\nfn logarithmicDepthToDistance(logDepth: f32, near: f32, far: f32) -> f32 {\n    let base = far / near + 1.0;\n    return near * (pow(base, logDepth) - 1.0);\n}",Je=Symbol(),et=e=>new Proxy(e,{construct:(e,t,n)=>e.prototype!==n.prototype?Reflect.construct(e,t,n):(e[Je]||(e[Je]=Reflect.construct(e,t,n)),e[Je])}),tt="rgba16float";const nt=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,it=(e,t,n=nt)=>{let i=class{#o;#a;#l;#c;#u=t;#h=n;#d=e;constructor(i,r,s){this.#o=i.createTexture({label:e,size:[r,s,1],format:t,usage:n}),this.#a=this.#o.createView({label:e}),this.#l=r,this.#c=s}get texture(){return this.#o}get view(){return this.#a}get width(){return this.#l}get height(){return this.#c}get format(){return this.#u}get usage(){return this.#h}get label(){return this.#d}};return i=function(e,t,n,i){var r,s=arguments.length,o=s<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(r=e[a])&&(o=(s<3?r(o):s>3?r(t,n,o):r(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o}([et],i),i},rt=it("albedo","rgba16float"),st=it("normal","rgba16float"),ot=it("depth","r32float",GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST),at=it("velocity","rgba16float"),lt=it("world position","rgba32float"),ct=it("output",tt),ut=async()=>{const e=await(async()=>{const e={binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},t={binding:9,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},n={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},i={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},r={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},s={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba32float",viewDimension:"2d"}},a={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},l=(GPUShaderStage.COMPUTE,{binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),c=Is.createBindGroupLayout({label:"raymarch g-buffer",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},e,{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},a,n,i,r,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s,l,o,t]}),u=await Is.createComputePipelineAsync({label:"raymarch g-buffer",layout:Is.createPipelineLayout({bindGroupLayouts:[c]}),compute:{module:Is.createShaderModule({code:`\n          struct Time {\n            frame: u32,\n            deltaTime: f32\n          };\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> time : Time;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(6) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(9) var blueNoiseTex : texture_2d<f32>;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${He}\n          ${Ye}\n          ${Xe}\n          ${Ze}\n          ${Ke}\n          ${Qe}\n          struct ViewProjectionMatrices {\n  viewProjection : mat4x4<f32>,\n  previousViewProjection : mat4x4<f32>,\n  inverseViewProjection : mat4x4<f32>,\n  previousInverseViewProjection : mat4x4<f32>,\n  projection : mat4x4<f32>,\n  inverseProjection: mat4x4<f32>,\n  viewMatrix : mat4x4<f32>,\n};\n\n\nfn plainIntersect(ro: vec3<f32>, rd: vec3<f32>, p: vec4<f32>) -> f32 {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\nfn getVelocityStatic(worldPos: vec3<f32>, viewProjections:ViewProjectionMatrices) -> vec2<f32>{\n  let vp = viewProjections.viewProjection;\n  let previousVp = viewProjections.previousViewProjection;\n\n  let clipSpace = vp * vec4(worldPos.xyz, 1.0);\n  let previousClipSpace = previousVp * vec4(worldPos.xyz, 1.0);\n\n  let ndc = clipSpace.xyz / clipSpace.w;\n  let previousNdc = previousClipSpace.xyz / previousClipSpace.w;\n\n  var uv = ndc.xy * 0.5 + 0.5;\n  var previousUv = previousNdc.xy * 0.5 + 0.5;\n\n  var velocity = previousUv - uv;\n  return velocity;\n}\n\nfn getVelocity(objectPos: vec3<f32>, modelMatrix: mat4x4<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec2<f32> {\n  let vp = viewProjections.viewProjection;\n  let previousVp = viewProjections.previousViewProjection;\n\n  // Get current object space position of the current pixel\n  let objectClipSpace = vp * modelMatrix * vec4(objectPos.xyz, 1.0);\n  let objectNDC = objectClipSpace.xyz / objectClipSpace.w;\n\n  // Get previous position of the current object space position\n  let previousObjectClipSpace = previousVp * previousModelMatrix * vec4(objectPos.xyz, 1.0);\n  let previousObjectNDC = previousObjectClipSpace.xyz / previousObjectClipSpace.w;\n\n  // UV\n  var uv = objectNDC.xy * 0.5 + 0.5;\n  var previousUv = previousObjectNDC.xy * 0.5 + 0.5;\n  uv.y = 1.0 - uv.y;\n  previousUv.y = 1.0 - previousUv.y;\n\n  // Get velocity based on the difference between the current and previous positions\n  var velocity = previousUv - uv;\n  return velocity;\n}\n\nfn getLeftChildIndex(index: i32) -> i32 {\n  return index * 2 + 1;\n}\n\nfn getRightChildIndex(index: i32) -> i32 {\n  return index * 2 + 2;\n}\n\nfn getParentIndex(index: i32) -> i32 {\n  return (index - 1) / 2;\n}\n\n\nfn dirIsNegative(dir: vec3<f32>, axis: i32) -> bool {\n  return dir[axis] < 0.0;\n}\n\nfn getDebugColour(index: i32) -> vec3<f32> {\n  let colours = array<vec3<f32>, 6>(\n    vec3<f32>(1.0, 0.0, 0.0),\n    vec3<f32>(0.0, 1.0, 0.0),\n    vec3<f32>(0.0, 0.0, 1.0),\n    vec3<f32>(1.0, 1.0, 0.0),\n    vec3<f32>(1.0, 0.0, 1.0),\n    vec3<f32>(0.0, 1.0, 1.0)\n  );\n  return colours[index % 6];\n}\n\n\nfn customNormalize(value: f32, min: f32, max: f32) -> f32 {\n    return (value - min) / (max - min);\n}\n\nconst IDENTITY_MATRIX = mat4x4<f32>(\n  vec4<f32>(1.0, 0.0, 0.0, 0.0),\n  vec4<f32>(0.0, 1.0, 0.0, 0.0),\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0)\n);\n\nfn intersectSphere(origin: vec3<f32>, dir: vec3<f32>, spherePos: vec3<f32>, sphereRad: f32) -> f32\n{\n\tlet oc = origin - spherePos;\n\tlet b = 2.0 * dot(dir, oc);\n\tlet c = dot(oc, oc) - sphereRad*sphereRad;\n\tlet disc = b * b - 4.0 * c;\n\tif (disc < 0.0)\n\t{\n\t  return -1.0;\n\t}\n\n//    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\n  let q = (-b + select(sqrt(disc), -sqrt(disc), b < 0.0)) / 2.0;\n\tvar t0 = q;\n\tvar t1 = c / q;\n\tif (t0 > t1) {\n\t\tvar temp = t0;\n\t\tt0 = t1;\n\t\tt1 = temp;\n\t}\n\tif (t1 < 0.0){\n\t  return -1.0;\n\t}\n\n  return select(t0, t1, t0 < 0.0);\n}\n\nfn skyDomeIntersection(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\n    return intersectSphere(ro, rd, vec3<f32>(0.0, 0.0, 0.0), FAR_PLANE);\n}\n\nconst BLUE_NOISE_SIZE = 511;\n\nfn tracePixel(pixel: vec2<u32>){\n   let resolution = textureDimensions(albedoTex);\n   var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\n   var rayDirection = calculateRayDirection(uv,viewProjections.inverseViewProjection);\n\n    // DOF\n    let blueNoiseOffset = vec2<u32>(0);\n    var blueNoisePixel = pixel;\n    blueNoisePixel.x += time.frame * 32;\n    blueNoisePixel.y += time.frame * 16;\n    blueNoisePixel = (blueNoisePixel + blueNoiseOffset) % BLUE_NOISE_SIZE;\n    if(time.frame % 2 == 0){\n      blueNoisePixel.y = BLUE_NOISE_SIZE - blueNoisePixel.y;\n    }\n    if(time.frame % 3 == 0){\n      blueNoisePixel.x = BLUE_NOISE_SIZE - blueNoisePixel.x;\n    }\n    var r = textureLoad(blueNoiseTex, blueNoisePixel, 0).rg;\n    let aperture = 0.0;\n    let focalDistance = 100.0;\n    let randomOffset = randomInUnitDisk(r) * aperture;\n    let cameraRight = vec3(viewProjections.viewMatrix[0].x, viewProjections.viewMatrix[1].x, viewProjections.viewMatrix[2].x);\n    let cameraUp = vec3(viewProjections.viewMatrix[0].y, viewProjections.viewMatrix[1].y, viewProjections.viewMatrix[2].y);\n    let rayOrigin = cameraPosition + randomOffset.x * cameraRight + randomOffset.y * cameraUp;\n    let focalPoint = cameraPosition + normalize(rayDirection) * focalDistance;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\n    var closestIntersection = RayMarchResult();\n    var worldPos = vec3(0.0);\n    var normal = vec3(0.0);\n    var albedo = vec3(0.0);\n    var velocity = vec2(0.0);\n    let bvhResult = rayMarchBVH(rayOrigin, rayDirection);\n//    if(bvhResult.hit){\n      let voxelObject = voxelObjects[bvhResult.voxelObjectIndex];\n      albedo = bvhResult.colour;\n      normal = transformNormal(voxelObject.inverseTransform,vec3<f32>(bvhResult.normal));\n      worldPos = rayOrigin + rayDirection * bvhResult.t;\n//    }\n//    else{\n//      albedo = vec3(0.0);\n//      worldPos = rayOrigin + skyDomeIntersection(rayOrigin, rayDirection) * rayDirection;\n//    }\n    velocity = getVelocityStatic(worldPos, viewProjections);\n\n    textureStore(albedoTex, pixel, vec4(albedo, 1));\n    textureStore(normalTex, pixel, vec4(normal,1));\n    textureStore(velocityTex, pixel, vec4(velocity,0,f32(bvhResult.voxelObjectIndex)));\n    textureStore(worldPosTex, pixel, vec4(worldPos,0));\n}\n\n@compute @workgroup_size(16, 8, 1)\nfn main(\n   @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\n) {\n  let pixel = GlobalInvocationID.xy;\n  tracePixel(pixel);\n}\n\n@group(1) @binding(0) var<storage, read> screenRayBuffer : array<vec2<u32>>;\n\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\n  vec2<u32>(0,1),\n  vec2<u32>(1,0),\n  vec2<u32>(1,1),\n  vec2<u32>(2,0),\n  vec2<u32>(2,1),\n  vec2<u32>(0,2),\n  vec2<u32>(1,2),\n  vec2<u32>(2,2)\n);\n\n@compute @workgroup_size(64, 1, 1)\nfn bufferMarch(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n) {\n  let bufferIndex = GlobalInvocationID.x / 8;\n  let localRayIndex = GlobalInvocationID.x % 8;\n  let pixel = screenRayBuffer[bufferIndex];\n  let offsetPixel = pixel + REMAINING_RAY_OFFSETS[localRayIndex];\n\n  tracePixel(offsetPixel);\n//  textureStore(depthWrite, offsetPixel, vec4(0,0,0,0));\n//   textureStore(albedoTex, offsetPixel, vec4(1,0,0,1));\n}`}),entryPoint:"main"}});let h;return(e,t)=>{h=(e=>Is.createBindGroup({layout:c,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:1,resource:{buffer:e.timeBuffer}},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.worldPositionTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:9,resource:e.blueNoiseTextureView},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),e.setPipeline(u),e.setBindGroup(0,h),e.dispatchWorkgroups(Math.ceil(Cs[0]/16),Math.ceil(Cs[1]/8))}})();let t,n,i,r={albedoTexture:null,velocityTexture:null,depthTexture:null,normalTexture:null};return{render:s=>{if(!n){n=Is.createBuffer({size:12,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),t=Is.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const e=new Uint32Array(3);e[0]=1,e[1]=1,e[2]=1,Is.queue.writeBuffer(n,0,e,0,e.length);const{width:r,height:a}=s.outputTextures.finalTexture,l=(o=r/3*(a/3)*4,4,4*Math.ceil(o/4));i=Is.createBuffer({size:l,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}var o;Object.keys(r).forEach((e=>{const t=s.outputTextures[e];null===r[e]&&(r[e]=((e,t)=>new(it(`${t.label}-copy`,t.format,t.usage))(e,t.width,t.height))(Is,t))}));const{commandEncoder:a,timestampWrites:l}=s;a.clearBuffer(n,0,4),a.clearBuffer(t,0,4),a.clearBuffer(i);let c=a.beginComputePass({timestampWrites:l});e(c,s),c.end()},label:"primary rays",timestampLabels:["full raymarch"]}};class ht{constructor(e,t,n,i,r="div"){this.parent=e,this.object=t,this.property=n,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(r),this.domElement.classList.add("controller"),this.domElement.classList.add(i),this.$name=document.createElement("div"),this.$name.classList.add("name"),ht.nextNameID=ht.nextNameID||0,this.$name.id="lil-gui-name-"+ ++ht.nextNameID,this.$widget=document.createElement("div"),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.domElement.addEventListener("keydown",(e=>e.stopPropagation())),this.domElement.addEventListener("keyup",(e=>e.stopPropagation())),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(n)}name(e){return this._name=e,this.$name.textContent=e,this}onChange(e){return this._onChange=e,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(e=!0){return this.disable(!e)}disable(e=!0){return e===this._disabled||(this._disabled=e,this.domElement.classList.toggle("disabled",e),this.$disable.toggleAttribute("disabled",e)),this}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(e){const t=this.parent.add(this.object,this.property,e);return t.name(this._name),this.destroy(),t}min(e){return this}max(e){return this}step(e){return this}decimals(e){return this}listen(e=!0){return this._listening=e,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const e=this.save();e!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=e}getValue(){return this.object[this.property]}setValue(e){return this.getValue()!==e&&(this.object[this.property]=e,this._callOnChange(),this.updateDisplay()),this}updateDisplay(){return this}load(e){return this.setValue(e),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class dt extends ht{constructor(e,t,n){super(e,t,n,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",(()=>{this.setValue(this.$input.checked),this._callOnFinishChange()})),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function pt(e){let t,n;return(t=e.match(/(#|0x)?([a-f0-9]{6})/i))?n=t[2]:(t=e.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?n=parseInt(t[1]).toString(16).padStart(2,0)+parseInt(t[2]).toString(16).padStart(2,0)+parseInt(t[3]).toString(16).padStart(2,0):(t=e.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(n=t[1]+t[1]+t[2]+t[2]+t[3]+t[3]),!!n&&"#"+n}const ft={isPrimitive:!0,match:e=>"number"==typeof e,fromHexString:e=>parseInt(e.substring(1),16),toHexString:e=>"#"+e.toString(16).padStart(6,0)},mt={isPrimitive:!1,match:e=>Array.isArray(e),fromHexString(e,t,n=1){const i=ft.fromHexString(e);t[0]=(i>>16&255)/255*n,t[1]=(i>>8&255)/255*n,t[2]=(255&i)/255*n},toHexString:([e,t,n],i=1)=>ft.toHexString(e*(i=255/i)<<16^t*i<<8^n*i<<0)},gt={isPrimitive:!1,match:e=>Object(e)===e,fromHexString(e,t,n=1){const i=ft.fromHexString(e);t.r=(i>>16&255)/255*n,t.g=(i>>8&255)/255*n,t.b=(255&i)/255*n},toHexString:({r:e,g:t,b:n},i=1)=>ft.toHexString(e*(i=255/i)<<16^t*i<<8^n*i<<0)},vt=[{isPrimitive:!0,match:e=>"string"==typeof e,fromHexString:pt,toHexString:pt},ft,mt,gt];class yt extends ht{constructor(e,t,n,i){var r;super(e,t,n,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(r=this.initialValue,vt.find((e=>e.match(r)))),this._rgbScale=i,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",(()=>{this._setValueFromHexString(this.$input.value)})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$text.addEventListener("input",(()=>{const e=pt(this.$text.value);e&&this._setValueFromHexString(e)})),this.$text.addEventListener("focus",(()=>{this._textFocused=!0,this.$text.select()})),this.$text.addEventListener("blur",(()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()})),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(e){if(this._format.isPrimitive){const t=this._format.fromHexString(e);this.setValue(t)}else this._format.fromHexString(e,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(e){return this._setValueFromHexString(e),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class xt extends ht{constructor(e,t,n){super(e,t,n,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",(e=>{e.preventDefault(),this.getValue().call(this.object),this._callOnChange()})),this.$button.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$disable=this.$button}}class wt extends ht{constructor(e,t,n,i,r,s){super(e,t,n,"number"),this._initInput(),this.min(i),this.max(r);const o=void 0!==s;this.step(o?s:this._getImplicitStep(),o),this.updateDisplay()}decimals(e){return this._decimals=e,this.updateDisplay(),this}min(e){return this._min=e,this._onUpdateMinMax(),this}max(e){return this._max=e,this._onUpdateMinMax(),this}step(e,t=!0){return this._step=e,this._stepExplicit=t,this}updateDisplay(){const e=this.getValue();if(this._hasSlider){let t=(e-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=100*t+"%"}return this._inputFocused||(this.$input.value=void 0===this._decimals?e:e.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),window.matchMedia("(pointer: coarse)").matches&&(this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any")),this.$widget.appendChild(this.$input),this.$disable=this.$input;const e=e=>{const t=parseFloat(this.$input.value);isNaN(t)||(this._snapClampSetValue(t+e),this.$input.value=this.getValue())};let t,n,i,r,s,o=!1;const a=e=>{if(o){const i=e.clientX-t,r=e.clientY-n;Math.abs(r)>5?(e.preventDefault(),this.$input.blur(),o=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(i)>5&&l()}if(!o){const t=e.clientY-i;s-=t*this._step*this._arrowKeyMultiplier(e),r+s>this._max?s=this._max-r:r+s<this._min&&(s=this._min-r),this._snapClampSetValue(r+s)}i=e.clientY},l=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",a),window.removeEventListener("mouseup",l)};this.$input.addEventListener("input",(()=>{let e=parseFloat(this.$input.value);isNaN(e)||(this._stepExplicit&&(e=this._snap(e)),this.setValue(this._clamp(e)))})),this.$input.addEventListener("keydown",(t=>{"Enter"===t.key&&this.$input.blur(),"ArrowUp"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t))),"ArrowDown"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t)*-1))})),this.$input.addEventListener("wheel",(t=>{this._inputFocused&&(t.preventDefault(),e(this._step*this._normalizeMouseWheel(t)))}),{passive:!1}),this.$input.addEventListener("mousedown",(e=>{t=e.clientX,n=i=e.clientY,o=!0,r=this.getValue(),s=0,window.addEventListener("mousemove",a),window.addEventListener("mouseup",l)})),this.$input.addEventListener("focus",(()=>{this._inputFocused=!0})),this.$input.addEventListener("blur",(()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()}))}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const e=e=>{const t=this.$slider.getBoundingClientRect();let n=((e,t,n,i,r)=>(e-t)/(n-t)*(this._max-i)+i)(e,t.left,t.right,this._min);this._snapClampSetValue(n)},t=t=>{e(t.clientX)},n=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",t),window.removeEventListener("mouseup",n)};let i,r,s=!1;const o=t=>{t.preventDefault(),this._setDraggingStyle(!0),e(t.touches[0].clientX),s=!1},a=t=>{if(s){const e=t.touches[0].clientX-i,n=t.touches[0].clientY-r;Math.abs(e)>Math.abs(n)?o(t):(window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l))}else t.preventDefault(),e(t.touches[0].clientX)},l=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l)},c=this._callOnFinishChange.bind(this);let u;this.$slider.addEventListener("mousedown",(i=>{this._setDraggingStyle(!0),e(i.clientX),window.addEventListener("mousemove",t),window.addEventListener("mouseup",n)})),this.$slider.addEventListener("touchstart",(e=>{e.touches.length>1||(this._hasScrollBar?(i=e.touches[0].clientX,r=e.touches[0].clientY,s=!0):o(e),window.addEventListener("touchmove",a,{passive:!1}),window.addEventListener("touchend",l))}),{passive:!1}),this.$slider.addEventListener("wheel",(e=>{if(Math.abs(e.deltaX)<Math.abs(e.deltaY)&&this._hasScrollBar)return;e.preventDefault();const t=this._normalizeMouseWheel(e)*this._step;this._snapClampSetValue(this.getValue()+t),this.$input.value=this.getValue(),clearTimeout(u),u=setTimeout(c,400)}),{passive:!1})}_setDraggingStyle(e,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",e),document.body.classList.toggle("lil-gui-dragging",e),document.body.classList.toggle(`lil-gui-${t}`,e)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(e){let{deltaX:t,deltaY:n}=e;return Math.floor(e.deltaY)!==e.deltaY&&e.wheelDelta&&(t=0,n=-e.wheelDelta/120,n*=this._stepExplicit?1:10),t+-n}_arrowKeyMultiplier(e){let t=this._stepExplicit?1:10;return e.shiftKey?t*=10:e.altKey&&(t/=10),t}_snap(e){const t=Math.round(e/this._step)*this._step;return parseFloat(t.toPrecision(15))}_clamp(e){return e<this._min&&(e=this._min),e>this._max&&(e=this._max),e}_snapClampSetValue(e){this.setValue(this._clamp(this._snap(e)))}get _hasScrollBar(){const e=this.parent.root.$children;return e.scrollHeight>e.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class bt extends ht{constructor(e,t,n,i){super(e,t,n,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$select.addEventListener("change",(()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()})),this.$select.addEventListener("focus",(()=>{this.$display.classList.add("focus")})),this.$select.addEventListener("blur",(()=>{this.$display.classList.remove("focus")})),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.options(i)}options(e){return this._values=Array.isArray(e)?e:Object.values(e),this._names=Array.isArray(e)?e:Object.keys(e),this.$select.replaceChildren(),this._names.forEach((e=>{const t=document.createElement("option");t.textContent=e,this.$select.appendChild(t)})),this.updateDisplay(),this}updateDisplay(){const e=this.getValue(),t=this._values.indexOf(e);return this.$select.selectedIndex=t,this.$display.textContent=-1===t?e:this._names[t],this}}class _t extends ht{constructor(e,t,n){super(e,t,n,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("spellcheck","false"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",(()=>{this.setValue(this.$input.value)})),this.$input.addEventListener("keydown",(e=>{"Enter"===e.code&&this.$input.blur()})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let kt=!1;class St{constructor({parent:e,autoPlace:t=void 0===e,container:n,width:i,title:r="Controls",closeFolders:s=!1,injectStyles:o=!0,touchStyles:a=!0}={}){if(this.parent=e,this.root=e?e.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",(()=>this.openAnimated(this._closed))),this.$title.addEventListener("keydown",(e=>{"Enter"!==e.code&&"Space"!==e.code||(e.preventDefault(),this.$title.click())})),this.$title.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(r),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add("root"),a&&this.domElement.classList.add("allow-touch-styles"),!kt&&o&&(function(e){const t=document.createElement("style");t.innerHTML='.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;\n  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n  background: var(--background-color);\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller > .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: " ";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: "lil-gui";\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-dragging .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-dragging * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui-dragging.lil-gui-vertical * {\n  cursor: ns-resize !important;\n}\n\n.lil-gui .title {\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: "lil-gui";\n  content: "";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  body:not(.lil-gui-dragging) .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: "";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: "Empty";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui label, .lil-gui input, .lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n}\n.lil-gui input {\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input:disabled {\n  opacity: 1;\n}\n.lil-gui input[type=text],\n.lil-gui input[type=number] {\n  padding: var(--widget-padding);\n  -moz-appearance: textfield;\n}\n.lil-gui input[type=text]:focus,\n.lil-gui input[type=number]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  width: var(--checkbox-size);\n  height: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n  cursor: pointer;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: "lil-gui";\n  content: "";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: none;\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: "lil-gui";\n  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");\n}';const n=document.querySelector("head link[rel=stylesheet], head style");n?document.head.insertBefore(t,n):document.head.appendChild(t)}(),kt=!0),n?n.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),i&&this.domElement.style.setProperty("--width",i+"px"),this._closeFolders=s}add(e,t,n,i,r){if(Object(n)===n)return new bt(this,e,t,n);const s=e[t];switch(typeof s){case"number":return new wt(this,e,t,n,i,r);case"boolean":return new dt(this,e,t);case"string":return new _t(this,e,t);case"function":return new xt(this,e,t)}console.error("gui.add failed\n\tproperty:",t,"\n\tobject:",e,"\n\tvalue:",s)}addColor(e,t,n=1){return new yt(this,e,t,n)}addFolder(e){const t=new St({parent:this,title:e});return this.root._closeFolders&&t.close(),t}load(e,t=!0){return e.controllers&&this.controllers.forEach((t=>{t instanceof xt||t._name in e.controllers&&t.load(e.controllers[t._name])})),t&&e.folders&&this.folders.forEach((t=>{t._title in e.folders&&t.load(e.folders[t._title])})),this}save(e=!0){const t={controllers:{},folders:{}};return this.controllers.forEach((e=>{if(!(e instanceof xt)){if(e._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${e._name}"`);t.controllers[e._name]=e.save()}})),e&&this.folders.forEach((e=>{if(e._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${e._title}"`);t.folders[e._title]=e.save()})),t}open(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(e){this._closed!==e&&(this._closed=e,this._callOnOpenClose(this))}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame((()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const n=e=>{e.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",n))};this.$children.addEventListener("transitionend",n);const i=e?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!e),requestAnimationFrame((()=>{this.$children.style.height=i+"px"}))})),this}title(e){return this._title=e,this.$title.textContent=e,this}reset(e=!0){return(e?this.controllersRecursive():this.controllers).forEach((e=>e.reset())),this}onChange(e){return this._onChange=e,this}_callOnChange(e){this.parent&&this.parent._callOnChange(e),void 0!==this._onChange&&this._onChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(e){this.parent&&this.parent._callOnFinishChange(e),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onOpenClose(e){return this._onOpenClose=e,this}_callOnOpenClose(e){this.parent&&this.parent._callOnOpenClose(e),void 0!==this._onOpenClose&&this._onOpenClose.call(this,e)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach((e=>e.destroy()))}controllersRecursive(){let e=Array.from(this.controllers);return this.folders.forEach((t=>{e=e.concat(t.controllersRecursive())})),e}foldersRecursive(){let e=Array.from(this.folders);return this.folders.forEach((t=>{e=e.concat(t.foldersRecursive())})),e}}const Et=St,At=async e=>{const t=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\n//@group(0) @binding(2) var debugTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n}\n\n@vertex\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}\n\nfn get_debug_colour(index : i32) -> vec4<f32> {\n  if(index < 0){\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n  }\n\n  let colours = array(\n    vec4<f32>(1.0, 0.0, 0.0, 1.0),\n    vec4<f32>(0.0, 1.0, 0.0, 1.0),\n    vec4<f32>(0.0, 0.0, 1.0, 1.0),\n    vec4<f32>(1.0, 1.0, 0.0, 1.0),\n    vec4<f32>(1.0, 0.0, 1.0, 1.0),\n    vec4<f32>(0.0, 1.0, 1.0, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  );\n  return colours[index % 8];\n}\n\n@fragment\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\n    let pixel = fragUV * vec2<f32>(textureDimensions(myTexture));\n    var colour = textureLoad(myTexture, vec2<u32>(pixel),0);\n    return colour;\n//    return colour;\n//    return abs(colour) % 8.0 * 0.125;\n//    return colour.gggg * 0.5;\n//    return (colour.rrrr * 500.0 % 1.0);\n//    return get_debug_colour(i32(colour.a));\n}\n"}),n=e.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vertex_main"},fragment:{module:t,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]}});return{render:t=>{const i=t.commandEncoder.beginRenderPass({timestampWrites:t.timestampWrites,colorAttachments:[{view:Ps.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]}),r=e.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:1,resource:t.outputTextures.finalTexture.view}]});i.setPipeline(n),i.setBindGroup(0,r),i.draw(6),i.end()},label:"fullscreen quad"}};var Tt;!function(e){const t=[];e.updateAll=e=>{for(const n of t)n.update(e)},e.register=e=>class extends e{constructor(...e){super(...e),t.push(this)}}}(Tt||(Tt={}));const Pt={duration:.3,delay:0,endDelay:0,repeat:0,easing:"ease"},Mt=e=>1e3*e,zt=e=>e/1e3,It=()=>{},Ct=e=>e;function Bt(e,t=!0){if(e&&"finished"!==e.playState)try{e.stop?e.stop():(t&&e.commitStyles(),e.cancel())}catch(e){}}const Ot=e=>e(),Nt=(e,t,n=Pt.duration)=>new Proxy({animations:e.map(Ot).filter(Boolean),duration:n,options:t},Rt),Rt={get:(e,t)=>{const n=e.animations[0];switch(t){case"duration":return e.duration;case"currentTime":return zt((null==n?void 0:n[t])||0);case"playbackRate":case"playState":return null==n?void 0:n[t];case"finished":return e.finished||(e.finished=Promise.all(e.animations.map(Ft)).catch(It)),e.finished;case"stop":return()=>{e.animations.forEach((e=>Bt(e)))};case"forEachNative":return t=>{e.animations.forEach((n=>t(n,e)))};default:return void 0===(null==n?void 0:n[t])?void 0:()=>e.animations.forEach((e=>e[t]()))}},set:(e,t,n)=>{switch(t){case"currentTime":n=Mt(n);case"playbackRate":for(let i=0;i<e.animations.length;i++)e.animations[i][t]=n;return!0}return!1}},Ft=e=>e.finished,Dt=e=>"object"==typeof e&&Boolean(e.createAnimation),Ut=e=>"number"==typeof e,Lt=e=>Array.isArray(e)&&!Ut(e[0]),qt=(e,t,n)=>-n*e+n*t+e,jt=(e,t,n)=>t-e==0?1:(n-e)/(t-e);function Vt(e,t){const n=e[e.length-1];for(let i=1;i<=t;i++){const r=jt(0,t,i);e.push(qt(n,1,r))}}const Gt=(e,t,n)=>Math.min(Math.max(n,e),t);const $t=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e,Wt=1e-7,Ht=12;function Yt(e,t,n,i){if(e===t&&n===i)return Ct;return r=>0===r||1===r?r:$t(function(e,t,n,i,r){let s,o,a=0;do{o=t+(n-t)/2,s=$t(o,i,r)-e,s>0?n=o:t=o}while(Math.abs(s)>Wt&&++a<Ht);return o}(r,0,1,e,n),t,i)}const Xt=e=>"function"==typeof e,Zt=e=>Array.isArray(e)&&Ut(e[0]),Kt={ease:Yt(.25,.1,.25,1),"ease-in":Yt(.42,0,1,1),"ease-in-out":Yt(.42,0,.58,1),"ease-out":Yt(0,0,.58,1)},Qt=/\((.*?)\)/;function Jt(e){if(Xt(e))return e;if(Zt(e))return Yt(...e);if(Kt[e])return Kt[e];if(e.startsWith("steps")){const t=Qt.exec(e);if(t){const e=t[1].split(",");return((e,t="end")=>n=>{const i=(n="end"===t?Math.min(n,.999):Math.max(n,.001))*e,r="end"===t?Math.floor(i):Math.ceil(i);return Gt(0,1,r/e)})(parseFloat(e[0]),e[1].trim())}}return Ct}class en{constructor(e,t=[0,1],{easing:n,duration:i=Pt.duration,delay:r=Pt.delay,endDelay:s=Pt.endDelay,repeat:o=Pt.repeat,offset:a,direction:l="normal",autoplay:c=!0}={}){if(this.startTime=null,this.rate=1,this.t=0,this.cancelTimestamp=null,this.easing=Ct,this.duration=0,this.totalDuration=0,this.repeat=0,this.playState="idle",this.finished=new Promise(((e,t)=>{this.resolve=e,this.reject=t})),n=n||Pt.easing,Dt(n)){const e=n.createAnimation(t);n=e.easing,t=e.keyframes||t,i=e.duration||i}this.repeat=o,this.easing=Lt(n)?Ct:Jt(n),this.updateDuration(i);const u=function(e,t=function(e){const t=[0];return Vt(t,e-1),t}(e.length),n=Ct){const i=e.length,r=i-t.length;return r>0&&Vt(t,r),r=>{let s=0;for(;s<i-2&&!(r<t[s+1]);s++);let o=Gt(0,1,jt(t[s],t[s+1],r));const a=function(e,t){return Lt(e)?e[((e,t,n)=>{const i=t-e;return((n-e)%i+i)%i+e})(0,e.length,t)]:e}(n,s);return o=a(o),qt(e[s],e[s+1],o)}}(t,a,Lt(n)?n.map(Jt):Ct);this.tick=t=>{var n;let i=0;i=void 0!==this.pauseTime?this.pauseTime:(t-this.startTime)*this.rate,this.t=i,i/=1e3,i=Math.max(i-r,0),"finished"===this.playState&&void 0===this.pauseTime&&(i=this.totalDuration);const o=i/this.duration;let a=Math.floor(o),c=o%1;!c&&o>=1&&(c=1),1===c&&a--;const h=a%2;("reverse"===l||"alternate"===l&&h||"alternate-reverse"===l&&!h)&&(c=1-c);const d=i>=this.totalDuration?1:Math.min(c,1),p=u(this.easing(d));e(p),void 0===this.pauseTime&&("finished"===this.playState||i>=this.totalDuration+s)?(this.playState="finished",null===(n=this.resolve)||void 0===n||n.call(this,p)):"idle"!==this.playState&&(this.frameRequestId=requestAnimationFrame(this.tick))},c&&this.play()}play(){const e=performance.now();this.playState="running",void 0!==this.pauseTime?this.startTime=e-this.pauseTime:this.startTime||(this.startTime=e),this.cancelTimestamp=this.startTime,this.pauseTime=void 0,this.frameRequestId=requestAnimationFrame(this.tick)}pause(){this.playState="paused",this.pauseTime=this.t}finish(){this.playState="finished",this.tick(0)}stop(){var e;this.playState="idle",void 0!==this.frameRequestId&&cancelAnimationFrame(this.frameRequestId),null===(e=this.reject)||void 0===e||e.call(this,!1)}cancel(){this.stop(),this.tick(this.cancelTimestamp)}reverse(){this.rate*=-1}commitStyles(){}updateDuration(e){this.duration=e,this.totalDuration=e*(this.repeat+1)}get currentTime(){return this.t}set currentTime(e){void 0!==this.pauseTime||0===this.rate?this.pauseTime=e:this.startTime=performance.now()-e/this.rate}get playbackRate(){return this.rate}set playbackRate(e){this.rate=e}}class tn{setAnimation(e){this.animation=e,null==e||e.finished.then((()=>this.clearAnimation())).catch((()=>{}))}clearAnimation(){this.animation=this.generator=void 0}}const nn=new WeakMap;function rn(e){return nn.has(e)||nn.set(e,{transforms:[],values:new Map}),nn.get(e)}const sn=["","X","Y","Z"],on={x:"translateX",y:"translateY",z:"translateZ"},an={syntax:"<angle>",initialValue:"0deg",toDefaultUnit:e=>e+"deg"},ln={translate:{syntax:"<length-percentage>",initialValue:"0px",toDefaultUnit:e=>e+"px"},rotate:an,scale:{syntax:"<number>",initialValue:1,toDefaultUnit:Ct},skew:an},cn=new Map,un=e=>`--motion-${e}`,hn=["x","y","z"];["translate","scale","rotate","skew"].forEach((e=>{sn.forEach((t=>{hn.push(e+t),cn.set(un(e+t),ln[e])}))}));const dn=(e,t)=>hn.indexOf(e)-hn.indexOf(t),pn=new Set(hn),fn=e=>pn.has(e),mn=e=>e.sort(dn).reduce(gn,"").trim(),gn=(e,t)=>`${e} ${t}(var(${un(t)}))`,vn=e=>e.startsWith("--"),yn=new Set,xn=(e,t)=>document.createElement("div").animate(e,t),wn={cssRegisterProperty:()=>"undefined"!=typeof CSS&&Object.hasOwnProperty.call(CSS,"registerProperty"),waapi:()=>Object.hasOwnProperty.call(Element.prototype,"animate"),partialKeyframes:()=>{try{xn({opacity:[1]})}catch(e){return!1}return!0},finished:()=>Boolean(xn({opacity:[0,1]},{duration:.001}).finished),linearEasing:()=>{try{xn({opacity:0},{easing:"linear(0, 1)"})}catch(e){return!1}return!0}},bn={},_n={};for(const e in wn)_n[e]=()=>(void 0===bn[e]&&(bn[e]=wn[e]()),bn[e]);const kn=(e,t)=>Xt(e)?_n.linearEasing()?`linear(${((e,t)=>{let n="";const i=Math.round(t/.015);for(let t=0;t<i;t++)n+=e(jt(0,i-1,t))+", ";return n.substring(0,n.length-2)})(e,t)})`:Pt.easing:Zt(e)?Sn(e):e,Sn=([e,t,n,i])=>`cubic-bezier(${e}, ${t}, ${n}, ${i})`;function En(e){return on[e]&&(e=on[e]),fn(e)?un(e):e}const An=(e,t)=>{t=En(t);let n=vn(t)?e.style.getPropertyValue(t):getComputedStyle(e)[t];if(!n&&0!==n){const e=cn.get(t);e&&(n=e.initialValue)}return n},Tn=(e,t,n)=>{t=En(t),vn(t)?e.style.setProperty(t,n):e.style[t]=n},Pn=e=>"string"==typeof e;function Mn(e,t){var n;let i=(null==t?void 0:t.toDefaultUnit)||Ct;const r=e[e.length-1];if(Pn(r)){const e=(null===(n=r.match(/(-?[\d.]+)([a-z%]*)/))||void 0===n?void 0:n[2])||"";e&&(i=t=>t+e)}return i}function zn(e,t,n,i={},r){const s=window.__MOTION_DEV_TOOLS_RECORD,o=!1!==i.record&&s;let a,{duration:l=Pt.duration,delay:c=Pt.delay,endDelay:u=Pt.endDelay,repeat:h=Pt.repeat,easing:d=Pt.easing,persist:p=!1,direction:f,offset:m,allowWebkitAcceleration:g=!1,autoplay:v=!0}=i;const y=rn(e),x=fn(t);let w=_n.waapi();x&&((e,t)=>{on[t]&&(t=on[t]);const{transforms:n}=rn(e);var i,r;r=t,-1===(i=n).indexOf(r)&&i.push(r),e.style.transform=mn(n)})(e,t);const b=En(t),_=function(e,t){return e.has(t)||e.set(t,new tn),e.get(t)}(y.values,b),k=cn.get(b);return Bt(_.animation,!(Dt(d)&&_.generator)&&!1!==i.record),()=>{const y=()=>{var t,n;return null!==(n=null!==(t=An(e,b))&&void 0!==t?t:null==k?void 0:k.initialValue)&&void 0!==n?n:0};let S=function(e,t){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=n?e[n-1]:t());return e}((e=>Array.isArray(e)?e:[e])(n),y);const E=Mn(S,k);if(Dt(d)){const e=d.createAnimation(S,"opacity"!==t,y,b,_);d=e.easing,S=e.keyframes||S,l=e.duration||l}if(vn(b)&&(_n.cssRegisterProperty()?function(e){if(!yn.has(e)){yn.add(e);try{const{syntax:t,initialValue:n}=cn.has(e)?cn.get(e):{};CSS.registerProperty({name:e,inherits:!1,syntax:t,initialValue:n})}catch(e){}}}(b):w=!1),x&&!_n.linearEasing()&&(Xt(d)||Lt(d)&&d.some(Xt))&&(w=!1),w){k&&(S=S.map((e=>Ut(e)?k.toDefaultUnit(e):e))),1!==S.length||_n.partialKeyframes()&&!o||S.unshift(y());const t={delay:Mt(c),duration:Mt(l),endDelay:Mt(u),easing:Lt(d)?void 0:kn(d,l),direction:f,iterations:h+1,fill:"both"};a=e.animate({[b]:S,offset:m,easing:Lt(d)?d.map((e=>kn(e,l))):void 0},t),a.finished||(a.finished=new Promise(((e,t)=>{a.onfinish=e,a.oncancel=t})));const n=S[S.length-1];a.finished.then((()=>{p||(Tn(e,b,n),a.cancel())})).catch(It),g||(a.playbackRate=1.000001)}else if(r&&x)S=S.map((e=>"string"==typeof e?parseFloat(e):e)),1===S.length&&S.unshift(parseFloat(y())),a=new r((t=>{Tn(e,b,E?E(t):t)}),S,Object.assign(Object.assign({},i),{duration:l,easing:d}));else{const t=S[S.length-1];Tn(e,b,k&&Ut(t)?k.toDefaultUnit(t):t)}return o&&s(e,t,S,{duration:l,delay:c,easing:d,repeat:h,offset:m},"motion-one"),_.setAnimation(a),a&&!v&&a.pause(),a}}const In=(e,t)=>e[t]?Object.assign(Object.assign({},e),e[t]):Object.assign({},e);function Cn(e,t,n){return Xt(e)?e(t,n):e}const Bn=(On=en,function(e,t,n={}){const i=(e=function(e,t){return"string"==typeof e?e=document.querySelectorAll(e):e instanceof Element&&(e=[e]),Array.from(e||[])}(e)).length;Boolean(i),Boolean(t);const r=[];for(let s=0;s<i;s++){const o=e[s];for(const e in t){const a=In(n,e);a.delay=Cn(a.delay,s,i);const l=zn(o,e,t[e],a,On);r.push(l)}}return Nt(r,n,n.duration)});var On;function Nn(e,t={}){return Nt([()=>{const n=new en(e,[0,1],t);return n.finished.catch((()=>{})),n}],t,t.duration)}function Rn(e,t,n){return(Xt(e)?Nn:Bn)(e,t,n)}function Fn(e,t,n){const i=Math.max(t-5,0);return r=n-e(i),(s=t-i)?r*(1e3/s):0;var r,s}function Dn(e){return Ut(e)&&!isNaN(e)}function Un(e){return Pn(e)?parseFloat(e):e}const Ln=function(e){const t=new WeakMap;return(e={})=>{const n=new Map,i=(t=0,i=100,r=0,s=!1)=>{const o=`${t}-${i}-${r}-${s}`;return n.has(o)||n.set(o,(({from:e=0,velocity:t=0,power:n=.8,decay:i=.325,bounceDamping:r,bounceStiffness:s,changeTarget:o,min:a,max:l,restDistance:c=.5,restSpeed:u})=>{i=Mt(i);const h={hasReachedTarget:!1,done:!1,current:e,target:e},d=e=>void 0===a?l:void 0===l||Math.abs(a-e)<Math.abs(l-e)?a:l;let p=n*t;const f=e+p,m=void 0===o?f:o(f);h.target=m,m!==f&&(p=m-e);const g=e=>-p*Math.exp(-e/i),v=e=>m+g(e),y=e=>{const t=g(e),n=v(e);h.done=Math.abs(t)<=c,h.current=h.done?m:n};let x,w;const b=e=>{var t;t=h.current,(void 0!==a&&t<a||void 0!==l&&t>l)&&(x=e,w=(({stiffness:e=100,damping:t=10,mass:n=1,from:i=0,to:r=1,velocity:s=0,restSpeed:o,restDistance:a}={})=>{s=s?zt(s):0;const l={done:!1,hasReachedTarget:!1,current:i,target:r},c=r-i,u=Math.sqrt(e/n)/1e3,h=((e=100,t=10,n=1)=>t/(2*Math.sqrt(e*n)))(e,t,n),d=Math.abs(c)<5;let p;if(o||(o=d?.01:2),a||(a=d?.005:.5),h<1){const e=u*Math.sqrt(1-h*h);p=t=>r-Math.exp(-h*u*t)*((h*u*c-s)/e*Math.sin(e*t)+c*Math.cos(e*t))}else p=e=>r-Math.exp(-u*e)*(c+(u*c-s)*e);return e=>{l.current=p(e);const t=0===e?s:Fn(p,e,l.current),n=Math.abs(t)<=o,c=Math.abs(r-l.current)<=a;var u,h,d;return l.done=n&&c,l.hasReachedTarget=(u=i,h=r,d=l.current,u<h&&d>=h||u>h&&d<=h),l}})({from:h.current,to:d(h.current),velocity:Fn(v,e,h.current),damping:r,stiffness:s,restDistance:c,restSpeed:u}))};return b(0),e=>{let t=!1;return w||void 0!==x||(t=!0,y(e),b(e)),void 0!==x&&e>x?(h.hasReachedTarget=!0,w(e-x)):(h.hasReachedTarget=!1,!t&&y(e),h)}})(Object.assign({from:t,to:i,velocity:r},e))),n.get(o)},r=(e,n)=>(t.has(e)||t.set(e,function(e,t=Ct){let n,i=10,r=e(0);const s=[t(r.current)];for(;!r.done&&i<1e4;)r=e(i),s.push(t(r.done?r.target:r.current)),void 0===n&&r.hasReachedTarget&&(n=i),i+=10;const o=i-10;return 1===s.length&&s.push(r.current),{keyframes:s,duration:o/1e3,overshootDuration:(null!=n?n:o)/1e3}}(e,n)),t.get(e));return{createAnimation:(e,t=!0,n,s,o)=>{let a,l,c,u=0,h=Ct;const d=e.length;if(t)if(h=Mn(e,s?cn.get(En(s)):void 0),c=Un(e[d-1]),d>1&&null!==e[0])l=Un(e[0]);else{const e=null==o?void 0:o.generator;if(e){const{animation:t,generatorStartTime:n}=o,i=(null==t?void 0:t.startTime)||n||0,r=(null==t?void 0:t.currentTime)||performance.now()-i,s=e(r).current;l=s,u=Fn((t=>e(t).current),r,s)}else n&&(l=Un(n()))}if(Dn(l)&&Dn(c)){const e=i(l,c,u,null==s?void 0:s.includes("scale"));a=Object.assign(Object.assign({},r(e,h)),{easing:"linear"}),o&&(o.generator=e,o.generatorStartTime=performance.now())}return a||(a={easing:"ease",duration:r(i(0,100)).overshootDuration}),a}}}}();var qn=function(e,t,n,i){var r,s=arguments.length,o=s<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(r=e[a])&&(o=(s<3?r(o):s>3?r(t,n,o):r(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};let jn=class{value;target;constructor(e){this.value=e,this.target=e}update(){Rn((e=>{this.value=ne.lerp(this.value,this.target,e)}),{easing:Ln({velocity:2e-4*Ns})})}};jn=qn([Tt.register],jn);let Vn=class{value;target;constructor(e){this.value=e,this.target=e}update(){Rn((e=>{this.value=this.value+(this.target-this.value)*e}),{easing:Ln({velocity:2e-4*Ns})})}};Vn=qn([Tt.register],Vn);let Gn=class{value;target;constructor(e){this.value=e,this.target=e}update(){Rn((e=>{this.value=Ve.slerp(this.value,this.target,e)}),{easing:Ln({velocity:2e-4*Ns})})}};Gn=qn([Tt.register],Gn);const $n=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength,Wn={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array},bool:{numElements:0,align:1,size:0,type:"bool",View:Uint32Array}},Hn={...Wn,"atomic<i32>":Wn.i32,"atomic<u32>":Wn.u32,"vec2<i32>":Wn.vec2i,"vec2<u32>":Wn.vec2u,"vec2<f32>":Wn.vec2f,"vec2<f16>":Wn.vec2h,"vec3<i32>":Wn.vec3i,"vec3<u32>":Wn.vec3u,"vec3<f32>":Wn.vec3f,"vec3<f16>":Wn.vec3h,"vec4<i32>":Wn.vec4i,"vec4<u32>":Wn.vec4u,"vec4<f32>":Wn.vec4f,"vec4<f16>":Wn.vec4h,"mat2x2<f32>":Wn.mat2x2f,"mat2x2<f16>":Wn.mat2x2h,"mat3x2<f32>":Wn.mat3x2f,"mat3x2<f16>":Wn.mat3x2h,"mat4x2<f32>":Wn.mat4x2f,"mat4x2<f16>":Wn.mat4x2h,"mat2x3<f32>":Wn.mat2x3f,"mat2x3<f16>":Wn.mat2x3h,"mat3x3<f32>":Wn.mat3x3f,"mat3x3<f16>":Wn.mat3x3h,"mat4x3<f32>":Wn.mat4x3f,"mat4x3<f16>":Wn.mat4x3h,"mat2x4<f32>":Wn.mat2x4f,"mat2x4<f16>":Wn.mat2x4h,"mat3x4<f32>":Wn.mat3x4f,"mat3x4<f16>":Wn.mat3x4h,"mat4x4<f32>":Wn.mat4x4f,"mat4x4<f16>":Wn.mat4x4h},Yn=(Xn=Hn,Object.keys(Xn));var Xn,Zn,Kn,Qn,Jn,ei;!function(e=[],t){const n=new Set;for(const i of Yn){const r=Hn[i];n.has(r)||(n.add(r),r.flatten=e.includes(i)?t:!t)}}(),new WeakMap;class ti{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class ni{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(ii.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(ri.instance)}}}class ii extends ni{}ii.instance=new ii;class ri extends ni{}ri.instance=new ri;class si extends ni{constructor(){super()}}class oi extends si{constructor(e,t,n,i){super(),this.name=e,this.args=t,this.returnType=n,this.body=i}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}}class ai extends si{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class li extends si{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class ci extends si{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class ui extends si{constructor(e,t,n,i){super(),this.init=e,this.condition=t,this.increment=n,this.body=i}get astNodeType(){return"for"}search(e){var t,n,i;null===(t=this.init)||void 0===t||t.search(e),null===(n=this.condition)||void 0===n||n.search(e),null===(i=this.increment)||void 0===i||i.search(e),this.searchBlock(this.body,e)}}class hi extends si{constructor(e,t,n,i,r){super(),this.name=e,this.type=t,this.storage=n,this.access=i,this.value=r}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class di extends si{constructor(e,t,n){super(),this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class pi extends si{constructor(e,t,n,i,r){super(),this.name=e,this.type=t,this.storage=n,this.access=i,this.value=r}get astNodeType(){return"let"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class fi extends si{constructor(e,t,n,i,r){super(),this.name=e,this.type=t,this.storage=n,this.access=i,this.value=r}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}!function(e){e.increment="++",e.decrement="--"}(Zn||(Zn={})),function(e){e.parse=function(t){const n=t;if("parse"==n)throw new Error("Invalid value for IncrementOperator");return e[n]}}(Zn||(Zn={}));class mi extends si{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(Kn||(Kn={})),function(e){e.parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t}}(Kn||(Kn={}));class gi extends si{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.value.search(e)}}class vi extends si{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}}class yi extends si{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class xi extends si{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class wi extends si{constructor(e,t,n,i){super(),this.condition=e,this.body=t,this.elseif=n,this.else=i}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class bi extends si{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class _i extends si{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class ki extends si{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class Si extends si{constructor(){super()}get astNodeType(){return"discard"}}class Ei extends si{constructor(){super()}get astNodeType(){return"break"}}class Ai extends si{constructor(){super()}get astNodeType(){return"continue"}}class Ti extends si{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class Pi extends Ti{constructor(e,t){super(e),this.members=t}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class Mi extends Ti{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}}class zi extends Ti{constructor(e,t,n,i){super(e),this.storage=t,this.type=n,this.access=i}get astNodeType(){return"pointer"}}class Ii extends Ti{constructor(e,t,n,i){super(e),this.attributes=t,this.format=n,this.count=i}get astNodeType(){return"array"}get isArray(){return!0}}class Ci extends Ti{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}}class Bi extends ni{constructor(){super()}}class Oi extends Bi{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class Ni extends Bi{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}}class Ri extends Bi{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class Fi extends Bi{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this)}}class Di extends Bi{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,n;if(this.initializer instanceof Ni){const i=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),r=null===(n=this.initializer.type)||void 0===n?void 0:n.name,s=e.structs.get(r),o=null==s?void 0:s.getMemberIndex(i);if(-1!=o)return this.initializer.args[o].evaluate(e);console.log(o)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class Ui extends Bi{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class Li extends Bi{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class qi extends Bi{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}}class ji extends Bi{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class Vi extends Bi{constructor(){super()}}class Gi extends Vi{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}}class $i extends Vi{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class Wi extends ni{constructor(){super()}}class Hi extends Wi{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class Yi extends Wi{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class Xi extends ni{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}}class Zi extends ni{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Ki extends ni{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}}class Qi extends ni{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(Jn||(Jn={}));class Ji{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class er{}Qn=er,er.none=new Ji("",Jn.reserved,""),er.eof=new Ji("EOF",Jn.token,""),er.reserved={asm:new Ji("asm",Jn.reserved,"asm"),bf16:new Ji("bf16",Jn.reserved,"bf16"),do:new Ji("do",Jn.reserved,"do"),enum:new Ji("enum",Jn.reserved,"enum"),f16:new Ji("f16",Jn.reserved,"f16"),f64:new Ji("f64",Jn.reserved,"f64"),handle:new Ji("handle",Jn.reserved,"handle"),i8:new Ji("i8",Jn.reserved,"i8"),i16:new Ji("i16",Jn.reserved,"i16"),i64:new Ji("i64",Jn.reserved,"i64"),mat:new Ji("mat",Jn.reserved,"mat"),premerge:new Ji("premerge",Jn.reserved,"premerge"),regardless:new Ji("regardless",Jn.reserved,"regardless"),typedef:new Ji("typedef",Jn.reserved,"typedef"),u8:new Ji("u8",Jn.reserved,"u8"),u16:new Ji("u16",Jn.reserved,"u16"),u64:new Ji("u64",Jn.reserved,"u64"),unless:new Ji("unless",Jn.reserved,"unless"),using:new Ji("using",Jn.reserved,"using"),vec:new Ji("vec",Jn.reserved,"vec"),void:new Ji("void",Jn.reserved,"void")},er.keywords={array:new Ji("array",Jn.keyword,"array"),atomic:new Ji("atomic",Jn.keyword,"atomic"),bool:new Ji("bool",Jn.keyword,"bool"),f32:new Ji("f32",Jn.keyword,"f32"),i32:new Ji("i32",Jn.keyword,"i32"),mat2x2:new Ji("mat2x2",Jn.keyword,"mat2x2"),mat2x3:new Ji("mat2x3",Jn.keyword,"mat2x3"),mat2x4:new Ji("mat2x4",Jn.keyword,"mat2x4"),mat3x2:new Ji("mat3x2",Jn.keyword,"mat3x2"),mat3x3:new Ji("mat3x3",Jn.keyword,"mat3x3"),mat3x4:new Ji("mat3x4",Jn.keyword,"mat3x4"),mat4x2:new Ji("mat4x2",Jn.keyword,"mat4x2"),mat4x3:new Ji("mat4x3",Jn.keyword,"mat4x3"),mat4x4:new Ji("mat4x4",Jn.keyword,"mat4x4"),ptr:new Ji("ptr",Jn.keyword,"ptr"),sampler:new Ji("sampler",Jn.keyword,"sampler"),sampler_comparison:new Ji("sampler_comparison",Jn.keyword,"sampler_comparison"),struct:new Ji("struct",Jn.keyword,"struct"),texture_1d:new Ji("texture_1d",Jn.keyword,"texture_1d"),texture_2d:new Ji("texture_2d",Jn.keyword,"texture_2d"),texture_2d_array:new Ji("texture_2d_array",Jn.keyword,"texture_2d_array"),texture_3d:new Ji("texture_3d",Jn.keyword,"texture_3d"),texture_cube:new Ji("texture_cube",Jn.keyword,"texture_cube"),texture_cube_array:new Ji("texture_cube_array",Jn.keyword,"texture_cube_array"),texture_multisampled_2d:new Ji("texture_multisampled_2d",Jn.keyword,"texture_multisampled_2d"),texture_storage_1d:new Ji("texture_storage_1d",Jn.keyword,"texture_storage_1d"),texture_storage_2d:new Ji("texture_storage_2d",Jn.keyword,"texture_storage_2d"),texture_storage_2d_array:new Ji("texture_storage_2d_array",Jn.keyword,"texture_storage_2d_array"),texture_storage_3d:new Ji("texture_storage_3d",Jn.keyword,"texture_storage_3d"),texture_depth_2d:new Ji("texture_depth_2d",Jn.keyword,"texture_depth_2d"),texture_depth_2d_array:new Ji("texture_depth_2d_array",Jn.keyword,"texture_depth_2d_array"),texture_depth_cube:new Ji("texture_depth_cube",Jn.keyword,"texture_depth_cube"),texture_depth_cube_array:new Ji("texture_depth_cube_array",Jn.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new Ji("texture_depth_multisampled_2d",Jn.keyword,"texture_depth_multisampled_2d"),texture_external:new Ji("texture_external",Jn.keyword,"texture_external"),u32:new Ji("u32",Jn.keyword,"u32"),vec2:new Ji("vec2",Jn.keyword,"vec2"),vec3:new Ji("vec3",Jn.keyword,"vec3"),vec4:new Ji("vec4",Jn.keyword,"vec4"),bitcast:new Ji("bitcast",Jn.keyword,"bitcast"),block:new Ji("block",Jn.keyword,"block"),break:new Ji("break",Jn.keyword,"break"),case:new Ji("case",Jn.keyword,"case"),continue:new Ji("continue",Jn.keyword,"continue"),continuing:new Ji("continuing",Jn.keyword,"continuing"),default:new Ji("default",Jn.keyword,"default"),discard:new Ji("discard",Jn.keyword,"discard"),else:new Ji("else",Jn.keyword,"else"),enable:new Ji("enable",Jn.keyword,"enable"),fallthrough:new Ji("fallthrough",Jn.keyword,"fallthrough"),false:new Ji("false",Jn.keyword,"false"),fn:new Ji("fn",Jn.keyword,"fn"),for:new Ji("for",Jn.keyword,"for"),function:new Ji("function",Jn.keyword,"function"),if:new Ji("if",Jn.keyword,"if"),let:new Ji("let",Jn.keyword,"let"),const:new Ji("const",Jn.keyword,"const"),loop:new Ji("loop",Jn.keyword,"loop"),while:new Ji("while",Jn.keyword,"while"),private:new Ji("private",Jn.keyword,"private"),read:new Ji("read",Jn.keyword,"read"),read_write:new Ji("read_write",Jn.keyword,"read_write"),return:new Ji("return",Jn.keyword,"return"),storage:new Ji("storage",Jn.keyword,"storage"),switch:new Ji("switch",Jn.keyword,"switch"),true:new Ji("true",Jn.keyword,"true"),alias:new Ji("alias",Jn.keyword,"alias"),type:new Ji("type",Jn.keyword,"type"),uniform:new Ji("uniform",Jn.keyword,"uniform"),var:new Ji("var",Jn.keyword,"var"),override:new Ji("override",Jn.keyword,"override"),workgroup:new Ji("workgroup",Jn.keyword,"workgroup"),write:new Ji("write",Jn.keyword,"write"),r8unorm:new Ji("r8unorm",Jn.keyword,"r8unorm"),r8snorm:new Ji("r8snorm",Jn.keyword,"r8snorm"),r8uint:new Ji("r8uint",Jn.keyword,"r8uint"),r8sint:new Ji("r8sint",Jn.keyword,"r8sint"),r16uint:new Ji("r16uint",Jn.keyword,"r16uint"),r16sint:new Ji("r16sint",Jn.keyword,"r16sint"),r16float:new Ji("r16float",Jn.keyword,"r16float"),rg8unorm:new Ji("rg8unorm",Jn.keyword,"rg8unorm"),rg8snorm:new Ji("rg8snorm",Jn.keyword,"rg8snorm"),rg8uint:new Ji("rg8uint",Jn.keyword,"rg8uint"),rg8sint:new Ji("rg8sint",Jn.keyword,"rg8sint"),r32uint:new Ji("r32uint",Jn.keyword,"r32uint"),r32sint:new Ji("r32sint",Jn.keyword,"r32sint"),r32float:new Ji("r32float",Jn.keyword,"r32float"),rg16uint:new Ji("rg16uint",Jn.keyword,"rg16uint"),rg16sint:new Ji("rg16sint",Jn.keyword,"rg16sint"),rg16float:new Ji("rg16float",Jn.keyword,"rg16float"),rgba8unorm:new Ji("rgba8unorm",Jn.keyword,"rgba8unorm"),rgba8unorm_srgb:new Ji("rgba8unorm_srgb",Jn.keyword,"rgba8unorm_srgb"),rgba8snorm:new Ji("rgba8snorm",Jn.keyword,"rgba8snorm"),rgba8uint:new Ji("rgba8uint",Jn.keyword,"rgba8uint"),rgba8sint:new Ji("rgba8sint",Jn.keyword,"rgba8sint"),bgra8unorm:new Ji("bgra8unorm",Jn.keyword,"bgra8unorm"),bgra8unorm_srgb:new Ji("bgra8unorm_srgb",Jn.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new Ji("rgb10a2unorm",Jn.keyword,"rgb10a2unorm"),rg11b10float:new Ji("rg11b10float",Jn.keyword,"rg11b10float"),rg32uint:new Ji("rg32uint",Jn.keyword,"rg32uint"),rg32sint:new Ji("rg32sint",Jn.keyword,"rg32sint"),rg32float:new Ji("rg32float",Jn.keyword,"rg32float"),rgba16uint:new Ji("rgba16uint",Jn.keyword,"rgba16uint"),rgba16sint:new Ji("rgba16sint",Jn.keyword,"rgba16sint"),rgba16float:new Ji("rgba16float",Jn.keyword,"rgba16float"),rgba32uint:new Ji("rgba32uint",Jn.keyword,"rgba32uint"),rgba32sint:new Ji("rgba32sint",Jn.keyword,"rgba32sint"),rgba32float:new Ji("rgba32float",Jn.keyword,"rgba32float"),static_assert:new Ji("static_assert",Jn.keyword,"static_assert")},er.tokens={decimal_float_literal:new Ji("decimal_float_literal",Jn.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new Ji("hex_float_literal",Jn.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new Ji("int_literal",Jn.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new Ji("uint_literal",Jn.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new Ji("ident",Jn.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new Ji("and",Jn.token,"&"),and_and:new Ji("and_and",Jn.token,"&&"),arrow:new Ji("arrow ",Jn.token,"->"),attr:new Ji("attr",Jn.token,"@"),attr_left:new Ji("attr_left",Jn.token,"[["),attr_right:new Ji("attr_right",Jn.token,"]]"),forward_slash:new Ji("forward_slash",Jn.token,"/"),bang:new Ji("bang",Jn.token,"!"),bracket_left:new Ji("bracket_left",Jn.token,"["),bracket_right:new Ji("bracket_right",Jn.token,"]"),brace_left:new Ji("brace_left",Jn.token,"{"),brace_right:new Ji("brace_right",Jn.token,"}"),colon:new Ji("colon",Jn.token,":"),comma:new Ji("comma",Jn.token,","),equal:new Ji("equal",Jn.token,"="),equal_equal:new Ji("equal_equal",Jn.token,"=="),not_equal:new Ji("not_equal",Jn.token,"!="),greater_than:new Ji("greater_than",Jn.token,">"),greater_than_equal:new Ji("greater_than_equal",Jn.token,">="),shift_right:new Ji("shift_right",Jn.token,">>"),less_than:new Ji("less_than",Jn.token,"<"),less_than_equal:new Ji("less_than_equal",Jn.token,"<="),shift_left:new Ji("shift_left",Jn.token,"<<"),modulo:new Ji("modulo",Jn.token,"%"),minus:new Ji("minus",Jn.token,"-"),minus_minus:new Ji("minus_minus",Jn.token,"--"),period:new Ji("period",Jn.token,"."),plus:new Ji("plus",Jn.token,"+"),plus_plus:new Ji("plus_plus",Jn.token,"++"),or:new Ji("or",Jn.token,"|"),or_or:new Ji("or_or",Jn.token,"||"),paren_left:new Ji("paren_left",Jn.token,"("),paren_right:new Ji("paren_right",Jn.token,")"),semicolon:new Ji("semicolon",Jn.token,";"),star:new Ji("star",Jn.token,"*"),tilde:new Ji("tilde",Jn.token,"~"),underscore:new Ji("underscore",Jn.token,"_"),xor:new Ji("xor",Jn.token,"^"),plus_equal:new Ji("plus_equal",Jn.token,"+="),minus_equal:new Ji("minus_equal",Jn.token,"-="),times_equal:new Ji("times_equal",Jn.token,"*="),division_equal:new Ji("division_equal",Jn.token,"/="),modulo_equal:new Ji("modulo_equal",Jn.token,"%="),and_equal:new Ji("and_equal",Jn.token,"&="),or_equal:new Ji("or_equal",Jn.token,"|="),xor_equal:new Ji("xor_equal",Jn.token,"^="),shift_right_equal:new Ji("shift_right_equal",Jn.token,">>="),shift_left_equal:new Ji("shift_left_equal",Jn.token,"<<=")},er.storage_class=[Qn.keywords.function,Qn.keywords.private,Qn.keywords.workgroup,Qn.keywords.uniform,Qn.keywords.storage],er.access_mode=[Qn.keywords.read,Qn.keywords.write,Qn.keywords.read_write],er.sampler_type=[Qn.keywords.sampler,Qn.keywords.sampler_comparison],er.sampled_texture_type=[Qn.keywords.texture_1d,Qn.keywords.texture_2d,Qn.keywords.texture_2d_array,Qn.keywords.texture_3d,Qn.keywords.texture_cube,Qn.keywords.texture_cube_array],er.multisampled_texture_type=[Qn.keywords.texture_multisampled_2d],er.storage_texture_type=[Qn.keywords.texture_storage_1d,Qn.keywords.texture_storage_2d,Qn.keywords.texture_storage_2d_array,Qn.keywords.texture_storage_3d],er.depth_texture_type=[Qn.keywords.texture_depth_2d,Qn.keywords.texture_depth_2d_array,Qn.keywords.texture_depth_cube,Qn.keywords.texture_depth_cube_array,Qn.keywords.texture_depth_multisampled_2d],er.texture_external_type=[Qn.keywords.texture_external],er.any_texture_type=[...Qn.sampled_texture_type,...Qn.multisampled_texture_type,...Qn.storage_texture_type,...Qn.depth_texture_type,...Qn.texture_external_type],er.texel_format=[Qn.keywords.r8unorm,Qn.keywords.r8snorm,Qn.keywords.r8uint,Qn.keywords.r8sint,Qn.keywords.r16uint,Qn.keywords.r16sint,Qn.keywords.r16float,Qn.keywords.rg8unorm,Qn.keywords.rg8snorm,Qn.keywords.rg8uint,Qn.keywords.rg8sint,Qn.keywords.r32uint,Qn.keywords.r32sint,Qn.keywords.r32float,Qn.keywords.rg16uint,Qn.keywords.rg16sint,Qn.keywords.rg16float,Qn.keywords.rgba8unorm,Qn.keywords.rgba8unorm_srgb,Qn.keywords.rgba8snorm,Qn.keywords.rgba8uint,Qn.keywords.rgba8sint,Qn.keywords.bgra8unorm,Qn.keywords.bgra8unorm_srgb,Qn.keywords.rgb10a2unorm,Qn.keywords.rg11b10float,Qn.keywords.rg32uint,Qn.keywords.rg32sint,Qn.keywords.rg32float,Qn.keywords.rgba16uint,Qn.keywords.rgba16sint,Qn.keywords.rgba16float,Qn.keywords.rgba32uint,Qn.keywords.rgba32sint,Qn.keywords.rgba32float],er.const_literal=[Qn.tokens.int_literal,Qn.tokens.uint_literal,Qn.tokens.decimal_float_literal,Qn.tokens.hex_float_literal,Qn.keywords.true,Qn.keywords.false],er.literal_or_ident=[Qn.tokens.ident,Qn.tokens.int_literal,Qn.tokens.uint_literal,Qn.tokens.decimal_float_literal,Qn.tokens.hex_float_literal],er.element_count_expression=[Qn.tokens.int_literal,Qn.tokens.uint_literal,Qn.tokens.ident],er.template_types=[Qn.keywords.vec2,Qn.keywords.vec3,Qn.keywords.vec4,Qn.keywords.mat2x2,Qn.keywords.mat2x3,Qn.keywords.mat2x4,Qn.keywords.mat3x2,Qn.keywords.mat3x3,Qn.keywords.mat3x4,Qn.keywords.mat4x2,Qn.keywords.mat4x3,Qn.keywords.mat4x4,Qn.keywords.atomic,Qn.keywords.bitcast,...Qn.any_texture_type],er.attribute_name=[Qn.tokens.ident,Qn.keywords.block],er.assignment_operators=[Qn.tokens.equal,Qn.tokens.plus_equal,Qn.tokens.minus_equal,Qn.tokens.times_equal,Qn.tokens.division_equal,Qn.tokens.modulo_equal,Qn.tokens.and_equal,Qn.tokens.or_equal,Qn.tokens.xor_equal,Qn.tokens.shift_right_equal,Qn.tokens.shift_left_equal],er.increment_operators=[Qn.tokens.plus_plus,Qn.tokens.minus_minus];class tr{constructor(e,t,n){this.type=e,this.lexeme=t,this.line=n}toString(){return this.lexeme}isTemplateType(){return-1!=er.template_types.indexOf(this.type)}isArrayType(){return this.type==er.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class nr{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new tr(er.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}let t=er.none;for(;;){let n=this._findType(e);const i=this._peekAhead();if(">"==e&&(">"==i||"="==i)){let e=!1,t=this._tokens.length-1;for(let n=0;n<5&&t>=0;++n,--t)if(this._tokens[t].type===er.tokens.less_than){t>0&&this._tokens[t-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(n),!0}if(n===er.none){let i=e,r=0;const s=2;for(let e=0;e<s;++e)if(i+=this._peekAhead(e),n=this._findType(i),n!==er.none){r=e;break}if(n===er.none)return t!==er.none&&(this._current--,this._addToken(t),!0);e=i,this._current+=r+1}if(t=n,this._isAtEnd())break;e+=this._advance()}return t!==er.none&&(this._addToken(t),!0)}_findType(e){for(const t in er.keywords){const n=er.keywords[t];if(this._match(e,n.rule))return n}for(const t in er.tokens){const n=er.tokens[t];if(this._match(e,n.rule))return n}return er.none}_match(e,t){if("string"==typeof t){if(t==e)return!0}else{const n=t.exec(e);if(n&&0==n.index&&n[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new tr(e,t,this._line))}}class ir{constructor(){this._tokens=[],this._current=0,this._context=new ti}parse(e){this._initialize(e);let t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}return t}_initialize(e){if(e)if("string"==typeof e){const t=new nr(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return console.error(e,t),{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==er.eof}_match(e){if(e instanceof Ji)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const n=e[t];if(this._check(n))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){let n=t.type;return-1!=e.indexOf(n)}return t.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(er.tokens.semicolon)&&!this._isAtEnd(););if(this._match(er.keywords.alias)){const e=this._type_alias();return this._consume(er.tokens.semicolon,"Expected ';'"),e}if(this._match(er.keywords.enable)){const e=this._enable_directive();return this._consume(er.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(er.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(er.tokens.semicolon,"Expected ';'."),t}if(this._check(er.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(er.tokens.semicolon,"Expected ';'."),t}if(this._check(er.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(er.tokens.semicolon,"Expected ';'."),t}if(this._check(er.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(er.tokens.semicolon,"Expected ';'."),t}if(this._check(er.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(er.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(er.keywords.fn))return null;const e=this._consume(er.tokens.ident,"Expected function name.").toString();this._consume(er.tokens.paren_left,"Expected '(' for function arguments.");const t=[];if(!this._check(er.tokens.paren_right))do{if(this._check(er.tokens.paren_right))break;const e=this._attribute(),n=this._consume(er.tokens.ident,"Expected argument name.").toString();this._consume(er.tokens.colon,"Expected ':' for argument type.");const i=this._attribute(),r=this._type_decl();null!=r&&(r.attributes=i,t.push(new Xi(n,r,e)))}while(this._match(er.tokens.comma));this._consume(er.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(er.tokens.arrow)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}const i=this._compound_statement();return new oi(e,t,n,i)}_compound_statement(){const e=[];for(this._consume(er.tokens.brace_left,"Expected '{' for block.");!this._check(er.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(er.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(er.tokens.semicolon)&&!this._isAtEnd(););if(this._check(er.keywords.if))return this._if_statement();if(this._check(er.keywords.switch))return this._switch_statement();if(this._check(er.keywords.loop))return this._loop_statement();if(this._check(er.keywords.for))return this._for_statement();if(this._check(er.keywords.while))return this._while_statement();if(this._check(er.keywords.continuing))return this._continuing_statement();if(this._check(er.keywords.static_assert))return this._static_assert_statement();if(this._check(er.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(er.keywords.return)?this._return_statement():this._check([er.keywords.var,er.keywords.let,er.keywords.const])?this._variable_statement():this._match(er.keywords.discard)?new Si:this._match(er.keywords.break)?new Ei:this._match(er.keywords.continue)?new Ai:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(er.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(er.keywords.static_assert))return null;let e=this._optional_paren_expression();return new ai(e)}_while_statement(){if(!this._match(er.keywords.while))return null;let e=this._optional_paren_expression();const t=this._compound_statement();return new li(e,t)}_continuing_statement(){if(!this._match(er.keywords.continuing))return null;const e=this._compound_statement();return new ci(e)}_for_statement(){if(!this._match(er.keywords.for))return null;this._consume(er.tokens.paren_left,"Expected '('.");const e=this._check(er.tokens.semicolon)?null:this._for_init();this._consume(er.tokens.semicolon,"Expected ';'.");const t=this._check(er.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(er.tokens.semicolon,"Expected ';'.");const n=this._check(er.tokens.paren_right)?null:this._for_increment();this._consume(er.tokens.paren_right,"Expected ')'.");const i=this._compound_statement();return new ui(e,t,n,i)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(er.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(er.tokens.equal)&&(t=this._short_circuit_or_expression()),new hi(e.name,e.type,e.storage,e.access,t)}if(this._match(er.keywords.let)){const e=this._consume(er.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(er.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(er.tokens.equal,"Expected '=' for let.");const n=this._short_circuit_or_expression();return new pi(e,t,null,null,n)}if(this._match(er.keywords.const)){const e=this._consume(er.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(er.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(er.tokens.equal,"Expected '=' for const.");const n=this._short_circuit_or_expression();return new fi(e,t,null,null,n)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(er.increment_operators))return this._current=e,null;const n=this._consume(er.increment_operators,"Expected increment operator");return new mi(n.type===er.tokens.plus_plus?Zn.increment:Zn.decrement,t)}_assignment_statement(){let e=null;if(this._check(er.tokens.brace_right))return null;let t=this._match(er.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const n=this._consume(er.assignment_operators,"Expected assignment operator."),i=this._short_circuit_or_expression();return new gi(Kn.parse(n.lexeme),e,i)}_func_call_statement(){if(!this._check(er.tokens.ident))return null;const e=this._current,t=this._consume(er.tokens.ident,"Expected function name."),n=this._argument_expression_list();return null===n?(this._current=e,null):new vi(t.lexeme,n)}_loop_statement(){if(!this._match(er.keywords.loop))return null;this._consume(er.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let n of t)e.push(n);else e.push(t);t=this._statement()}let n=null;return this._match(er.keywords.continuing)&&(n=this._compound_statement()),this._consume(er.tokens.brace_right,"Expected '}' for loop."),new yi(e,n)}_switch_statement(){if(!this._match(er.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(er.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(er.tokens.brace_right,"Expected '}' for switch."),new xi(e,t)}_switch_body(){const e=[];if(this._match(er.keywords.case)){const t=this._case_selectors();this._match(er.tokens.colon),this._consume(er.tokens.brace_left,"Exected '{' for switch case.");const n=this._case_body();this._consume(er.tokens.brace_right,"Exected '}' for switch case."),e.push(new Hi(t,n))}if(this._match(er.keywords.default)){this._match(er.tokens.colon),this._consume(er.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(er.tokens.brace_right,"Exected '}' for switch default."),e.push(new Yi(t))}if(this._check([er.keywords.default,er.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){var e,t,n,i;const r=[null!==(t=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==t?t:""];for(;this._match(er.tokens.comma);)r.push(null!==(i=null===(n=this._shift_expression())||void 0===n?void 0:n.evaluate(this._context).toString())&&void 0!==i?i:"");return r}_case_body(){if(this._match(er.keywords.fallthrough))return this._consume(er.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(er.keywords.if))return null;const e=this._optional_paren_expression(),t=this._compound_statement();let n=[];this._match_elseif()&&(n=this._elseif_statement(n));let i=null;return this._match(er.keywords.else)&&(i=this._compound_statement()),new wi(e,t,n,i)}_match_elseif(){return this._tokens[this._current].type===er.keywords.else&&this._tokens[this._current+1].type===er.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(new Zi(t,n)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(er.keywords.return))return null;const e=this._short_circuit_or_expression();return new bi(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(er.tokens.or_or);)e=new $i(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(er.tokens.and_and);)e=new $i(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(er.tokens.or);)e=new $i(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(er.tokens.xor);)e=new $i(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(er.tokens.and);)e=new $i(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([er.tokens.equal_equal,er.tokens.not_equal])?new $i(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([er.tokens.less_than,er.tokens.greater_than,er.tokens.less_than_equal,er.tokens.greater_than_equal]);)e=new $i(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([er.tokens.shift_left,er.tokens.shift_right]);)e=new $i(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([er.tokens.plus,er.tokens.minus]);)e=new $i(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([er.tokens.star,er.tokens.forward_slash,er.tokens.modulo]);)e=new $i(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([er.tokens.minus,er.tokens.bang,er.tokens.tilde,er.tokens.star,er.tokens.and])?new Gi(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(er.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(er.tokens.bracket_right,"Expected ']'.");const t=this._postfix_expression();return t&&(e.postfix=t),e}if(this._match(er.tokens.period)){const e=this._consume(er.tokens.ident,"Expected member name."),t=this._postfix_expression(),n=new Oi(e.lexeme);return t&&(n.postfix=t),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(er.tokens.ident)){const e=this._previous().toString();if(this._check(er.tokens.paren_left)){const t=this._argument_expression_list(),n=this._getStruct(e);return null!=n?new Ni(n,t):new Ri(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new Di(e,t.value)}return new Fi(e)}if(this._match(er.const_literal))return new Ui(parseFloat(this._previous().toString()));if(this._check(er.tokens.paren_left))return this._paren_expression();if(this._match(er.keywords.bitcast)){this._consume(er.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(er.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new Li(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new qi(e,t)}_argument_expression_list(){if(!this._match(er.tokens.paren_left))return null;const e=[];do{if(this._check(er.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(er.tokens.comma));return this._consume(er.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(er.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(er.tokens.paren_right),new ji([e])}_paren_expression(){this._consume(er.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(er.tokens.paren_right,"Expected ')'."),new ji([e])}_struct_decl(){if(!this._match(er.keywords.struct))return null;const e=this._consume(er.tokens.ident,"Expected name for struct.").toString();this._consume(er.tokens.brace_left,"Expected '{' for struct body.");const t=[];for(;!this._check(er.tokens.brace_right);){const e=this._attribute(),n=this._consume(er.tokens.ident,"Expected variable name.").toString();this._consume(er.tokens.colon,"Expected ':' for struct member type.");const i=this._attribute(),r=this._type_decl();null!=r&&(r.attributes=i),this._check(er.tokens.brace_right)?this._match(er.tokens.comma):this._consume(er.tokens.comma,"Expected ',' for struct member."),t.push(new Ki(n,r,e))}this._consume(er.tokens.brace_right,"Expected '}' after struct body.");const n=new Pi(e,t);return this._context.structs.set(e,n),n}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(er.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(er.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(er.keywords.const))return null;const e=this._consume(er.tokens.ident,"Expected variable name");let t=null;if(this._match(er.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;if(this._match(er.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof Ni)n=e;else if(e instanceof Di&&e.initializer instanceof Ni)n=e.initializer;else try{const t=e.evaluate(this._context);n=new Ui(t)}catch(t){n=e}}const i=new fi(e.toString(),t,"","",n);return this._context.constants.set(i.name,i),i}_global_let_decl(){if(!this._match(er.keywords.let))return null;const e=this._consume(er.tokens.ident,"Expected variable name");let t=null;if(this._match(er.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;return this._match(er.tokens.equal)&&(n=this._const_expression()),new pi(e.toString(),t,"","",n)}_const_expression(){if(this._match(er.const_literal))return new Oi(this._previous().toString());const e=this._type_decl();this._consume(er.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(er.tokens.paren_right)&&(t.push(this._const_expression()),this._check(er.tokens.comma));)this._advance();return this._consume(er.tokens.paren_right,"Expected ')'."),new Ni(e,t)}_variable_decl(){if(!this._match(er.keywords.var))return null;let e="",t="";this._match(er.tokens.less_than)&&(e=this._consume(er.storage_class,"Expected storage_class.").toString(),this._match(er.tokens.comma)&&(t=this._consume(er.access_mode,"Expected access_mode.").toString()),this._consume(er.tokens.greater_than,"Expected '>'."));const n=this._consume(er.tokens.ident,"Expected variable name");let i=null;if(this._match(er.tokens.colon)){const e=this._attribute();i=this._type_decl(),null!=i&&(i.attributes=e)}return new hi(n.toString(),i,e,t,null)}_override_decl(){if(!this._match(er.keywords.override))return null;const e=this._consume(er.tokens.ident,"Expected variable name");let t=null;if(this._match(er.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new di(e.toString(),t,null)}_enable_directive(){const e=this._consume(er.tokens.ident,"identity expected.");return new _i(e.toString())}_type_alias(){const e=this._consume(er.tokens.ident,"identity expected.");this._consume(er.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=new ki(e.toString(),t);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([er.tokens.ident,...er.texel_format,er.keywords.bool,er.keywords.f32,er.keywords.i32,er.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new Ti(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(er.template_types)){let e=this._advance().toString(),t=null,n=null;return this._match(er.tokens.less_than)&&(t=this._type_decl(),n=null,this._match(er.tokens.comma)&&(n=this._consume(er.access_mode,"Expected access_mode for pointer").toString()),this._consume(er.tokens.greater_than,"Expected '>' for type.")),new Mi(e,t,n)}if(this._match(er.keywords.ptr)){let e=this._previous().toString();this._consume(er.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(er.storage_class,"Expected storage_class for pointer");this._consume(er.tokens.comma,"Expected ',' for pointer.");const n=this._type_decl();let i=null;return this._match(er.tokens.comma)&&(i=this._consume(er.access_mode,"Expected access_mode for pointer").toString()),this._consume(er.tokens.greater_than,"Expected '>' for pointer."),new zi(e,t.toString(),n,i)}const t=this._attribute();if(this._match(er.keywords.array)){let e=null,n=-1;const i=this._previous();if(this._match(er.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";this._match(er.tokens.comma)&&(t=this._shift_expression().evaluate(this._context).toString()),this._consume(er.tokens.greater_than,"Expected '>' for array."),n=t?parseInt(t):0}return new Ii(i.toString(),t,e,n)}return null}_texture_sampler_types(){if(this._match(er.sampler_type))return new Ci(this._previous().toString(),null,null);if(this._match(er.depth_texture_type))return new Ci(this._previous().toString(),null,null);if(this._match(er.sampled_texture_type)||this._match(er.multisampled_texture_type)){const e=this._previous();this._consume(er.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(er.tokens.greater_than,"Expected '>' for sampler type."),new Ci(e.toString(),t,null)}if(this._match(er.storage_texture_type)){const e=this._previous();this._consume(er.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(er.texel_format,"Invalid texel format.").toString();this._consume(er.tokens.comma,"Expected ',' after texel format.");const n=this._consume(er.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(er.tokens.greater_than,"Expected '>' for sampler type."),new Ci(e.toString(),t,n)}return null}_attribute(){let e=[];for(;this._match(er.tokens.attr);){const t=this._consume(er.attribute_name,"Expected attribute name"),n=new Qi(t.toString(),null);if(this._match(er.tokens.paren_left)){if(n.value=this._consume(er.literal_or_ident,"Expected attribute value").toString(),this._check(er.tokens.comma)){this._advance();do{const e=this._consume(er.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(e)}while(this._match(er.tokens.comma))}this._consume(er.tokens.paren_right,"Expected ')'")}e.push(n)}for(;this._match(er.tokens.attr_left);){if(!this._check(er.tokens.attr_right))do{const t=this._consume(er.attribute_name,"Expected attribute name"),n=new Qi(t.toString(),null);if(this._match(er.tokens.paren_left)){if(n.value=[this._consume(er.literal_or_ident,"Expected attribute value").toString()],this._check(er.tokens.comma)){this._advance();do{const e=this._consume(er.literal_or_ident,"Expected attribute value").toString();n.value.push(e)}while(this._match(er.tokens.comma))}this._consume(er.tokens.paren_right,"Expected ')'")}e.push(n)}while(this._match(er.tokens.comma));this._consume(er.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class rr{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class sr{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class or extends rr{constructor(e,t){super(e,t),this.members=[],this.align=0}get isStruct(){return!0}}class ar extends rr{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class lr extends rr{constructor(e,t,n,i){super(e,n),this.format=t,this.access=i}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(ei||(ei={}));class cr{constructor(e,t,n,i,r,s,o){this.name=e,this.type=t,this.group=n,this.binding=i,this.attributes=r,this.resourceType=s,this.access=o}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class ur{constructor(e,t){this.name=e,this.type=t}}class hr{constructor(e,t){this.align=e,this.size=t}}class dr{constructor(e,t,n,i){this.name=e,this.type=t,this.locationType=n,this.location=i,this.interpolation=null}}class pr{constructor(e,t,n,i){this.name=e,this.type=t,this.locationType=n,this.location=i}}class fr{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.name=e,this.stage=t}}class mr{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class gr{constructor(e,t,n,i){this.name=e,this.type=t,this.attributes=n,this.id=i}}class vr{constructor(e){this.resources=null,this.node=e}}class yr{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new mr,this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new ir).parse(e);for(const e of t)e instanceof oi&&this._functions.set(e.name,new vr(e));for(const e of t)if(e instanceof Pi){const t=this._getTypeInfo(e,null);t instanceof or&&this.structs.push(t)}else if(e instanceof ki)this.aliases.push(this._getAliasInfo(e));else if(e instanceof di){const t=e,n=this._getAttributeNum(t.attributes,"id",0),i=null!=t.type?this._getTypeInfo(t.type,t.attributes):null;this.overrides.push(new gr(t.name,i,t.attributes,n))}else if(this._isUniformVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),r=this._getTypeInfo(t.type,t.attributes),s=new cr(t.name,r,n,i,t.attributes,ei.Uniform,t.access);this.uniforms.push(s)}else if(this._isStorageVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),r=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(r),o=new cr(t.name,r,n,i,t.attributes,s?ei.StorageTexture:ei.Storage,t.access);this.storage.push(o)}else if(this._isTextureVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),r=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(r),o=new cr(t.name,r,n,i,t.attributes,s?ei.StorageTexture:ei.Texture,t.access);s?this.storage.push(o):this.textures.push(o)}else if(this._isSamplerVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),i=this._getAttributeNum(t.attributes,"binding",0),r=this._getTypeInfo(t.type,t.attributes),s=new cr(t.name,r,n,i,t.attributes,ei.Sampler,t.access);this.samplers.push(s)}else if(e instanceof oi){const t=this._getAttribute(e,"vertex"),n=this._getAttribute(e,"fragment"),i=this._getAttribute(e,"compute"),r=t||n||i;if(r){const t=new fr(e.name,null==r?void 0:r.name);t.inputs=this._getInputs(e.args),t.outputs=this._getOutputs(e.returnType),t.resources=this._findResources(e),this.entry[r.name].push(t)}}}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_findResources(e){const t=[],n=this,i=[];return e.search((e=>{if(e instanceof ii)i.push({});else if(e instanceof ri)i.pop();else if(e instanceof hi){if(i.length>0){const t=e;i[i.length-1][t.name]=t}}else if(e instanceof pi){if(i.length>0){const t=e;i[i.length-1][t.name]=t}}else if(e instanceof Fi){const r=e;if(i.length>0&&i[i.length-1][r.name])return;const s=n._findResource(r.name);s&&t.push(s)}else if(e instanceof Ri){const i=e,r=n._functions.get(i.name);r&&(null===r.resources&&(r.resources=n._findResources(r.node)),t.push(...r.resources))}})),[...new Map(t.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,n){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),n>=e[t].length&&(e[t].length=n+1)}for(const n of this.uniforms)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.storage)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.textures)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.samplers)t(n.group,n.binding),e[n.group][n.binding]=n;return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof Pi)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);null!==n&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof Pi)this._getStructOutputs(n.type,t);else{const e=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(null!==e){const i=this._getTypeInfo(n.type,n.type.attributes),r=this._parseInt(e.value),s=new pr(n.name,i,e.name,r);t.push(s)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getTypeInfo(e,e.attributes),i=this._parseInt(t.value);return new pr("",n,t.name,i)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const n of e)if(n.type instanceof Pi)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof Pi)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getAttribute(e,"interpolation"),i=this._getTypeInfo(e.type,e.attributes),r=this._parseInt(t.value),s=new dr(e.name,i,t.name,r);return null!==n&&(s.interpolation=this._parseString(n.value)),s}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new ur(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof Ii){const n=e,i=this._getTypeInfo(n.format,n.attributes),r=new ar(n.name,t);return r.format=i,r.count=n.count,this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof Pi){const n=e,i=new or(n.name,t);for(const e of n.members){const t=this._getTypeInfo(e.type,e.attributes);i.members.push(new sr(e.name,t,e.attributes))}return this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof Ci){const n=e,i=n.format instanceof Ti,r=n.format?i?this._getTypeInfo(n.format,null):new rr(n.format,null):null,s=new lr(n.name,r,t,n.access);return this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof Mi){const n=e,i=n.format?this._getTypeInfo(n.format,null):null,r=new lr(n.name,i,t,n.access);return this._types.set(e,r),this._updateTypeInfo(r),r}const n=new rr(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n;const i=this._getTypeSize(e);if(e.size=null!==(t=null==i?void 0:i.size)&&void 0!==t?t:0,e instanceof ar){const t=this._getTypeSize(e.format);e.stride=null!==(n=null==t?void 0:t.size)&&void 0!==n?n:0,this._updateTypeInfo(e.format)}e instanceof or&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,i=0,r=0,s=0;for(let o=0,a=e.members.length;o<a;++o){const a=e.members[o],l=this._getTypeSize(a);if(!l)continue;null!==(t=this._getAlias(a.type.name))&&void 0!==t||a.type;const c=l.align,u=l.size;n=this._roundUp(c,n+i),i=u,r=n,s=Math.max(s,c),a.offset=n,a.size=u,this._updateTypeInfo(a.type)}e.size=this._roundUp(s,r+i),e.align=s}_getTypeSize(e){var t;if(null==e)return null;const n=this._getAttributeNum(e.attributes,"size",0),i=this._getAttributeNum(e.attributes,"align",0);if(e instanceof sr&&(e=e.type),e instanceof rr){const t=this._getAlias(e.name);null!==t&&(e=t)}{const t=yr._typeInfo[e.name];if(void 0!==t){const r="f16"===e.format?2:1;return new hr(Math.max(i,t.align/r),Math.max(n,t.size/r))}}{const t=yr._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const r="h"===e.name[e.name.length-1]?2:1;return new hr(Math.max(i,t.align/r),Math.max(n,t.size/r))}}if(e instanceof ar){let r=e,s=8,o=8;const a=this._getTypeSize(r.format);return null!==a&&(o=a.size,s=a.align),o=r.count*this._getAttributeNum(null!==(t=null==e?void 0:e.attributes)&&void 0!==t?t:null,"stride",this._roundUp(s,o)),n&&(o=n),new hr(Math.max(i,s),Math.max(n,o))}if(e instanceof or){let t=0,r=0,s=0,o=0,a=0;for(const n of e.members){const e=this._getTypeSize(n.type);null!==e&&(t=Math.max(e.align,t),s=this._roundUp(e.align,s+o),o=e.size,a=s)}return r=this._roundUp(t,a+o),new hr(Math.max(i,t),Math.max(n,r))}return null}_isUniformVar(e){return e instanceof hi&&"uniform"==e.storage}_isStorageVar(e){return e instanceof hi&&"storage"==e.storage}_isTextureVar(e){return e instanceof hi&&null!==e.type&&-1!=yr._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof hi&&null!==e.type&&-1!=yr._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const i=n.attributes;for(let e of i)if(e.name==t)return e;return null}_getAttributeNum(e,t,n){if(null===e)return n;for(let i of e)if(i.name==t){let e=null!==i&&null!==i.value?i.value:n;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}function xr(e,t){const n=function(e){return Array.isArray(e)||$n(e)?[...e,1,1].slice(0,3):function(e){return[e.width,e.height||1,e.depthOrArrayLayers||1]}(e)}(e),i=Math.max(...n.slice(0,"3d"===t?3:2));return 1+Math.log2(i)|0}yr._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},yr._textureTypes=er.any_texture_type.map((e=>e.name)),yr._samplerTypes=er.sampler_type.map((e=>e.name));const wr=new WeakMap;const br=new Map([[Int8Array,{formats:["sint8","snorm8"],defaultForType:1}],[Uint8Array,{formats:["uint8","unorm8"],defaultForType:1}],[Int16Array,{formats:["sint16","snorm16"],defaultForType:1}],[Uint16Array,{formats:["uint16","unorm16"],defaultForType:1}],[Int32Array,{formats:["sint32","snorm32"],defaultForType:0}],[Uint32Array,{formats:["uint32","unorm32"],defaultForType:0}],[Float32Array,{formats:["float32","float32"],defaultForType:0}]]);function _r(e){return $n(e)||Array.isArray(e)||function(e){const t=e;return $n(t.data)||Array.isArray(t.data)}(e)}function kr(e){switch(e){case"1d":return"1d";case"3d":return"3d";default:return"2d"}}new Map([...br.entries()].map((([e,{formats:[t,n]}])=>[[t,e],[n,e]])).flat());const Sr={"8snorm":Int8Array,"8unorm":Uint8Array,"8sint":Int8Array,"8uint":Uint8Array,"16snorm":Int16Array,"16unorm":Uint16Array,"16sint":Int16Array,"16uint":Uint16Array,"32snorm":Int32Array,"32unorm":Uint32Array,"32sint":Int32Array,"32uint":Uint32Array,"16float":Uint16Array,"32float":Float32Array},Er=/([a-z]+)(\d+)([a-z]+)/;function Ar(e){const[,t,n,i]=Er.exec(e),r=t.length,s=parseInt(n)/8;return{channels:t,numChannels:r,bytesPerChannel:s,bytesPerElement:r*s,Type:Sr[`${n}${i}`]}}function Tr(e,t,n,i={}){n.forEach(((n,r)=>{const s=[0,0,r+(i.baseArrayLayer||0)];if(_r(n))!function(e,t,n,i){const r=function(e,t){if($n(e))return e;const{Type:n}=Ar(t);return new n(e)}(n.data||n,t.format),s=function(e,t){return[e.width,e.height,e.depthOrArrayLayers].map((e=>Math.max(1,Math.floor(e/1))))}(t),{bytesPerElement:o}=Ar(t.format),a=i.origin||[0,0,0];e.queue.writeTexture({texture:t,origin:a},r,{bytesPerRow:o*s[0],rowsPerImage:s[1]},s)}(e,t,n,{origin:s});else{const r=n,{flipY:o,premultipliedAlpha:a,colorSpace:l}=i;e.queue.copyExternalImageToTexture({source:r,flipY:o},{texture:t,premultipliedAlpha:a,colorSpace:l,origin:s},Pr(r,i))}})),t.mipLevelCount>1&&function(e,t,n){let i=wr.get(e);i||(i={pipelineByFormatAndView:{},moduleByViewType:{}},wr.set(e,i));let{sampler:r,uniformBuffer:s,uniformValues:o}=i;const{pipelineByFormatAndView:a,moduleByViewType:l}=i;n=n||function(e){switch(e.dimension){case"1d":return"1d";case"3d":return"3d";default:return e.depthOrArrayLayers>1?"2d-array":"2d"}}(t);let c=l[n];if(!c){const t=function(e){let t,n;switch(e){case"2d":t="texture_2d<f32>",n="textureSample(ourTexture, ourSampler, fsInput.texcoord)";break;case"2d-array":t="texture_2d_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              fsInput.texcoord,\n              uni.layer)";break;case"cube":t="texture_cube<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1))";break;case"cube-array":t="texture_cube_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1), uni.layer)";break;default:throw new Error(`unsupported view: ${e}`)}return`\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n          var pos = array<vec2f, 3>(\n            vec2f(-1.0, -1.0),\n            vec2f(-1.0,  3.0),\n            vec2f( 3.0, -1.0),\n          );\n\n          var vsOutput: VSOutput;\n          let xy = pos[vertexIndex];\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n          return vsOutput;\n        }\n\n        struct Uniforms {\n          layer: u32,\n        };\n\n        @group(0) @binding(0) var ourSampler: sampler;\n        @group(0) @binding(1) var ourTexture: ${t};\n        @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni.layer; // make sure this is used so all pipelines have the same bindings\n          return ${n};\n        }\n      `}(n);c=e.createShaderModule({label:`mip level generation for ${n}`,code:t}),l[n]=c}r||(r=e.createSampler({minFilter:"linear",magFilter:"linear"}),s=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=new Uint32Array(1),Object.assign(i,{sampler:r,uniformBuffer:s,uniformValues:o}));const u=`${t.format}.${n}`;a[u]||(a[u]=e.createRenderPipeline({label:`mip level generator pipeline for ${n}`,layout:"auto",vertex:{module:c,entryPoint:"vs"},fragment:{module:c,entryPoint:"fs",targets:[{format:t.format}]}}));const h=a[u];for(let i=1;i<t.mipLevelCount;++i)for(let a=0;a<t.depthOrArrayLayers;++a){o[0]=a,e.queue.writeBuffer(s,0,o);const l=e.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:r},{binding:1,resource:t.createView({dimension:n,baseMipLevel:i-1,mipLevelCount:1})},{binding:2,resource:{buffer:s}}]}),c={label:"mip gen renderPass",colorAttachments:[{view:t.createView({dimension:"2d",baseMipLevel:i,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},u=e.createCommandEncoder({label:"mip gen encoder"}),d=u.beginRenderPass(c);d.setPipeline(h),d.setBindGroup(0,l),d.draw(3),d.end();const p=u.finish();e.queue.submit([p])}}(e,t)}function Pr(e,t){if(e instanceof HTMLVideoElement)return[e.videoWidth,e.videoHeight,1];{const n=e,{width:i,height:r}=n;if(i>0&&r>0&&!_r(e))return[i,r,1];const s=t.format||"rgba8unorm",{bytesPerElement:o,bytesPerChannel:a}=Ar(s),l=$n(e)||Array.isArray(e)?e:e.data;return function(e,t,n,i="2d"){if(n%1!=0)throw new Error("can't guess dimensions");if(e||t){if(t){if(!e&&(e=n/t)%1)throw new Error("can't guess dimensions")}else if((t=n/e)%1)throw new Error("can't guess dimensions")}else{const r=Math.sqrt(n/("cube"===i?6:1));r%1==0?(e=r,t=r):(e=n,t=1)}const r=n/e/t;if(r%1)throw new Error("can't guess dimensions");return[e,t,r]}(i,r,($n(l)?l.byteLength:l.length*a)/o)}}async function Mr(e,t,n={}){const i=await Promise.all(t.map((e=>async function(e,t={}){const n=await fetch(e),i=await n.blob(),r={...t,...void 0!==t.colorSpaceConversion&&{colorSpaceConversion:"none"}};return await createImageBitmap(i,r)}(e))));return function(e,t,n={}){const i=Pr(t[0],n);i[2]=i[2]>1?i[2]:t.length;const r=e.createTexture({dimension:kr(n.dimension),format:n.format||"rgba8unorm",mipLevelCount:n.mipLevelCount?n.mipLevelCount:n.mips?xr(i):1,size:i,usage:(n.usage??0)|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return Tr(e,r,t,n),r}(e,i,n)}const zr=e=>{let t=ne.create(1/0,1/0,1/0),n=ne.create(-1/0,-1/0,-1/0);for(const{AABB:i}of e)t=ne.min(i.min,t),n=ne.max(i.max,n);return{min:t,max:n}},Ir=e=>{const t=zr(e),n=(t.max[0]-t.min[0])*(t.max[1]-t.min[1])*(t.max[2]-t.min[2]);return e.length*n},Cr=(56,16,16*Math.ceil(3.5));class Br{#p;#f;#m;#g;#v;constructor(e,t){this.#p=e,this.#m=t.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#g=0,this.#f=[],this.#r(this.#m,0,-1,-1),this.#y()}get gpuBuffer(){return this.#v}update(e){this.#m=e.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#g=0,this.#f=[],this.#r(this.#m,0,-1,-1),this.#y()}#r(e,t,n,i){if(0===this.#m.length)return;if(1===e.length)return void(this.#f[t]={leftChildIndex:this.#m.indexOf(e[0]),rightChildIndex:-1,objectCount:1,AABBMax:e[0].AABB.max,AABBMin:e[0].AABB.min,parentIndex:n,siblingIndex:i});const r=zr(e);let s=-1,o=-1;const{left:a,right:l}=(e=>{let t=1/0,n=-1;const i=Math.floor(e.length/2);for(let r=1;r<e.length;r++){const s=e.slice(0,r),o=e.slice(r),a=Ir(s)+Ir(o),l=1*Math.abs(r-i)+1*a;l<t&&(t=l,n=r)}return{left:e.slice(0,n),right:e.slice(n)}})(e);a.length>0&&(s=++this.#g,this.#r(a,s,t,o)),l.length>0&&(o=++this.#g,this.#r(l,o,t,s)),this.#f[t]={leftChildIndex:s,rightChildIndex:o,objectCount:e.length,AABBMax:r.max,AABBMin:r.min,parentIndex:n,siblingIndex:i}}#y(){return this.#v=this.#p.createBuffer({size:Math.max(this.#f.length,1)*Cr,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1,label:"bvh buffer"}),this.#f.forEach(((e,t)=>{const n=t*Cr,i=new ArrayBuffer(Cr),r=new DataView(i);r.setInt32(0,e.leftChildIndex,!0),r.setInt32(4,e.rightChildIndex,!0),r.setUint32(8,e.objectCount,!0),r.setFloat32(16,e.AABBMin[0],!0),r.setFloat32(20,e.AABBMin[1],!0),r.setFloat32(24,e.AABBMin[2],!0),r.setFloat32(32,e.AABBMax[0],!0),r.setFloat32(36,e.AABBMax[1],!0),r.setFloat32(40,e.AABBMax[2],!0),r.setInt32(48,e.parentIndex,!0),r.setInt32(52,e.siblingIndex,!0),this.#p.queue.writeBuffer(this.#v,n,i,0,Cr)})),this.#v}}const Or="clear",Nr=async()=>{const e=Is.createShaderModule({code:"\n    struct VertexOutput {\n      @builtin(position) position : vec4f,\n    }\n    @vertex\n    fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n      var output : VertexOutput;\n      return output;\n    }\n    @fragment\n    fn fragment_main(@builtin(position) position : vec4f) -> @location(0) vec4<f32> {\n        return vec4(0.0);\n    }"}),t=Is.createRenderPipeline({label:Or,layout:"auto",vertex:{module:e,entryPoint:"vertex_main"},fragment:{module:e,entryPoint:"fragment_main",targets:[{format:tt}]}});return{render:e=>{const n=e.commandEncoder.beginRenderPass({label:Or,timestampWrites:e.timestampWrites,colorAttachments:[{view:e.outputTextures.finalTexture.view,loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});n.setPipeline(t),n.draw(6),n.end()},label:Or}};function Rr(e,t){let n=0,i=1/t,r=e;for(;r>0;)n+=i*(r%t),r=Math.floor(r/t),i/=t;return n}let Fr,Dr=!1;class Ur extends e{position;rotation;scale;#x;constructor(e,t,n){super(),this.position=e,this.rotation=t,this.scale=n,this.#x=ye.identity()}get transform(){let e=ye.identity();return ye.translate(e,this.position,e),ye.multiply(e,ye.fromQuat(this.rotation),e),ye.scale(e,this.scale,e),e}get previousTransform(){return this.#x}set previousTransform(e){this.#x=e}get direction(){return ne.transformQuat(ne.create(0,0,1),this.rotation)}get right(){return ne.transformQuat(ne.create(1,0,0),this.rotation)}get left(){return ne.transformQuat(ne.create(-1,0,0),this.rotation)}get up(){return ne.transformQuat(ne.create(0,1,0),this.rotation)}get down(){return ne.transformQuat(ne.create(0,-1,0),this.rotation)}}class Lr extends e{size;atlasLocation;paletteIndex;octreeBufferIndex;name;constructor({size:e,atlasLocation:t,paletteIndex:n,octreeBufferIndex:i,name:r}){super(),this.size=e,this.atlasLocation=t,this.paletteIndex=n,this.octreeBufferIndex=i,this.name=r}}const qr="const MAX_COARSE_RAY_STEPS = 64;\n\nfn rayMarchCoarse(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>) -> bool {\n    let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\n    var voxelSize = vec3<f32>(1.0);\n    var objectPos = objectRayOrigin;\n    var currentIndex = vec3<i32>(round(objectPos));\n    var tDelta = voxelSize / abs(objectRayDirection);\n    var tIncrement = min(tDelta.x, min(tDelta.y, tDelta.z));\n\n    for(var i = 0; i < MAX_COARSE_RAY_STEPS; i++)\n    {\n      let samplePosition = objectPos + voxelObject.atlasLocation;\n      let uv = samplePosition / vec3<f32>(textureDimensions(voxels));\n      let mipSample0 = textureSampleLevel(voxels, nearestSampler, uv, 0.0);\n\n      if(mipSample0.a > 0.0){\n          return true;\n      }\n\n      objectPos += objectRayDirection * tIncrement;\n      currentIndex = vec3<i32>(round(objectPos));\n//      if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\n//          break;\n//      }\n    }\n    return false;\n}\n\nfn rayMarchTransformedCoarse(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> bool {\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz;\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\n    return rayMarchCoarse(voxelObject, objectRayDirection, objectRayOrigin);\n}\n\n// Used for shadows, return first hit\nfn rayMarchBVHCoarse(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxDistance: f32) -> bool {\n  // Create a stack to store the nodes to visit\n      var stack = stack_new();\n      stack_push(&stack, 0);\n\n      var iterations = 0;\n      var nodeIndex = 0;\n\n      while (stack.head > 0u && iterations < 32) {\n        let node = bvhNodes[nodeIndex];\n        if(node.objectCount == 0){\n          nodeIndex = stack_pop(&stack);\n        }\n        // valid leaf, raymarch it\n        else if(node.objectCount == 1){\n            // Raymarch the voxel object if it's a leaf node\n            let voxelObject = voxelObjects[node.leftIndex]; // left index represents the voxel object index for leaf nodes\n            let AABBDist = nodeRayIntersection(rayOrigin, rayDirection, node);\n            if(rayMarchTransformedCoarse(voxelObject, rayDirection, rayOrigin + rayDirection * AABBDist)){\n              return true;\n            }\n            // Pop the stack and continue\n            nodeIndex = stack_pop(&stack);\n        }\n        else{\n          let leftDist = nodeRayIntersection(rayOrigin, rayDirection, bvhNodes[node.leftIndex]);\n          let rightDist = nodeRayIntersection(rayOrigin, rayDirection, bvhNodes[node.rightIndex]);\n          let hitLeft = leftDist >= 0.0 && leftDist < maxDistance;\n          let hitRight = rightDist >= 0.0 && rightDist < maxDistance;\n          if(hitLeft){\n            var nearIndex = node.leftIndex;\n            // We hit both left and right, choose the closest one\n            if(hitRight){\n              if(leftDist < rightDist){\n                // left is closer, push right to stack\n                stack_push(&stack, node.rightIndex);\n              } else {\n                // right is closer, push left to stack\n                stack_push(&stack, node.leftIndex);\n                nearIndex = node.rightIndex;\n              }\n            }\n            nodeIndex = nearIndex;\n          }\n          // We only hit the right Node\n          else if(hitRight){\n            nodeIndex = node.rightIndex;\n          }\n          // We didn't hit any node, pop the stack\n          else{\n            nodeIndex = stack_pop(&stack);\n          }\n        }\n\n        iterations += 1;\n      }\n\n      return false;\n}",jr="struct ViewProjectionMatrices {\n  viewProjection : mat4x4<f32>,\n  previousViewProjection : mat4x4<f32>,\n  inverseViewProjection : mat4x4<f32>,\n  previousInverseViewProjection : mat4x4<f32>,\n  projection : mat4x4<f32>,\n  inverseProjection: mat4x4<f32>\n};",Vr={binding:9,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Gr={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},$r={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Wr={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:tt}},Hr={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Yr={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},Xr={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Zr={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},Kr={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Qr={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},Jr={binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},es={binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},ts={binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},ns={binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},is={binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},rs={binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},ss={binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},os={binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},as={binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},ls={binding:19,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},cs="diffuse",us=[Gr,$r,Wr,Hr,Yr,Xr,Zr,Kr,Qr,Jr,es,ts,ns,is,rs,ss,os,as,ls],hs=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32,\n  elapsed: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${tt}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(9) var intermediaryTexture : texture_2d<f32>;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\n\nconst DOWNSCALE = 1;\n${jr}\n${He}\n${Ye}\n${Xe}\n${Ze}\n${Ke}\n${qr}\n${Qe}\nconst SUN_COLOR = vec3(0.6,0.5,0.4) * 20.0;\nconst MOON_COLOR = vec3<f32>(0.5, 0.5, 1.0);\nconst MIN_RADIANCE = 0.0;\nconst SUBPIXEL_SAMPLE_POSITIONS: array<vec2<f32>, 8> = array<vec2<f32>, 8>(\n  vec2<f32>(0.25, 0.25),\n  vec2<f32>(0.75, 0.25),\n  vec2<f32>(0.25, 0.75),\n  vec2<f32>(0.75, 0.75),\n  vec2<f32>(0.125, 0.125),\n  vec2<f32>(0.375, 0.125),\n  vec2<f32>(0.625, 0.125),\n  vec2<f32>(0.875, 0.125)\n);\nconst BLUE_NOISE_SIZE = 511;\nconst SUN_DIRECTION: vec3<f32> = vec3<f32>(1.0,-1.0,-1.0);\nconst SHADOW_ACNE_OFFSET: f32 = 0.01;\nconst SCATTER_AMOUNT: f32 = 0.01;\nconst POSITION_SCATTER_AMOUNT: f32 = 0.00;\n\n// TODO: offset in object space instead of world space to scale with object size\nfn diffuseRay(worldPos: vec3<f32>, shadowRayDirection: vec3<f32>, normal: vec3<f32>, voxelObjectSize: f32) -> bool {\n  let rayOrigin = worldPos;\n  return rayMarchBVH(rayOrigin, shadowRayDirection).hit;\n}\n\nfn calculateNDC(worldPos: vec3<f32>, viewProjection: mat4x4<f32>) -> vec3<f32> {\n  let clipPos = viewProjection * vec4(worldPos, 1.0);\n  return clipPos.xyz / clipPos.w;\n}\n\nfn calculateNDCDirection(worldDirection: vec3<f32>, viewProjection: mat4x4<f32>) -> vec3<f32> {\n  let clipDirection = viewProjection * vec4(worldDirection, 0.0);\n  return clipDirection.xyz / clipDirection.w;\n}\n\nfn shadowRay(worldPos: vec3<f32>, shadowRayDirection: vec3<f32>, normal: vec3<f32>) -> bool {\n  let rayOrigin = worldPos + normal * SHADOW_ACNE_OFFSET;\n  return rayMarchBVH(rayOrigin, shadowRayDirection).hit;\n}\n\nstruct Light {\n  direction: vec3<f32>,\n  colour: vec3<f32>,\n};\n\nstruct BufferRay {\n  pixel : vec2<u32>,\n  direction : vec3<f32>,\n  origin : vec3<f32>,\n  lightColour : vec3<f32>,\n};\n\nfn randomInCosineWeightedHemisphere(r: vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\n  let r1 = 2.0 * PI * r.x;\n  let r2 = r.y;\n  let r2s = sqrt(r2);\n  let w = normal;\n  let u = normalize(cross((select(vec3<f32>(1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0),abs(w.x) > 0.1)), w));\n  let v = cross(w, u);\n  return normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.0 - r2));\n}\n\nconst SAMPLES_PER_PIXEL = 1u;\nconst SAMPLE_OFFSETS: array<vec2<i32>, 4> = array<vec2<i32>, 4>(\n  vec2<i32>(0, 0),\n  vec2<i32>(1, 1),\n  vec2<i32>(0, 1),\n  vec2<i32>(1, 0),\n);\n\nfn tracePixel(outputPixel:vec2<i32>, downscaleFactor: i32, blueNoiseOffset: vec2<i32>) -> vec3<f32>{\n  let pixel = outputPixel * downscaleFactor;\n  let albedoRef = textureLoad(albedoTex, pixel, 0);\n  var normalSample = textureLoad(normalTex, pixel, 0).rgb;\n  let worldPosSample = textureLoad(worldPosTex, pixel, 0);\n  let uv = vec2<f32>(pixel) / vec2<f32>(textureDimensions(outputTex));\n\n  let distanceToSurface = length(worldPosSample.rgb - cameraPosition);\n  var worldPos = worldPosSample.rgb;\n\n  var samplePixel = pixel;\n  samplePixel.x += i32(time.frame) * 32;\n  samplePixel.y += i32(time.frame) * 16;\n  var blueNoisePixel = ((samplePixel / downscaleFactor) + blueNoiseOffset) % BLUE_NOISE_SIZE;\n  if(time.frame % 2 == 0){\n    blueNoisePixel.y = BLUE_NOISE_SIZE - blueNoisePixel.y;\n  }\n  if(time.frame % 3 == 0){\n    blueNoisePixel.x = BLUE_NOISE_SIZE - blueNoisePixel.x;\n  }\n  var r = textureLoad(blueNoiseTex, blueNoisePixel, 0).rg;\n\n  let maxSunIntensity = vec3(128.0);\n  // TODO: push to buffer instead and evaluate in a separate pass\n\n  let shadowRayDirection = normalize(sunDirection + randomInCosineWeightedHemisphere(r, sunDirection) * SCATTER_AMOUNT);\n\n  let isInShadow = shadowRay(worldPos, shadowRayDirection, normalSample);\n\n  let inputRef = textureLoad(inputTex, pixel, 0);\n\n  if(isInShadow){\n    return inputRef.rgb;\n  }\n\n  return SUN_COLOR;\n}\n\n@compute @workgroup_size(16, 8, 1)\nfn main(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\n  let result = tracePixel(pixel, 1, vec2(0));\n  textureStore(outputTex, pixel, vec4(result, 1.0));\n}\n\n\n@group(1) @binding(0) var<storage, read_write> shadowRayBuffer : array<vec2<u32>>;\n\n// 2x2 grid of offsets\nconst RAY_OFFSETS = array<vec2<u32>, 4>(\n  vec2<u32>(0,0),\n  vec2<u32>(1, 0),\n  vec2<u32>(0, 1),\n  vec2<u32>(1, 1)\n);\n\n@compute @workgroup_size(128, 1, 1)\nfn bufferMarch(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n) {\n  let bufferIndex = GlobalInvocationID.x / 4;\n  let localRayIndex = GlobalInvocationID.x % 4;\n  let pixel = shadowRayBuffer[bufferIndex];\n  let offsetPixel = pixel + RAY_OFFSETS[localRayIndex];\n  let result = tracePixel(vec2<i32>(offsetPixel), 1, vec2(0));\n  textureStore(outputTex, offsetPixel, vec4(result, 1.0));\n}\n\nconst PI = 3.1415926535897932384626433832795;\n\nfn polarToCartesian(angle: f32, radius: f32) -> vec2<f32> {\n  let radians = angle * PI / 180.0;\n  let x = radius * cos(radians);\n  let y = radius * sin(radians);\n  return vec2<f32>(x, y);\n}\n\nfn calculateVariance(neighborhood: array<vec3<f32>, 9>) -> f32 {\n    var mean: vec3<f32> = vec3<f32>(0.0);\n    var variance: f32 = 0.0;\n    // Calculate the mean\n    for (var i = 0; i < 9; i = i + 1) {\n        mean = mean + neighborhood[i];\n    }\n    mean = mean / 9.0;\n    // Calculate the variance\n    for (var i = 0; i < 9; i = i + 1) {\n        var diff = length(neighborhood[i] - mean);\n        variance = variance + diff * diff;\n    }\n\n    return variance / 9.0;\n}\n\n\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\n    vec2<i32>(-1, -1),\n    vec2<i32>(0, -1),\n    vec2<i32>(1, -1),\n    vec2<i32>(-1, 0),\n    vec2<i32>(1, 0),\n    vec2<i32>(-1, 1),\n    vec2<i32>(0, 1),\n    vec2<i32>(1, 1)\n);\n\nconst DEPTH_SENSITIVITY = 10000.0;\nconst BLUR_RADIUS = 2.0;\nconst GOLDEN_RATIO = 1.61803398875;\n\n@compute @workgroup_size(16, 8, 1)\nfn composite(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\n  let shadowRef = textureLoad(intermediaryTexture, pixel, 0);\n  let albedoRef = textureLoad(albedoTex, pixel, 0);\n  let inputRef = textureLoad(inputTex, pixel, 0);\n\n  textureStore(outputTex, pixel, shadowRef * albedoRef + inputRef);\n}\n`,ds=async()=>{const e=Is.createBindGroupLayout({entries:us}),t=Is.createComputePipeline({label:cs,layout:Is.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:Is.createShaderModule({code:hs}),entryPoint:"main"}});let n,i,r,s,o,a,l,c,u,h,d=Is.createSampler({magFilter:"nearest",minFilter:"nearest"}),p=Is.createSampler({magFilter:"linear",minFilter:"linear"});const f=await(async()=>{const e=Is.createBindGroupLayout({entries:[...us,Vr]}),t=await Is.createComputePipelineAsync({label:"diffuse - composite",layout:Is.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:Is.createShaderModule({code:hs}),entryPoint:"composite"}});let n;return(i,r,s,o,a)=>{n||(n=((t,n,i)=>Is.createBindGroup({layout:e,entries:[...t,{binding:2,resource:n},{binding:9,resource:i}]}))(r,o,a)),i.setPipeline(t),i.setBindGroup(0,n),i.dispatchWorkgroups(Math.ceil(s.width/16),Math.ceil(s.height/8))}})();return{render:m=>{const{outputTextures:g,timestampWrites:v,viewProjectionMatricesBuffer:y,volumeAtlas:x,cameraPositionBuffer:w,transformationMatrixBuffer:b,sunDirectionBuffer:_,blueNoiseTextureView:k,timeBuffer:S,bvhBuffer:E,commandEncoder:A}=m;if(n||(n=Is.createTexture({size:[g.finalTexture.width,g.finalTexture.height,1],format:g.finalTexture.format,usage:g.finalTexture.usage}),i=n.createView()),!r){const e={size:[g.finalTexture.width,g.finalTexture.height,1],mipLevelCount:2,format:g.finalTexture.format,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST};r=Is.createTexture(e),a=Is.createTexture(e),u=Is.createTexture(e),l=a.createView({baseMipLevel:0,mipLevelCount:1}),s=r.createView({baseMipLevel:0,mipLevelCount:1}),h=u.createView({baseMipLevel:0,mipLevelCount:1}),o=r.createView({baseMipLevel:1,mipLevelCount:1}),c=a.createView({baseMipLevel:1,mipLevelCount:1})}A.copyTextureToTexture({texture:g.finalTexture.texture},{texture:n},{width:g.finalTexture.width,height:g.finalTexture.height,depthOrArrayLayers:1});const T=[{binding:0,resource:g.depthTexture.view},{binding:1,resource:i},{binding:3,resource:{buffer:y}},{binding:4,resource:x.atlasTextureView},{binding:5,resource:{buffer:w}},{binding:6,resource:{buffer:b}},{binding:7,resource:{buffer:_}},{binding:8,resource:p},{binding:10,resource:g.normalTexture.view},{binding:11,resource:k},{binding:12,resource:{buffer:S}},{binding:13,resource:d},{binding:14,resource:g.velocityTexture.view},{binding:15,resource:{buffer:E}},{binding:16,resource:g.worldPositionTexture.view},{binding:17,resource:g.albedoTexture.view},{binding:18,resource:g.skyTexture.createView({dimension:"cube"})},{binding:19,resource:{buffer:x.octreeBuffer}}],P={layout:e,entries:[...T,{binding:2,resource:s}]};let M=A.beginComputePass({label:"shadow trace",timestampWrites:v});const z=Is.createBindGroup(P);M.setPipeline(t),M.setBindGroup(0,z);const I=Math.ceil(g.finalTexture.width/16),C=Math.ceil(g.finalTexture.height/8);M.dispatchWorkgroups(I,C),M.end(),M=A.beginComputePass({label:"shadow composite",timestampWrites:{querySet:v.querySet,beginningOfPassWriteIndex:v.beginningOfPassWriteIndex+2,endOfPassWriteIndex:v.endOfPassWriteIndex+2}}),f(M,T,g.finalTexture.texture,g.finalTexture.view,s),M.end()},label:cs,timestampLabels:["shadow trace","shadow composite"]}},ps=async()=>{let e,t,n;const i=Is.createComputePipeline({layout:"auto",compute:{module:Is.createShaderModule({code:"// Helper function to compute luminance\nfn Luminance(color: vec3<f32>) -> f32 {\n    return dot(color, vec3<f32>(0.299, 0.587, 0.114));\n}\n\nfn rcp(x: f32) -> f32 {\n    return 1.0 / x;\n}\n\nstruct ViewProjectionMatrices {\n  viewProjection : mat4x4<f32>,\n  previousViewProjection : mat4x4<f32>,\n  inverseViewProjection : mat4x4<f32>,\n  projection : mat4x4<f32>,\n  inverseProjection: mat4x4<f32>\n};\n\n//fn calculateWorldDisplacementFromVelocity(velocity: vec2<f32>, depth: f32) -> vec3<f32> {\n//    let worldDisplacement = vec3<f32>(velocity, depth);\n//    return worldDisplacement;\n//}\n\nfn calculateUvFromWorldPostion(worldPos: vec3<f32>, matrices: ViewProjectionMatrices) -> vec2<f32> {\n  let clipPos = matrices.viewProjection * vec4<f32>(worldPos, 1.0);\n  let uv = (matrices.inverseProjection * clipPos).xy;\n  return uv * 0.5 + 0.5;\n}\n\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\n    vec2<i32>(-1, -1),\n    vec2<i32>(0, -1),\n    vec2<i32>(1, -1),\n    vec2<i32>(-1, 0),\n    vec2<i32>(1, 0),\n    vec2<i32>(-1, 1),\n    vec2<i32>(0, 1),\n    vec2<i32>(1, 1)\n);\n\n@group(0) @binding(0) var CurrentColor : texture_2d<f32>;\n@group(0) @binding(1) var Velocity : texture_2d<f32>;\n@group(0) @binding(2) var HistoryWrite : texture_storage_2d<rgba16float, write>;\n@group(0) @binding(3) var HistoryRead : texture_2d<f32>;\n@group(0) @binding(5) var Depth : texture_2d<f32>;\n@group(0) @binding(6) var linearSampler : sampler;\n@group(0) @binding(7) var nearestSampler : sampler;\n@group(0) @binding(8) var worldPosTex : texture_2d<f32>;\n//@group(0) @binding(9) var<uniform> viewProjectionMatrices : ViewProjectionMatrices;\n\nconst DEPTH_THRESHOLD : f32 = 4.0;\nconst MIN_SOURCE_BLEND = 0.075;\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n    @builtin(global_invocation_id) id : vec3<u32>\n) {\n    let texSize = vec2<f32>(textureDimensions(CurrentColor));\n    let uv = (vec2<f32>(id.xy) + vec2(0.5)) / texSize;\n    let depthSample: f32 = textureLoad(Depth, id.xy, 0).r;\n\n    // Get velocity from pixel with closest depth value in 3x3 neighborhood\n    var closestDepthPixel = vec2<i32>(id.xy);\n    var closestDepth = 999999999.0;\n    for (var i = 0; i < 8; i = i + 1) {\n        let neighbourPixel = clamp(vec2<i32>(id.xy) + NEIGHBORHOOD_SAMPLE_POSITIONS[i], vec2<i32>(0), vec2<i32>(texSize - 1));\n        let neighbourDepth = textureLoad(Depth, neighbourPixel, 0).r;\n        if (abs(neighbourDepth - depthSample) < abs(closestDepth - depthSample)) {\n            closestDepth = neighbourDepth;\n            closestDepthPixel = neighbourPixel;\n        }\n    }\n\n    let velocity = textureLoad(Velocity, closestDepthPixel, 0).xy;\n    let pixelVelocity: vec2<f32> = velocity * texSize;\n    let previousPixel: vec2<i32> = vec2<i32>(id.xy) -  vec2<i32>(pixelVelocity);\n    let previousUv = uv - velocity;\n\n    let worldPos = textureLoad(worldPosTex, id.xy, 0).xyz;\n    let worldPosPrev = textureLoad(worldPosTex, previousPixel, 0).xyz;\n\n    var depthAtPreviousPixel: f32 = textureLoad(Depth, previousPixel, 0).r;\n\n    var sourceSample: vec3<f32> = textureSampleLevel(CurrentColor, nearestSampler, uv, 0).rgb;\n    var historySample: vec3<f32> = textureSampleLevel(HistoryRead, linearSampler, previousUv, 0).rgb;\n\n    // Calculate depth difference between source and history samples\n    let depthDifference: f32 = abs(depthSample - depthAtPreviousPixel);\n\n    // Apply depth clamping\n    if (depthDifference > DEPTH_THRESHOLD) {\n        return;\n    }\n//\n    // Clamp the history sample to the min and max of the 3x3 neighborhood\n    var minCol: vec3<f32> = sourceSample;\n    var maxCol: vec3<f32> = sourceSample;\n    for (var x: i32 = -1; x <= 1; x = x + 1) {\n        for (var y: i32 = -1; y <= 1; y = y + 1) {\n            let neighbourPixel = clamp(vec2(i32(id.x) + x, i32(id.y) + y), vec2(0), vec2(i32(texSize.x - 1), i32(texSize.y - 1)));\n            let s: vec3<f32> = textureLoad(CurrentColor, neighbourPixel, 0).rgb;\n            minCol = min(minCol, s);\n            maxCol = max(maxCol, s);\n        }\n    }\n    historySample = clamp(historySample, minCol, maxCol);\n\n    var sourceWeight: f32 = clamp(length(velocity), MIN_SOURCE_BLEND, 1.0);\n    var historyWeight: f32 = 1.0 - sourceWeight;\n    let compressedSource: vec3<f32> = sourceSample * rcp(max(max(sourceSample.r, sourceSample.g), sourceSample.b) + 1.0);\n    let compressedHistory: vec3<f32> = historySample * rcp(max(max(historySample.r, historySample.g), historySample.b) + 1.0);\n    let luminanceSource: f32 = Luminance(compressedSource);\n    let luminanceHistory: f32 = Luminance(compressedHistory);\n    sourceWeight *= 1.0 / (1.0 + luminanceSource);\n    historyWeight *= 1.0 / (1.0 + luminanceHistory);\n    let result: vec3<f32> = (sourceSample * sourceWeight + historySample * historyWeight) / max(sourceWeight + historyWeight, 0.0001);\n\n    textureStore(HistoryWrite, id.xy, vec4<f32>(result, 1.0));\n}\n"}),entryPoint:"main"}});let r;return{render:({commandEncoder:s,timestampWrites:o,outputTextures:a,viewProjectionMatricesBuffer:l})=>{e||(e=Is.createTexture({label:"TAA History Texture",size:[Cs[0],Cs[1],1],format:tt,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),r=e.createView()),t||(t=Is.createTexture({size:[Cs[0],Cs[1],1],format:tt,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),n=t.createView()),s.copyTextureToTexture({texture:a.finalTexture.texture},{texture:t},{width:t.width,height:t.height,depthOrArrayLayers:1});const c=s.beginComputePass({timestampWrites:o});c.setPipeline(i);const u=Is.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:a.velocityTexture.view},{binding:2,resource:a.finalTexture.view},{binding:3,resource:r},{binding:5,resource:a.depthTexture.view},{binding:6,resource:Is.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})},{binding:7,resource:Is.createSampler({magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest"})},{binding:8,resource:a.worldPositionTexture.view}]});c.setBindGroup(0,u),c.dispatchWorkgroups(Cs[0]/8,Cs[1]/8),c.end(),s.copyTextureToTexture({texture:a.finalTexture.texture},{texture:e},{width:e.width,height:e.height,depthOrArrayLayers:1})},label:"taa"}},fs={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},ms={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},gs={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:tt}},vs={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},ys={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},xs={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},ws={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},bs={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},_s={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},ks=(GPUShaderStage.COMPUTE,[fs,ms,gs,vs,ys,xs,ws,bs,_s,{binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},{binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},{binding:19,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]),Ss=async({shaderCode:e,entryPoint:t,label:n})=>{const i=Is.createBindGroupLayout({entries:ks}),r=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${tt}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\n${jr}\n${He}\n${Ye}\n${Xe}\n${Ze}\n${Ke}\n${qr}\n${e}`,s=Is.createComputePipeline({layout:Is.createPipelineLayout({bindGroupLayouts:[i]}),compute:{module:Is.createShaderModule({code:r}),entryPoint:t}});let o,a,l,c=Is.createSampler({magFilter:"nearest",minFilter:"nearest"}),u=Is.createSampler({magFilter:"linear",minFilter:"linear"});return{render:({commandEncoder:e,outputTextures:t,timestampWrites:n,viewProjectionMatricesBuffer:r,volumeAtlas:h,cameraPositionBuffer:d,transformationMatrixBuffer:p,sunDirectionBuffer:f,blueNoiseTextureView:m,timeBuffer:g,bvhBuffer:v})=>{if(o||(o=Is.createTexture({size:[t.finalTexture.width,t.finalTexture.height,1],format:t.finalTexture.format,usage:t.finalTexture.usage}),a=o.createView()),e.copyTextureToTexture({texture:t.finalTexture.texture},{texture:o},{width:t.finalTexture.width,height:t.finalTexture.height,depthOrArrayLayers:1}),!l){const e=[{binding:0,resource:t.depthTexture.view},{binding:1,resource:a},{binding:2,resource:t.finalTexture.view},{binding:3,resource:{buffer:r}},{binding:4,resource:h.atlasTextureView},{binding:5,resource:{buffer:d}},{binding:6,resource:{buffer:p}},{binding:7,resource:{buffer:f}},{binding:8,resource:u},{binding:10,resource:t.normalTexture.view},{binding:11,resource:m},{binding:12,resource:{buffer:g}},{binding:13,resource:c},{binding:14,resource:t.velocityTexture.view},{binding:15,resource:{buffer:v}},{binding:16,resource:t.worldPositionTexture.view},{binding:17,resource:t.albedoTexture.view},{binding:18,resource:t.skyTexture.createView({dimension:"cube"})},{binding:19,resource:{buffer:h.octreeBuffer}}],n={layout:i,entries:e};l=Is.createBindGroup(n)}const y=e.beginComputePass({timestampWrites:n});y.setPipeline(s),y.setBindGroup(0,l),y.dispatchWorkgroups(Math.ceil(t.finalTexture.width/8),Math.ceil(t.finalTexture.height/8)),y.end()},label:n}},Es=async()=>Ss({shaderCode:"const TARGET_DELTA_TIME: f32 = 16.66;\nconst MAX_SAMPLES: i32 = 8;\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let pixel = GlobalInvocationID.xy;\n  var velocity = textureLoad(velocityAndWaterTex, pixel, 0).xy;\n  let resolution = textureDimensions(inputTex);\n  let centerOfPixel = vec2<f32>(GlobalInvocationID.xy) + vec2<f32>(0.5);\n  var uv = centerOfPixel / vec2<f32>(resolution);\n  let blurScale = (TARGET_DELTA_TIME / time.deltaTime); // less blur when framerate is high\n  let scaledVelocity = velocity * blurScale;\n  var samples = MAX_SAMPLES;\n  var validSamples = 0.0;\n  var result = vec4<f32>(0.0);\n  for (var i = 0; i < samples; i++) {\n    var offset = scaledVelocity * (f32(i) / f32(samples - 1) - 0.5);\n    let offsetUv = uv + offset;\n    let textureSample = textureSampleLevel(inputTex, nearestSampler, offsetUv, 0.0);\n    result += textureSample;\n    validSamples += 1.0;\n  }\n  result /= validSamples;\n  textureStore(outputTex, pixel, result);\n}",entryPoint:"main",label:"motion blur"}),As=async()=>Ss({shaderCode:"fn uncharted2_tonemap_partial(x: vec3<f32>) -> vec3<f32>\n{\n    let A = 0.15f;\n    let B = 0.50f;\n    let C = 0.10f;\n    let D = 0.20f;\n    let E = 0.02f;\n    let F = 0.30f;\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nfn luminance(v: vec3<f32>) -> f32\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\nfn aces(v: vec3<f32>) -> vec3<f32>\n{\n    let a = 2.51f;\n    let b = 0.03f;\n    let c = 2.43f;\n    let d = 0.59f;\n    let e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), vec3(0.0), vec3(1.0f));\n}\n\nfn reverse_aces(v: vec3<f32>) -> vec3<f32>\n{\n    let a = 2.51f;\n    let b = 0.03f;\n    let c = 2.43f;\n    let d = 0.59f;\n    let e = 0.14f;\n    return clamp((v*(v*(c-e)-b))/(a-v*(d-e)), vec3(0.0), vec3(1.0f));\n}\n\nfn uncharted2_filmic(v: vec3<f32>) -> vec3<f32>\n{\n    let exposure_bias = 0.3f;\n    let curr = uncharted2_tonemap_partial(v * exposure_bias);\n    let W = vec3(11.2f);\n    let white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\n    return curr * white_scale;\n}\n\nfn reinhard_jodie(v: vec3<f32>) -> vec3<f32>\n{\n    let l = luminance(v);\n    let tv = v / (1.0f + v);\n    return mix(v / (1.0f + l), tv, tv);\n}\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let pixel = GlobalInvocationID.xy;\n  let inputSample = textureLoad(inputTex, pixel, 0);\n  let toneMapped = uncharted2_filmic(inputSample.rgb);\n//  let gammaCorrected = pow(toneMapped, vec3(1.0f / 0.3f));\n  textureStore(outputTex,pixel,vec4(toneMapped,1));\n}",entryPoint:"main",label:"tonemap"}),Ts=async()=>Ss({shaderCode:"const DENSITY = 0.0002;\nconst BLUE_FOG: vec3<f32> = vec3<f32>(16.,21.,29.);\nconst YELLOW_FOG: vec3<f32> = vec3<f32>(25.,24.,23.);\n\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let pixel = GlobalInvocationID.xy;\n  let worldPos = textureLoad(worldPosTex, pixel, 0).xyz;\n  let depth = distance(worldPos, cameraPosition);\n  let fogDensity = depth * DENSITY;\n\n  let rayDir = normalize(worldPos - cameraPosition);\n  let sunAmount = max(dot(rayDir, sunDirection), 0.0 );\n  let fogColor  = mix( BLUE_FOG, // blue\n                       YELLOW_FOG, // yellow\n                       pow(sunAmount,2.0));\n\n  let fogAmount = 1.0 - exp(-fogDensity);\n  let inputSample = textureLoad(inputTex, pixel, 0).xyz;\n  let result = mix(inputSample, fogColor, fogAmount);\n  textureStore(outputTex, pixel, vec4(result, 1));\n}",entryPoint:"main",label:"fog"});new class{#w;#b;#_;#k;constructor(){this.#w=new Vn(1),this.#b=new Vn(0),this.#_=new Vn(0),this.#k=new Vn(.8)}set targetScale(e){this.#w.target=e}set targetTranslateX(e){this.#b.target=e}set targetRotateY(e){this.#_.target=e}set targetSunRotateY(e){this.#k.target=e}get targetScale(){return this.#w.target}get targetTranslateX(){return this.#b.target}get targetRotateY(){return this.#_.target}get targetSunRotateY(){return this.#k.target}get sunRotateY(){return this.#k.value}get scale(){return this.#w.value}get translateX(){return this.#b.value}};let Ps,Ms,zs,Is,Cs=I.create(4,4),Bs=0,Os=Bs,Ns=0,Rs=0;const Fs=new class{gui;timingsFolder;passesFolder;constructor(){this.gui=new Et,this.timingsFolder=this.gui.addFolder("timings"),this.passesFolder=this.gui.addFolder("passes")}log(e){Object.keys(e).forEach((t=>{const n=this.timingsFolder.controllers.find((e=>e.property===t));n?n.setValue(e[t].toFixed(2)):this.timingsFolder.add(e,t)}))}setupDebugControls(e){const t=e.reduce(((e,t)=>(e[t.label]=!0,e)),{});e.forEach((e=>{this.passesFolder.add(t,e.label)}))}setupOctreeLogging(e){this.gui.addFolder("octree").add(e,"octreeBufferSizeMB").listen()}},Ds=(()=>{let e={};const t=t=>{const n=e[t];return n?n.reduce(((e,t)=>e+t))/n.length:0};return{addSample:(t,n)=>{e[t]||(e[t]=[]),e[t].push(n)>50&&e[t].shift()},clearEntry:t=>{e[t]&&(e[t]=[0])},toString:()=>Object.keys(e).map((e=>`${e}: ${t(e).toFixed(2)}ms`)).join("\n"),toHTML:()=>Object.keys(e).map((e=>`<div class="debug-row">\n                    <div>\n                        ${e}\n                    </div>\n                   <div>${t(e).toFixed(2)}ms</div>\n                </div>`)).join("\n"),getAverages:()=>Object.keys(e).reduce(((e,n)=>(e[n]=t(n),e)),{})}})();Ds.addSample("frame time",0);let Us,Ls,qs,js,Vs,Gs,$s,Ws,Hs,Ys,Xs,Zs,Ks,Qs,Js,eo,to,no,io,ro,so,oo,ao,lo=ye.create();Ls=Array.from({length:200}).map((()=>({position:[-80*Math.random(),50*Math.random(),-200*Math.random()],size:4,color:ne.normalize(ne.create(Math.random(),Math.random(),Math.random()))})));const co=async(e,t,n)=>{if(Is=e,zs=t,!navigator.gpu)throw new Error("WebGPU not supported");ho=((e,t,n)=>{const i=new Float32Array(t),r=e.createBuffer({size:i.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"camera position"});return We(r,t),r})(Is,[0,0,0,0]),uo(Is),no=new Br(Is,[]),Us=Is.createTexture({label:"sky texture",dimension:"2d",size:[640,640,6],format:"rgba16float",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),qs=await Promise.all([Nr(),ut(),(async()=>({label:"copy albedo",render:e=>{((e,t,n)=>{if(t.width!==n.width||t.height!==n.height)throw new Error("Source and destination textures must have the same dimensions");e.copyTextureToTexture({texture:t.texture},{texture:n.texture},{width:t.texture.width,height:t.texture.height,depthOrArrayLayers:1})})(e.commandEncoder,e.outputTextures.albedoTexture,e.outputTextures.finalTexture)}}))(),ds(),Ts(),ps(),As(),Es(),At(Is)]),ao=qs.reduce(((e,t)=>t.timestampLabels?e.concat(t.timestampLabels):e.concat(t.label)),[]),Fs.setupDebugControls(qs),Fs.setupOctreeLogging(zs),Ms=document.getElementById("webgpu-canvas"),Ms.style.imageRendering="pixelated",Ps=Ms.getContext("webgpu"),Ps.configure({device:Is,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT}),so=Is.createSampler({magFilter:"linear",minFilter:"linear"}),oo=Is.createSampler({magFilter:"nearest",minFilter:"nearest"}),Is.features.has("timestamp-query")&&(io=Is.createQuerySet({type:"timestamp",count:1e3}),ro=Is.createBuffer({label:"timestamp query",size:8*io.count,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}));const{clientWidth:i,clientHeight:r}=Ms.parentElement,s=I.create(1*i,1*r);Cs=I.mulScalar(s,1),Ms.width=s[0],Ms.height=s[1],Ms.style.transform="scale(1)"},uo=async e=>{const t=await async function(e,t,n={}){return Mr(e,[t],n)}(e,"blue-noise-rg.png",{usage:GPUTextureUsage.COPY_SRC});Ys=t.createView()};let ho;setInterval((()=>{Fs.log(Ds.getAverages())}),500);let po=0;const fo=(e,t,n,i,r)=>{if(!Is||!qs||!zs||0===r.length)return;const s=Is.createCommandEncoder();0===Bs&&(Bs=e),s.pushDebugGroup("frame");const o=e-Bs;Ns=o-Os,Ds.addSample("frame time",Ns),Os=o,Rs++,((e,t)=>{const n=function(e,t,n,i,r,s){const o=2*Math.tan(i/2)*s,a=o*r,l=1/t,c=1/n;return[(Rr(e,2)-.5)*l*a,(Rr(e,3)-.5)*c*o]}(Rs,Cs[0],Cs[1],"fieldOfView"in e.config?e.config.fieldOfView:90,Cs[0]/Cs[1],"near"in e.config?e.config.near:.1),i=function(e,t){const n=new Float32Array(e);return n[8]+=t[0],n[9]+=t[1],n}(e.projectionMatrix,n),r=(e=>{const t=e.position;return ye.lookAt(t,ne.add(t,e.direction),e.up)})(t),s=ye.mul(i,r);eo=new Float32Array([...s,...lo,...ye.invert(s),...ye.invert(lo),...i,...ye.invert(i),...r]),Qs||(Qs=Is.createBuffer({size:eo.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"view matrices buffer"})),Is.queue.writeBuffer(Qs,0,eo.buffer,0,eo.length*Float32Array.BYTES_PER_ELEMENT);const o=ye.mul((a=i,ye.invert(a)),s);var a;const l=ye.invert(o);to=new Float32Array(ye.getTranslation(l)),Is.queue.writeBuffer(ho,0,to.buffer,0,to.length*Float32Array.BYTES_PER_ELEMENT),lo=s})(n,i),((e,t,n)=>{const i=76*n.length;Ks&&i===Ks.size||(Ks=e.createBuffer({size:i*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"voxel objects buffer"})),n.forEach(((n,i)=>{const r=((e,t)=>{const n=((e,t)=>[...t.transform,...ye.invert(t.transform),...t.previousTransform,...ye.invert(t.previousTransform),...e.size,0,...e.atlasLocation,e.paletteIndex])(e,t),i=4*(n.length+1),r=new DataView(new ArrayBuffer(i));for(let e=0;e<n.length-1;e++)r.setFloat32(4*e,n[e],!0);return r.setUint32(i-4,e.octreeBufferIndex,!0),r})(t.getComponents(n).get(Lr),t.getComponents(n).get(Ur)).buffer;e.queue.writeBuffer(Ks,76*i*Float32Array.BYTES_PER_ELEMENT,r,0,r.byteLength)}))})(Is,t,r),Xs||(Xs=$e([Rs,0,0],"time buffer")),Is.queue.writeBuffer(Xs,4,new Float32Array([Ns])),Is.queue.writeBuffer(Xs,0,new Uint32Array([Rs])),Is.queue.writeBuffer(Xs,8,new Float32Array([Os/1e3])),Zs?Ge(Zs,[Cs[0],Cs[1]]):Zs=$e([Cs[0],Cs[1]]),(()=>{let e=Math.cos(Os/5e3),t=Math.sin(Os/5e3);const n=ne.create(e,1,t);Js?We(Js,[n[0],n[1],n[2]]):Js=$e([n[0],n[1],n[2]],"sun buffer")})(),po!==r.length&&no.update(r.map((e=>((e,t)=>{const n=ne.create(e.size[0]/2,e.size[1]/2,e.size[2]/2);return(e=>{let t=ne.create(1/0,1/0,1/0),n=ne.create(-1/0,-1/0,-1/0);for(const i of e)t=ne.min(t,i),n=ne.max(n,i);return{min:t,max:n}})([ne.create(-n[0],-n[1],-n[2]),ne.create(-n[0],-n[1],n[2]),ne.create(-n[0],n[1],-n[2]),ne.create(-n[0],n[1],n[2]),ne.create(n[0],-n[1],-n[2]),ne.create(n[0],-n[1],n[2]),ne.create(n[0],n[1],-n[2]),ne.create(n[0],n[1],n[2])].map((e=>ne.transformMat4(e,t.transform))))})(t.getComponents(e).get(Lr),t.getComponents(e).get(Ur))))),po=r.length,Vs=new rt(Is,Cs[0],Cs[1]),js=new st(Is,Cs[0],Cs[1]),$s=new ot(Is,Cs[0],Cs[1]),Ws=new at(Is,Cs[0],Cs[1]),Gs=new ct(Is,Cs[0],Cs[1]),Hs=new lt(Is,Cs[0],Cs[1]);let a=0;qs.forEach(((e,o)=>{const{render:l,label:c}=e;if(!1===Fs.passesFolder.controllers.find((e=>e.property===c))?.getValue())return;let u;Is.features.has("timestamp-query")&&s.clearBuffer(ro),Is.features.has("timestamp-query")&&(u={querySet:io,beginningOfPassWriteIndex:a,endOfPassWriteIndex:a+1}),c&&s.pushDebugGroup(c),l({enabled:document.getElementById(`flag-${c}`)?.checked,commandEncoder:s,resolutionBuffer:Zs,timeBuffer:Xs,outputTextures:{finalTexture:Gs,albedoTexture:Vs,normalTexture:js,depthTexture:$s,skyTexture:Us,velocityTexture:Ws,worldPositionTexture:Hs},cameraPositionBuffer:ho,volumeAtlas:zs,transformationMatrixBuffer:Ks,viewProjectionMatricesArray:eo,viewProjectionMatricesBuffer:Qs,timestampWrites:u,sunDirectionBuffer:Js,blueNoiseTextureView:Ys,bvhBuffer:no.gpuBuffer,lights:Ls,linearSampler:so,nearestSampler:oo,camera:n,cameraTransform:i,renderableEntities:r,ecs:t,device:Is}),e.timestampLabels?.length>0?a+=2*e.timestampLabels.length:a+=2,c&&s.popDebugGroup()})),s.popDebugGroup(),Is.features.has("timestamp-query")&&(async(e,t,n)=>{const i=n.size;Fr||(Fr=Is.createBuffer({size:i,label:"gpu read buffer",usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}));const r=Is.createCommandEncoder();if(Dr)return;Dr=!0,r.resolveQuerySet(t,0,t.count,n,0),r.copyBufferToBuffer(n,0,Fr,0,i),Is.queue.submit([r.finish()]),await Is.queue.onSubmittedWorkDone(),await Fr.mapAsync(GPUMapMode.READ).finally((()=>{Dr=!1}));const s=Fr.getMappedRange(),o=new BigInt64Array(s),a=[];o.forEach((e=>{a.push(Number(e)/1e6)})),a.reduce(((e,t,n)=>(n%2==0&&e.push(a[n+1]-t),e)),[]).forEach(((t,n)=>{Ds.addSample(e[n],t)})),Fr.unmap()})(ao,io,ro),Is.queue.submit([s.finish()])};class mo extends e{config;constructor(e){super(),this.config=e}get projectionMatrix(){return"size"in this.config?ye.ortho(-Cs[0]/this.config.size,Cs[0]/this.config.size,-Cs[1]/this.config.size,Cs[1]/this.config.size,this.config.size,-this.config.size):ye.perspective(this.config.fieldOfView,Cs[0]/Cs[1],this.config.near,this.config.far)}}new Error("timeout while waiting for mutex to become available"),new Error("mutex already locked");const go=new Error("request for lock canceled");class vo{constructor(e,t=go){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise(((n,i)=>{const r={resolve:n,reject:i,weight:e,priority:t},s=yo(this._queue,(e=>t<=e.priority));-1===s&&e<=this._value?this._dispatchItem(r):this._queue.splice(s+1,0,r)}))}runExclusive(e){return t=this,n=arguments,r=function*(e,t=1,n=0){const[i,r]=yield this.acquire(t,n);try{return yield e(i)}finally{r()}},new((i=void 0)||(i=Promise))((function(e,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(t){var n;t.done?e(t.value):(n=t.value,n instanceof i?n:new i((function(e){e(n)}))).then(o,a)}l((r=r.apply(t,n||[])).next())}));var t,n,i,r}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise((n=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),function(e,t){const n=yo(e,(e=>t.priority<=e.priority));e.splice(n+1,0,t)}(this._weightedWaiters[e-1],{resolve:n,priority:t})}))}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach((e=>e.reject(this._cancelError))),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(0===this._queue.length)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach((e=>e.resolve())),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const n=this._weightedWaiters[t-1];if(!n)continue;const i=n.findIndex((t=>t.priority<=e));(-1===i?n:n.splice(0,i)).forEach((e=>e.resolve()))}}}_couldLockImmediately(e,t){return(0===this._queue.length||this._queue[0].priority<t)&&e<=this._value}}function yo(e,t){for(let n=e.length-1;n>=0;n--)if(t(e[n]))return n;return-1}class xo{constructor(e){this._semaphore=new vo(1,e)}acquire(){return e=this,t=arguments,i=function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t},new((n=void 0)||(n=Promise))((function(r,s){function o(e){try{l(i.next(e))}catch(e){s(e)}}function a(e){try{l(i.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((i=i.apply(e,t||[])).next())}));var e,t,n,i}runExclusive(e,t=0){return this._semaphore.runExclusive((()=>e()),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const wo={format:"r8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d"},bo=Math.pow(2,3);class _o{#S={};#E;#A;#p;#T;#P;#M;#z=new xo;constructor(e){this.#p=e,this.#E=e.createTexture({size:{width:bo,height:bo,depthOrArrayLayers:bo},...wo,label:"Volume atlas containing ",mipLevelCount:4}),this.#A=e.createTexture({size:{width:256,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1}),this.#T=this.#E.createView(),this.#P=this.#A.createView(),this.#M=e.createBuffer({size:0,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,label:"Octree buffer"})}get dictionary(){return this.#S}addVolume=async(e,t,n,i)=>{if(this.#S[e])throw new Error(`Error adding volume to atlas: volume with label ${e} already exists`);await this.#z.runExclusive((async()=>{const r=this.#p.createCommandEncoder(),[s,o,a]=t,l=this.#M.size/8,c=i||n.byteLength;this.#S[e]={location:[0,0,0],size:[s,o,a],paletteIndex:0,octreeOffset:l,octreeSizeBytes:c,textureSizeBytes:s*o*a};const u=this.#p.createBuffer({label:"Octree buffer",size:this.#M.size+c,usage:this.#M.usage});r.copyBufferToBuffer(this.#M,0,u,0,this.#M.size),this.#p.queue.submit([r.finish()]),this.#p.queue.writeBuffer(u,this.#M.size,n,0,c),await this.#p.queue.onSubmittedWorkDone(),this.#M=u,this.#M.unmap()}))};get atlasTextureView(){return this.#T}get paletteTextureView(){return this.#P}get octreeBuffer(){return this.#M}get octreeBufferSizeMB(){return(this.#M.size/1048576).toFixed(2)}}class ko extends e{device;volumeAtlas}const So=e=>{const t=e.getEntitiesithComponent(ko).values().next().value;return e.getComponents(t).get(ko)};class Eo{pressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1," ":!1,shift:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1})),window.addEventListener("blur",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))})),window.addEventListener("contextmenu",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))}))}}class Ao extends e{speed=.1;rotationSpeed=.002}class To{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new Mo);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new Mo);const n=this.elements,i=e.x,r=e.y,s=e.z;return t.x=n[0]*i+n[1]*r+n[2]*s,t.y=n[3]*i+n[4]*r+n[5]*s,t.z=n[6]*i+n[7]*r+n[8]*s,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new To);const n=this.elements,i=e.elements,r=t.elements,s=n[0],o=n[1],a=n[2],l=n[3],c=n[4],u=n[5],h=n[6],d=n[7],p=n[8],f=i[0],m=i[1],g=i[2],v=i[3],y=i[4],x=i[5],w=i[6],b=i[7],_=i[8];return r[0]=s*f+o*v+a*w,r[1]=s*m+o*y+a*b,r[2]=s*g+o*x+a*_,r[3]=l*f+c*v+u*w,r[4]=l*m+c*y+u*b,r[5]=l*g+c*x+u*_,r[6]=h*f+d*v+p*w,r[7]=h*m+d*y+p*b,r[8]=h*g+d*x+p*_,t}scale(e,t){void 0===t&&(t=new To);const n=this.elements,i=t.elements;for(let t=0;3!==t;t++)i[3*t+0]=e.x*n[3*t+0],i[3*t+1]=e.y*n[3*t+1],i[3*t+2]=e.z*n[3*t+2];return t}solve(e,t){void 0===t&&(t=new Mo);const n=[];let i,r;for(i=0;i<12;i++)n.push(0);for(i=0;i<3;i++)for(r=0;r<3;r++)n[i+4*r]=this.elements[i+3*r];n[3]=e.x,n[7]=e.y,n[11]=e.z;let s=3;const o=s;let a,l;do{if(i=o-s,0===n[i+4*i])for(r=i+1;r<o;r++)if(0!==n[i+4*r]){a=4;do{l=4-a,n[l+4*i]+=n[l+4*r]}while(--a);break}if(0!==n[i+4*i])for(r=i+1;r<o;r++){const e=n[i+4*r]/n[i+4*i];a=4;do{l=4-a,n[l+4*r]=l<=i?0:n[l+4*r]-n[l+4*i]*e}while(--a)}}while(--s);if(t.z=n[11]/n[10],t.y=(n[7]-n[6]*t.z)/n[5],t.x=(n[3]-n[2]*t.z-n[1]*t.y)/n[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(void 0===n)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new To);const t=Po;let n,i;for(n=0;n<3;n++)for(i=0;i<3;i++)t[n+6*i]=this.elements[n+3*i];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let r=3;const s=r;let o,a;do{if(n=s-r,0===t[n+6*n])for(i=n+1;i<s;i++)if(0!==t[n+6*i]){o=6;do{a=6-o,t[a+6*n]+=t[a+6*i]}while(--o);break}if(0!==t[n+6*n])for(i=n+1;i<s;i++){const e=t[n+6*i]/t[n+6*n];o=6;do{a=6-o,t[a+6*i]=a<=n?0:t[a+6*i]-t[a+6*n]*e}while(--o)}}while(--r);n=2;do{i=n-1;do{const e=t[n+6*i]/t[n+6*n];o=6;do{a=6-o,t[a+6*i]=t[a+6*i]-t[a+6*n]*e}while(--o)}while(i--)}while(--n);n=2;do{const e=1/t[n+6*n];o=6;do{a=6-o,t[a+6*n]=t[a+6*n]*e}while(--o)}while(n--);n=2;do{i=2;do{if(a=t[3+i+6*n],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(n,i,a)}while(i--)}while(n--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,i=e.z,r=e.w,s=t+t,o=n+n,a=i+i,l=t*s,c=t*o,u=t*a,h=n*o,d=n*a,p=i*a,f=r*s,m=r*o,g=r*a,v=this.elements;return v[0]=1-(h+p),v[1]=c-g,v[2]=u+m,v[3]=c+g,v[4]=1-(l+p),v[5]=d-f,v[6]=u-m,v[7]=d+f,v[8]=1-(l+h),this}transpose(e){void 0===e&&(e=new To);const t=this.elements,n=e.elements;let i;return n[0]=t[0],n[4]=t[4],n[8]=t[8],i=t[1],n[1]=t[3],n[3]=i,i=t[2],n[2]=t[6],n[6]=i,i=t[5],n[5]=t[7],n[7]=i,e}}const Po=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class Mo{constructor(e,t,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){void 0===t&&(t=new Mo);const n=e.x,i=e.y,r=e.z,s=this.x,o=this.y,a=this.z;return t.x=o*r-a*i,t.y=a*n-s*r,t.z=s*i-o*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new Mo(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new Mo(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new To([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,i=Math.sqrt(e*e+t*t+n*n);if(i>0){const e=1/i;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return i}unit(e){void 0===e&&(e=new Mo);const t=this.x,n=this.y,i=this.z;let r=Math.sqrt(t*t+n*n+i*i);return r>0?(r=1/r,e.x=t*r,e.y=n*r,e.z=i*r):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,i=this.z,r=e.x,s=e.y,o=e.z;return Math.sqrt((r-t)*(r-t)+(s-n)*(s-n)+(o-i)*(o-i))}distanceSquared(e){const t=this.x,n=this.y,i=this.z,r=e.x,s=e.y,o=e.z;return(r-t)*(r-t)+(s-n)*(s-n)+(o-i)*(o-i)}scale(e,t){void 0===t&&(t=new Mo);const n=this.x,i=this.y,r=this.z;return t.x=e*n,t.y=e*i,t.z=e*r,t}vmul(e,t){return void 0===t&&(t=new Mo),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return void 0===n&&(n=new Mo),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new Mo),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const i=zo,r=1/n;i.set(this.x*r,this.y*r,this.z*r);const s=Io;Math.abs(i.x)<.9?(s.set(1,0,0),i.cross(s,e)):(s.set(0,1,0),i.cross(s,e)),i.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const i=this.x,r=this.y,s=this.z;n.x=i+(e.x-i)*t,n.y=r+(e.y-r)*t,n.z=s+(e.z-s)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(Co),Co.almostEquals(e,t)}clone(){return new Mo(this.x,this.y,this.z)}}Mo.ZERO=new Mo(0,0,0),Mo.UNIT_X=new Mo(1,0,0),Mo.UNIT_Y=new Mo(0,1,0),Mo.UNIT_Z=new Mo(0,0,1);const zo=new Mo,Io=new Mo,Co=new Mo;class Bo{constructor(e){void 0===e&&(e={}),this.lowerBound=new Mo,this.upperBound=new Mo,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,i){const r=this.lowerBound,s=this.upperBound,o=n;r.copy(e[0]),o&&o.vmult(r,r),s.copy(r);for(let t=1;t<e.length;t++){let n=e[t];o&&(o.vmult(n,Oo),n=Oo),n.x>s.x&&(s.x=n.x),n.x<r.x&&(r.x=n.x),n.y>s.y&&(s.y=n.y),n.y<r.y&&(r.y=n.y),n.z>s.z&&(s.z=n.z),n.z<r.z&&(r.z=n.z)}return t&&(t.vadd(r,r),t.vadd(s,s)),i&&(r.x-=i,r.y-=i,r.z-=i,s.x+=i,s.y+=i,s.z+=i),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new Bo).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,i=e.lowerBound,r=e.upperBound,s=i.x<=n.x&&n.x<=r.x||t.x<=r.x&&r.x<=n.x,o=i.y<=n.y&&n.y<=r.y||t.y<=r.y&&r.y<=n.y,a=i.z<=n.z&&n.z<=r.z||t.z<=r.z&&r.z<=n.z;return s&&o&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,i=e.lowerBound,r=e.upperBound;return t.x<=i.x&&n.x>=r.x&&t.y<=i.y&&n.y>=r.y&&t.z<=i.z&&n.z>=r.z}getCorners(e,t,n,i,r,s,o,a){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),n.set(c.x,c.y,l.z),i.set(l.x,c.y,c.z),r.set(c.x,l.y,c.z),s.set(l.x,c.y,l.z),o.set(l.x,l.y,c.z),a.copy(c)}toLocalFrame(e,t){const n=No,i=n[0],r=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(i,r,s,o,a,l,c,u);for(let t=0;8!==t;t++){const i=n[t];e.pointToLocal(i,i)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=No,i=n[0],r=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(i,r,s,o,a,l,c,u);for(let t=0;8!==t;t++){const i=n[t];e.pointToWorld(i,i)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,i=1/t.x,r=1/t.y,s=1/t.z,o=(this.lowerBound.x-n.x)*i,a=(this.upperBound.x-n.x)*i,l=(this.lowerBound.y-n.y)*r,c=(this.upperBound.y-n.y)*r,u=(this.lowerBound.z-n.z)*s,h=(this.upperBound.z-n.z)*s,d=Math.max(Math.max(Math.min(o,a),Math.min(l,c)),Math.min(u,h)),p=Math.min(Math.min(Math.max(o,a),Math.max(l,c)),Math.max(u,h));return!(p<0||d>p)}}const Oo=new Mo,No=[new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo];class Ro{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:i}=t;if(i>n){const e=i;i=n,n=e}return this.matrix[(n*(n+1)>>1)+i-1]}set(e,t,n){let{index:i}=e,{index:r}=t;if(r>i){const e=r;r=i,i=e}this.matrix[(i*(i+1)>>1)+r-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class Fo{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;return void 0===n[e]&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return!(void 0===n[e]||!n[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const n=this._listeners;if(void 0===n[e])return this;const i=n[e].indexOf(t);return-1!==i&&n[e].splice(i,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let n=0,i=t.length;n<i;n++)t[n].call(this,e)}return this}}class Do{constructor(e,t,n,i){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),this.x=e,this.y=t,this.z=n,this.w=i}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(.5*t);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new Mo),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=Uo,n=Lo;e.tangents(t,n),this.setFromAxisAngle(t,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new Do);const n=this.x,i=this.y,r=this.z,s=this.w,o=e.x,a=e.y,l=e.z,c=e.w;return t.x=n*c+s*o+i*l-r*a,t.y=i*c+s*a+r*o-n*l,t.z=r*c+s*l+n*a-i*o,t.w=s*c-n*o-i*a-r*l,t}inverse(e){void 0===e&&(e=new Do);const t=this.x,n=this.y,i=this.z,r=this.w;this.conjugate(e);const s=1/(t*t+n*n+i*i+r*r);return e.x*=s,e.y*=s,e.z*=s,e.w*=s,e}conjugate(e){return void 0===e&&(e=new Do),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new Mo);const n=e.x,i=e.y,r=e.z,s=this.x,o=this.y,a=this.z,l=this.w,c=l*n+o*r-a*i,u=l*i+a*n-s*r,h=l*r+s*i-o*n,d=-s*n-o*i-a*r;return t.x=c*l+d*-s+u*-a-h*-o,t.y=u*l+d*-o+h*-s-c*-a,t.z=h*l+d*-a+c*-o-u*-s,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let n,i,r;void 0===t&&(t="YZX");const s=this.x,o=this.y,a=this.z,l=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=s*o+a*l;if(e>.499&&(n=2*Math.atan2(s,l),i=Math.PI/2,r=0),e<-.499&&(n=-2*Math.atan2(s,l),i=-Math.PI/2,r=0),void 0===n){const t=s*s,c=o*o,u=a*a;n=Math.atan2(2*o*l-2*s*a,1-2*c-2*u),i=Math.asin(2*e),r=Math.atan2(2*s*l-2*o*a,1-2*t-2*u)}}e.y=n,e.z=i,e.x=r}setFromEuler(e,t,n,i){void 0===i&&(i="XYZ");const r=Math.cos(e/2),s=Math.cos(t/2),o=Math.cos(n/2),a=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(n/2);return"XYZ"===i?(this.x=a*s*o+r*l*c,this.y=r*l*o-a*s*c,this.z=r*s*c+a*l*o,this.w=r*s*o-a*l*c):"YXZ"===i?(this.x=a*s*o+r*l*c,this.y=r*l*o-a*s*c,this.z=r*s*c-a*l*o,this.w=r*s*o+a*l*c):"ZXY"===i?(this.x=a*s*o-r*l*c,this.y=r*l*o+a*s*c,this.z=r*s*c+a*l*o,this.w=r*s*o-a*l*c):"ZYX"===i?(this.x=a*s*o-r*l*c,this.y=r*l*o+a*s*c,this.z=r*s*c-a*l*o,this.w=r*s*o+a*l*c):"YZX"===i?(this.x=a*s*o+r*l*c,this.y=r*l*o+a*s*c,this.z=r*s*c-a*l*o,this.w=r*s*o-a*l*c):"XZY"===i&&(this.x=a*s*o-r*l*c,this.y=r*l*o-a*s*c,this.z=r*s*c+a*l*o,this.w=r*s*o+a*l*c),this}clone(){return new Do(this.x,this.y,this.z,this.w)}slerp(e,t,n){void 0===n&&(n=new Do);const i=this.x,r=this.y,s=this.z,o=this.w;let a,l,c,u,h,d=e.x,p=e.y,f=e.z,m=e.w;return l=i*d+r*p+s*f+o*m,l<0&&(l=-l,d=-d,p=-p,f=-f,m=-m),1-l>1e-6?(a=Math.acos(l),c=Math.sin(a),u=Math.sin((1-t)*a)/c,h=Math.sin(t*a)/c):(u=1-t,h=t),n.x=u*i+h*d,n.y=u*r+h*p,n.z=u*s+h*f,n.w=u*o+h*m,n}integrate(e,t,n,i){void 0===i&&(i=new Do);const r=e.x*n.x,s=e.y*n.y,o=e.z*n.z,a=this.x,l=this.y,c=this.z,u=this.w,h=.5*t;return i.x+=h*(r*u+s*c-o*l),i.y+=h*(s*u+o*a-r*c),i.z+=h*(o*u+r*l-s*a),i.w+=h*(-r*a-s*l-o*c),i}}const Uo=new Mo,Lo=new Mo;class qo{constructor(e){void 0===e&&(e={}),this.id=qo.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,n,i){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}qo.idCounter=0,qo.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class jo{constructor(e){void 0===e&&(e={}),this.position=new Mo,this.quaternion=new Do,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return jo.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return jo.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new Mo),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,i){return void 0===i&&(i=new Mo),n.vsub(e,i),t.conjugate(Vo),Vo.vmult(i,i),i}static pointToWorldFrame(e,t,n,i){return void 0===i&&(i=new Mo),t.vmult(n,i),i.vadd(e,i),i}static vectorToWorldFrame(e,t,n){return void 0===n&&(n=new Mo),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,i){return void 0===i&&(i=new Mo),t.w*=-1,t.vmult(n,i),t.w*=-1,i}}const Vo=new Do;class Go extends qo{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:n=[],normals:i=[],axes:r,boundingSphereRadius:s}=e;super({type:qo.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=i,0===this.faceNormals.length&&this.computeNormals(),s?this.boundingSphereRadius=s:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=r?r.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const i=new Mo;for(let r=0;r!==e.length;r++){const s=e[r],o=s.length;for(let e=0;e!==o;e++){const r=(e+1)%o;t[s[e]].vsub(t[s[r]],i),i.normalize();let a=!1;for(let e=0;e!==n.length;e++)if(n[e].almostEquals(i)||n[e].almostEquals(i)){a=!0;break}a||n.push(i.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new Mo;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],i=this.vertices[n[0]],r=this.vertices[n[1]],s=this.vertices[n[2]];Go.computeNormal(i,r,s,t)}static computeNormal(e,t,n,i){const r=new Mo,s=new Mo;t.vsub(e,s),n.vsub(t,r),r.cross(s,i),i.isZero()||i.normalize()}clipAgainstHull(e,t,n,i,r,s,o,a,l){const c=new Mo;let u=-1,h=-Number.MAX_VALUE;for(let e=0;e<n.faces.length;e++){c.copy(n.faceNormals[e]),r.vmult(c,c);const t=c.dot(s);t>h&&(h=t,u=e)}const d=[];for(let e=0;e<n.faces[u].length;e++){const t=n.vertices[n.faces[u][e]],s=new Mo;s.copy(t),r.vmult(s,s),i.vadd(s,s),d.push(s)}u>=0&&this.clipFaceAgainstHull(s,e,t,d,o,a,l)}findSeparatingAxis(e,t,n,i,r,s,o,a){const l=new Mo,c=new Mo,u=new Mo,h=new Mo,d=new Mo,p=new Mo;let f=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let o=0;o!==m.uniqueAxes.length;o++){n.vmult(m.uniqueAxes[o],l);const a=m.testSepAxis(l,e,t,n,i,r);if(!1===a)return!1;a<f&&(f=a,s.copy(l))}else{const a=o?o.length:m.faces.length;for(let c=0;c<a;c++){const a=o?o[c]:c;l.copy(m.faceNormals[a]),n.vmult(l,l);const u=m.testSepAxis(l,e,t,n,i,r);if(!1===u)return!1;u<f&&(f=u,s.copy(l))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){r.vmult(e.uniqueAxes[o],c);const a=m.testSepAxis(c,e,t,n,i,r);if(!1===a)return!1;a<f&&(f=a,s.copy(c))}else{const o=a?a.length:e.faces.length;for(let l=0;l<o;l++){const o=a?a[l]:l;c.copy(e.faceNormals[o]),r.vmult(c,c);const u=m.testSepAxis(c,e,t,n,i,r);if(!1===u)return!1;u<f&&(f=u,s.copy(c))}}for(let o=0;o!==m.uniqueEdges.length;o++){n.vmult(m.uniqueEdges[o],h);for(let o=0;o!==e.uniqueEdges.length;o++)if(r.vmult(e.uniqueEdges[o],d),h.cross(d,p),!p.almostZero()){p.normalize();const o=m.testSepAxis(p,e,t,n,i,r);if(!1===o)return!1;o<f&&(f=o,s.copy(p))}}return i.vsub(t,u),u.dot(s)>0&&s.negate(s),!0}testSepAxis(e,t,n,i,r,s){Go.project(this,e,n,i,$o),Go.project(t,e,r,s,Wo);const o=$o[0],a=$o[1],l=Wo[0],c=Wo[1];if(o<c||l<a)return!1;const u=o-c,h=l-a;return u<h?u:h}calculateLocalInertia(e,t){const n=new Mo,i=new Mo;this.computeLocalAABB(i,n);const r=n.x-i.x,s=n.y-i.y,o=n.z-i.z;t.x=1/12*e*(2*s*2*s+2*o*2*o),t.y=1/12*e*(2*r*2*r+2*o*2*o),t.z=1/12*e*(2*s*2*s+2*r*2*r)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],i=this.vertices[t[0]];return-n.dot(i)}clipFaceAgainstHull(e,t,n,i,r,s,o){const a=new Mo,l=new Mo,c=new Mo,u=new Mo,h=new Mo,d=new Mo,p=new Mo,f=new Mo,m=this,g=i,v=[];let y=-1,x=Number.MAX_VALUE;for(let t=0;t<m.faces.length;t++){a.copy(m.faceNormals[t]),n.vmult(a,a);const i=a.dot(e);i<x&&(x=i,y=t)}if(y<0)return;const w=m.faces[y];w.connectedFaces=[];for(let e=0;e<m.faces.length;e++)for(let t=0;t<m.faces[e].length;t++)-1!==w.indexOf(m.faces[e][t])&&e!==y&&-1===w.connectedFaces.indexOf(e)&&w.connectedFaces.push(e);const b=w.length;for(let e=0;e<b;e++){const i=m.vertices[w[e]],r=m.vertices[w[(e+1)%b]];i.vsub(r,l),c.copy(l),n.vmult(c,c),t.vadd(c,c),u.copy(this.faceNormals[y]),n.vmult(u,u),t.vadd(u,u),c.cross(u,h),h.negate(h),d.copy(i),n.vmult(d,d),t.vadd(d,d);const s=w.connectedFaces[e];p.copy(this.faceNormals[s]);const o=this.getPlaneConstantOfFace(s);f.copy(p),n.vmult(f,f);const a=o-f.dot(t);for(this.clipFaceAgainstPlane(g,v,f,a);g.length;)g.shift();for(;v.length;)g.push(v.shift())}p.copy(this.faceNormals[y]);const _=this.getPlaneConstantOfFace(y);f.copy(p),n.vmult(f,f);const k=_-f.dot(t);for(let e=0;e<g.length;e++){let t=f.dot(g[e])+k;if(t<=r&&(console.log(`clamped: depth=${t} to minDist=${r}`),t=r),t<=s){const n=g[e];if(t<=1e-6){const e={point:n,normal:f,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,n,i){let r,s;const o=e.length;if(o<2)return t;let a=e[e.length-1],l=e[0];r=n.dot(a)+i;for(let c=0;c<o;c++){if(l=e[c],s=n.dot(l)+i,r<0)if(s<0){const e=new Mo;e.copy(l),t.push(e)}else{const e=new Mo;a.lerp(l,r/(r-s),e),t.push(e)}else if(s<0){const e=new Mo;a.lerp(l,r/(r-s),e),t.push(e),t.push(l)}a=l,r=s}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new Mo);const n=this.vertices,i=this.worldVertices;for(let r=0;r!==this.vertices.length;r++)t.vmult(n[r],i[r]),e.vadd(i[r],i[r]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const r=n[i];r.x<e.x?e.x=r.x:r.x>t.x&&(t.x=r.x),r.y<e.y?e.y=r.y:r.y>t.y&&(t.y=r.y),r.z<e.z?e.z=r.z:r.z>t.z&&(t.z=r.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new Mo);const n=this.faceNormals,i=this.worldFaceNormals;for(let r=0;r!==t;r++)e.vmult(n[r],i[r]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const i=t[n].lengthSquared();i>e&&(e=i)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,i){const r=this.vertices;let s,o,a,l,c,u,h=new Mo;for(let n=0;n<r.length;n++){h.copy(r[n]),t.vmult(h,h),e.vadd(h,h);const i=h;(void 0===s||i.x<s)&&(s=i.x),(void 0===l||i.x>l)&&(l=i.x),(void 0===o||i.y<o)&&(o=i.y),(void 0===c||i.y>c)&&(c=i.y),(void 0===a||i.z<a)&&(a=i.z),(void 0===u||i.z>u)&&(u=i.z)}n.set(s,o,a),i.set(l,c,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new Mo);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,i=this.vertices;if(t){for(let e=0;e<n;e++){const n=i[e];t.vmult(n,n)}for(let e=0;e<this.faceNormals.length;e++){const n=this.faceNormals[e];t.vmult(n,n)}}if(e)for(let t=0;t<n;t++){const n=i[t];n.vadd(e,n)}}pointIsInside(e){const t=this.vertices,n=this.faces,i=this.faceNormals,r=new Mo;this.getAveragePointLocal(r);for(let s=0;s<this.faces.length;s++){let o=i[s];const a=t[n[s][0]],l=new Mo;e.vsub(a,l);const c=o.dot(l),u=new Mo;r.vsub(a,u);const h=o.dot(u);if(c<0&&h>0||c>0&&h<0)return!1}return-1}static project(e,t,n,i,r){const s=e.vertices.length,o=Ho;let a=0,l=0;const c=Yo,u=e.vertices;c.setZero(),jo.vectorToLocalFrame(n,i,t,o),jo.pointToLocalFrame(n,i,c,c);const h=c.dot(o);l=a=u[0].dot(o);for(let e=1;e<s;e++){const t=u[e].dot(o);t>a&&(a=t),t<l&&(l=t)}if(l-=h,a-=h,l>a){const e=l;l=a,a=e}r[0]=a,r[1]=l}}const $o=[],Wo=[],Ho=(new Mo,new Mo),Yo=new Mo;class Xo extends qo{constructor(e){super({type:qo.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,i=Mo,r=[new i(-e,-t,-n),new i(e,-t,-n),new i(e,t,-n),new i(-e,t,-n),new i(-e,-t,n),new i(e,-t,n),new i(e,t,n),new i(-e,t,n)],s=[new i(0,0,1),new i(0,1,0),new i(1,0,0)],o=new Go({vertices:r,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:s});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new Mo),Xo.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const i=e;n.x=1/12*t*(2*i.y*2*i.y+2*i.z*2*i.z),n.y=1/12*t*(2*i.x*2*i.x+2*i.z*2*i.z),n.z=1/12*t*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(e,t){const n=e,i=this.halfExtents;if(n[0].set(i.x,0,0),n[1].set(0,i.y,0),n[2].set(0,0,i.z),n[3].set(-i.x,0,0),n[4].set(0,-i.y,0),n[5].set(0,0,-i.z),void 0!==t)for(let e=0;e!==n.length;e++)t.vmult(n[e],n[e]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const i=this.halfExtents,r=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let i=0;i<r.length;i++)Zo.set(r[i][0],r[i][1],r[i][2]),t.vmult(Zo,Zo),e.vadd(Zo,Zo),n(Zo.x,Zo.y,Zo.z)}calculateWorldAABB(e,t,n,i){const r=this.halfExtents;Ko[0].set(r.x,r.y,r.z),Ko[1].set(-r.x,r.y,r.z),Ko[2].set(-r.x,-r.y,r.z),Ko[3].set(-r.x,-r.y,-r.z),Ko[4].set(r.x,-r.y,-r.z),Ko[5].set(r.x,r.y,-r.z),Ko[6].set(-r.x,r.y,-r.z),Ko[7].set(r.x,-r.y,r.z);const s=Ko[0];t.vmult(s,s),e.vadd(s,s),i.copy(s),n.copy(s);for(let r=1;r<8;r++){const s=Ko[r];t.vmult(s,s),e.vadd(s,s);const o=s.x,a=s.y,l=s.z;o>i.x&&(i.x=o),a>i.y&&(i.y=a),l>i.z&&(i.z=l),o<n.x&&(n.x=o),a<n.y&&(n.y=a),l<n.z&&(n.z=l)}}}const Zo=new Mo,Ko=[new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo];class Qo extends Fo{constructor(e){void 0===e&&(e={}),super(),this.id=Qo.idCounter++,this.index=-1,this.world=null,this.vlambda=new Mo,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new Mo,this.previousPosition=new Mo,this.interpolatedPosition=new Mo,this.initPosition=new Mo,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new Mo,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new Mo,this.force=new Mo;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Qo.STATIC:Qo.DYNAMIC,typeof e.type==typeof Qo.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Qo.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new Mo,this.quaternion=new Do,this.initQuaternion=new Do,this.previousQuaternion=new Do,this.interpolatedQuaternion=new Do,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new Mo,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new Mo,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new Mo,this.invInertia=new Mo,this.invInertiaWorld=new To,this.invMassSolve=0,this.invInertiaSolve=new Mo,this.invInertiaWorldSolve=new To,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new Mo(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new Mo(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new Bo,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new Mo,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=Qo.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Qo.SLEEPING&&this.dispatchEvent(Qo.wakeupEvent)}sleep(){this.sleepState=Qo.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;t===Qo.AWAKE&&n<i?(this.sleepState=Qo.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Qo.sleepyEvent)):t===Qo.SLEEPY&&n>i?this.wakeUp():t===Qo.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Qo.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Qo.SLEEPING||this.type===Qo.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new Mo),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new Mo),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new Mo),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new Mo),this.quaternion.vmult(e,t),t}addShape(e,t,n){const i=new Mo,r=new Do;return t&&i.copy(t),n&&r.copy(n),this.shapes.push(e),this.shapeOffsets.push(i),this.shapeOrientations.push(r),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let i=0;for(let r=0;r!==n;r++){const n=e[r];n.updateBoundingSphereRadius();const s=t[r].length(),o=n.boundingSphereRadius;s+o>i&&(i=s+o)}this.boundingRadius=i}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,i=e.length,r=Jo,s=ea,o=this.quaternion,a=this.aabb,l=ta;for(let c=0;c!==i;c++){const i=e[c];o.vmult(t[c],r),r.vadd(this.position,r),o.mult(n[c],s),i.calculateWorldAABB(r,s,l.lowerBound,l.upperBound),0===c?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=na,n=ia;e.setRotationFromQuaternion(this.quaternion),e.transpose(n),e.scale(t,e),e.mmult(n,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new Mo),this.type!==Qo.DYNAMIC)return;this.sleepState===Qo.SLEEPING&&this.wakeUp();const n=ra;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new Mo),this.type!==Qo.DYNAMIC)return;const n=sa,i=oa;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,i),this.applyForce(n,i)}applyTorque(e){this.type===Qo.DYNAMIC&&(this.sleepState===Qo.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new Mo),this.type!==Qo.DYNAMIC)return;this.sleepState===Qo.SLEEPING&&this.wakeUp();const n=t,i=aa;i.copy(e),i.scale(this.invMass,i),this.velocity.vadd(i,this.velocity);const r=la;n.cross(e,r),this.invInertiaWorld.vmult(r,r),this.angularVelocity.vadd(r,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new Mo),this.type!==Qo.DYNAMIC)return;const n=ca,i=ua;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,i),this.applyImpulse(n,i)}updateMassProperties(){const e=ha;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Xo.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new Mo;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Qo.DYNAMIC&&this.type!==Qo.KINEMATIC||this.sleepState===Qo.SLEEPING)return;const i=this.velocity,r=this.angularVelocity,s=this.position,o=this.force,a=this.torque,l=this.quaternion,c=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,d=c*e;i.x+=o.x*d*h.x,i.y+=o.y*d*h.y,i.z+=o.z*d*h.z;const p=u.elements,f=this.angularFactor,m=a.x*f.x,g=a.y*f.y,v=a.z*f.z;r.x+=e*(p[0]*m+p[1]*g+p[2]*v),r.y+=e*(p[3]*m+p[4]*g+p[5]*v),r.z+=e*(p[6]*m+p[7]*g+p[8]*v),s.x+=i.x*e,s.y+=i.y*e,s.z+=i.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(n?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Qo.idCounter=0,Qo.COLLIDE_EVENT_NAME="collide",Qo.DYNAMIC=1,Qo.STATIC=2,Qo.KINEMATIC=4,Qo.AWAKE=0,Qo.SLEEPY=1,Qo.SLEEPING=2,Qo.wakeupEvent={type:"wakeup"},Qo.sleepyEvent={type:"sleepy"},Qo.sleepEvent={type:"sleep"};const Jo=new Mo,ea=new Do,ta=new Bo,na=new To,ia=new To,ra=(new To,new Mo),sa=new Mo,oa=new Mo,aa=new Mo,la=new Mo,ca=new Mo,ua=new Mo,ha=new Mo;class da{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&Qo.STATIC)&&e.sleepState!==Qo.SLEEPING||0==(t.type&Qo.STATIC)&&t.sleepState!==Qo.SLEEPING)}intersectionTest(e,t,n,i){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,i):this.doBoundingSphereBroadphase(e,t,n,i)}doBoundingSphereBroadphase(e,t,n,i){const r=pa;t.position.vsub(e.position,r);const s=(e.boundingRadius+t.boundingRadius)**2;r.lengthSquared()<s&&(n.push(e),i.push(t))}doBoundingBoxBroadphase(e,t,n,i){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),i.push(t))}makePairsUnique(e,t){const n=fa,i=ma,r=ga,s=e.length;for(let n=0;n!==s;n++)i[n]=e[n],r[n]=t[n];e.length=0,t.length=0;for(let e=0;e!==s;e++){const t=i[e].id,s=r[e].id,o=t<s?`${t},${s}`:`${s},${t}`;n[o]=e,n.keys.push(o)}for(let s=0;s!==n.keys.length;s++){const s=n.keys.pop(),o=n[s];e.push(i[o]),t.push(r[o]),delete n[s]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new Mo;e.position.vsub(t.position,n);const i=e.shapes[0],r=t.shapes[0];return Math.pow(i.boundingSphereRadius+r.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const pa=new Mo;new Mo,new Do,new Mo;const fa={keys:[]},ma=[],ga=[];new Mo,new Mo,new Mo;class va extends da{constructor(){super()}collisionPairs(e,t,n){const i=e.bodies,r=i.length;let s,o;for(let e=0;e!==r;e++)for(let r=0;r!==e;r++)s=i[e],o=i[r],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,t,n)}aabbQuery(e,t,n){void 0===n&&(n=[]);for(let i=0;i<e.bodies.length;i++){const r=e.bodies[i];r.aabbNeedsUpdate&&r.updateAABB(),r.aabb.overlaps(t)&&n.push(r)}return n}}class ya{constructor(){this.rayFromWorld=new Mo,this.rayToWorld=new Mo,this.hitNormalWorld=new Mo,this.hitPointWorld=new Mo,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,i,r,s,o){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(i),this.shape=r,this.body=s,this.distance=o}}let xa,wa,ba,_a,ka,Sa,Ea;xa=qo.types.SPHERE,wa=qo.types.PLANE,ba=qo.types.BOX,_a=qo.types.CYLINDER,ka=qo.types.CONVEXPOLYHEDRON,Sa=qo.types.HEIGHTFIELD,Ea=qo.types.TRIMESH;class Aa{get[xa](){return this._intersectSphere}get[wa](){return this._intersectPlane}get[ba](){return this._intersectBox}get[_a](){return this._intersectConvex}get[ka](){return this._intersectConvex}get[Sa](){return this._intersectHeightfield}get[Ea](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new Mo),void 0===t&&(t=new Mo),this.from=e.clone(),this.to=t.clone(),this.direction=new Mo,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Aa.ANY,this.result=new ya,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||Aa.ANY,this.result=t.result||new ya,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(Ta),Pa.length=0,e.broadphase.aabbQuery(e,Ta,Pa),this.intersectBodies(Pa),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const i=Ia,r=Ca;for(let t=0,s=e.shapes.length;t<s;t++){const s=e.shapes[t];if((!n||s.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],r),e.quaternion.vmult(e.shapeOffsets[t],i),i.vadd(e.position,i),this.intersectShape(s,r,i,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,n=e.length;!this.result.shouldStop&&t<n;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,i){const r=function(e,t,n){n.vsub(e,Ja);const i=Ja.dot(t);t.scale(i,el),el.vadd(e,el);return n.distanceTo(el)}(this.from,this.direction,n);if(r>e.boundingSphereRadius)return;const s=this[e.type];s&&s.call(this,e,t,n,i,e)}_intersectBox(e,t,n,i,r){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,i,r)}_intersectPlane(e,t,n,i,r){const s=this.from,o=this.to,a=this.direction,l=new Mo(0,0,1);t.vmult(l,l);const c=new Mo;s.vsub(n,c);const u=c.dot(l);if(o.vsub(n,c),u*c.dot(l)>0)return;if(s.distanceTo(o)<u)return;const h=l.dot(a);if(Math.abs(h)<this.precision)return;const d=new Mo,p=new Mo,f=new Mo;s.vsub(n,d);const m=-l.dot(d)/h;a.scale(m,p),s.vadd(p,f),this.reportIntersection(l,f,r,i,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,i=this.to,r=this.from;t.x=Math.min(i.x,r.x),t.y=Math.min(i.y,r.y),t.z=Math.min(i.z,r.z),n.x=Math.max(i.x,r.x),n.y=Math.max(i.y,r.y),n.z=Math.max(i.z,r.z)}_intersectHeightfield(e,t,n,i,r){e.data,e.elementSize;const s=Ua;s.from.copy(this.from),s.to.copy(this.to),jo.pointToLocalFrame(n,t,s.from,s.from),jo.pointToLocalFrame(n,t,s.to,s.to),s.updateDirection();const o=La;let a,l,c,u;a=l=0,c=u=e.data.length-1;const h=new Bo;s.getAABB(h),e.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,o,!0),a=Math.max(a,o[0]),l=Math.max(l,o[1]),e.getIndexOfPosition(h.upperBound.x,h.upperBound.y,o,!0),c=Math.min(c,o[0]+1),u=Math.min(u,o[1]+1);for(let o=a;o<c;o++)for(let a=l;a<u;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(o,a,h),h.overlapsRay(s)){if(e.getConvexTrianglePillar(o,a,!1),jo.pointToWorldFrame(n,t,e.pillarOffset,Da),this._intersectConvex(e.pillarConvex,t,Da,i,r,Fa),this.result.shouldStop)return;e.getConvexTrianglePillar(o,a,!0),jo.pointToWorldFrame(n,t,e.pillarOffset,Da),this._intersectConvex(e.pillarConvex,t,Da,i,r,Fa)}}}_intersectSphere(e,t,n,i,r){const s=this.from,o=this.to,a=e.radius,l=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2,c=2*((o.x-s.x)*(s.x-n.x)+(o.y-s.y)*(s.y-n.y)+(o.z-s.z)*(s.z-n.z)),u=c**2-4*l*((s.x-n.x)**2+(s.y-n.y)**2+(s.z-n.z)**2-a**2),h=qa,d=ja;if(!(u<0))if(0===u)s.lerp(o,u,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,r,i,-1);else{const e=(-c-Math.sqrt(u))/(2*l),t=(-c+Math.sqrt(u))/(2*l);if(e>=0&&e<=1&&(s.lerp(o,e,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,r,i,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(s.lerp(o,t,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,r,i,-1))}}_intersectConvex(e,t,n,i,r,s){const o=Va,a=Ga,l=s&&s.faceList||null,c=e.faces,u=e.vertices,h=e.faceNormals,d=this.direction,p=this.from,f=this.to,m=p.distanceTo(f),g=l?l.length:c.length,v=this.result;for(let e=0;!v.shouldStop&&e<g;e++){const s=l?l[e]:e,f=c[s],g=h[s],y=t,x=n;a.copy(u[f[0]]),y.vmult(a,a),a.vadd(x,a),a.vsub(p,a),y.vmult(g,o);const w=d.dot(o);if(Math.abs(w)<this.precision)continue;const b=o.dot(a)/w;if(!(b<0)){d.scale(b,Ba),Ba.vadd(p,Ba),Oa.copy(u[f[0]]),y.vmult(Oa,Oa),x.vadd(Oa,Oa);for(let e=1;!v.shouldStop&&e<f.length-1;e++){Na.copy(u[f[e]]),Ra.copy(u[f[e+1]]),y.vmult(Na,Na),y.vmult(Ra,Ra),x.vadd(Na,Na),x.vadd(Ra,Ra);const t=Ba.distanceTo(p);!Aa.pointInTriangle(Ba,Oa,Na,Ra)&&!Aa.pointInTriangle(Ba,Na,Oa,Ra)||t>m||this.reportIntersection(o,Ba,r,i,s)}}}}_intersectTrimesh(e,t,n,i,r,s){const o=$a,a=Ka,l=Qa,c=Ga,u=Wa,h=Ha,d=Ya,p=Za,f=Xa,m=e.indices;e.vertices;const g=this.from,v=this.to,y=this.direction;l.position.copy(n),l.quaternion.copy(t),jo.vectorToLocalFrame(n,t,y,u),jo.pointToLocalFrame(n,t,g,h),jo.pointToLocalFrame(n,t,v,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,d.vsub(h,u),u.normalize();const x=h.distanceSquared(d);e.tree.rayQuery(this,l,a);for(let s=0,l=a.length;!this.result.shouldStop&&s!==l;s++){const l=a[s];e.getNormal(l,o),e.getVertex(m[3*l],Oa),Oa.vsub(h,c);const d=u.dot(o),g=o.dot(c)/d;if(g<0)continue;u.scale(g,Ba),Ba.vadd(h,Ba),e.getVertex(m[3*l+1],Na),e.getVertex(m[3*l+2],Ra);const v=Ba.distanceSquared(h);!Aa.pointInTriangle(Ba,Na,Oa,Ra)&&!Aa.pointInTriangle(Ba,Oa,Na,Ra)||v>x||(jo.vectorToWorldFrame(t,o,f),jo.pointToWorldFrame(n,t,Ba,p),this.reportIntersection(f,p,r,i,l))}a.length=0}reportIntersection(e,t,n,i,r){const s=this.from,o=this.to,a=s.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==r?r:-1,this.mode){case Aa.ALL:this.hasHit=!0,l.set(s,o,e,t,n,i,a),l.hasHit=!0,this.callback(l);break;case Aa.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,i,a));break;case Aa.ANY:this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,i,a),l.shouldStop=!0}}static pointInTriangle(e,t,n,i){i.vsub(t,Ja),n.vsub(t,Ma),e.vsub(t,za);const r=Ja.dot(Ja),s=Ja.dot(Ma),o=Ja.dot(za),a=Ma.dot(Ma),l=Ma.dot(za);let c,u;return(c=a*o-s*l)>=0&&(u=r*l-s*o)>=0&&c+u<r*a-s*s}}Aa.CLOSEST=1,Aa.ANY=2,Aa.ALL=4;const Ta=new Bo,Pa=[],Ma=new Mo,za=new Mo,Ia=new Mo,Ca=new Do,Ba=new Mo,Oa=new Mo,Na=new Mo,Ra=new Mo;new Mo,new ya;const Fa={faceList:[0]},Da=new Mo,Ua=new Aa,La=[],qa=new Mo,ja=new Mo,Va=new Mo,Ga=(new Mo,new Mo,new Mo),$a=new Mo,Wa=new Mo,Ha=new Mo,Ya=new Mo,Xa=new Mo,Za=new Mo;new Bo;const Ka=[],Qa=new jo,Ja=new Mo,el=new Mo;class tl{static defaults(e,t){void 0===e&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class nl{constructor(e,t,n){void 0===n&&(n={}),n=tl.defaults(n,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=nl.idCounter++,this.collideConnected=n.collideConnected,n.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}nl.idCounter=0;class il{constructor(){this.spatial=new Mo,this.rotational=new Mo}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class rl{constructor(e,t,n,i){void 0===n&&(n=-1e6),void 0===i&&(i=1e6),this.id=rl.idCounter++,this.minForce=n,this.maxForce=i,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new il,this.jacobianElementB=new il,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const i=t,r=e,s=n;this.a=4/(s*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(s*s*r*(1+4*i))}computeB(e,t,n){const i=this.computeGW();return-this.computeGq()*e-i*t-this.computeGiMf()*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,r=n.position,s=i.position;return e.spatial.dot(r)+t.spatial.dot(s)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,r=n.velocity,s=i.velocity,o=n.angularVelocity,a=i.angularVelocity;return e.multiplyVectors(r,o)+t.multiplyVectors(s,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,r=n.vlambda,s=i.vlambda,o=n.wlambda,a=i.wlambda;return e.multiplyVectors(r,o)+t.multiplyVectors(s,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,r=n.force,s=n.torque,o=i.force,a=i.torque,l=n.invMassSolve,c=i.invMassSolve;return r.scale(l,sl),o.scale(c,ol),n.invInertiaWorldSolve.vmult(s,al),i.invInertiaWorldSolve.vmult(a,ll),e.multiplyVectors(sl,al)+t.multiplyVectors(ol,ll)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,i=this.bj,r=n.invMassSolve,s=i.invMassSolve,o=n.invInertiaWorldSolve,a=i.invInertiaWorldSolve;let l=r+s;return o.vmult(e.rotational,cl),l+=cl.dot(e.rotational),a.vmult(t.rotational,cl),l+=cl.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,i=this.bi,r=this.bj,s=ul;i.vlambda.addScaledVector(i.invMassSolve*e,t.spatial,i.vlambda),r.vlambda.addScaledVector(r.invMassSolve*e,n.spatial,r.vlambda),i.invInertiaWorldSolve.vmult(t.rotational,s),i.wlambda.addScaledVector(e,s,i.wlambda),r.invInertiaWorldSolve.vmult(n.rotational,s),r.wlambda.addScaledVector(e,s,r.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}rl.idCounter=0;const sl=new Mo,ol=new Mo,al=new Mo,ll=new Mo,cl=new Mo,ul=new Mo;class hl extends rl{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new Mo,this.rj=new Mo,this.ni=new Mo}computeB(e){const t=this.a,n=this.b,i=this.bi,r=this.bj,s=this.ri,o=this.rj,a=dl,l=pl,c=i.velocity,u=i.angularVelocity;i.force,i.torque;const h=r.velocity,d=r.angularVelocity;r.force,r.torque;const p=fl,f=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;s.cross(g,a),o.cross(g,l),g.negate(f.spatial),a.negate(f.rotational),m.spatial.copy(g),m.rotational.copy(l),p.copy(r.position),p.vadd(o,p),p.vsub(i.position,p),p.vsub(s,p);const v=g.dot(p),y=this.restitution+1;return-v*t-(y*h.dot(g)-y*c.dot(g)+d.dot(l)-u.dot(a))*n-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=ml,t=gl,n=vl,i=yl,r=xl;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,i),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(i,t),e.vsub(t,r),this.ni.dot(r)}}const dl=new Mo,pl=new Mo,fl=new Mo,ml=new Mo,gl=new Mo,vl=new Mo,yl=new Mo,xl=new Mo;new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo;class wl extends rl{constructor(e,t,n){super(e,t,-n,n),this.ri=new Mo,this.rj=new Mo,this.t=new Mo}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,i=this.rj,r=bl,s=_l,o=this.t;n.cross(o,r),i.cross(o,s);const a=this.jacobianElementA,l=this.jacobianElementB;return o.negate(a.spatial),r.negate(a.rotational),l.spatial.copy(o),l.rotational.copy(s),-this.computeGW()*t-e*this.computeGiMf()}}const bl=new Mo,_l=new Mo;class kl{constructor(e,t,n){n=tl.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=kl.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}kl.idCounter=0;class Sl{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=Sl.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}Sl.idCounter=0,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Aa,new Mo,new Mo,new Mo,new Mo(1,0,0),new Mo(0,1,0),new Mo(0,0,1),new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Bo,new Mo,new Bo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Mo,new Bo,new Mo,new jo,new Bo;class El{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);-1!==n&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class Al extends El{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const i=this.iterations,r=this.tolerance*this.tolerance,s=this.equations,o=s.length,a=t.bodies,l=a.length,c=e;let u,h,d,p,f,m;if(0!==o)for(let e=0;e!==l;e++)a[e].updateSolveMassProperties();const g=Pl,v=Ml,y=Tl;g.length=o,v.length=o,y.length=o;for(let e=0;e!==o;e++){const t=s[e];y[e]=0,v[e]=t.computeB(c),g[e]=1/t.computeC()}if(0!==o){for(let e=0;e!==l;e++){const t=a[e],n=t.vlambda,i=t.wlambda;n.set(0,0,0),i.set(0,0,0)}for(n=0;n!==i;n++){p=0;for(let e=0;e!==o;e++){const t=s[e];u=v[e],h=g[e],m=y[e],f=t.computeGWlambda(),d=h*(u-f-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),y[e]+=d,p+=d>0?d:-d,t.addToWlambda(d)}if(p*p<r)break}for(let e=0;e!==l;e++){const t=a[e],n=t.velocity,i=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),n.vadd(t.vlambda,n),t.wlambda.vmul(t.angularFactor,t.wlambda),i.vadd(t.wlambda,i)}let e=s.length;const t=1/c;for(;e--;)s[e].multiplier=y[e]*t}return n}}const Tl=[],Pl=[],Ml=[];Qo.STATIC;class zl{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class Il extends zl{constructor(){super(...arguments),this.type=Mo}constructObject(){return new Mo}}const Cl=qo.types.SPHERE,Bl=qo.types.SPHERE|qo.types.PLANE,Ol=qo.types.BOX|qo.types.BOX,Nl=qo.types.SPHERE|qo.types.BOX,Rl=qo.types.PLANE|qo.types.BOX,Fl=qo.types.CONVEXPOLYHEDRON,Dl=qo.types.SPHERE|qo.types.CONVEXPOLYHEDRON,Ul=qo.types.PLANE|qo.types.CONVEXPOLYHEDRON,Ll=qo.types.BOX|qo.types.CONVEXPOLYHEDRON,ql=qo.types.SPHERE|qo.types.HEIGHTFIELD,jl=qo.types.BOX|qo.types.HEIGHTFIELD,Vl=qo.types.CONVEXPOLYHEDRON|qo.types.HEIGHTFIELD,Gl=qo.types.PARTICLE|qo.types.SPHERE,$l=qo.types.PLANE|qo.types.PARTICLE,Wl=qo.types.BOX|qo.types.PARTICLE,Hl=qo.types.PARTICLE|qo.types.CONVEXPOLYHEDRON,Yl=qo.types.CYLINDER,Xl=qo.types.SPHERE|qo.types.CYLINDER,Zl=qo.types.PLANE|qo.types.CYLINDER,Kl=qo.types.BOX|qo.types.CYLINDER,Ql=qo.types.CONVEXPOLYHEDRON|qo.types.CYLINDER,Jl=qo.types.HEIGHTFIELD|qo.types.CYLINDER,ec=qo.types.PARTICLE|qo.types.CYLINDER,tc=qo.types.SPHERE|qo.types.TRIMESH,nc=qo.types.PLANE|qo.types.TRIMESH;class ic{get[Cl](){return this.sphereSphere}get[Bl](){return this.spherePlane}get[Ol](){return this.boxBox}get[Nl](){return this.sphereBox}get[Rl](){return this.planeBox}get[Fl](){return this.convexConvex}get[Dl](){return this.sphereConvex}get[Ul](){return this.planeConvex}get[Ll](){return this.boxConvex}get[ql](){return this.sphereHeightfield}get[jl](){return this.boxHeightfield}get[Vl](){return this.convexHeightfield}get[Gl](){return this.sphereParticle}get[$l](){return this.planeParticle}get[Wl](){return this.boxParticle}get[Hl](){return this.convexParticle}get[Yl](){return this.convexConvex}get[Xl](){return this.sphereConvex}get[Zl](){return this.planeConvex}get[Kl](){return this.boxConvex}get[Ql](){return this.convexConvex}get[Jl](){return this.heightfieldCylinder}get[ec](){return this.particleCylinder}get[tc](){return this.sphereTrimesh}get[nc](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Il,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,i,r,s){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=e,o.bj=t):o=new hl(e,t),o.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&i.collisionResponse;const a=this.currentContactMaterial;o.restitution=a.restitution,o.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=n.material||e.material,c=i.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(o.restitution=l.restitution*c.restitution),o.si=r||n,o.sj=s||i,o}createFrictionEquationsFromContact(e,t){const n=e.bi,i=e.bj,r=e.si,s=e.sj,o=this.world,a=this.currentContactMaterial;let l=a.friction;const c=r.material||n.material,u=s.material||i.material;if(c&&u&&c.friction>=0&&u.friction>=0&&(l=c.friction*u.friction),l>0){const r=l*(o.frictionGravity||o.gravity).length();let s=n.invMass+i.invMass;s>0&&(s=1/s);const c=this.frictionEquationPool,u=c.length?c.pop():new wl(n,i,r*s),h=c.length?c.pop():new wl(n,i,r*s);return u.bi=h.bi=n,u.bj=h.bj=i,u.minForce=h.minForce=-r*s,u.maxForce=h.maxForce=r*s,u.ri.copy(e.ri),u.rj.copy(e.rj),h.ri.copy(e.ri),h.rj.copy(e.rj),e.ni.tangents(u.t,h.t),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),u.enabled=h.enabled=e.enabled,t.push(u,h),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const n=this.frictionResult[this.frictionResult.length-2],i=this.frictionResult[this.frictionResult.length-1];rc.setZero(),sc.setZero(),oc.setZero();const r=t.bi;t.bj;for(let n=0;n!==e;n++)t=this.result[this.result.length-1-n],t.bi!==r?(rc.vadd(t.ni,rc),sc.vadd(t.ri,sc),oc.vadd(t.rj,oc)):(rc.vsub(t.ni,rc),sc.vadd(t.rj,sc),oc.vadd(t.ri,oc));const s=1/e;sc.scale(s,n.ri),oc.scale(s,n.rj),i.ri.copy(n.ri),i.rj.copy(n.rj),rc.normalize(),rc.tangents(n.t,i.t)}getContacts(e,t,n,i,r,s,o){this.contactPointPool=r,this.frictionEquationPool=o,this.result=i,this.frictionResult=s;const a=cc,l=uc,c=ac,u=lc;for(let i=0,r=e.length;i!==r;i++){const r=e[i],s=t[i];let o=null;r.material&&s.material&&(o=n.getContactMaterial(r.material,s.material)||null);const h=r.type&Qo.KINEMATIC&&s.type&Qo.STATIC||r.type&Qo.STATIC&&s.type&Qo.KINEMATIC||r.type&Qo.KINEMATIC&&s.type&Qo.KINEMATIC;for(let e=0;e<r.shapes.length;e++){r.quaternion.mult(r.shapeOrientations[e],a),r.quaternion.vmult(r.shapeOffsets[e],c),c.vadd(r.position,c);const t=r.shapes[e];for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],l),s.quaternion.vmult(s.shapeOffsets[e],u),u.vadd(s.position,u);const i=s.shapes[e];if(!(t.collisionFilterMask&i.collisionFilterGroup&&i.collisionFilterMask&t.collisionFilterGroup))continue;if(c.distanceTo(u)>t.boundingSphereRadius+i.boundingSphereRadius)continue;let d=null;t.material&&i.material&&(d=n.getContactMaterial(t.material,i.material)||null),this.currentContactMaterial=d||o||n.defaultContactMaterial;const p=this[t.type|i.type];if(p){let e=!1;e=t.type<i.type?p.call(this,t,i,c,u,a,l,r,s,t,i,h):p.call(this,i,t,u,c,l,a,s,r,t,i,h),e&&h&&(n.shapeOverlapKeeper.set(t.id,i.id),n.bodyOverlapKeeper.set(r.id,s.id))}}}}}sphereSphere(e,t,n,i,r,s,o,a,l,c,u){if(u)return n.distanceSquared(i)<(e.radius+t.radius)**2;const h=this.createContactEquation(o,a,e,t,l,c);i.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(o.position,h.ri),h.rj.vadd(i,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,n,i,r,s,o,a,l,c,u){const h=this.createContactEquation(o,a,e,t,l,c);if(h.ni.set(0,0,1),s.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),n.vsub(i,Mc),h.ni.scale(h.ni.dot(Mc),zc),Mc.vsub(zc,h.rj),-Mc.dot(h.ni)<=e.radius){if(u)return!0;const e=h.ri,t=h.rj;e.vadd(n,e),e.vsub(o.position,e),t.vadd(i,t),t.vsub(a.position,t),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,n,i,r,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,i,r,s,o,a,e,t,u)}sphereBox(e,t,n,i,r,s,o,a,l,c,u){const h=this.v3pool,d=Uc;n.vsub(i,Nc),t.getSideNormals(d,s);const p=e.radius;let f=!1;const m=qc,g=jc,v=Vc;let y=null,x=0,w=0,b=0,_=null;for(let e=0,t=d.length;e!==t&&!1===f;e++){const t=Rc;t.copy(d[e]);const n=t.length();t.normalize();const i=Nc.dot(t);if(i<n+p&&i>0){const r=Fc,s=Dc;r.copy(d[(e+1)%3]),s.copy(d[(e+2)%3]);const o=r.length(),a=s.length();r.normalize(),s.normalize();const l=Nc.dot(r),c=Nc.dot(s);if(l<o&&l>-o&&c<a&&c>-a){const e=Math.abs(i-n-p);if((null===_||e<_)&&(_=e,w=l,b=c,y=n,m.copy(t),g.copy(r),v.copy(s),x++,u))return!0}}}if(x){f=!0;const r=this.createContactEquation(o,a,e,t,l,c);m.scale(-p,r.ri),r.ni.copy(m),r.ni.negate(r.ni),m.scale(y,m),g.scale(w,g),m.vadd(g,m),v.scale(b,v),m.vadd(v,r.rj),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),r.rj.vadd(i,r.rj),r.rj.vsub(a.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}let k=h.get();const S=Lc;for(let r=0;2!==r&&!f;r++)for(let s=0;2!==s&&!f;s++)for(let h=0;2!==h&&!f;h++)if(k.set(0,0,0),r?k.vadd(d[0],k):k.vsub(d[0],k),s?k.vadd(d[1],k):k.vsub(d[1],k),h?k.vadd(d[2],k):k.vsub(d[2],k),i.vadd(k,S),S.vsub(n,S),S.lengthSquared()<p*p){if(u)return!0;f=!0;const r=this.createContactEquation(o,a,e,t,l,c);r.ri.copy(S),r.ri.normalize(),r.ni.copy(r.ri),r.ri.scale(p,r.ri),r.rj.copy(k),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),r.rj.vadd(i,r.rj),r.rj.vsub(a.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}h.release(k),k=null;const E=h.get(),A=h.get(),T=h.get(),P=h.get(),M=h.get(),z=d.length;for(let r=0;r!==z&&!f;r++)for(let s=0;s!==z&&!f;s++)if(r%3!=s%3){d[s].cross(d[r],E),E.normalize(),d[r].vadd(d[s],A),T.copy(n),T.vsub(A,T),T.vsub(i,T);const h=T.dot(E);E.scale(h,P);let m=0;for(;m===r%3||m===s%3;)m++;M.copy(n),M.vsub(P,M),M.vsub(A,M),M.vsub(i,M);const g=Math.abs(h),v=M.length();if(g<d[m].length()&&v<p){if(u)return!0;f=!0;const r=this.createContactEquation(o,a,e,t,l,c);A.vadd(P,r.rj),r.rj.copy(r.rj),M.negate(r.ni),r.ni.normalize(),r.ri.copy(r.rj),r.ri.vadd(i,r.ri),r.ri.vsub(n,r.ri),r.ri.normalize(),r.ri.scale(p,r.ri),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),r.rj.vadd(i,r.rj),r.rj.vsub(a.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}h.release(E,A,T,P,M)}planeBox(e,t,n,i,r,s,o,a,l,c,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,i,r,s,o,a,e,t,u)}convexConvex(e,t,n,i,r,s,o,a,l,c,u,h,d){const p=ru;if(!(n.distanceTo(i)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,r,i,s,p,h,d)){const h=[],d=su;e.clipAgainstHull(n,r,t,i,s,p,-100,100,h);let f=0;for(let r=0;r!==h.length;r++){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c),m=s.ri,g=s.rj;p.negate(s.ni),h[r].normal.negate(d),d.scale(h[r].depth,d),h[r].point.vadd(d,m),g.copy(h[r].point),m.vsub(n,m),g.vsub(i,g),m.vadd(n,m),m.vsub(o.position,m),g.vadd(i,g),g.vsub(a.position,g),this.result.push(s),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}}sphereConvex(e,t,n,i,r,s,o,a,l,c,u){const h=this.v3pool;n.vsub(i,Gc);const d=t.faceNormals,p=t.faces,f=t.vertices,m=e.radius;let g=!1;for(let r=0;r!==f.length;r++){const h=f[r],d=Yc;s.vmult(h,d),i.vadd(d,d);const p=Hc;if(d.vsub(n,p),p.lengthSquared()<m*m){if(u)return!0;g=!0;const r=this.createContactEquation(o,a,e,t,l,c);return r.ri.copy(p),r.ri.normalize(),r.ni.copy(r.ri),r.ri.scale(m,r.ri),d.vsub(i,r.rj),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),r.rj.vadd(i,r.rj),r.rj.vsub(a.position,r.rj),this.result.push(r),void this.createFrictionEquationsFromContact(r,this.frictionResult)}}for(let r=0,v=p.length;r!==v&&!1===g;r++){const v=d[r],y=p[r],x=Xc;s.vmult(v,x);const w=Zc;s.vmult(f[y[0]],w),w.vadd(i,w);const b=Kc;x.scale(-m,b),n.vadd(b,b);const _=Qc;b.vsub(w,_);const k=_.dot(x),S=Jc;if(n.vsub(w,S),k<0&&S.dot(x)>0){const r=[];for(let e=0,t=y.length;e!==t;e++){const t=h.get();s.vmult(f[y[e]],t),i.vadd(t,t),r.push(t)}if(Oc(r,x,n)){if(u)return!0;g=!0;const s=this.createContactEquation(o,a,e,t,l,c);x.scale(-m,s.ri),x.negate(s.ni);const d=h.get();x.scale(-k,d);const p=h.get();x.scale(-m,p),n.vsub(i,s.rj),s.rj.vadd(p,s.rj),s.rj.vadd(d,s.rj),s.rj.vadd(i,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),h.release(d),h.release(p),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=r.length;e!==t;e++)h.release(r[e]);return}for(let d=0;d!==y.length;d++){const p=h.get(),g=h.get();s.vmult(f[y[(d+1)%y.length]],p),s.vmult(f[y[(d+2)%y.length]],g),i.vadd(p,p),i.vadd(g,g);const v=$c;g.vsub(p,v);const x=Wc;v.unit(x);const w=h.get(),b=h.get();n.vsub(p,b);const _=b.dot(x);x.scale(_,w),w.vadd(p,w);const k=h.get();if(w.vsub(n,k),_>0&&_*_<v.lengthSquared()&&k.lengthSquared()<m*m){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c);w.vsub(i,s.rj),w.vsub(n,s.ni),s.ni.normalize(),s.ni.scale(m,s.ri),s.rj.vadd(i,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=r.length;e!==t;e++)h.release(r[e]);return h.release(p),h.release(g),h.release(w),h.release(k),void h.release(b)}h.release(p),h.release(g),h.release(w),h.release(k),h.release(b)}for(let e=0,t=r.length;e!==t;e++)h.release(r[e])}}}planeConvex(e,t,n,i,r,s,o,a,l,c,u){const h=eu,d=tu;d.set(0,0,1),r.vmult(d,d);let p=0;const f=nu;for(let r=0;r!==t.vertices.length;r++)if(h.copy(t.vertices[r]),s.vmult(h,h),i.vadd(h,h),h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const r=this.createContactEquation(o,a,e,t,l,c),s=iu;d.scale(d.dot(f),s),h.vsub(s,s),s.vsub(n,r.ri),r.ni.copy(d),h.vsub(i,r.rj),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),r.rj.vadd(i,r.rj),r.rj.vsub(a.position,r.rj),this.result.push(r),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(r,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(e,t,n,i,r,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,i,r,s,o,a,e,t,u)}sphereHeightfield(e,t,n,i,r,s,o,a,l,c,u){const h=t.data,d=e.radius,p=t.elementSize,f=xu,m=yu;jo.pointToLocalFrame(i,s,n,m);let g=Math.floor((m.x-d)/p)-1,v=Math.ceil((m.x+d)/p)+1,y=Math.floor((m.y-d)/p)-1,x=Math.ceil((m.y+d)/p)+1;if(v<0||x<0||g>h.length||y>h[0].length)return;g<0&&(g=0),v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),g>=h.length&&(g=h.length-1),v>=h.length&&(v=h.length-1),x>=h[0].length&&(x=h[0].length-1),y>=h[0].length&&(y=h[0].length-1);const w=[];t.getRectMinMax(g,y,v,x,w);const b=w[0],_=w[1];if(m.z-d>_||m.z+d<b)return;const k=this.result;for(let l=g;l<v;l++)for(let c=y;c<x;c++){const h=k.length;let d=!1;if(t.getConvexTrianglePillar(l,c,!1),jo.pointToWorldFrame(i,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,r,s,o,a,e,t,u)),u&&d)return!0;if(t.getConvexTrianglePillar(l,c,!0),jo.pointToWorldFrame(i,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,r,s,o,a,e,t,u)),u&&d)return!0;if(k.length-h>2)return}}boxHeightfield(e,t,n,i,r,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,i,r,s,o,a,e,t,u)}convexHeightfield(e,t,n,i,r,s,o,a,l,c,u){const h=t.data,d=t.elementSize,p=e.boundingSphereRadius,f=gu,m=vu,g=mu;jo.pointToLocalFrame(i,s,n,g);let v=Math.floor((g.x-p)/d)-1,y=Math.ceil((g.x+p)/d)+1,x=Math.floor((g.y-p)/d)-1,w=Math.ceil((g.y+p)/d)+1;if(y<0||w<0||v>h.length||x>h[0].length)return;v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),w<0&&(w=0),v>=h.length&&(v=h.length-1),y>=h.length&&(y=h.length-1),w>=h[0].length&&(w=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const b=[];t.getRectMinMax(v,x,y,w,b);const _=b[0],k=b[1];if(!(g.z-p>k||g.z+p<_))for(let l=v;l<y;l++)for(let c=x;c<w;c++){let h=!1;if(t.getConvexTrianglePillar(l,c,!1),jo.pointToWorldFrame(i,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,r,s,o,a,null,null,u,m,null)),u&&h)return!0;if(t.getConvexTrianglePillar(l,c,!0),jo.pointToWorldFrame(i,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,r,s,o,a,null,null,u,m,null)),u&&h)return!0}}sphereParticle(e,t,n,i,r,s,o,a,l,c,u){const h=cu;if(h.set(0,0,1),i.vsub(n,h),h.lengthSquared()<=e.radius*e.radius){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);h.normalize(),n.rj.copy(h),n.rj.scale(e.radius,n.rj),n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}planeParticle(e,t,n,i,r,s,o,a,l,c,u){const h=ou;h.set(0,0,1),o.quaternion.vmult(h,h);const d=au;if(i.vsub(o.position,d),h.dot(d)<=0){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0);const r=lu;h.scale(h.dot(i),r),i.vsub(r,r),n.rj.copy(r),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}boxParticle(e,t,n,i,r,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,i,r,s,o,a,e,t,u)}convexParticle(e,t,n,i,r,s,o,a,l,c,u){let h=-1;const d=du,p=fu;let f=null;const m=hu;if(m.copy(i),m.vsub(n,m),r.conjugate(uu),uu.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,r),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(r);for(let t=0,n=e.faces.length;t!==n;t++){const n=[e.worldVertices[e.faces[t][0]]],r=e.worldFaceNormals[t];i.vsub(n[0],pu);const s=-r.dot(pu);if(null===f||Math.abs(s)<Math.abs(f)){if(u)return!0;f=s,h=t,d.copy(r)}}if(-1!==h){const r=this.createContactEquation(a,o,t,e,l,c);d.scale(f,p),p.vadd(i,p),p.vsub(n,p),r.rj.copy(p),d.negate(r.ni),r.ri.set(0,0,0);const s=r.ri,u=r.rj;s.vadd(i,s),s.vsub(a.position,s),u.vadd(n,u),u.vsub(o.position,u),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,i,r,s,o,a,l,c,u){return this.convexHeightfield(t,e,i,n,s,r,a,o,l,c,u)}particleCylinder(e,t,n,i,r,s,o,a,l,c,u){return this.convexParticle(t,e,i,n,s,r,a,o,l,c,u)}sphereTrimesh(e,t,n,i,r,s,o,a,l,c,u){const h=yc,d=xc,p=wc,f=bc,m=_c,g=kc,v=Tc,y=vc,x=mc,w=Pc;jo.pointToLocalFrame(i,s,n,m);const b=e.radius;v.lowerBound.set(m.x-b,m.y-b,m.z-b),v.upperBound.set(m.x+b,m.y+b,m.z+b),t.getTrianglesInAABB(v,w);const _=gc,k=e.radius*e.radius;for(let r=0;r<w.length;r++)for(let h=0;h<3;h++)if(t.getVertex(t.indices[3*w[r]+h],_),_.vsub(m,x),x.lengthSquared()<=k){if(y.copy(_),jo.pointToWorldFrame(i,s,y,_),_.vsub(n,x),u)return!0;let r=this.createContactEquation(o,a,e,t,l,c);r.ni.copy(x),r.ni.normalize(),r.ri.copy(r.ni),r.ri.scale(e.radius,r.ri),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),r.rj.copy(_),r.rj.vsub(a.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}for(let r=0;r<w.length;r++)for(let v=0;v<3;v++){t.getVertex(t.indices[3*w[r]+v],h),t.getVertex(t.indices[3*w[r]+(v+1)%3],d),d.vsub(h,p),m.vsub(d,g);const y=g.dot(p);m.vsub(h,g);let x=g.dot(p);if(x>0&&y<0&&(m.vsub(h,g),f.copy(p),f.normalize(),x=g.dot(f),f.scale(x,g),g.vadd(h,g),g.distanceTo(m)<e.radius)){if(u)return!0;const r=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,r.ni),r.ni.normalize(),r.ni.scale(e.radius,r.ri),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),jo.pointToWorldFrame(i,s,g,g),g.vsub(a.position,r.rj),jo.vectorToWorldFrame(s,r.ni,r.ni),jo.vectorToWorldFrame(s,r.ri,r.ri),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}const S=Sc,E=Ec,A=Ac,T=fc;for(let r=0,h=w.length;r!==h;r++){t.getTriangleVertices(w[r],S,E,A),t.getNormal(w[r],T),m.vsub(S,g);let h=g.dot(T);if(T.scale(h,g),m.vsub(g,g),h=g.distanceTo(m),Aa.pointInTriangle(g,S,E,A)&&h<e.radius){if(u)return!0;let r=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,r.ni),r.ni.normalize(),r.ni.scale(e.radius,r.ri),r.ri.vadd(n,r.ri),r.ri.vsub(o.position,r.ri),jo.pointToWorldFrame(i,s,g,g),g.vsub(a.position,r.rj),jo.vectorToWorldFrame(s,r.ni,r.ni),jo.vectorToWorldFrame(s,r.ri,r.ri),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}w.length=0}planeTrimesh(e,t,n,i,r,s,o,a,l,c,u){const h=new Mo,d=hc;d.set(0,0,1),r.vmult(d,d);for(let r=0;r<t.vertices.length/3;r++){t.getVertex(r,h);const p=new Mo;p.copy(h),jo.pointToWorldFrame(i,s,p,h);const f=dc;if(h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const n=this.createContactEquation(o,a,e,t,l,c);n.ni.copy(d);const i=pc;d.scale(f.dot(d),i),h.vsub(i,i),n.ri.copy(i),n.ri.vsub(o.position,n.ri),n.rj.copy(h),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}}const rc=new Mo,sc=new Mo,oc=new Mo,ac=new Mo,lc=new Mo,cc=new Do,uc=new Do,hc=new Mo,dc=new Mo,pc=new Mo,fc=new Mo,mc=new Mo;new Mo;const gc=new Mo,vc=new Mo,yc=new Mo,xc=new Mo,wc=new Mo,bc=new Mo,_c=new Mo,kc=new Mo,Sc=new Mo,Ec=new Mo,Ac=new Mo,Tc=new Bo,Pc=[],Mc=new Mo,zc=new Mo,Ic=new Mo,Cc=new Mo,Bc=new Mo;function Oc(e,t,n){let i=null;const r=e.length;for(let s=0;s!==r;s++){const o=e[s],a=Ic;e[(s+1)%r].vsub(o,a);const l=Cc;a.cross(t,l);const c=Bc;n.vsub(o,c);const u=l.dot(c);if(!(null===i||u>0&&!0===i||u<=0&&!1===i))return!1;null===i&&(i=u>0)}return!0}const Nc=new Mo,Rc=new Mo,Fc=new Mo,Dc=new Mo,Uc=[new Mo,new Mo,new Mo,new Mo,new Mo,new Mo],Lc=new Mo,qc=new Mo,jc=new Mo,Vc=new Mo,Gc=new Mo,$c=new Mo,Wc=new Mo,Hc=new Mo,Yc=new Mo,Xc=new Mo,Zc=new Mo,Kc=new Mo,Qc=new Mo,Jc=new Mo;new Mo,new Mo;const eu=new Mo,tu=new Mo,nu=new Mo,iu=new Mo,ru=new Mo,su=new Mo,ou=new Mo,au=new Mo,lu=new Mo,cu=new Mo,uu=new Do,hu=new Mo;new Mo;const du=new Mo,pu=new Mo,fu=new Mo,mu=new Mo,gu=new Mo,vu=[0],yu=new Mo,xu=new Mo;class wu{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),i=this.current;let r=0;for(;n>i[r];)r++;if(n!==i[r]){for(let e=i.length-1;e>=r;e--)i[e+1]=i[e];i[r]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,i=this.previous,r=n.length,s=i.length;let o=0;for(let t=0;t<r;t++){let r=!1;const s=n[t];for(;s>i[o];)o++;r=s===i[o],r||bu(e,s)}o=0;for(let e=0;e<s;e++){let r=!1;const s=i[e];for(;s>n[o];)o++;r=n[o]===s,r||bu(t,s)}}}function bu(e,t){e.push((4294901760&t)>>16,65535&t)}const _u=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class ku{constructor(){this.data={keys:[]}}get(e,t){const n=_u(e,t);return this.data[n]}set(e,t,n){const i=_u(e,t);this.get(e,t)||this.data.keys.push(i),this.data[i]=n}delete(e,t){const n=_u(e,t),i=this.data.keys.indexOf(n);-1!==i&&this.data.keys.splice(i,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;)delete e[t.pop()]}}class Su extends Fo{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new Mo,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new Mo,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new va,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new Al,this.constraints=[],this.narrowphase=new ic(this),this.collisionMatrix=new Ro,this.collisionMatrixPrevious=new Ro,this.bodyOverlapKeeper=new wu,this.shapeOverlapKeeper=new wu,this.contactmaterials=[],this.contactMaterialTable=new ku,this.defaultMaterial=new Sl("default"),this.defaultContactMaterial=new kl(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof ya?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,i){return void 0===n&&(n={}),n.mode=Aa.ALL,n.from=e,n.to=t,n.callback=i,Eu.intersectWorld(this,n)}raycastAny(e,t,n,i){return void 0===n&&(n={}),n.mode=Aa.ANY,n.from=e,n.to=t,n.result=i,Eu.intersectWorld(this,n)}raycastClosest(e,t,n,i){return void 0===n&&(n={}),n.mode=Aa.CLOSEST,n.from=e,n.to=t,n.result=i,Eu.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Qo&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,i=n.indexOf(e);if(-1!==i){n.splice(i,1);for(let e=0;e!==n.length;e++)n[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const i=t[n].shapes;for(let t=0;t<i.length;t++){const n=i[t];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const n=Au.now()/1e3;if(this.lastCallTime){const i=n-this.lastCallTime;this.step(e,i,t)}else this.step(e,void 0,t);this.lastCallTime=n}step(e,t,n){if(void 0===n&&(n=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const i=Au.now();let r=0;for(;this.accumulator>=e&&r<n&&(this.internalStep(e),this.accumulator-=e,r++,!(Au.now()-i>1e3*e)););this.accumulator=this.accumulator%e;const s=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,s,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,s,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=Cu,i=Bu,r=this.bodies.length,s=this.bodies,o=this.solver,a=this.gravity,l=this.doProfiling,c=this.profile,u=Qo.DYNAMIC;let h=-1/0;const d=this.constraints,p=Iu;a.length();const f=a.x,m=a.y,g=a.z;let v=0;for(l&&(h=Au.now()),v=0;v!==r;v++){const e=s[v];if(e.type===u){const t=e.force,n=e.mass;t.x+=n*f,t.y+=n*m,t.z+=n*g}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(h=Au.now()),n.length=0,i.length=0,this.broadphase.collisionPairs(this,n,i),l&&(c.broadphase=Au.now()-h);let y=d.length;for(v=0;v!==y;v++){const e=d[v];if(!e.collideConnected)for(let t=n.length-1;t>=0;t-=1)(e.bodyA===n[t]&&e.bodyB===i[t]||e.bodyB===n[t]&&e.bodyA===i[t])&&(n.splice(t,1),i.splice(t,1))}this.collisionMatrixTick(),l&&(h=Au.now());const x=zu,w=t.length;for(v=0;v!==w;v++)x.push(t[v]);t.length=0;const b=this.frictionEquations.length;for(v=0;v!==b;v++)p.push(this.frictionEquations[v]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,i,this,t,x,this.frictionEquations,p),l&&(c.narrowphase=Au.now()-h),l&&(h=Au.now()),v=0;v<this.frictionEquations.length;v++)o.addEquation(this.frictionEquations[v]);const _=t.length;for(let e=0;e!==_;e++){const n=t[e],i=n.bi,r=n.bj,s=n.si,a=n.sj;let l;l=i.material&&r.material&&this.getContactMaterial(i.material,r.material)||this.defaultContactMaterial,l.friction,i.material&&r.material&&(i.material.friction>=0&&r.material.friction>=0&&(i.material.friction,r.material.friction),i.material.restitution>=0&&r.material.restitution>=0&&(n.restitution=i.material.restitution*r.material.restitution)),o.addEquation(n),i.allowSleep&&i.type===Qo.DYNAMIC&&i.sleepState===Qo.SLEEPING&&r.sleepState===Qo.AWAKE&&r.type!==Qo.STATIC&&r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0),r.allowSleep&&r.type===Qo.DYNAMIC&&r.sleepState===Qo.SLEEPING&&i.sleepState===Qo.AWAKE&&i.type!==Qo.STATIC&&i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(i,r,!0),this.collisionMatrixPrevious.get(i,r)||(Mu.body=r,Mu.contact=n,i.dispatchEvent(Mu),Mu.body=i,r.dispatchEvent(Mu)),this.bodyOverlapKeeper.set(i.id,r.id),this.shapeOverlapKeeper.set(s.id,a.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=Au.now()-h,h=Au.now()),v=0;v!==r;v++){const e=s[v];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(y=d.length,v=0;v!==y;v++){const e=d[v];e.update();for(let t=0,n=e.equations.length;t!==n;t++){const n=e.equations[t];o.addEquation(n)}}o.solve(e,this),l&&(c.solve=Au.now()-h),o.removeAllEquations();const k=Math.pow;for(v=0;v!==r;v++){const t=s[v];if(t.type&u){const n=k(1-t.linearDamping,e),i=t.velocity;i.scale(n,i);const r=t.angularVelocity;if(r){const n=k(1-t.angularDamping,e);r.scale(n,r)}}}this.dispatchEvent(Pu),l&&(h=Au.now());const S=this.stepnumber%(this.quatNormalizeSkip+1)==0,E=this.quatNormalizeFast;for(v=0;v!==r;v++)s[v].integrate(e,S,E);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=Au.now()-h),this.stepnumber+=1,this.dispatchEvent(Tu);let A=!0;if(this.allowSleep)for(A=!1,v=0;v!==r;v++){const e=s[v];e.sleepTick(this.time),e.sleepState!==Qo.SLEEPING&&(A=!0)}this.hasActiveBodies=A}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(Ou,Nu),e){for(let e=0,t=Ou.length;e<t;e+=2)Ru.bodyA=this.getBodyById(Ou[e]),Ru.bodyB=this.getBodyById(Ou[e+1]),this.dispatchEvent(Ru);Ru.bodyA=Ru.bodyB=null}if(t){for(let e=0,t=Nu.length;e<t;e+=2)Fu.bodyA=this.getBodyById(Nu[e]),Fu.bodyB=this.getBodyById(Nu[e+1]),this.dispatchEvent(Fu);Fu.bodyA=Fu.bodyB=null}Ou.length=Nu.length=0;const n=this.hasAnyEventListener("beginShapeContact"),i=this.hasAnyEventListener("endShapeContact");if((n||i)&&this.shapeOverlapKeeper.getDiff(Ou,Nu),n){for(let e=0,t=Ou.length;e<t;e+=2){const t=this.getShapeById(Ou[e]),n=this.getShapeById(Ou[e+1]);Du.shapeA=t,Du.shapeB=n,t&&(Du.bodyA=t.body),n&&(Du.bodyB=n.body),this.dispatchEvent(Du)}Du.bodyA=Du.bodyB=Du.shapeA=Du.shapeB=null}if(i){for(let e=0,t=Nu.length;e<t;e+=2){const t=this.getShapeById(Nu[e]),n=this.getShapeById(Nu[e+1]);Uu.shapeA=t,Uu.shapeB=n,t&&(Uu.bodyA=t.body),n&&(Uu.bodyB=n.body),this.dispatchEvent(Uu)}Uu.bodyA=Uu.bodyB=Uu.shapeA=Uu.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const t=e[n];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new Bo;const Eu=new Aa,Au=globalThis.performance||{};if(!Au.now){let e=Date.now();Au.timing&&Au.timing.navigationStart&&(e=Au.timing.navigationStart),Au.now=()=>Date.now()-e}new Mo;const Tu={type:"postStep"},Pu={type:"preStep"},Mu={type:Qo.COLLIDE_EVENT_NAME,body:null,contact:null},zu=[],Iu=[],Cu=[],Bu=[],Ou=[],Nu=[],Ru={type:"beginContact",bodyA:null,bodyB:null},Fu={type:"endContact",bodyA:null,bodyB:null},Du={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Uu={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class Lu extends e{world=new Su({gravity:new Mo(0,-150,0)});constructor(){super()}}class qu extends e{speed=1;rotationSpeed=.025;player;constructor(e=0,t=1,n=.025){super(),this.player=e,this.speed=t,this.rotationSpeed=n}}class ju extends e{bodyId;halfExtents;options;constructor(e,t={}){super(),this.halfExtents=new Mo(e[0]/2,e[1]/2,e[2]/2),this.options=t}}class Vu extends e{chunkMap=new Map}var Gu=n(491);let $u=[];var Wu=n(590),Hu=n(284);const Yu=128,Xu=navigator.hardwareConcurrency||4,Zu=new class{lastTime=0;entities=new Map;systems=new Map;nextEntityID=0;entitiesToDestroy=new Array;addEntity(){let e=this.nextEntityID;return this.nextEntityID++,this.entities.set(e,new i),e}removeEntity(e){this.entitiesToDestroy.push(e)}addComponent(e,t){this.entities.get(e).add(t),this.checkE(e)}addComponents(e,...t){for(let n of t)this.addComponent(e,n)}getComponents(e){return this.entities.get(e)}removeComponent(e,t){this.entities.get(e).delete(t),this.checkE(e)}addSystem(e){if(0==e.componentsRequired.size)return console.warn("System not added: empty Components list."),void console.warn(e);e.ecs=this,this.systems.set(e,new Set);for(let t of this.entities.keys())this.checkES(t,e)}removeSystem(e){this.systems.delete(e)}update(e){let t=e-this.lastTime;for(let[n,i]of this.systems.entries())n.update(i,e,t);for(;this.entitiesToDestroy.length>0;)this.destroyEntity(this.entitiesToDestroy.pop());this.lastTime=e}destroyEntity(e){this.entities.delete(e);for(let t of this.systems.values())t.delete(e)}checkE(e){for(let t of this.systems.keys())this.checkES(e,t)}checkES(e,t){let n=this.entities.get(e),i=t.componentsRequired;n.hasAll(i)?this.systems.get(t).add(e):this.systems.get(t).delete(e)}getEntitiesithComponent(e){let t=new Set;for(let[n,i]of this.entities)i.has(e)&&t.add(n);return t}};Zu.addSystem(new class extends t{keyboardControls=new Eo;componentsRequired=new Set([Ur,Ao]);update(e,t,n){for(const t of e){const e=this.ecs.getComponents(t),i=e.get(Ur),r=e.get(Ao),s=r.speed*n,o=r.rotationSpeed*n;this.keyboardControls.pressed.a&&(i.position=ne.add(i.position,ne.mulScalar(i.left,s))),this.keyboardControls.pressed.d&&(i.position=ne.add(i.position,ne.mulScalar(i.right,s))),this.keyboardControls.pressed.w&&(i.position=ne.add(i.position,ne.mulScalar(i.direction,s))),this.keyboardControls.pressed.s&&(i.position=ne.sub(i.position,ne.mulScalar(i.direction,s))),this.keyboardControls.pressed.q&&(i.rotation=Ve.rotateY(i.rotation,-o)),this.keyboardControls.pressed.e&&(i.rotation=Ve.rotateY(i.rotation,o)),this.keyboardControls.pressed[" "]&&(i.position=ne.add(i.position,ne.mulScalar(i.up,s))),this.keyboardControls.pressed.shift&&(i.position=ne.add(i.position,ne.mulScalar(i.down,s)))}}}),Zu.addSystem(new class extends t{componentsRequired=new Set([Lr,Ur]);constructor(){super(),(async()=>{const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});let t;console.log(e);try{t=await e.requestDevice({requiredFeatures:["timestamp-query"],requiredLimits:{maxColorAttachmentBytesPerSample:64}})}catch(n){console.warn("Timestamp query or 64 byte colour attachment not supported, falling back"),t=await e.requestDevice()}return t})().then((async e=>{const t=new _o(e),n=So(this.ecs);n.device=e,n.volumeAtlas=t,co(e,t,this.ecs)}))}update(e,t){const n=this.ecs.getEntitiesithComponent(mo).values().next().value,i=this.ecs.getComponents(n),r=i.get(mo),s=i.get(Ur);fo(t,this.ecs,r,s,Array.from(e))}}),Zu.addSystem(new class extends t{componentsRequired=new Set([ju,Ur,qu]);update(e,t,n){const i=this.ecs.getEntitiesithComponent(Lu).values().next().value,r=this.ecs.getComponents(i).get(Lu).world;for(const t of e){const e=this.ecs.getComponents(t),i=e.get(ju),s=e.get(Ur),o=e.get(qu),a=navigator.getGamepads()[o.player];if(!a)return;const l=ne.mulScalar(s.right,a.axes[0]),c=ne.mulScalar(s.direction,-a.axes[1]),u=ne.add(l,c),h=ne.add(s.position,ne.mulScalar(u,o.speed)),d=r.getBodyById(i.bodyId);if(!d)continue;d.position.set(h[0],h[1],h[2]);const p=Ve.rotateY(s.rotation,o.rotationSpeed*a.axes[2]),f=a.buttons[0].pressed,m=a.buttons[1].pressed,g=.001*n;f&&(s.scale=ne.add(s.scale,ne.create(g,g,g))),m&&(s.scale=ne.sub(s.scale,ne.create(g,g,g))),r.getBodyById(i.bodyId).quaternion.set(p[0],p[1],p[2],p[3])}}}),Zu.addSystem(new class extends t{componentsRequired=new Set([Vu]);isInitialized=!1;update(e){So(this.ecs).device&&0!==e.size&&(this.ecs.getComponents(e.values().next().value).get(Vu),this.isInitialized||((async e=>{const t=So(e).volumeAtlas,i=Array.from({length:Math.floor(Xu)},(()=>new Worker(new URL(n.p+n.u(365),n.b)))),r=i.map((e=>(0,Wu.LV)(e)));let s=[];for(let e=-768;e<=768;e+=Yu)for(let t=-768;t<=768;t+=Yu)for(let n=Hu.yq-Yu;n>=0;n-=Yu)s.push([e,n,t]);const o=async([n,i,s],o)=>{const a=e.addEntity(),l=await(async(e,t,n,i,r)=>{const s=performance.now(),o=`Terrain - ${n[0]}, ${n[1]}, ${n[2]}`,a=(e=>{const t=Math.ceil(Math.log2(Math.max(...e)));let n=0;for(let e=0;e<t;e++)n+=1<<3*e;return n})(i)*Gu.ps;let l=new SharedArrayBuffer(a);const c=await r(n,i,l);if(c<=16)return;await e.addVolume(o,i,l,c),l=null;const{size:u,location:h,paletteIndex:d,octreeOffset:p}=e.dictionary[o],f=performance.now();return $u.push(f-s),console.log(`Average chunk creation time: ${($u.reduce(((e,t)=>e+t),0)/$u.length).toFixed(0)}`),new Lr({name:o,size:u,atlasLocation:h,paletteIndex:d,octreeBufferIndex:p})})(t,0,[n,i,s],[Yu,Yu,Yu],r[o].createOctreeAndReturnBytes);return l?(e.addComponent(a,new Lr(l)),e.addComponent(a,new Ur([n,i,s],Ve.fromEuler(0,0,0,"xyz"),[1,1,1])),o):o};let a=[];for(;s.length>0;){if(a.length<Xu){const[e,t,n]=s.shift(),i=a.length;a[i]=o([e,t,n],i);continue}const e=await Promise.race(a),[t,n,i]=s.shift();a[e]=o([t,n,i],e)}await Promise.all(a),i.forEach((e=>e.terminate()))})(this.ecs),this.isInitialized=!0))}});const Ku=Zu.addEntity();Zu.addComponent(Ku,new ko),Zu.addComponent(Ku,new Lu),Zu.addComponent(Ku,new Vu);const Qu=Zu.addEntity();Zu.addComponents(Qu,new mo({fieldOfView:Math.PI/180*70,near:.5,far:1e4}),new Ur(ne.create(0,384,-512),Ve.fromEuler(0,0,0,"xyz"),ne.create(1,1,1)),new Ao);const Ju=()=>{Zu.update(performance.now()),requestAnimationFrame(Ju)};Ju()})()})();