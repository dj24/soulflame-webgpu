(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};e.d({},{nS:()=>h,JQ:()=>d,sL:()=>y,Uh:()=>l,ZU:()=>f});const t=(e,t)=>{const r=new Uint32Array(t);l.queue.writeBuffer(e,0,r.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},r=(e,r)=>{const n=new Uint32Array(e),o=l.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:r});return t(o,e),o},n=(e,t)=>{const r=new Float32Array(e),n=l.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return((e,t)=>{const r=new Float32Array(t);l.queue.writeBuffer(e,0,r.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)})(n,e),n};class o{x;y;constructor(e,t){this.x=e,this.y=t}get uniformBuffer(){return r([this.x,this.y])}static zero=new o(0,0);static one=new o(1,1);static up=new o(0,1);static down=new o(0,-1);static left=new o(-1,0);static right=new o(1,1);toArray(){return[this.x,this.y]}mul(e){if(e instanceof o)return new o(this.x*e.x,this.y*e.y);if("number"==typeof e)return new o(this.x*e,this.y*e);throw new Error("Can only multiply Vector2 by Vector2 or Number")}add(e){return new o(this.x+e.x,this.y+e.y)}subtract(e){return new o(this.x-e.x,this.y-e.y)}normalize(){const e=Math.sqrt(this.x**2+this.y**2);return new o(this.x/e,this.y/e)}negate(){return new o(-this.x,-this.y)}}class i{x;y;z;constructor(e,t,r){this.x=e,this.y=t,this.z=r}get uniformBuffer(){return r([this.x,this.y,this.z])}static zero=new i(0,0,0);static one=new i(1,1,1);static up=new i(0,1,0);static down=new i(0,-1,0);static left=new i(-1,0,0);static right=new i(1,0,0);toArray(){return[this.x,this.y,this.z]}toString(){return`Vector3(${this.x.toFixed(2)},${this.y.toFixed(2)},${this.z.toFixed(2)})`}mul(e){if(e instanceof i)return new i(this.x*e.x,this.y*e.y,this.z*e.z);if("number"==typeof e)return new i(this.x*e,this.y*e,this.z*e);throw new Error("Can only multiply Vector3 by Vector3 or Number")}add(e){return new i(this.x+e.x,this.y+e.y,this.z+e.z)}subtract(e){return new i(this.x-e.x,this.y-e.y,this.z-e.z)}cross(e){return new i(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}normalize(){const e=Math.sqrt(this.x**2+this.y**2+this.z**2);return new i(0!==this.x?this.x/e:0,0!==this.y?this.y/e:0,0!==this.z?this.z/e:0)}negate(){return new i(-this.x,-this.y,-this.z)}rotateAroundAxis(e,t){const r=Math.cos(t),n=Math.sin(t),o=this.x*(r+(1-r)*e.x*e.x)+this.y*((1-r)*e.x*e.y-n*e.z)+this.z*((1-r)*e.x*e.z+n*e.y),s=this.x*((1-r)*e.y*e.x+n*e.z)+this.y*(r+(1-r)*e.y*e.y)+this.z*((1-r)*e.y*e.z-n*e.x),a=this.x*((1-r)*e.z*e.x-n*e.y)+this.y*((1-r)*e.z*e.y+n*e.x)+this.z*(r+(1-r)*e.z*e.z);return new i(o,s,a)}}class s{position;targetPosition;velocity;constructor(e){this.position=e.position,this.targetPosition=this.position,this.velocity=i.zero}update(){h.velocity=h.velocity.mul(1-.015*y),this.position=this.position.add(this.velocity.mul(y))}}const a=new class{pressed={w:!1,a:!1,s:!1,d:!1," ":!1,Control:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1}))}},c=new class{velocity=o.zero;animationFrame;constructor(){window.addEventListener("mousemove",(e=>{cancelAnimationFrame(this.animationFrame),this.velocity=new o(e.movementX,e.movementY),this.animationFrame=requestAnimationFrame((()=>{this.velocity=o.zero}))}))}};let l,u,d,f=new o(0,0),m=1;const x=performance.now();let v=x,y=0,h=new class extends s{fieldOfView;direction;constructor(e){super({position:e.position}),this.fieldOfView=e.fieldOfView,this.direction=e.direction}reset(e){this.position=new i(16,16,-16),this.targetPosition=this.position,this.fieldOfView=e.fieldOfView,this.direction=new i(0,0,1)}get right(){return i.up.cross(this.direction).normalize()}get left(){return this.direction.cross(i.up).normalize()}get up(){return this.direction.cross(this.right).normalize()}get down(){return this.up.negate()}rotateX(e){this.direction=this.direction.rotateAroundAxis(this.right,e)}rotateY(e){this.direction=this.direction.rotateAroundAxis(i.up,e)}}({fieldOfView:82.5,position:new i(120,120,120),direction:new i(-1,-1,-1).normalize()});const p=new class{logElement;constructor(){document.getElementById("reset").addEventListener("click",(e=>{h.reset({fieldOfView:90}),document.getElementById("captures").innerHTML=""})),document.getElementById("capture").addEventListener("click",(e=>{const t=new Image;t.id=performance.now().toString(),t.src=d.toDataURL(),document.getElementById("captures").appendChild(t).addEventListener("click",(e=>{e.target,console.log(e.target)}))})),document.getElementById("downscale").addEventListener("input",(e=>{const t=e.target;window.dispatchEvent(new CustomEvent("changeDownscale",{detail:t.value})),t.parentElement.getElementsByTagName("label")[0].innerText=`Downscale: ${parseFloat(t.value).toFixed(1)}`})),document.getElementById("fov").addEventListener("input",(e=>{const t=e.target;window.dispatchEvent(new CustomEvent("changeFov",{detail:t.value})),t.parentElement.getElementsByTagName("label")[0].innerText=`FOV: ${parseFloat(t.value).toFixed(1)}`})),this.logElement=document.getElementById("log")}log(e){this.logElement.innerText=e}};let g;window.addEventListener("changeFov",(e=>{h.fieldOfView=e.detail}));void 0!==navigator.gpu?navigator.gpu.requestAdapter().then((e=>{e.requestDevice().then((e=>{l=e;const s=(()=>{let e;return{start:()=>{e=l.createComputePipeline({layout:"auto",compute:{module:l.createShaderModule({code:"\n          // Function to mimic the ease_out_expo function\r\nfn ease_out_expo(x: f32) -> f32 {\r\n    let t: f32 = x;\r\n    let b: f32 = 0.0;\r\n    let c: f32 = 1.0;\r\n    let d: f32 = 1.0; // Set the duration within the function\r\n\r\n    let intermediate_result: f32 = c * (-pow(2.0, -10.0 * t / d) + 1.0) + b;\r\n\r\n    return select(intermediate_result, b + c, t == d);\r\n\r\n}\r\n\r\nfn sample_sky(rayDirection: vec3<f32>) -> vec3<f32> {\r\n    //TODO: add this to uniforms\r\n    let lightDirection = normalize(vec3(1.0,1.0,0.));\r\n    let y = clamp(ease_out_expo(rayDirection.y * 0.66), 0.0, 1.0);\r\n//    let y = rayDirection.y;\r\n    let sunHeight = clamp(lightDirection.y, 0.0, 1.0);\r\n    let horizon = mix(vec3<f32>(0.95, 0.5, 0.4), vec3<f32>(0.6, 0.8, 1.0), sunHeight);\r\n    let sky = mix(vec3<f32>(0.55, 0.7, 0.7), vec3<f32>(0.3, 0.6, 0.95), sunHeight);\r\n    let sunFalloff = 0.8;\r\n    let sunAmount = 1.0 - ease_out_expo(length(lightDirection - rayDirection) * sunFalloff);\r\n//    let sunAmount = 1.0 - length(lightDirection - rayDirection) * sunFalloff;\r\n    let skyColour = mix(horizon, sky, y);\r\n    let sunColour = mix(vec3<f32>(1.8, 1.6, 1.1), vec3<f32>(1.6, 1.6, 1.4), sunHeight);\r\n\r\n    let intensity = clamp(sunHeight, 0.75, 1.0);\r\n    return mix(skyColour, sunColour, clamp(sunAmount, 0.0, 1.0)) * intensity;\r\n}struct FrustumCornerDirections {\r\n  topLeft : vec3<f32>,\r\n  topRight : vec3<f32>,\r\n  bottomLeft : vec3<f32>,\r\n  bottomRight : vec3<f32>\r\n}\r\n\r\nfn calculateRayDirection(uv: vec2<f32>, directions: FrustumCornerDirections) -> vec3<f32> {\r\n  let topInterpolated = mix(directions.topLeft, directions.topRight, uv.x);\r\n  let bottomInterpolated = mix(directions.bottomLeft, directions.bottomRight, uv.x);\r\n  let finalInterpolated = mix(bottomInterpolated, topInterpolated, uv.y);\r\n  return normalize(finalInterpolated);\r\n}\r\n\r\nfn plainIntersect(ro: vec3<f32>, rd: vec3<f32>, p: vec4<f32>) -> f32 {\r\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\r\n}\r\n\r\nstruct BoxIntersectionResult {\r\n    tNear: f32,\r\n    tFar: f32,\r\n    normal: vec3<f32>,\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n\r\n    if (tN > tF || tF < 0.0) {\r\n        result.tNear = -1.0;\r\n        result.tFar = -1.0;\r\n        result.normal = vec3(0.0);\r\n\r\n        return result;\r\n    }\r\n\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n\r\n    normal *= -sign(rd);\r\n\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        result.tNear = -1.0;\r\n        result.tFar = -1.0;\r\n        result.normal = vec3(0.0);\r\n        return result;\r\n    }\r\n\r\n\r\n\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n\r\n    return result;\r\n}\r\n\r\n@group(0) @binding(0) var outputTex : texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> time : u32;\r\n@group(0) @binding(2) var<uniform> resolution : vec2<u32>;\r\n@group(0) @binding(3) var<uniform> frustumCornerDirections : FrustumCornerDirections;\r\n@group(0) @binding(4) var<uniform> cameraPosition : vec3<f32>;\r\n\r\nconst EPSILON = 0.0001;\r\nconst BORDER_WIDTH = 0.05;\r\nconst BOUNDS_SIZE = 64.0;\r\nconst MAX_RAY_STEPS = 256;\r\n\r\nfn addVoxelBorderColour(baseColour: vec3<f32>, worldPos: vec3<f32>) -> vec3<f32> {\r\n  let positionInVoxel = fract(worldPos);\r\n  let voxelBorder = step(positionInVoxel, vec3(1 - BORDER_WIDTH)) - step(positionInVoxel, vec3(BORDER_WIDTH));\r\n  let isVoxelBorder = step(length(voxelBorder), 1.0);\r\n  return mix(baseColour,baseColour * 0.8,isVoxelBorder);\r\n}\r\n\r\nfn addBoundsBorderColour(baseColour: vec3<f32>, worldPos: vec3<f32>) -> vec3<f32> {\r\n  let positionInBounds = fract(worldPos / BOUNDS_SIZE);\r\n  let boundsBorderWidth = BORDER_WIDTH / BOUNDS_SIZE * 4.0;\r\n  let boundsBorder = step(positionInBounds, vec3(1 - boundsBorderWidth)) - step(positionInBounds, vec3(boundsBorderWidth));\r\n  let isBoundsBorder = step(length(boundsBorder), 1.0);\r\n  return mix(baseColour,vec3(1.0,0.0,1.0),isBoundsBorder);\r\n}\r\n\r\nfn sampleVoxel(position: vec3<f32>) -> bool {\r\n  let layer1 = (sin(position.x * 0.25) - sin(position.z * 0.25)) * 2;\r\n  let layer2 = (sin(position.x * 0.125) - sin(position.z * 0.125)) * 4;\r\n  let isSolidVoxel = layer1 + layer2 > (position.y - 32);\r\n  return isSolidVoxel;\r\n}\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  var voxelSize = 1.0;\r\n  let pixel = vec2<f32>(f32(GlobalInvocationID.x), f32(resolution.y - GlobalInvocationID.y));\r\n  let uv = pixel / vec2<f32>(resolution);\r\n  var rayOrigin = cameraPosition;\r\n  var rayDirection = calculateRayDirection(uv,frustumCornerDirections);\r\n  var boxSize = vec3<f32>(BOUNDS_SIZE);\r\n  var colour = sample_sky(rayDirection);\r\n  let plainIntersection = plainIntersect(rayOrigin, rayDirection, vec4<f32>(0.0, 1.0, 0.0, 0.0));\r\n  if(plainIntersection > 0.0){\r\n    let worldPos = plainIntersection * rayDirection + rayOrigin;\r\n    var borderColour = addVoxelBorderColour(colour, worldPos * 0.25);\r\n    colour = borderColour;\r\n  }\r\n  let objectCenter = vec3<f32>(BOUNDS_SIZE / 2.0);\r\n\r\n  // Initialize the object transformation matrix as the translation matrix\r\n  var objectTransformMatrix: mat4x4<f32> = mat4x4<f32>(\r\n      vec4<f32>(1.0, 0.0, 0.0, 0.0),\r\n      vec4<f32>(0.0, 1.0, 0.0, 0.0),\r\n      vec4<f32>(0.0, 0.0, 1.0, 0.0),\r\n      vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n  );\r\n\r\n  // Rotate the object around its center based on time\r\n  let rotationAngle: f32 = f32(time) * 0.0005;\r\n  let rotationMatrix: mat4x4<f32> = mat4x4<f32>(\r\n      vec4<f32>(cos(rotationAngle), 0.0, sin(rotationAngle), 0.0),\r\n      vec4<f32>(0.0, 1.0, 0.0, 0.0),\r\n      vec4<f32>(-sin(rotationAngle), 0.0, cos(rotationAngle), 0.0),\r\n      vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n  );\r\n\r\n  // Create a translation matrix based on the new position\r\n  let translateMatrix: mat4x4<f32> = mat4x4<f32>(\r\n      vec4<f32>(1.0, 0.0, 0.0, 20.0),\r\n      vec4<f32>(0.0, 1.0, 0.0, 0.0),\r\n      vec4<f32>(0.0, 0.0, 1.0, 0.0),\r\n      vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n  );\r\n\r\n  // Add a scale transformation\r\n  let scaleX = 1.0 + (sin(f32(time) * 0.002) * 0.5 + 0.5) * 0.33;\r\n  let scale = vec3(scaleX, 1.0, 1.0);\r\n  let scaleMatrix: mat4x4<f32> = mat4x4<f32>(\r\n      vec4<f32>(scale.x, 0.0, 0.0, 0.0),  // Scale factor along the x-axis\r\n      vec4<f32>(0.0, scale.y, 0.0, 0.0),  // No scaling along the y-axis\r\n      vec4<f32>(0.0, 0.0, scale.z, 0.0),  // Scale factor along the z-axis\r\n      vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n  );\r\n\r\n  objectTransformMatrix =  translateMatrix * scaleMatrix * objectTransformMatrix;\r\n\r\n  // Transform the ray using the combined matrix\r\n  rayOrigin = (objectTransformMatrix * vec4<f32>(rayOrigin, 1.0)).xyz;\r\n  //  rayOrigin = rayOrigin + translationVector;\r\n  rayDirection = (objectTransformMatrix * vec4<f32>(rayDirection, 0.0)).xyz;\r\n\r\n  let intersect = boxIntersection(rayOrigin, rayDirection, boxSize * 0.5);\r\n\r\n  let tNear = intersect.tNear;\r\n  let boundingBoxSurfacePosition = rayOrigin + (tNear + EPSILON)  * rayDirection;\r\n  let isStartingInBounds = all(boundingBoxSurfacePosition > vec3(0.0)) && all(boundingBoxSurfacePosition < vec3(BOUNDS_SIZE / voxelSize));\r\n  if(tNear > 0.0 || isStartingInBounds){\r\n    var pos = boundingBoxSurfacePosition;\r\n    var normal = vec3(0.0);\r\n    var stepsTaken = 0;\r\n    var voxelStep = sign(rayDirection);\r\n    var tIntersection = 0.0;\r\n    var tDelta = vec3(voxelSize / abs(rayDirection));\r\n    var scaledStartingPoint = pos / voxelSize;\r\n    var scaledRayOrigin = vec3<f32>(rayOrigin) / voxelSize;\r\n    var currentIndex = floor(scaledStartingPoint);\r\n    var voxelOriginDifference = vec3<f32>(currentIndex) - scaledRayOrigin;\r\n    var clampedVoxelBoundary = (voxelStep * 0.5) + 0.5; // 0 if <= 0, 1 if > 0\r\n    var tMax = (voxelStep * voxelOriginDifference + clampedVoxelBoundary) * tDelta + EPSILON;\r\n    var occlusion = false;\r\n\r\n    while(stepsTaken <= MAX_RAY_STEPS)\r\n    {\r\n      tIntersection = min(min(tMax.x, tMax.y), tMax.z);\r\n      let mask = vec3(\r\n          select(0.0, 1.0, tMax.x == tIntersection),\r\n          select(0.0, 1.0, tMax.y == tIntersection),\r\n          select(0.0, 1.0, tMax.z == tIntersection)\r\n      );\r\n      tMax += mask * tDelta;\r\n      currentIndex += mask * voxelStep;\r\n      normal = vec3(mask * -voxelStep);\r\n      pos = rayOrigin + rayDirection * tIntersection;\r\n      stepsTaken ++;\r\n      let isInBounds = all(currentIndex > vec3(0.0)) && all(currentIndex < vec3(BOUNDS_SIZE / voxelSize));\r\n      if(!isInBounds){\r\n          break;\r\n      }\r\n      if(sampleVoxel(currentIndex)){\r\n          occlusion = true;\r\n          break;\r\n      }\r\n    }\r\n\r\n//    if(occlusion){\r\n      colour = normal;\r\n      colour = addVoxelBorderColour(colour, pos);\r\n//    }\r\n    colour = addBoundsBorderColour(colour, boundingBoxSurfacePosition);\r\n\r\n  }\r\n  textureStore(outputTex, GlobalInvocationID.xy, vec4(colour,1));\r\n}\r\n"}),entryPoint:"main"}})},render:({commandEncoder:t,timeBuffer:r,resolutionBuffer:o,outputTextureView:s})=>{const a=(e=>{const t=f.x/f.y,r=e.fieldOfView/2,n=Math.tan(r),o=i.up.cross(e.direction).normalize(),s=e.direction.cross(o).normalize().mul(n);return[e.direction.add(s).add(o.mul(-t*n)),e.direction.add(s).add(o.mul(t*n)),e.direction.subtract(s).add(o.mul(-t*n)),e.direction.subtract(s).add(o.mul(t*n))]})(h).flatMap((e=>[...e.toArray(),0])),c=n(a,"frustum corner directions"),u=n(h.position.toArray(),"camera position"),d=t.beginComputePass();d.setPipeline(e);const m=l.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:s},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:c}},{binding:4,resource:{buffer:u}}]});d.setBindGroup(0,m),d.dispatchWorkgroups(Math.ceil(f.x/8),Math.ceil(f.y/8)),d.end()}}})();((e,n)=>{let s,l,w,b,B,z,I;d=document.getElementById("webgpu-canvas"),d.addEventListener("click",(async()=>{d.requestPointerLock()})),document.addEventListener("pointerlockchange",(()=>{z=null!==document.pointerLockElement})),u=d.getContext("webgpu");const E=navigator.gpu.getPreferredCanvasFormat();u.configure({device:e,format:E,usage:GPUTextureUsage.RENDER_ATTACHMENT});const S=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n//    return vec4(sin(f32(time) * 0.001), 0, 0, 1);\r\n    return textureSample(myTexture, mySampler, fragUV);\r\n}\r\n"}),D=e.createRenderPipeline({layout:"auto",vertex:{module:S,entryPoint:"vertex_main"},fragment:{module:S,entryPoint:"fragment_main",targets:[{format:E}]}}),O=()=>{cancelAnimationFrame(w),P()},P=()=>{const{clientWidth:e,clientHeight:t}=d.parentElement;f=new o(e*window.devicePixelRatio,t*window.devicePixelRatio),I=f.mul(1/m),d.width=f.x,d.height=f.y,d.style.transform=`scale(${1/window.devicePixelRatio})`,n.forEach((e=>{e.start()})),w=requestAnimationFrame(T)},T=async()=>{const o=performance.now()-x;y=o-v,v=o,z&&(()=>{if(h.rotateY(.001*c.velocity.x),h.rotateX(.001*c.velocity.y),!document.hasFocus())return;let e=i.zero;a.pressed.a&&(e=e.add(h.left)),a.pressed.d&&(e=e.add(h.right)),a.pressed.w&&(e=e.add(h.direction)),a.pressed.s&&(e=e.subtract(h.direction)),a.pressed[" "]&&(e=e.add(h.up)),a.pressed.Control&&(e=e.add(h.down)),e=e.normalize(),h.velocity=h.velocity.add(e.mul(.01))})(),h.update(),p.log(`Position: ${h.position.toString()}\n    Resolution: ${I.x.toFixed(0)}x${I.y.toFixed(0)}\n    FPS: ${(1e3/y).toFixed(1)}\n    `);const d=e.createCommandEncoder();b?t(b,[v]):b=r([v]),B?t(B,[I.x,I.y]):B=r([I.x,I.y]);const f=(l&&l.destroy(),l=e.createTexture({size:[I.x,I.y,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING}),l.createView());n.forEach((e=>{e.render({commandEncoder:d,timeBuffer:b,resolutionBuffer:B,outputTextureView:f})})),(({commandEncoder:t,outputTextureView:r})=>{const n=t.beginRenderPass({colorAttachments:[{view:u.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]});s=e.createBindGroup({layout:D.getBindGroupLayout(0),entries:[{binding:0,resource:e.createSampler({magFilter:"linear",minFilter:"linear"})},{binding:1,resource:r}]}),n.setPipeline(D),n.setBindGroup(0,s),n.draw(6),n.end()})({commandEncoder:d,outputTextureView:f}),e.queue.submit([d.finish()]),w=requestAnimationFrame(T)},V=new ResizeObserver(O);g=e=>{m=e.detail,O()},window.addEventListener("changeDownscale",g),V.observe(d.parentElement)})(l,[s])}))})):console.error("WebGPU not supported")})();