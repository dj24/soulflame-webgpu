(()=>{"use strict";class e{}class t{ecs}class r{map=new Map;add(e){this.map.set(e.constructor,e)}get(e){return this.map.get(e)}has(e){return this.map.has(e)}hasAll(e){for(let t of e)if(!this.map.has(t))return!1;return!0}delete(e){this.map.delete(e)}}let n=1e-6,i=Float32Array;function s(e=0,t=0){const r=new i(2);return void 0!==e&&(r[0]=e,void 0!==t&&(r[1]=t)),r}let o=Float32Array;function a(e,t,r){const n=new o(3);return void 0!==e&&(n[0]=e,void 0!==t&&(n[1]=t,void 0!==r&&(n[2]=r))),n}const c=s;function l(e,t,r){return(r=r||new i(2))[0]=e[0]-t[0],r[1]=e[1]-t[1],r}const u=l;function h(e,t,r){return(r=r||new i(2))[0]=e[0]*t,r[1]=e[1]*t,r}const d=h;function f(e,t){return(t=t||new i(2))[0]=1/e[0],t[1]=1/e[1],t}const p=f;function m(e,t){return e[0]*t[0]+e[1]*t[1]}function v(e){const t=e[0],r=e[1];return Math.sqrt(t*t+r*r)}const g=v;function y(e){const t=e[0],r=e[1];return t*t+r*r}const x=y;function b(e,t){const r=e[0]-t[0],n=e[1]-t[1];return Math.sqrt(r*r+n*n)}const w=b;function _(e,t){const r=e[0]-t[0],n=e[1]-t[1];return r*r+n*n}const T=_;function S(e,t){return(t=t||new i(2))[0]=e[0],t[1]=e[1],t}const P=S;function k(e,t,r){return(r=r||new i(2))[0]=e[0]*t[0],r[1]=e[1]*t[1],r}const E=k;function M(e,t,r){return(r=r||new i(2))[0]=e[0]/t[0],r[1]=e[1]/t[1],r}const A=M;var C=Object.freeze({__proto__:null,create:s,setDefaultType:function(e){const t=i;return i=e,t},fromValues:c,set:function(e,t,r){return(r=r||new i(2))[0]=e,r[1]=t,r},ceil:function(e,t){return(t=t||new i(2))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},floor:function(e,t){return(t=t||new i(2))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},round:function(e,t){return(t=t||new i(2))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},clamp:function(e,t=0,r=1,n){return(n=n||new i(2))[0]=Math.min(r,Math.max(t,e[0])),n[1]=Math.min(r,Math.max(t,e[1])),n},add:function(e,t,r){return(r=r||new i(2))[0]=e[0]+t[0],r[1]=e[1]+t[1],r},addScaled:function(e,t,r,n){return(n=n||new i(2))[0]=e[0]+t[0]*r,n[1]=e[1]+t[1]*r,n},angle:function(e,t){const r=e[0],n=e[1],i=e[0],s=e[1],o=Math.sqrt(r*r+n*n)*Math.sqrt(i*i+s*s),a=o&&m(e,t)/o;return Math.acos(a)},subtract:l,sub:u,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<n&&Math.abs(e[1]-t[1])<n},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:function(e,t,r,n){return(n=n||new i(2))[0]=e[0]+r*(t[0]-e[0]),n[1]=e[1]+r*(t[1]-e[1]),n},lerpV:function(e,t,r,n){return(n=n||new i(2))[0]=e[0]+r[0]*(t[0]-e[0]),n[1]=e[1]+r[1]*(t[1]-e[1]),n},max:function(e,t,r){return(r=r||new i(2))[0]=Math.max(e[0],t[0]),r[1]=Math.max(e[1],t[1]),r},min:function(e,t,r){return(r=r||new i(2))[0]=Math.min(e[0],t[0]),r[1]=Math.min(e[1],t[1]),r},mulScalar:h,scale:d,divScalar:function(e,t,r){return(r=r||new i(2))[0]=e[0]/t,r[1]=e[1]/t,r},inverse:f,invert:p,cross:function(e,t,r){r=r||new o(3);const n=e[0]*t[1]-e[1]*t[0];return r[0]=0,r[1]=0,r[2]=n,r},dot:m,length:v,len:g,lengthSq:y,lenSq:x,distance:b,dist:w,distanceSq:_,distSq:T,normalize:function(e,t){t=t||new i(2);const r=e[0],n=e[1],s=Math.sqrt(r*r+n*n);return s>1e-5?(t[0]=r/s,t[1]=n/s):(t[0]=0,t[1]=0),t},negate:function(e,t){return(t=t||new i(2))[0]=-e[0],t[1]=-e[1],t},copy:S,clone:P,multiply:k,mul:E,divide:M,div:A,random:function(e=1,t){t=t||new i(2);const r=2*Math.random()*Math.PI;return t[0]=Math.cos(r)*e,t[1]=Math.sin(r)*e,t},zero:function(e){return(e=e||new i(2))[0]=0,e[1]=0,e},transformMat4:function(e,t,r){r=r||new i(2);const n=e[0],s=e[1];return r[0]=n*t[0]+s*t[4]+t[12],r[1]=n*t[1]+s*t[5]+t[13],r},transformMat3:function(e,t,r){r=r||new i(2);const n=e[0],s=e[1];return r[0]=t[0]*n+t[4]*s+t[8],r[1]=t[1]*n+t[5]*s+t[9],r}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);const I=a;function z(e,t,r){return(r=r||new o(3))[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}const O=z;function R(e,t,r){return(r=r||new o(3))[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r}const B=R;function U(e,t){return(t=t||new o(3))[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}const N=U;function D(e,t,r){r=r||new o(3);const n=e[2]*t[0]-e[0]*t[2],i=e[0]*t[1]-e[1]*t[0];return r[0]=e[1]*t[2]-e[2]*t[1],r[1]=n,r[2]=i,r}function L(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function j(e){const t=e[0],r=e[1],n=e[2];return Math.sqrt(t*t+r*r+n*n)}const F=j;function G(e){const t=e[0],r=e[1],n=e[2];return t*t+r*r+n*n}const q=G;function V(e,t){const r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2];return Math.sqrt(r*r+n*n+i*i)}const W=V;function Y(e,t){const r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2];return r*r+n*n+i*i}const H=Y;function $(e,t){t=t||new o(3);const r=e[0],n=e[1],i=e[2],s=Math.sqrt(r*r+n*n+i*i);return s>1e-5?(t[0]=r/s,t[1]=n/s,t[2]=i/s):(t[0]=0,t[1]=0,t[2]=0),t}function X(e,t){return(t=t||new o(3))[0]=e[0],t[1]=e[1],t[2]=e[2],t}const Z=X;function K(e,t,r){return(r=r||new o(3))[0]=e[0]*t[0],r[1]=e[1]*t[1],r[2]=e[2]*t[2],r}const Q=K;function J(e,t,r){return(r=r||new o(3))[0]=e[0]/t[0],r[1]=e[1]/t[1],r[2]=e[2]/t[2],r}const ee=J;var te=Object.freeze({__proto__:null,create:a,setDefaultType:function(e){const t=o;return o=e,t},fromValues:I,set:function(e,t,r,n){return(n=n||new o(3))[0]=e,n[1]=t,n[2]=r,n},ceil:function(e,t){return(t=t||new o(3))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},floor:function(e,t){return(t=t||new o(3))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},round:function(e,t){return(t=t||new o(3))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},clamp:function(e,t=0,r=1,n){return(n=n||new o(3))[0]=Math.min(r,Math.max(t,e[0])),n[1]=Math.min(r,Math.max(t,e[1])),n[2]=Math.min(r,Math.max(t,e[2])),n},add:function(e,t,r){return(r=r||new o(3))[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r},addScaled:function(e,t,r,n){return(n=n||new o(3))[0]=e[0]+t[0]*r,n[1]=e[1]+t[1]*r,n[2]=e[2]+t[2]*r,n},angle:function(e,t){const r=e[0],n=e[1],i=e[2],s=e[0],o=e[1],a=e[2],c=Math.sqrt(r*r+n*n+i*i)*Math.sqrt(s*s+o*o+a*a),l=c&&L(e,t)/c;return Math.acos(l)},subtract:z,sub:O,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<n&&Math.abs(e[1]-t[1])<n&&Math.abs(e[2]-t[2])<n},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:function(e,t,r,n){return(n=n||new o(3))[0]=e[0]+r*(t[0]-e[0]),n[1]=e[1]+r*(t[1]-e[1]),n[2]=e[2]+r*(t[2]-e[2]),n},lerpV:function(e,t,r,n){return(n=n||new o(3))[0]=e[0]+r[0]*(t[0]-e[0]),n[1]=e[1]+r[1]*(t[1]-e[1]),n[2]=e[2]+r[2]*(t[2]-e[2]),n},max:function(e,t,r){return(r=r||new o(3))[0]=Math.max(e[0],t[0]),r[1]=Math.max(e[1],t[1]),r[2]=Math.max(e[2],t[2]),r},min:function(e,t,r){return(r=r||new o(3))[0]=Math.min(e[0],t[0]),r[1]=Math.min(e[1],t[1]),r[2]=Math.min(e[2],t[2]),r},mulScalar:R,scale:B,divScalar:function(e,t,r){return(r=r||new o(3))[0]=e[0]/t,r[1]=e[1]/t,r[2]=e[2]/t,r},inverse:U,invert:N,cross:D,dot:L,length:j,len:F,lengthSq:G,lenSq:q,distance:V,dist:W,distanceSq:Y,distSq:H,normalize:$,negate:function(e,t){return(t=t||new o(3))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},copy:X,clone:Z,multiply:K,mul:Q,divide:J,div:ee,random:function(e=1,t){t=t||new o(3);const r=2*Math.random()*Math.PI,n=2*Math.random()-1,i=Math.sqrt(1-n*n)*e;return t[0]=Math.cos(r)*i,t[1]=Math.sin(r)*i,t[2]=n*e,t},zero:function(e){return(e=e||new o(3))[0]=0,e[1]=0,e[2]=0,e},transformMat4:function(e,t,r){r=r||new o(3);const n=e[0],i=e[1],s=e[2],a=t[3]*n+t[7]*i+t[11]*s+t[15]||1;return r[0]=(t[0]*n+t[4]*i+t[8]*s+t[12])/a,r[1]=(t[1]*n+t[5]*i+t[9]*s+t[13])/a,r[2]=(t[2]*n+t[6]*i+t[10]*s+t[14])/a,r},transformMat4Upper3x3:function(e,t,r){r=r||new o(3);const n=e[0],i=e[1],s=e[2];return r[0]=n*t[0]+i*t[4]+s*t[8],r[1]=n*t[1]+i*t[5]+s*t[9],r[2]=n*t[2]+i*t[6]+s*t[10],r},transformMat3:function(e,t,r){r=r||new o(3);const n=e[0],i=e[1],s=e[2];return r[0]=n*t[0]+i*t[4]+s*t[8],r[1]=n*t[1]+i*t[5]+s*t[9],r[2]=n*t[2]+i*t[6]+s*t[10],r},transformQuat:function(e,t,r){r=r||new o(3);const n=t[0],i=t[1],s=t[2],a=2*t[3],c=e[0],l=e[1],u=e[2],h=i*u-s*l,d=s*c-n*u,f=n*l-i*c;return r[0]=c+h*a+2*(i*f-s*d),r[1]=l+d*a+2*(s*h-n*f),r[2]=u+f*a+2*(n*d-i*h),r},getTranslation:function(e,t){return(t=t||new o(3))[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,r){const n=4*t;return(r=r||new o(3))[0]=e[n+0],r[1]=e[n+1],r[2]=e[n+2],r},getScaling:function(e,t){t=t||new o(3);const r=e[0],n=e[1],i=e[2],s=e[4],a=e[5],c=e[6],l=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(r*r+n*n+i*i),t[1]=Math.sqrt(s*s+a*a+c*c),t[2]=Math.sqrt(l*l+u*u+h*h),t}});let re=Float32Array;function ne(e,t){return(t=t||new re(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}const ie=ne;function se(e){return(e=e||new re(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function oe(e,t){t=t||new re(16);const r=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],h=e[9],d=e[10],f=e[11],p=e[12],m=e[13],v=e[14],g=e[15],y=d*g,x=v*f,b=c*g,w=v*l,_=c*f,T=d*l,S=i*g,P=v*s,k=i*f,E=d*s,M=i*l,A=c*s,C=u*m,I=p*h,z=o*m,O=p*a,R=o*h,B=u*a,U=r*m,N=p*n,D=r*h,L=u*n,j=r*a,F=o*n,G=y*a+w*h+_*m-(x*a+b*h+T*m),q=x*n+S*h+E*m-(y*n+P*h+k*m),V=b*n+P*a+M*m-(w*n+S*a+A*m),W=T*n+k*a+A*h-(_*n+E*a+M*h),Y=1/(r*G+o*q+u*V+p*W);return t[0]=Y*G,t[1]=Y*q,t[2]=Y*V,t[3]=Y*W,t[4]=Y*(x*o+b*u+T*p-(y*o+w*u+_*p)),t[5]=Y*(y*r+P*u+k*p-(x*r+S*u+E*p)),t[6]=Y*(w*r+S*o+A*p-(b*r+P*o+M*p)),t[7]=Y*(_*r+E*o+M*u-(T*r+k*o+A*u)),t[8]=Y*(C*l+O*f+R*g-(I*l+z*f+B*g)),t[9]=Y*(I*s+U*f+L*g-(C*s+N*f+D*g)),t[10]=Y*(z*s+N*l+j*g-(O*s+U*l+F*g)),t[11]=Y*(B*s+D*l+F*f-(R*s+L*l+j*f)),t[12]=Y*(z*d+B*v+I*c-(R*v+C*c+O*d)),t[13]=Y*(D*v+C*i+N*d-(U*d+L*v+I*i)),t[14]=Y*(U*c+F*v+O*i-(j*v+z*i+N*c)),t[15]=Y*(j*d+R*i+L*c-(D*c+F*d+B*i)),t}const ae=oe;function ce(e,t,r){r=r||new re(16);const n=e[0],i=e[1],s=e[2],o=e[3],a=e[4],c=e[5],l=e[6],u=e[7],h=e[8],d=e[9],f=e[10],p=e[11],m=e[12],v=e[13],g=e[14],y=e[15],x=t[0],b=t[1],w=t[2],_=t[3],T=t[4],S=t[5],P=t[6],k=t[7],E=t[8],M=t[9],A=t[10],C=t[11],I=t[12],z=t[13],O=t[14],R=t[15];return r[0]=n*x+a*b+h*w+m*_,r[1]=i*x+c*b+d*w+v*_,r[2]=s*x+l*b+f*w+g*_,r[3]=o*x+u*b+p*w+y*_,r[4]=n*T+a*S+h*P+m*k,r[5]=i*T+c*S+d*P+v*k,r[6]=s*T+l*S+f*P+g*k,r[7]=o*T+u*S+p*P+y*k,r[8]=n*E+a*M+h*A+m*C,r[9]=i*E+c*M+d*A+v*C,r[10]=s*E+l*M+f*A+g*C,r[11]=o*E+u*M+p*A+y*C,r[12]=n*I+a*z+h*O+m*R,r[13]=i*I+c*z+d*O+v*R,r[14]=s*I+l*z+f*O+g*R,r[15]=o*I+u*z+p*O+y*R,r}const le=ce;let ue,he,de;function fe(e,t,r){r=r||new re(16);let n=e[0],i=e[1],s=e[2];const o=Math.sqrt(n*n+i*i+s*s);n/=o,i/=o,s/=o;const a=n*n,c=i*i,l=s*s,u=Math.cos(t),h=Math.sin(t),d=1-u;return r[0]=a+(1-a)*u,r[1]=n*i*d+s*h,r[2]=n*s*d-i*h,r[3]=0,r[4]=n*i*d-s*h,r[5]=c+(1-c)*u,r[6]=i*s*d+n*h,r[7]=0,r[8]=n*s*d+i*h,r[9]=i*s*d-n*h,r[10]=l+(1-l)*u,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}const pe=fe;function me(e,t,r,n){n=n||new re(16);let i=t[0],s=t[1],o=t[2];const a=Math.sqrt(i*i+s*s+o*o);i/=a,s/=a,o/=a;const c=i*i,l=s*s,u=o*o,h=Math.cos(r),d=Math.sin(r),f=1-h,p=c+(1-c)*h,m=i*s*f+o*d,v=i*o*f-s*d,g=i*s*f-o*d,y=l+(1-l)*h,x=s*o*f+i*d,b=i*o*f+s*d,w=s*o*f-i*d,_=u+(1-u)*h,T=e[0],S=e[1],P=e[2],k=e[3],E=e[4],M=e[5],A=e[6],C=e[7],I=e[8],z=e[9],O=e[10],R=e[11];return n[0]=p*T+m*E+v*I,n[1]=p*S+m*M+v*z,n[2]=p*P+m*A+v*O,n[3]=p*k+m*C+v*R,n[4]=g*T+y*E+x*I,n[5]=g*S+y*M+x*z,n[6]=g*P+y*A+x*O,n[7]=g*k+y*C+x*R,n[8]=b*T+w*E+_*I,n[9]=b*S+w*M+_*z,n[10]=b*P+w*A+_*O,n[11]=b*k+w*C+_*R,e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n}const ve=me;var ge=Object.freeze({__proto__:null,setDefaultType:function(e){const t=re;return re=e,t},create:function(e,t,r,n,i,s,o,a,c,l,u,h,d,f,p,m){const v=new re(16);return void 0!==e&&(v[0]=e,void 0!==t&&(v[1]=t,void 0!==r&&(v[2]=r,void 0!==n&&(v[3]=n,void 0!==i&&(v[4]=i,void 0!==s&&(v[5]=s,void 0!==o&&(v[6]=o,void 0!==a&&(v[7]=a,void 0!==c&&(v[8]=c,void 0!==l&&(v[9]=l,void 0!==u&&(v[10]=u,void 0!==h&&(v[11]=h,void 0!==d&&(v[12]=d,void 0!==f&&(v[13]=f,void 0!==p&&(v[14]=p,void 0!==m&&(v[15]=m)))))))))))))))),v},set:function(e,t,r,n,i,s,o,a,c,l,u,h,d,f,p,m,v){return(v=v||new re(16))[0]=e,v[1]=t,v[2]=r,v[3]=n,v[4]=i,v[5]=s,v[6]=o,v[7]=a,v[8]=c,v[9]=l,v[10]=u,v[11]=h,v[12]=d,v[13]=f,v[14]=p,v[15]=m,v},fromMat3:function(e,t){return(t=t||new re(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=0,t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=0,t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromQuat:function(e,t){t=t||new re(16);const r=e[0],n=e[1],i=e[2],s=e[3],o=r+r,a=n+n,c=i+i,l=r*o,u=n*o,h=n*a,d=i*o,f=i*a,p=i*c,m=s*o,v=s*a,g=s*c;return t[0]=1-h-p,t[1]=u+g,t[2]=d-v,t[3]=0,t[4]=u-g,t[5]=1-l-p,t[6]=f+m,t[7]=0,t[8]=d+v,t[9]=f-m,t[10]=1-l-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},negate:function(e,t){return(t=t||new re(16))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t[9]=-e[9],t[10]=-e[10],t[11]=-e[11],t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=-e[15],t},copy:ne,clone:ie,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<n&&Math.abs(e[1]-t[1])<n&&Math.abs(e[2]-t[2])<n&&Math.abs(e[3]-t[3])<n&&Math.abs(e[4]-t[4])<n&&Math.abs(e[5]-t[5])<n&&Math.abs(e[6]-t[6])<n&&Math.abs(e[7]-t[7])<n&&Math.abs(e[8]-t[8])<n&&Math.abs(e[9]-t[9])<n&&Math.abs(e[10]-t[10])<n&&Math.abs(e[11]-t[11])<n&&Math.abs(e[12]-t[12])<n&&Math.abs(e[13]-t[13])<n&&Math.abs(e[14]-t[14])<n&&Math.abs(e[15]-t[15])<n},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},identity:se,transpose:function(e,t){if((t=t||new re(16))===e){let r;return r=e[1],e[1]=e[4],e[4]=r,r=e[2],e[2]=e[8],e[8]=r,r=e[3],e[3]=e[12],e[12]=r,r=e[6],e[6]=e[9],e[9]=r,r=e[7],e[7]=e[13],e[13]=r,r=e[11],e[11]=e[14],e[14]=r,t}const r=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],c=e[6],l=e[7],u=e[8],h=e[9],d=e[10],f=e[11],p=e[12],m=e[13],v=e[14],g=e[15];return t[0]=r,t[1]=o,t[2]=u,t[3]=p,t[4]=n,t[5]=a,t[6]=h,t[7]=m,t[8]=i,t[9]=c,t[10]=d,t[11]=v,t[12]=s,t[13]=l,t[14]=f,t[15]=g,t},inverse:oe,determinant:function(e){const t=e[0],r=e[1],n=e[2],i=e[3],s=e[4],o=e[5],a=e[6],c=e[7],l=e[8],u=e[9],h=e[10],d=e[11],f=e[12],p=e[13],m=e[14],v=e[15],g=h*v,y=m*d,x=a*v,b=m*c,w=a*d,_=h*c,T=n*v,S=m*i,P=n*d,k=h*i,E=n*c,M=a*i;return t*(g*o+b*u+w*p-(y*o+x*u+_*p))+s*(y*r+T*u+k*p-(g*r+S*u+P*p))+l*(x*r+S*o+E*p-(b*r+T*o+M*p))+f*(_*r+P*o+M*u-(w*r+k*o+E*u))},invert:ae,multiply:ce,mul:le,setTranslation:function(e,t,r){return e!==(r=r||se())&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11]),r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r},getTranslation:function(e,t){return(t=t||a())[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,r){const n=4*t;return(r=r||a())[0]=e[n+0],r[1]=e[n+1],r[2]=e[n+2],r},setAxis:function(e,t,r,n){n!==e&&(n=ne(e,n));const i=4*r;return n[i+0]=t[0],n[i+1]=t[1],n[i+2]=t[2],n},getScaling:function(e,t){t=t||a();const r=e[0],n=e[1],i=e[2],s=e[4],o=e[5],c=e[6],l=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(r*r+n*n+i*i),t[1]=Math.sqrt(s*s+o*o+c*c),t[2]=Math.sqrt(l*l+u*u+h*h),t},perspective:function(e,t,r,n,i){i=i||new re(16);const s=Math.tan(.5*Math.PI-.5*e);if(i[0]=s/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=s,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,n===1/0)i[10]=-1,i[14]=-r;else{const e=1/(r-n);i[10]=n*e,i[14]=n*r*e}return i},ortho:function(e,t,r,n,i,s,o){return(o=o||new re(16))[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(n-r),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(i-s),o[11]=0,o[12]=(t+e)/(e-t),o[13]=(n+r)/(r-n),o[14]=i/(i-s),o[15]=1,o},frustum:function(e,t,r,n,i,s,o){const a=t-e,c=n-r,l=i-s;return(o=o||new re(16))[0]=2*i/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*i/c,o[6]=0,o[7]=0,o[8]=(e+t)/a,o[9]=(n+r)/c,o[10]=s/l,o[11]=-1,o[12]=0,o[13]=0,o[14]=i*s/l,o[15]=0,o},aim:function(e,t,r,n){return n=n||new re(16),ue=ue||a(),he=he||a(),de=de||a(),$(z(t,e,de),de),$(D(r,de,ue),ue),$(D(de,ue,he),he),n[0]=ue[0],n[1]=ue[1],n[2]=ue[2],n[3]=0,n[4]=he[0],n[5]=he[1],n[6]=he[2],n[7]=0,n[8]=de[0],n[9]=de[1],n[10]=de[2],n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n},cameraAim:function(e,t,r,n){return n=n||new re(16),ue=ue||a(),he=he||a(),de=de||a(),$(z(e,t,de),de),$(D(r,de,ue),ue),$(D(de,ue,he),he),n[0]=ue[0],n[1]=ue[1],n[2]=ue[2],n[3]=0,n[4]=he[0],n[5]=he[1],n[6]=he[2],n[7]=0,n[8]=de[0],n[9]=de[1],n[10]=de[2],n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n},lookAt:function(e,t,r,n){return n=n||new re(16),ue=ue||a(),he=he||a(),de=de||a(),$(z(e,t,de),de),$(D(r,de,ue),ue),$(D(de,ue,he),he),n[0]=ue[0],n[1]=he[0],n[2]=de[0],n[3]=0,n[4]=ue[1],n[5]=he[1],n[6]=de[1],n[7]=0,n[8]=ue[2],n[9]=he[2],n[10]=de[2],n[11]=0,n[12]=-(ue[0]*e[0]+ue[1]*e[1]+ue[2]*e[2]),n[13]=-(he[0]*e[0]+he[1]*e[1]+he[2]*e[2]),n[14]=-(de[0]*e[0]+de[1]*e[1]+de[2]*e[2]),n[15]=1,n},translation:function(e,t){return(t=t||new re(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},translate:function(e,t,r){r=r||new re(16);const n=t[0],i=t[1],s=t[2],o=e[0],a=e[1],c=e[2],l=e[3],u=e[4],h=e[5],d=e[6],f=e[7],p=e[8],m=e[9],v=e[10],g=e[11],y=e[12],x=e[13],b=e[14],w=e[15];return e!==r&&(r[0]=o,r[1]=a,r[2]=c,r[3]=l,r[4]=u,r[5]=h,r[6]=d,r[7]=f,r[8]=p,r[9]=m,r[10]=v,r[11]=g),r[12]=o*n+u*i+p*s+y,r[13]=a*n+h*i+m*s+x,r[14]=c*n+d*i+v*s+b,r[15]=l*n+f*i+g*s+w,r},rotationX:function(e,t){t=t||new re(16);const r=Math.cos(e),n=Math.sin(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=n,t[7]=0,t[8]=0,t[9]=-n,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateX:function(e,t,r){r=r||new re(16);const n=e[4],i=e[5],s=e[6],o=e[7],a=e[8],c=e[9],l=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return r[4]=h*n+d*a,r[5]=h*i+d*c,r[6]=h*s+d*l,r[7]=h*o+d*u,r[8]=h*a-d*n,r[9]=h*c-d*i,r[10]=h*l-d*s,r[11]=h*u-d*o,e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r},rotationY:function(e,t){t=t||new re(16);const r=Math.cos(e),n=Math.sin(e);return t[0]=r,t[1]=0,t[2]=-n,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=n,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateY:function(e,t,r){r=r||new re(16);const n=e[0],i=e[1],s=e[2],o=e[3],a=e[8],c=e[9],l=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return r[0]=h*n-d*a,r[1]=h*i-d*c,r[2]=h*s-d*l,r[3]=h*o-d*u,r[8]=h*a+d*n,r[9]=h*c+d*i,r[10]=h*l+d*s,r[11]=h*u+d*o,e!==r&&(r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r},rotationZ:function(e,t){t=t||new re(16);const r=Math.cos(e),n=Math.sin(e);return t[0]=r,t[1]=n,t[2]=0,t[3]=0,t[4]=-n,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateZ:function(e,t,r){r=r||new re(16);const n=e[0],i=e[1],s=e[2],o=e[3],a=e[4],c=e[5],l=e[6],u=e[7],h=Math.cos(t),d=Math.sin(t);return r[0]=h*n+d*a,r[1]=h*i+d*c,r[2]=h*s+d*l,r[3]=h*o+d*u,r[4]=h*a-d*n,r[5]=h*c-d*i,r[6]=h*l-d*s,r[7]=h*u-d*o,e!==r&&(r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r},axisRotation:fe,rotation:pe,axisRotate:me,rotate:ve,scaling:function(e,t){return(t=t||new re(16))[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},scale:function(e,t,r){r=r||new re(16);const n=t[0],i=t[1],s=t[2];return r[0]=n*e[0],r[1]=n*e[1],r[2]=n*e[2],r[3]=n*e[3],r[4]=i*e[4],r[5]=i*e[5],r[6]=i*e[6],r[7]=i*e[7],r[8]=s*e[8],r[9]=s*e[9],r[10]=s*e[10],r[11]=s*e[11],e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r},uniformScaling:function(e,t){return(t=t||new re(16))[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},uniformScale:function(e,t,r){return(r=r||new re(16))[0]=t*e[0],r[1]=t*e[1],r[2]=t*e[2],r[3]=t*e[3],r[4]=t*e[4],r[5]=t*e[5],r[6]=t*e[6],r[7]=t*e[7],r[8]=t*e[8],r[9]=t*e[9],r[10]=t*e[10],r[11]=t*e[11],e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r}});let ye=Float32Array;function xe(e,t,r,n){const i=new ye(4);return void 0!==e&&(i[0]=e,void 0!==t&&(i[1]=t,void 0!==r&&(i[2]=r,void 0!==n&&(i[3]=n)))),i}const be=xe;function we(e,t,r){r=r||new ye(4);const n=.5*t,i=Math.sin(n);return r[0]=i*e[0],r[1]=i*e[1],r[2]=i*e[2],r[3]=Math.cos(n),r}function _e(e,t,r){r=r||new ye(4);const n=e[0],i=e[1],s=e[2],o=e[3],a=t[0],c=t[1],l=t[2],u=t[3];return r[0]=n*u+o*a+i*l-s*c,r[1]=i*u+o*c+s*a-n*l,r[2]=s*u+o*l+n*c-i*a,r[3]=o*u-n*a-i*c-s*l,r}const Te=_e;function Se(e,t,r,i){i=i||new ye(4);const s=e[0],o=e[1],a=e[2],c=e[3];let l,u,h=t[0],d=t[1],f=t[2],p=t[3],m=s*h+o*d+a*f+c*p;if(m<0&&(m=-m,h=-h,d=-d,f=-f,p=-p),1-m>n){const e=Math.acos(m),t=Math.sin(e);l=Math.sin((1-r)*e)/t,u=Math.sin(r*e)/t}else l=1-r,u=r;return i[0]=l*s+u*h,i[1]=l*o+u*d,i[2]=l*a+u*f,i[3]=l*c+u*p,i}function Pe(e,t){return(t=t||new ye(4))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}const ke=Pe;function Ee(e,t,r){return(r=r||new ye(4))[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r[3]=e[3]-t[3],r}const Me=Ee;function Ae(e,t,r){return(r=r||new ye(4))[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r[3]=e[3]*t,r}const Ce=Ae;function Ie(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function ze(e){const t=e[0],r=e[1],n=e[2],i=e[3];return Math.sqrt(t*t+r*r+n*n+i*i)}const Oe=ze;function Re(e){const t=e[0],r=e[1],n=e[2],i=e[3];return t*t+r*r+n*n+i*i}const Be=Re;function Ue(e,t){t=t||new ye(4);const r=e[0],n=e[1],i=e[2],s=e[3],o=Math.sqrt(r*r+n*n+i*i+s*s);return o>1e-5?(t[0]=r/o,t[1]=n/o,t[2]=i/o,t[3]=s/o):(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}let Ne,De,Le,je,Fe;var Ge=Object.freeze({__proto__:null,create:xe,setDefaultType:function(e){const t=ye;return ye=e,t},fromValues:be,set:function(e,t,r,n,i){return(i=i||new ye(4))[0]=e,i[1]=t,i[2]=r,i[3]=n,i},fromAxisAngle:we,toAxisAngle:function(e,t){t=t||a(4);const r=2*Math.acos(e[3]),i=Math.sin(.5*r);return i>n?(t[0]=e[0]/i,t[1]=e[1]/i,t[2]=e[2]/i):(t[0]=1,t[1]=0,t[2]=0),{angle:r,axis:t}},angle:function(e,t){const r=Ie(e,t);return Math.acos(2*r*r-1)},multiply:_e,mul:Te,rotateX:function(e,t,r){r=r||new ye(4);const n=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],c=Math.sin(n),l=Math.cos(n);return r[0]=i*l+a*c,r[1]=s*l+o*c,r[2]=o*l-s*c,r[3]=a*l-i*c,r},rotateY:function(e,t,r){r=r||new ye(4);const n=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],c=Math.sin(n),l=Math.cos(n);return r[0]=i*l-o*c,r[1]=s*l+a*c,r[2]=o*l+i*c,r[3]=a*l-s*c,r},rotateZ:function(e,t,r){r=r||new ye(4);const n=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],c=Math.sin(n),l=Math.cos(n);return r[0]=i*l+s*c,r[1]=s*l-i*c,r[2]=o*l+a*c,r[3]=a*l-o*c,r},slerp:Se,inverse:function(e,t){t=t||new ye(4);const r=e[0],n=e[1],i=e[2],s=e[3],o=r*r+n*n+i*i+s*s,a=o?1/o:0;return t[0]=-r*a,t[1]=-n*a,t[2]=-i*a,t[3]=s*a,t},conjugate:function(e,t){return(t=t||new ye(4))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},fromMat:function(e,t){t=t||new ye(4);const r=e[0]+e[5]+e[10];if(r>0){const n=Math.sqrt(r+1);t[3]=.5*n;const i=.5/n;t[0]=(e[6]-e[9])*i,t[1]=(e[8]-e[2])*i,t[2]=(e[1]-e[4])*i}else{let r=0;e[5]>e[0]&&(r=1),e[10]>e[4*r+r]&&(r=2);const n=(r+1)%3,i=(r+2)%3,s=Math.sqrt(e[4*r+r]-e[4*n+n]-e[4*i+i]+1);t[r]=.5*s;const o=.5/s;t[3]=(e[4*n+i]-e[4*i+n])*o,t[n]=(e[4*n+r]+e[4*r+n])*o,t[i]=(e[4*i+r]+e[4*r+i])*o}return t},fromEuler:function(e,t,r,n,i){i=i||new ye(4);const s=.5*e,o=.5*t,a=.5*r,c=Math.sin(s),l=Math.cos(s),u=Math.sin(o),h=Math.cos(o),d=Math.sin(a),f=Math.cos(a);switch(n){case"xyz":i[0]=c*h*f+l*u*d,i[1]=l*u*f-c*h*d,i[2]=l*h*d+c*u*f,i[3]=l*h*f-c*u*d;break;case"xzy":i[0]=c*h*f-l*u*d,i[1]=l*u*f-c*h*d,i[2]=l*h*d+c*u*f,i[3]=l*h*f+c*u*d;break;case"yxz":i[0]=c*h*f+l*u*d,i[1]=l*u*f-c*h*d,i[2]=l*h*d-c*u*f,i[3]=l*h*f+c*u*d;break;case"yzx":i[0]=c*h*f+l*u*d,i[1]=l*u*f+c*h*d,i[2]=l*h*d-c*u*f,i[3]=l*h*f-c*u*d;break;case"zxy":i[0]=c*h*f-l*u*d,i[1]=l*u*f+c*h*d,i[2]=l*h*d+c*u*f,i[3]=l*h*f-c*u*d;break;case"zyx":i[0]=c*h*f-l*u*d,i[1]=l*u*f+c*h*d,i[2]=l*h*d-c*u*f,i[3]=l*h*f+c*u*d;break;default:throw new Error(`Unknown rotation order: ${n}`)}return i},copy:Pe,clone:ke,add:function(e,t,r){return(r=r||new ye(4))[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r[3]=e[3]+t[3],r},subtract:Ee,sub:Me,mulScalar:Ae,scale:Ce,divScalar:function(e,t,r){return(r=r||new ye(4))[0]=e[0]/t,r[1]=e[1]/t,r[2]=e[2]/t,r[3]=e[3]/t,r},dot:Ie,lerp:function(e,t,r,n){return(n=n||new ye(4))[0]=e[0]+r*(t[0]-e[0]),n[1]=e[1]+r*(t[1]-e[1]),n[2]=e[2]+r*(t[2]-e[2]),n[3]=e[3]+r*(t[3]-e[3]),n},length:ze,len:Oe,lengthSq:Re,lenSq:Be,normalize:Ue,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<n&&Math.abs(e[1]-t[1])<n&&Math.abs(e[2]-t[2])<n&&Math.abs(e[3]-t[3])<n},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(e){return(e=e||new ye(4))[0]=0,e[1]=0,e[2]=0,e[3]=1,e},rotationTo:function(e,t,r){r=r||new ye(4),Ne=Ne||a(),De=De||a(1,0,0),Le=Le||a(0,1,0);const n=L(e,t);return n<-.999999?(D(De,e,Ne),F(Ne)<1e-6&&D(Le,e,Ne),$(Ne,Ne),we(Ne,Math.PI,r),r):n>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(D(e,t,Ne),r[0]=Ne[0],r[1]=Ne[1],r[2]=Ne[2],r[3]=1+n,Ue(r,r))},sqlerp:function(e,t,r,n,i,s){return s=s||new ye(4),je=je||new ye(4),Fe=Fe||new ye(4),Se(e,n,i,je),Se(t,r,i,Fe),Se(je,Fe,2*i*(1-i),s),s}});Float32Array;const qe=(e,t)=>{const r=new Uint32Array(t);bs.queue.writeBuffer(e,0,r.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},Ve=(e,t)=>{const r=new Uint32Array(e),n=bs.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return qe(n,e),n},We=(e,t)=>{if(t instanceof Float32Array)bs.queue.writeBuffer(e,0,t.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT);else{const r=new Float32Array(t);bs.queue.writeBuffer(e,0,r.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)}},Ye="fn calculateRayDirection(uv: vec2<f32>, inverseProjection: mat4x4<f32>) -> vec3<f32> {\r\n  let clipSpace = vec2(1.0 - uv.x, 1.0 - uv.y) * 2.0 - 1.0;\r\n  let viewRay = vec3<f32>(clipSpace, 1.0);\r\n  let viewRayView = inverseProjection * vec4(viewRay, 1.0);\r\n  return normalize(viewRayView.xyz);\r\n}\r\n\r\nfn normaliseValue(min: f32, max: f32, value: f32) -> f32 {\r\n  return (value - min) / (max - min);\r\n}",He="// TODO: actually make linear\r\nfn distanceToReversedLinearDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n  return (far - cameraDistance) / (far - near);//Reversed\r\n}\r\n\r\nfn reversedLinearDepthToDistance(linearDepth: f32, near: f32, far: f32) -> f32 {\r\n    return far - linearDepth * (far - near); //Reversed\r\n}\r\n\r\nfn distanceToLogarithmicDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n    return log2(cameraDistance / near + 1.0) / log2(far / near + 1.0);\r\n}\r\n\r\nfn logarithmicDepthToDistance(logDepth: f32, near: f32, far: f32) -> f32 {\r\n    let base = far / near + 1.0;\r\n    return near * (pow(base, logDepth) - 1.0);\r\n}",$e="r8unorm",Xe="rgba16float",Ze="rgba16float",Ke="r32float",Qe="struct BoxIntersectionResult {\r\n    tNear: f32,\r\n    tFar: f32,\r\n    normal: vec3<f32>,\r\n    isHit: bool,\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n    result.isHit = false;\r\n    result.tNear = -1.0;\r\n    result.tFar = -1.0;\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n    if (tN > tF || tF < 0.0) {\r\n        return result;\r\n    }\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n    normal *= -sign(rd);\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        return result;\r\n    }\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n    result.isHit = true;\r\n    return result;\r\n}\r\n\r\nfn get3x3From4x4(m: mat4x4<f32>) -> mat3x3<f32> {\r\n    return mat3x3<f32>(\r\n        m[0].xyz,\r\n        m[1].xyz,\r\n        m[2].xyz,\r\n    );\r\n}\r\n\r\n\r\nfn intersectOBB(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n    boxOrientation: mat3x3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n    result.isHit = false;\r\n    result.tNear = -1.0;\r\n    result.tFar = -1.0;\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n    if (tN > tF || tF < 0.0) {\r\n        return result;\r\n    }\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n    normal *= -sign(rd);\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        return result;\r\n    }\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n    result.isHit = true;\r\n    return result;\r\n}",Je='const EPSILON = 0.001;\r\nconst MAX_RAY_STEPS = 256;\r\nconst FAR_PLANE = 10000.0;\r\nconst NEAR_PLANE = 0.5;\r\nconst STACK_LEN: u32 = 32u;\r\n\r\n// Function to transform a normal vector from object to world space\r\nfn transformNormal(inverseTransform: mat4x4<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let worldNormal = normalize((vec4<f32>(normal, 0.0) * inverseTransform).xyz);\r\n    return worldNormal;\r\n}\r\n\r\n// Function to transform an object space position to world space\r\nfn transformPosition(transform: mat4x4<f32>, position: vec3<f32>) -> vec3<f32> {\r\n    let worldPosition = (transform * vec4<f32>(position, 1.0)).xyz;\r\n    return worldPosition;\r\n}\r\n\r\n\r\nstruct VoxelObject {\r\n  transform: mat4x4<f32>,\r\n  inverseTransform: mat4x4<f32>,\r\n  previousTransform: mat4x4<f32>,\r\n  previousInverseTransform: mat4x4<f32>,\r\n  size : vec3<f32>,\r\n  atlasLocation : vec3<f32>,\r\n  paletteIndex : f32,\r\n  octreeBufferIndex: u32\r\n}\r\n\r\nstruct RayMarchResult {\r\n  voxelObjectIndex: i32,\r\n  colour: vec3<f32>,\r\n  normal: vec3<f32>,\r\n  hit: bool,\r\n  t: f32,\r\n  iterations: u32,\r\n}\r\n\r\nfn isInBounds(position: vec3<i32>, size: vec3<i32>) -> bool {\r\n  return all(position >= vec3(0)) && all(position <= size - vec3(1));\r\n}\r\n\r\nfn getBit(value: u32, bitIndex: u32) -> bool {\r\n  return (value & (1u << bitIndex)) != 0;\r\n}\r\n\r\nfn getScaleFromMatrix(transform: mat4x4<f32>) -> vec3<f32> {\r\n  return vec3<f32>(length(transform[0].xyz), length(transform[1].xyz), length(transform[2].xyz));\r\n}\r\n\r\nfn rayMarchAtMip(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>, mipLevel: u32) -> RayMarchResult {\r\n  var output = RayMarchResult();\r\n\r\n//  var intersect = boxIntersection(objectRayOrigin, objectRayDirection,voxelObject.size * 0.5);\r\n//\r\n//  if(intersect.isHit){\r\n//    output.hit = true;\r\n//    output.t = intersect.tNear;\r\n//    output.normal = intersect.normal;\r\n//    output.colour = vec3<f32>(0.0, 1.0, 0.0);\r\n//    return output;\r\n//  }\r\n\r\n  let rayDirSign = sign(objectRayDirection);\r\n  let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\r\n  var voxelSize = vec3(f32(1 << mipLevel));\r\n  var shiftedRayOrigin = objectRayOrigin - objectRayDirection * EPSILON;\r\n  var objectPos = shiftedRayOrigin;\r\n  var currentIndex = vec3<i32>(floor(objectPos));\r\n  var scaledRayOrigin =  objectRayOrigin / voxelSize;\r\n  var scaledObjectPos = floor(objectPos / voxelSize);\r\n  var scaledOriginDifference = scaledObjectPos - scaledRayOrigin;\r\n  var tMax = voxelSize * (rayDirSign * scaledOriginDifference + (rayDirSign * 0.5) + 0.5) / abs(objectRayDirection);\r\n  let mask = vec3<f32>(tMax.xyz <= min(tMax.yzx, tMax.zxy));\r\n  var objectNormal = mask * -rayDirSign;\r\n  var tCurrent = min(tMax.x, min(tMax.y, tMax.z));\r\n\r\n  // RAYMARCH\r\n  for(var i = 0; i < MAX_RAY_STEPS; i++)\r\n  {\r\n    let samplePosition = vec3<u32>(currentIndex) + atlasLocation;\r\n    let mipSample0 = textureLoad(voxels, samplePosition / vec3((1u << mipLevel)), mipLevel);\r\n\r\n    if(mipSample0.r > 0.0 && isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n        output.normal = objectNormal;\r\n        output.hit = true;\r\n        output.t = tCurrent + EPSILON;\r\n//        output.colour = vec3<f32>(mipSample0.r, 0,0);\r\n        // palette system no longer used in shader, precomputed in octree\r\n        output.colour = vec3(1,0,0);\r\n        output.iterations = u32(i);\r\n        return output;\r\n    }\r\n\r\n    var scaledRayOrigin = shiftedRayOrigin / voxelSize;\r\n    var scaledObjectPos = floor(objectPos / voxelSize);\r\n    var scaledOriginDifference = scaledObjectPos - scaledRayOrigin;\r\n    var tMax = voxelSize * (rayDirSign * scaledOriginDifference + (rayDirSign * 0.5) + 0.5) / abs(objectRayDirection);\r\n    let mask = vec3<f32>(tMax.xyz <= min(tMax.yzx, tMax.zxy));\r\n\r\n    tCurrent = min(tMax.x, min(tMax.y, tMax.z));\r\n    objectPos = objectRayOrigin + objectRayDirection * tCurrent;\r\n    currentIndex = vec3<i32>(floor(objectPos / voxelSize) * voxelSize);\r\n    objectNormal = mask * -rayDirSign;\r\n\r\n//    if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n//        break;\r\n//    }\r\n  }\r\n  return output;\r\n}\r\n\r\nfn rayMarchTransformed(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>, mipLevel: u32) -> RayMarchResult {\r\n      let halfExtents = voxelObject.size * 0.5;\r\n      var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz + halfExtents;\r\n      let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n      return  rayMarchAtMip(voxelObject, objectRayDirection, objectRayOrigin, mipLevel);\r\n}\r\n\r\nstruct Stack {\r\n  arr: array<i32, STACK_LEN>,\r\n\thead: u32,\r\n}\r\n\r\nfn stack_new() -> Stack {\r\n    var arr: array<i32, STACK_LEN>;\r\n    return Stack(arr, 0u);\r\n}\r\n\r\nfn stack_push(stack: ptr<function, Stack>, val: i32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stack_pop(stack: ptr<function, Stack>) -> i32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\nstruct StackU32 {\r\n  arr: array<u32, STACK_LEN>,\r\n  head: u32,\r\n}\r\n\r\nfn stacku32_new() -> StackU32 {\r\n    var arr: array<u32, STACK_LEN>;\r\n    return StackU32(arr, 0u);\r\n}\r\n\r\nfn stacku32_push(stack: ptr<function, StackU32>, val: u32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stacku32_pop(stack: ptr<function, StackU32>) -> u32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\n\r\nstruct InternalNode {\r\n  firstChildOffset: u32,\r\n  childMask: u32,\r\n  position: vec3<u32>,\r\n  size: u32,\r\n}\r\n\r\nstruct LeafNode {\r\n  colour: vec3<u32>,\r\n  position: vec3<u32>,\r\n}\r\n\r\nconst mask8 = 0xFFu;\r\nconst mask16 = 0xFFFFu;\r\nconst mask24 = 0xFFFFFFu;\r\n\r\n// if first child offset is 0, then it is a leaf\r\nfn isLeaf(node:vec2<u32>) -> bool {\r\n  return (node[0] & mask16) == 0;\r\n}\r\n\r\n/**\r\n  * Unpacks a leaf node from a 32 bit integer\r\n  * First 16 bits are the leaf flag (0)\r\n  * The next 8 bits are the red component\r\n  * The next 8 bits are the green component\r\n  * The next 8 bits are the blue component\r\n  * The next 8 bits are the x position\r\n  * The next 8 bits are the y position\r\n  * The next 8 bits are the z position\r\n  */\r\nfn unpackLeaf(node: vec2<u32>) -> LeafNode {\r\n  var output = LeafNode();\r\n  let first4Bytes = node.x;\r\n  let second4Bytes = node.y;\r\n  let r = (first4Bytes >> 16u) & mask8;\r\n  let g = (first4Bytes >> 24u) & mask8;\r\n  let b = second4Bytes & mask8;\r\n  let x = (second4Bytes >> 8u) & mask8;\r\n  let y = (second4Bytes >> 16u) & mask8;\r\n  let z = (second4Bytes >> 24u) & mask8;\r\n  output.colour = vec3<u32>(r, g, b);\r\n  output.position = vec3<u32>(x, y, z);\r\n  return output;\r\n}\r\n\r\n/**\r\n  * Unpacks an internal node from a 32 bit integer\r\n  * First 24 bits are the firstChildOffset\r\n  * The next 8 bits are the child mask\r\n  * The next 8 bits are the x position\r\n  * The next 8 bits are the y position\r\n  * The next 8 bits are the z position\r\n  * The next 8 bits are the size\r\n  */\r\nfn unpackInternal(node: vec2<u32>) -> InternalNode {\r\n  var output = InternalNode();\r\n  let first4Bytes = node.x;\r\n  let second4Bytes = node.y;\r\n  output.firstChildOffset = first4Bytes & mask24;\r\n  output.childMask = (first4Bytes >> 24u) & mask8;\r\n  let x = second4Bytes & mask8;\r\n  let y = (second4Bytes >> 8u) & mask8;\r\n  let z = (second4Bytes >> 16u) & mask8;\r\n  output.position = vec3<u32>(x, y, z);\r\n  output.size = (second4Bytes >> 24u) & mask8;\r\n  return output;\r\n}\r\n\r\nfn getNodeSizeAtDepth(rootSize: u32, depth: u32) -> u32 {\r\n  return rootSize >> depth;\r\n}\r\n\r\nfn octantIndexToOffset(index: u32) -> vec3<u32> {\r\n  return vec3<u32>(\r\n    select(0u, 1u, (index & 1u) != 0u),\r\n    select(0u, 1u, (index & 2u) != 0u),\r\n    select(0u, 1u, (index & 4u) != 0u)\r\n  );\r\n}\r\n\r\nfn octantOffsetToIndex(offset: vec3<u32>) -> u32 {\r\n  return offset.x + offset.y * 2u + offset.z * 4u;\r\n}\r\n\r\nfn ceilToPowerOfTwo(value: f32) -> f32 {\r\n  return pow(2.0, ceil(log2(value)));\r\n}\r\n\r\nfn max3(value: vec3<f32>) -> f32 {\r\n  return max(value.x, max(value.y, value.z));\r\n}\r\n\r\nfn planeIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, planeNormal: vec3<f32>, planeDistance: f32) -> f32 {\r\n  return -(dot(rayOrigin,planeNormal)+planeDistance)/dot(rayDirection,planeNormal);\r\n}\r\n\r\nstruct PlaneIntersection {\r\n  tNear: f32,\r\n  side: vec3<i32>\r\n}\r\n\r\n\r\nfn sort3Asc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    min(a, min(b, c)),\r\n    min(max(a, b), max(min(a, b), c)),\r\n    max(a, max(b, c))\r\n  );\r\n}\r\n\r\nfn sort3Desc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    max(a, max(b, c)),\r\n    max(min(a, b), min(max(a, b), c)),\r\n    min(a, min(b, c))\r\n  );\r\n}\r\n\r\nfn getPlaneIntersections(rayOrigin: vec3<f32>, rayDirection:vec3<f32>, nodeSize: f32) -> vec3<f32> {\r\n    let boxExtents = nodeSize * 0.5;\r\n\r\n    var yPlaneIntersectionTNear = planeIntersection(rayOrigin, rayDirection, vec3(0.0, -1, 0.0), boxExtents);\r\n    var xPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(-1, 0.0, 0.0), boxExtents);\r\n    var zPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(0.0, 0.0, -1), boxExtents);\r\n\r\n    // If the intersection is outside the bounds of the node, set it to a large value to ignore it\r\n    let yPlaneHitPosition = rayOrigin + rayDirection * yPlaneIntersectionTNear  - EPSILON;\r\n    if(any(yPlaneHitPosition < vec3(0.0)) || any(yPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      yPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n    let xPlaneHitPosition = rayOrigin + rayDirection * xPlaneIntersectionTNear  - EPSILON;\r\n    if(any(xPlaneHitPosition < vec3(0.0)) || any(xPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      xPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n    let zPlaneHitPosition = rayOrigin + rayDirection * zPlaneIntersectionTNear  - EPSILON;\r\n    if(any(zPlaneHitPosition < vec3(0.0)) || any(zPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      zPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n\r\n    return vec3(xPlaneIntersectionTNear, yPlaneIntersectionTNear, zPlaneIntersectionTNear);\r\n}\r\n\r\nfn rayMarchOctree(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> RayMarchResult {\r\n    let halfExtents = voxelObject.size * 0.5;\r\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz + halfExtents;\r\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n    var output = RayMarchResult();\r\n    let distanceToRoot = boxIntersection(objectRayOrigin, objectRayDirection, voxelObject.size * 0.5).tNear;\r\n\r\n    // Set the initial t value to the far plane - essentially an out of bounds value\r\n    output.t = FAR_PLANE;\r\n\r\n    // Create a stack to hold the indices of the nodes we need to check\r\n    var stack = stacku32_new();\r\n\r\n    // Push the root node index onto the stack\r\n    stacku32_push(&stack, voxelObject.octreeBufferIndex);\r\n\r\n    // Main loop\r\n    while (stack.head > 0u && output.iterations < MAX_STEPS) {\r\n      output.iterations += 1u;\r\n      let nodeIndex = stacku32_pop(&stack);\r\n      let node = octreeBuffer[nodeIndex];\r\n\r\n      if(isLeaf(node)){\r\n        // TODO: find out how to get normal without extra intersection\r\n        let leafNode = unpackLeaf(node);\r\n        let nodeOrigin = vec3(f32(leafNode.position.x), f32(leafNode.position.y), f32(leafNode.position.z));\r\n        let nodeRayOrigin = objectRayOrigin - nodeOrigin;\r\n        let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(0.5));\r\n        if(nodeIntersection.isHit){\r\n          output.hit = true;\r\n          output.t = nodeIntersection.tNear;\r\n          output.normal = nodeIntersection.normal;\r\n          output.colour = vec3<f32>(leafNode.colour) / 255.0;\r\n          return output;\r\n        }\r\n      }\r\n\r\n      // Get the current nodes data\r\n      let internalNode = unpackInternal(node);\r\n\r\n      // Get the size of the node to get the center for plane intersections\r\n      let nodeSize = f32(internalNode.size);\r\n\r\n\r\n\r\n      // Check if the ray intersects the node, if not, skip it\r\n      let nodeOrigin = vec3<f32>(internalNode.position);\r\n      let nodeRayOrigin = objectRayOrigin - nodeOrigin;\r\n      let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(nodeSize * 0.5));\r\n      let isOriginInside = all(nodeRayOrigin >= vec3(0.0)) && all(nodeRayOrigin <= vec3(nodeSize));\r\n      if(!nodeIntersection.isHit && !isOriginInside){\r\n        continue;\r\n      }\r\n\r\n      /// TEMP LOD\r\n//      if(nodeSize <= 4.0 && distanceToRoot > 1000.0){\r\n//        output.hit = true;\r\n//        output.t = nodeIntersection.tNear;\r\n//        output.normal = nodeIntersection.normal;\r\n//        output.colour = vec3<f32>(1.0, 0.0, 0.0);\r\n//        return output;\r\n//    }\r\n//      if(nodeSize <= 2.0 && distanceToRoot > 500.0){\r\n//          output.hit = true;\r\n//          output.t = nodeIntersection.tNear;\r\n//          output.normal = nodeIntersection.normal;\r\n//          output.colour = vec3<f32>(0.0, 1.0, 0.0);\r\n//          return output;\r\n//      }\r\n\r\n      let centerOfChild = vec3(nodeSize* 0.5);\r\n\r\n      // Use planes to find the "inner" intersections\r\n      let planeIntersections = getPlaneIntersections(nodeRayOrigin, objectRayDirection, nodeSize);\r\n\r\n      // Get the closest plane intersection\r\n      let sortedIntersections = sort3Desc(planeIntersections[0], planeIntersections[1], planeIntersections[2]);\r\n\r\n      // Get the side of the planes that the ray is on\r\n      let sideOfPlanes = vec3<f32>(sign(nodeRayOrigin - centerOfChild));\r\n\r\n      // Push the children onto the stack, furthest first\r\n      for(var i = 0u; i < 3u; i++){\r\n        if(sortedIntersections[i] > 9999.0){\r\n          continue;\r\n        }\r\n\r\n        var hitPosition = nodeRayOrigin + objectRayDirection * sortedIntersections[i] - sideOfPlanes * EPSILON;\r\n        let hitOctant = vec3<u32>(hitPosition >= centerOfChild);\r\n        let hitIndex = octantOffsetToIndex(hitOctant);\r\n\r\n        // If the child is present, push it onto the stack\r\n        if(getBit(internalNode.childMask, hitIndex)){\r\n           let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\r\n           stacku32_push(&stack, childIndex);\r\n        }\r\n      }\r\n\r\n      // Get octant hit on the surface of the nodes bounding box\r\n      let intersectionPoint = nodeRayOrigin + objectRayDirection * nodeIntersection.tNear - EPSILON;\r\n      let hitOctant = vec3<u32>(intersectionPoint >= centerOfChild);\r\n      let hitIndex = octantOffsetToIndex(vec3<u32>(hitOctant));\r\n\r\n      // If the child is present, push it onto the stack\r\n      if(getBit(internalNode.childMask, hitIndex)){\r\n        let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\r\n        stacku32_push(&stack, childIndex);\r\n      }\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n\r\nconst colours = array<vec3<f32>, 8>(\r\n  vec3<f32>(0.5),\r\n  vec3<f32>(1.0, 0.0, 0.0),\r\n  vec3<f32>(0.0, 1.0, 0.0),\r\n  vec3<f32>(1.0, 1.0, 0.0),\r\n  vec3<f32>(0.0, 0.0, 1.0),\r\n  vec3<f32>(1.0, 0.0, 1.0),\r\n  vec3<f32>(0.0, 1.0, 1.0),\r\n  vec3<f32>(1.0, 1.0, 1.0)\r\n);\r\n\r\nfn debugColourFromIndex(index: i32) -> vec3<f32> {\r\n  return colours[index % 8];\r\n}\r\n',et="const BRICK_SIZE = 8;\r\nconst MAX_STEPS = 256;\r\n\r\n\r\nstruct BVHNode {\r\n  leftIndex: i32,\r\n  rightIndex: i32,\r\n  objectCount: u32,\r\n  AABBMin: vec3<f32>,\r\n  AABBMax: vec3<f32>\r\n}\r\n\r\nfn getDistanceToNode(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, node: BVHNode) -> f32 {\r\n  if(all(rayOrigin >= node.AABBMin) && all(rayOrigin <= node.AABBMax)){\r\n    return 0.0;\r\n  }\r\n  let boxSize = (node.AABBMax - node.AABBMin) / 2;\r\n  let intersection = boxIntersection(rayOrigin - node.AABBMin, rayDirection, boxSize);\r\n  if(intersection.isHit){\r\n    return intersection.tNear;\r\n  }\r\n  return -1.0;\r\n\r\n}\r\n\r\n// Stack-based BVH traversal\r\nfn rayMarchBVH(rayOrigin: vec3<f32>, rayDirection: vec3<f32>) -> RayMarchResult {\r\n  var closestIntersection = RayMarchResult();\r\n closestIntersection.t = FAR_PLANE;\r\n\r\n  // Create a stack to store the nodes to visit\r\n  var stack = stack_new();\r\n  stack_push(&stack, 0);\r\n\r\n  var iterations = 0;\r\n  var nodeIndex = 0;\r\n  var closestRayMarchDistance = FAR_PLANE;\r\n\r\n  while (stack.head > 0u && iterations < MAX_STEPS) {\r\n    let node = bvhNodes[nodeIndex];\r\n    if(node.objectCount > 1){\r\n      let leftNode = bvhNodes[node.leftIndex];\r\n      let rightNode = bvhNodes[node.rightIndex];\r\n      let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\r\n      let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\r\n      let hitLeft = leftDist >= 0.0;\r\n      let hitRight = rightDist >= 0.0;\r\n      if(hitLeft){\r\n        var nearIndex = node.leftIndex;\r\n        // We hit both left and right, choose the closest one\r\n        if(hitRight){\r\n          if(leftDist < rightDist){\r\n            // left is closer, push right to stack\r\n            stack_push(&stack, node.rightIndex);\r\n          } else {\r\n            // right is closer, push left to stack\r\n            stack_push(&stack, node.leftIndex);\r\n            nearIndex = node.rightIndex;\r\n          }\r\n        }\r\n        nodeIndex = nearIndex;\r\n      }\r\n      // We only hit the right Node\r\n      else if(hitRight){\r\n        nodeIndex = node.rightIndex;\r\n      }\r\n      // We didn't hit any node, pop the stack\r\n      else{\r\n        nodeIndex = stack_pop(&stack);\r\n      }\r\n    }\r\n    // valid leaf, raymarch it\r\n    else if(node.objectCount == 1){\r\n        let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\r\n        if(distanceToLeaf > closestRayMarchDistance){\r\n          nodeIndex = stack_pop(&stack);\r\n          continue;\r\n        }\r\n        let worldPos = rayOrigin + rayDirection * distanceToLeaf;\r\n        let voxelObject = voxelObjects[node.leftIndex];\r\n//         var rayMarchResult = rayMarchTransformed(voxelObject, rayDirection, worldPos, 0);\r\n        var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, rayOrigin);\r\n//        rayMarchResult.voxelObjectIndex = node.leftIndex;\r\n//               var rayMarchResult = RayMarchResult();\r\n\r\n        let totalDistance = rayMarchResult.t + distanceToLeaf;\r\n        if(rayMarchResult.hit){\r\n          closestIntersection = rayMarchResult;\r\n          closestRayMarchDistance = totalDistance;\r\n          break;\r\n        }\r\n\r\n        nodeIndex = stack_pop(&stack);\r\n    }\r\n\r\n    iterations += 1;\r\n//    closestIntersection.colour += vec3<f32>(0.075);\r\n  }\r\n\r\n  return closestIntersection;\r\n}\r\n\r\nconst MAX_SHADOW_BVH_VISITS = 32;\r\n\r\nfn rayMarchBVHShadows(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, mipLevel: u32) -> RayMarchResult {\r\n   var closestIntersection = RayMarchResult();\r\n   closestIntersection.t = FAR_PLANE;\r\n\r\n   // Create a stack to store the nodes to visit\r\n   var stack = stack_new();\r\n   stack_push(&stack, 0);\r\n\r\n   var iterations = 0;\r\n   var nodeIndex = 0;\r\n\r\n   while (stack.head > 0u && iterations < MAX_SHADOW_BVH_VISITS) {\r\n     let node = bvhNodes[nodeIndex];\r\n     if(node.objectCount > 1){\r\n       let leftNode = bvhNodes[node.leftIndex];\r\n       let rightNode = bvhNodes[node.rightIndex];\r\n       let leftDist = getDistanceToNode(rayOrigin, rayDirection, leftNode);\r\n       let rightDist = getDistanceToNode(rayOrigin, rayDirection, rightNode);\r\n       let hitLeft = leftDist >= 0.0;\r\n       let hitRight = rightDist >= 0.0;\r\n       if(hitLeft){\r\n         var nearIndex = node.leftIndex;\r\n         // We hit both left and right, choose the closest one\r\n         if(hitRight){\r\n           if(leftDist < rightDist){\r\n             // left is closer, push right to stack\r\n             stack_push(&stack, node.rightIndex);\r\n           } else {\r\n             // right is closer, push left to stack\r\n             stack_push(&stack, node.leftIndex);\r\n             nearIndex = node.rightIndex;\r\n           }\r\n         }\r\n         nodeIndex = nearIndex;\r\n       }\r\n       // We only hit the right Node\r\n       else if(hitRight){\r\n         nodeIndex = node.rightIndex;\r\n       }\r\n       // We didn't hit any node, pop the stack\r\n       else{\r\n         nodeIndex = stack_pop(&stack);\r\n       }\r\n     }\r\n     // valid leaf, raymarch it\r\n     else if(node.objectCount == 1){\r\n         let distanceToLeaf = getDistanceToNode(rayOrigin, rayDirection, node);\r\n         if(distanceToLeaf < 0.0){\r\n           nodeIndex = stack_pop(&stack);\r\n           continue;\r\n         }\r\n         let worldPos = rayOrigin + rayDirection * distanceToLeaf;\r\n         let voxelObject = voxelObjects[node.leftIndex];\r\n         var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, worldPos);\r\n//         var rayMarchResult = rayMarchTransformed(voxelObject, rayDirection, worldPos, mipLevel);\r\n         rayMarchResult.t += distanceToLeaf;\r\n//\r\n         rayMarchResult.voxelObjectIndex = node.leftIndex;\r\n         if(rayMarchResult.hit){\r\n           return rayMarchResult;\r\n         }\r\n\r\n         nodeIndex = stack_pop(&stack);\r\n     }\r\n\r\n     iterations += 1;\r\n //    closestIntersection.colour += vec3<f32>(0.0075);\r\n   }\r\n\r\n   return closestIntersection;\r\n }",tt="struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\r\n\r\n\r\nfn plainIntersect(ro: vec3<f32>, rd: vec3<f32>, p: vec4<f32>) -> f32 {\r\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\r\n}\r\n\r\nfn getVelocityStatic(worldPos: vec3<f32>, viewProjections:ViewProjectionMatrices) -> vec2<f32>{\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  let clipSpace = vp * vec4(worldPos.xyz, 1.0);\r\n  let previousClipSpace = previousVp * vec4(worldPos.xyz, 1.0);\r\n\r\n  let ndc = clipSpace.xyz / clipSpace.w;\r\n  let previousNdc = previousClipSpace.xyz / previousClipSpace.w;\r\n\r\n  var uv = ndc.xy * 0.5 + 0.5;\r\n  var previousUv = previousNdc.xy * 0.5 + 0.5;\r\n\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getVelocity(objectPos: vec3<f32>, modelMatrix: mat4x4<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec2<f32> {\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  // Get current object space position of the current pixel\r\n  let objectClipSpace = vp * modelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let objectNDC = objectClipSpace.xyz / objectClipSpace.w;\r\n\r\n  // Get previous position of the current object space position\r\n  let previousObjectClipSpace = previousVp * previousModelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let previousObjectNDC = previousObjectClipSpace.xyz / previousObjectClipSpace.w;\r\n\r\n  // UV\r\n  var uv = objectNDC.xy * 0.5 + 0.5;\r\n  var previousUv = previousObjectNDC.xy * 0.5 + 0.5;\r\n  uv.y = 1.0 - uv.y;\r\n  previousUv.y = 1.0 - previousUv.y;\r\n\r\n  // Get velocity based on the difference between the current and previous positions\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getLeftChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 1;\r\n}\r\n\r\nfn getRightChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 2;\r\n}\r\n\r\nfn getParentIndex(index: i32) -> i32 {\r\n  return (index - 1) / 2;\r\n}\r\n\r\n\r\nfn dirIsNegative(dir: vec3<f32>, axis: i32) -> bool {\r\n  return dir[axis] < 0.0;\r\n}\r\n\r\nfn getDebugColour(index: i32) -> vec3<f32> {\r\n  let colours = array<vec3<f32>, 6>(\r\n    vec3<f32>(1.0, 0.0, 0.0),\r\n    vec3<f32>(0.0, 1.0, 0.0),\r\n    vec3<f32>(0.0, 0.0, 1.0),\r\n    vec3<f32>(1.0, 1.0, 0.0),\r\n    vec3<f32>(1.0, 0.0, 1.0),\r\n    vec3<f32>(0.0, 1.0, 1.0)\r\n  );\r\n  return colours[index % 6];\r\n}\r\n\r\n\r\nfn customNormalize(value: f32, min: f32, max: f32) -> f32 {\r\n    return (value - min) / (max - min);\r\n}\r\n\r\nconst IDENTITY_MATRIX = mat4x4<f32>(\r\n  vec4<f32>(1.0, 0.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 1.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n);\r\n\r\nfn intersectSphere(origin: vec3<f32>, dir: vec3<f32>, spherePos: vec3<f32>, sphereRad: f32) -> f32\r\n{\r\n\tlet oc = origin - spherePos;\r\n\tlet b = 2.0 * dot(dir, oc);\r\n\tlet c = dot(oc, oc) - sphereRad*sphereRad;\r\n\tlet disc = b * b - 4.0 * c;\r\n\tif (disc < 0.0)\r\n\t{\r\n\t  return -1.0;\r\n\t}\r\n\r\n//    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\r\n  let q = (-b + select(sqrt(disc), -sqrt(disc), b < 0.0)) / 2.0;\r\n\tvar t0 = q;\r\n\tvar t1 = c / q;\r\n\tif (t0 > t1) {\r\n\t\tvar temp = t0;\r\n\t\tt0 = t1;\r\n\t\tt1 = temp;\r\n\t}\r\n\tif (t1 < 0.0){\r\n\t  return -1.0;\r\n\t}\r\n\r\n  return select(t0, t1, t0 < 0.0);\r\n}\r\n\r\nfn skyDomeIntersection(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\r\n    return intersectSphere(ro, rd, vec3<f32>(0.0, 0.0, 0.0), 100.0);\r\n}\r\n\r\nfn reprojectWorldPos(worldPos: vec3<f32>, viewProjections: ViewProjectionMatrices) -> vec3<f32> {\r\n  let clipSpace = viewProjections.previousViewProjection * vec4(worldPos.xyz, 1.0);\r\n  return 0.5 * (clipSpace.xyz / clipSpace.w) + 0.5;\r\n}\r\n\r\nfn reprojectObjectWorldPos(worldPos: vec3<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec3<f32> {\r\n  let clipSpace = viewProjections.previousViewProjection * previousModelMatrix * vec4(worldPos.xyz, 1.0);\r\n  return 0.5 * (clipSpace.xyz / clipSpace.w) + 0.5;\r\n}\r\n\r\nfn simplePhongShading(normal: vec3<f32>, lightDir: vec3<f32>, lightColour: vec3<f32>, ambient: vec3<f32>, diffuse: vec3<f32>, specular: vec3<f32>, shininess: f32) -> vec3<f32> {\r\n  let nDotL = max(dot(normal, lightDir), 0.0);\r\n  let diffuseComponent = lightColour * diffuse * nDotL;\r\n\r\n  let reflectDir = reflect(-lightDir, normal);\r\n  let viewDir = normalize(vec3<f32>(0.0, 0.0, 1.0));\r\n  let spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\r\n  let specularComponent = lightColour * specular * spec;\r\n\r\n  return ambient + diffuseComponent + specularComponent;\r\n}\r\n\r\nfn tracePixel(pixel: vec2<u32>){\r\n   let resolution = textureDimensions(albedoTex);\r\n   var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\r\n   let rayDirection = calculateRayDirection(uv,viewProjections.inverseViewProjection);\r\n    var rayOrigin = cameraPosition;\r\n    var closestIntersection = RayMarchResult();\r\n\r\n    let bvhResult = rayMarchBVH(rayOrigin, rayDirection);\r\n//    if(!bvhResult.hit){\r\n//      textureStore(albedoTex, pixel, vec4(0));\r\n//      textureStore(normalTex, pixel, vec4(0));\r\n//      textureStore(depthWrite, pixel, vec4(0));\r\n//      let worldPos = rayOrigin + skyDomeIntersection(rayOrigin, rayDirection) * rayDirection;\r\n//      let velocity = getVelocityStatic(worldPos, viewProjections);\r\n//      textureStore(velocityTex, pixel, vec4(velocity,0, -1.0));\r\n//      return;\r\n//    }\r\n    closestIntersection = bvhResult;\r\n\r\n    let voxelObject = voxelObjects[closestIntersection.voxelObjectIndex];\r\n    let albedo = closestIntersection.colour;\r\n//\r\n//    var albedo = vec3<f32>(0.0);\r\n//    if(closestIntersection.hit){\r\n//        let paletteX = i32(closestIntersection.colour.r * 255.0);\r\n//        let paletteY = i32(voxelObject.paletteIndex);\r\n//        albedo = textureLoad(paletteTex, vec2(paletteX, paletteY), 0).rgb;\r\n//    }\r\n\r\n    let normal = transformNormal(voxelObject.inverseTransform,vec3<f32>(closestIntersection.normal));\r\n    let worldPos = rayOrigin + rayDirection * closestIntersection.t;\r\n    let velocity = getVelocityStatic(worldPos, viewProjections);\r\n    let cameraDistance = closestIntersection.t;\r\n//    let normalisedDepth = distanceToReversedLinearDepth(cameraDistance, NEAR_PLANE, FAR_PLANE);\r\nlet logDepth = distanceToLogarithmicDepth(cameraDistance, NEAR_PLANE, FAR_PLANE);\r\n\r\n//    textureStore(albedoTex, pixel, vec4(albedo, 1));\r\n//    let lightDirection = normalize(vec3<f32>(0.0, 0.5, 0.5));\r\n//    let lightColour = vec3<f32>(1.0);\r\n//    let ambientColour = vec3<f32>(0.5);\r\n//    let diffuseColour = vec3<f32>(0.2);\r\n//    let specularColour = vec3<f32>(0.5);\r\n//    let shininess = 1.0;\r\n//    var shaded = simplePhongShading(normal, lightDirection, lightColour, ambientColour, diffuseColour, specularColour, shininess) * albedo;\r\n//    if(all(shaded <= vec3(0.0))){\r\n//      shaded = vec3<f32>(uv.y, uv.y * 0.5, 1.0);\r\n//    }\r\n//    textureStore(albedoTex, pixel, vec4(shaded, 1));\r\n//    if(!bvhResult.hit){\r\n//      var debugColour = vec4(closestIntersection.normal, 1);\r\n//      var debugColour = vec4(f32(closestIntersection.iterations)/ 64.0);\r\n//      textureStore(albedoTex, pixel, debugColour);\r\n//    }\r\n    textureStore(albedoTex, pixel, vec4(albedo, 1));\r\n    textureStore(normalTex, pixel, vec4(normal,1));\r\n    textureStore(velocityTex, pixel, vec4(velocity,0,f32(closestIntersection.voxelObjectIndex)));\r\n    textureStore(depthWrite, pixel, vec4(logDepth));\r\n}\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn main(\r\n   @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  tracePixel(pixel);\r\n}\r\n\r\n@group(1) @binding(0) var<storage, read> screenRayBuffer : array<vec2<u32>>;\r\n\r\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\r\n  vec2<u32>(0,1),\r\n  vec2<u32>(1,0),\r\n  vec2<u32>(1,1),\r\n  vec2<u32>(2,0),\r\n  vec2<u32>(2,1),\r\n  vec2<u32>(0,2),\r\n  vec2<u32>(1,2),\r\n  vec2<u32>(2,2)\r\n);\r\n\r\n@compute @workgroup_size(64, 1, 1)\r\nfn bufferMarch(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n) {\r\n  let bufferIndex = GlobalInvocationID.x / 8;\r\n  let localRayIndex = GlobalInvocationID.x % 8;\r\n  let pixel = screenRayBuffer[bufferIndex];\r\n  let offsetPixel = pixel + REMAINING_RAY_OFFSETS[localRayIndex];\r\n\r\n  tracePixel(offsetPixel);\r\n//  textureStore(depthWrite, offsetPixel, vec4(0,0,0,0));\r\n//   textureStore(albedoTex, offsetPixel, vec4(1,0,0,1));\r\n}",rt=Symbol(),nt=e=>new Proxy(e,{construct:(e,t,r)=>e.prototype!==r.prototype?Reflect.construct(e,t,r):(e[rt]||(e[rt]=Reflect.construct(e,t,r)),e[rt])});const it=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,st=(e,t,r=it)=>{let n=class{#e;#t;#r;#n;#i=t;#s=r;#o=e;constructor(n,i,s){this.#e=n.createTexture({label:e,size:[i,s,1],format:t,usage:r}),this.#t=this.#e.createView({label:e}),this.#r=i,this.#n=s}get texture(){return this.#e}get view(){return this.#t}get width(){return this.#r}get height(){return this.#n}get format(){return this.#i}get usage(){return this.#s}get label(){return this.#o}};return n=function(e,t,r,n){var i,s=arguments.length,o=s<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,r,n);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,r,o):i(t,r))||o);return s>3&&o&&Object.defineProperty(t,r,o),o}([nt],n),n},ot=st("albedo","rgba8unorm"),at=st("normal","rgba16float"),ct=st("depth",Ke,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST),lt=st("velocity","rgba16float"),ut=st("world position","rgba32float"),ht=st("output",Xe),dt=async()=>{const e=await(async()=>{const e=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba32float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}}]}),t=await bs.createComputePipelineAsync({label:"reconstruct world pos",layout:bs.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:bs.createShaderModule({code:`\n          ${Ye}\n          ${He}\n          struct ViewProjectionMatrices {\n            viewProjection : mat4x4<f32>,\n            previousViewProjection : mat4x4<f32>,\n            inverseViewProjection : mat4x4<f32>,\n            projection : mat4x4<f32>,\n            inverseProjection: mat4x4<f32>\n          };\n          \n          @group(0) @binding(0) var depthTex : texture_2d<f32>;\n          @group(0) @binding(1) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(2) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(3) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n        \n          const NEAR_PLANE = 0.5;\n          const FAR_PLANE = 10000.0;\n         \n          \n          @compute @workgroup_size(8, 8, 1)\n          fn main(\n            @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\n          ) {\n            let resolution = textureDimensions(worldPosTex);\n            let pixel = GlobalInvocationID.xy;\n            var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\n            let depth = textureLoad(depthTex, pixel, 0).r;\n            let distanceToSurface = logarithmicDepthToDistance(depth, NEAR_PLANE, FAR_PLANE);\n            let rayDirection = calculateRayDirection(uv, viewProjections.inverseViewProjection);\n            var worldPos = cameraPosition + rayDirection * distanceToSurface;\n            \n            if(depth == 0.0) {\n              worldPos = vec3<f32>(0.0, 0.0, 0.0);\n            }\n            \n            //let normal = computeNormalImproved(vec2<i32>(pixel)); \n            //textureStore(normalTex, pixel, vec4(normal, 1));\n            textureStore(worldPosTex, pixel, vec4(worldPos, 1));\n          }\n`}),entryPoint:"main"}});let r;return(n,i)=>{r||(r=(t=>bs.createBindGroup({layout:e,entries:[{binding:0,resource:t.outputTextures.depthTexture.view},{binding:1,resource:{buffer:t.viewProjectionMatricesBuffer}},{binding:2,resource:t.outputTextures.worldPositionTexture.view},{binding:3,resource:{buffer:t.cameraPositionBuffer}},{binding:4,resource:t.outputTextures.normalTexture.view}]}))(i)),n.setPipeline(t),n.setBindGroup(0,r),n.dispatchWorkgroups(Math.ceil(ws[0]/8),Math.ceil(ws[1]/8))}})(),t=await(async()=>{const e={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},t={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",viewDimension:"2d"}},r={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},n={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Ke,viewDimension:"2d"}},i={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},s={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:12,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},a={binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},c=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s,e,t,n,r,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},i,o,a]}),l=await bs.createComputePipelineAsync({label:"raymarch g-buffer",layout:bs.createPipelineLayout({bindGroupLayouts:[c]}),compute:{module:bs.createShaderModule({code:`\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba8unorm, write>;\n          @group(0) @binding(6) var depthWrite : texture_storage_2d<${Ke}, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(11) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(12) var paletteTex : texture_2d<f32>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${Ye}\n          ${Qe}\n          ${Je}\n          ${et}\n          ${He}\n          ${tt}`}),entryPoint:"main"}});let u;return(e,t)=>{u=(e=>bs.createBindGroup({layout:c,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.depthTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:12,resource:e.volumeAtlas.paletteTextureView},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),e.setPipeline(l),e.setBindGroup(0,u),e.dispatchWorkgroups(Math.ceil(ws[0]/16),Math.ceil(ws[1]/8))}})(),r=(await(async()=>{const e=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Ke,viewDimension:"2d"}},{binding:5,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},{binding:7,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),t=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),r=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),n=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),i=await bs.createComputePipelineAsync({label:"interpolate g-buffer",layout:bs.createPipelineLayout({bindGroupLayouts:[e,t,r,n]}),compute:{module:bs.createShaderModule({code:`${He}${Ye}struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\r\n\r\nstruct VoxelObject {\r\n  transform: mat4x4<f32>,\r\n  inverseTransform: mat4x4<f32>,\r\n  previousTransform: mat4x4<f32>,\r\n  previousInverseTransform: mat4x4<f32>,\r\n  size : vec3<f32>,\r\n  atlasLocation : vec3<f32>,\r\n  paletteIndex : f32,\r\n  octreeBufferIndex: u32\r\n}\r\n\r\n// Textures\r\n@group(0) @binding(0) var albedoTex : texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var albedoCopyTex : texture_2d<f32>;\r\n@group(0) @binding(2) var velocityTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(3) var velocityCopyTex : texture_2d<f32>;\r\n@group(0) @binding(4) var depthTex : texture_storage_2d<r32float, write>;\r\n@group(0) @binding(5) var depthCopyTex : texture_2d<f32>;\r\n@group(0) @binding(6) var normalTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(7) var normalCopyTex : texture_2d<f32>;\r\n\r\n// Camera\r\n@group(1) @binding(0) var<uniform> cameraPosition : vec3<f32>;\r\n@group(1) @binding(1) var<uniform> viewProjections : ViewProjectionMatrices;\r\n\r\n// Voxels\r\n@group(2) @binding(0) var<storage> voxelObjects : array<VoxelObject>;\r\n@group(2) @binding(1) var volumeAtlasTex : texture_3d<f32>;\r\n@group(2) @binding(2) var paletteTex : texture_2d<f32>;\r\n\r\n// Screen Rays\r\nstruct ScreenRay {\r\n  pixel : vec2<u32>,\r\n};\r\n@group(3) @binding(0) var<storage, read_write> indirectArgs : array<atomic<u32>>;\r\n@group(3) @binding(1) var<storage, read_write> screenRays : array<ScreenRay>;\r\n@group(3) @binding(2) var<storage, read_write> counter : array<atomic<u32>>;\r\n\r\nconst neighborOffsets = array<vec2<i32>, 4>(\r\n  vec2<i32>(0, 0),\r\n  vec2<i32>(3, 0),\r\n  vec2<i32>(0, 3),\r\n  vec2<i32>(3, 3)\r\n);\r\n\r\n// Normal is in voxel (object) space, so will only have 1 or -1 values on one axis\r\nfn isOnSharedPlane(\r\n  normal : vec3<f32>,\r\n  voxelPos : vec3<f32>,\r\n  neighborVoxelPos : vec3<f32>,\r\n  neighborNormal : vec3<f32>\r\n) -> bool {\r\n  let epsilon = 0.001;\r\n  if(abs(neighborNormal.y) > 0.0 && abs(normal.y) > 0.0){\r\n    return abs(voxelPos.y - neighborVoxelPos.y) < epsilon;\r\n  }\r\n  if(abs(neighborNormal.x) > 0.0 && abs(normal.x) > 0.0){\r\n    return abs(voxelPos.x - neighborVoxelPos.x) < epsilon;\r\n  }\r\n  if(abs(neighborNormal.z) > 0.0 && abs(normal.z) > 0.0){\r\n    return abs(voxelPos.z - neighborVoxelPos.z) < epsilon;\r\n  }\r\n  return false;\r\n}\r\n\r\nconst NEAR_PLANE = 0.5;\r\nconst FAR_PLANE = 10000.0;\r\n\r\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\r\n  vec2<u32>(0,1),\r\n  vec2<u32>(1,0),\r\n  vec2<u32>(1,1),\r\n  vec2<u32>(2,0),\r\n  vec2<u32>(2,1),\r\n  vec2<u32>(0,2),\r\n  vec2<u32>(1,2),\r\n  vec2<u32>(2,2)\r\n);\r\n\r\n// Increment the count of the ray buffers, and only increment the dispatch indirect args every 8 rays, due to the 64x1x1 workgroup size (8 ray groups, 8 rays per group)\r\nfn incrementCounters() -> u32{\r\n  let count = atomicAdd(&counter[0], 1);\r\n  if(count % 8 == 0){\r\n   atomicAdd(&indirectArgs[0], 1);\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n  * Interpolate the depth, normal and uv of the pixel from the 4 nearest neighbors\r\n  * if not valid for interpolation, add to a ray buffer for use in the next pass\r\n  * Ray buffer is a list of pixel groups that need to be re-marched at full resolution\r\n  * The stored value is the origin of the group ([0,0] in a [3x3] kernel)\r\n  */\r\n@compute @workgroup_size(16, 16, 1)\r\n fn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n) {\r\n  let texSize = textureDimensions(albedoCopyTex);\r\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\r\n  let uv = vec2<f32>(pixel) / vec2<f32>(texSize);\r\n  let nearestFilledPixel = (pixel / 3) * 3;\r\n  let isOriginPixel = all(pixel == nearestFilledPixel);\r\n\r\n  let isCornerPixel = all(pixel == nearestFilledPixel + vec2(2));\r\n  let nearestUV = vec2<f32>(nearestFilledPixel) / vec2<f32>(texSize);\r\n  let velocityRef = textureLoad(velocityCopyTex, nearestFilledPixel, 0);\r\n  let depthRef = textureLoad(depthCopyTex, nearestFilledPixel, 0).r;\r\n  let distanceToSurface = logarithmicDepthToDistance(depthRef, NEAR_PLANE, FAR_PLANE);\r\n\r\n  // disable interpolation for distances greater than 1000, due to precision issues\r\n//  if(distanceToSurface > 9000){\r\n//    if(isOriginPixel){\r\n//      // Add to ray buffer\r\n//      let count = incrementCounters();\r\n//      screenRays[count].pixel = vec2<u32>(pixel);\r\n//    }else{\r\n//      textureStore(albedoTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n//      textureStore(normalTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n//      textureStore(velocityTex, pixel, vec4(velocityRef.xyz, -1.0));\r\n//      textureStore(depthTex, pixel, vec4(0.0));\r\n//    }\r\n//    return;\r\n//  }\r\n\r\n  var hasFoundObject = false;\r\n  // Check if each neightbor is the same object\r\n  for(var i = 1; i < 4; i = i + 1) {\r\n    let objectIndex = textureLoad(velocityCopyTex, nearestFilledPixel + neighborOffsets[i], 0).a;\r\n    if(objectIndex != velocityRef.a) {\r\n       if(isOriginPixel){\r\n         // Add to ray buffer\r\n         let count = incrementCounters();\r\n         screenRays[count].pixel = vec2<u32>(pixel);\r\n       }\r\n       return;\r\n    }\r\n    if(objectIndex != -1.0) {\r\n      hasFoundObject = true;\r\n    }\r\n  }\r\n  if(!hasFoundObject) {\r\n    // Dont march any more rays - we have hit the sky\r\n    textureStore(velocityTex, pixel, vec4(velocityRef.xyz, -1.0));\r\n    textureStore(depthTex, pixel, vec4(0.0));\r\n    textureStore(normalTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n    textureStore(albedoTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n    return;\r\n  }\r\n  let voxelObject = voxelObjects[i32(velocityRef.a)];\r\n\r\n  let normalRef = textureLoad(normalCopyTex, nearestFilledPixel, 0).xyz;\r\n  let localNormal = (voxelObject.inverseTransform * vec4(normalRef, 0.0)).xyz;\r\n  let rayDirection = calculateRayDirection(nearestUV, viewProjections.inverseViewProjection);\r\n  let worldPosRef = cameraPosition + rayDirection * distanceToSurface;\r\n  let localPosRef = (voxelObject.inverseTransform * vec4(worldPosRef, 1.0)).xyz;\r\n  let voxelPosRef = floor(localPosRef);\r\n\r\n  // Check if each neightbor is the same voxel plane\r\n  for(var i = 0; i < 4; i = i + 1) {\r\n    let neighborPixel = nearestFilledPixel + neighborOffsets[i];\r\n    let neighborUV = vec2<f32>(neighborPixel) / vec2<f32>(texSize);\r\n    let neighborDepth = textureLoad(depthCopyTex, neighborPixel, 0).r;\r\n    let neighborNormal = textureLoad(normalCopyTex, neighborPixel, 0).xyz;\r\n    let neighborLocalNormal = (voxelObject.inverseTransform * vec4(neighborNormal, 0.0)).xyz;\r\n    let neighborRayDirection = calculateRayDirection(neighborUV, viewProjections.inverseViewProjection);\r\n    let neighborWorldPos = cameraPosition + neighborRayDirection * logarithmicDepthToDistance(neighborDepth, NEAR_PLANE, FAR_PLANE);\r\n    let neighborLocalPos = (voxelObject.inverseTransform * vec4(neighborWorldPos, 1.0)).xyz;\r\n    let neighborVoxelPos = floor(neighborLocalPos);\r\n\r\n    if(!isOnSharedPlane(localNormal, voxelPosRef, neighborVoxelPos, neighborLocalNormal)) {\r\n      if(isOriginPixel){\r\n        // Add to ray buffer\r\n        let count = incrementCounters();\r\n        screenRays[count].pixel = vec2<u32>(pixel);\r\n      }else{\r\n        textureStore(albedoTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n        textureStore(normalTex, pixel, vec4(0.0, 0.0, 0.0, 1.0));\r\n        textureStore(velocityTex, pixel, vec4(velocityRef.xyz, -1.0));\r\n        textureStore(depthTex, pixel, vec4(0.0));\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  let pixel0 = nearestFilledPixel;\r\n  let pixel1 = nearestFilledPixel + vec2<i32>(3, 0);\r\n  let pixel2 = nearestFilledPixel + vec2<i32>(0, 3);\r\n  let pixel3 = nearestFilledPixel + vec2<i32>(3, 3);\r\n\r\n  // Interpolate\r\n  let normal0 = normalRef;\r\n  let normal1 = textureLoad(normalCopyTex, pixel1, 0).xyz;\r\n  let normal2 = textureLoad(normalCopyTex, pixel2, 0).xyz;\r\n  let normal3 = textureLoad(normalCopyTex, pixel3, 0).xyz;\r\n\r\n  let depth0 = depthRef;\r\n  let depth1 = textureLoad(depthCopyTex, pixel1, 0).r;\r\n  let depth2 = textureLoad(depthCopyTex, pixel2, 0).r;\r\n  let depth3 = textureLoad(depthCopyTex, pixel3, 0).r;\r\n\r\n  let xInterp = f32(pixel.x) % 3.0 / 3.0;\r\n  let yInterp = f32(pixel.y) % 3.0 / 3.0;\r\n\r\n  let depthBottom = mix(depth0, depth1, xInterp);\r\n  let depthTop = mix(depth2, depth3, xInterp);\r\n  let depth = mix(depthBottom, depthTop, yInterp);\r\n\r\n  let normalTop = mix(normal0, normal1, xInterp);\r\n  let normalBottom = mix(normal2, normal3, xInterp);\r\n  let normal = mix(normalTop, normalBottom, yInterp);\r\n\r\n  let worldPos =\r\n    cameraPosition\r\n    + calculateRayDirection(uv, viewProjections.inverseViewProjection)\r\n    * logarithmicDepthToDistance(depth, NEAR_PLANE, FAR_PLANE);\r\n\r\n  let localPos = (voxelObject.inverseTransform * vec4(worldPos, 1.0)).xyz;\r\n  let voxelPos = floor(localPos);\r\n  let atlasSamplePos = vec3<i32>(voxelObject.atlasLocation + voxelPos);\r\n  let palettePos = textureLoad(volumeAtlasTex, atlasSamplePos, 0).r;\r\n  let paletteX = i32(palettePos* 255.0);\r\n  let paletteY = i32(voxelObject.paletteIndex);\r\n  let albedo = textureLoad(paletteTex, vec2(paletteX, paletteY), 0).rgb;\r\n\r\n  textureStore(albedoTex, pixel, vec4(albedo, 1.0));\r\n  textureStore(velocityTex, pixel, velocityRef);\r\n  textureStore(depthTex, pixel, vec4(depth));\r\n  textureStore(normalTex, pixel, vec4(normal, 1.0));\r\n\r\n}`}),entryPoint:"main"}});let s,o,a,c;return(l,u,h,d,f,p,m,v,g)=>{s||(s=((t,r,n,i,s)=>bs.createBindGroup({layout:e,entries:[{binding:0,resource:t.outputTextures.albedoTexture.view},{binding:1,resource:r},{binding:2,resource:t.outputTextures.velocityTexture.view},{binding:3,resource:n},{binding:4,resource:t.outputTextures.depthTexture.view},{binding:5,resource:i},{binding:6,resource:t.outputTextures.normalTexture.view},{binding:7,resource:s}]}))(u,h,d,f,p)),o||(o=(e=>bs.createBindGroup({layout:t,entries:[{binding:0,resource:{buffer:e.cameraPositionBuffer}},{binding:1,resource:{buffer:e.viewProjectionMatricesBuffer}}]}))(u)),a||(a=(e=>bs.createBindGroup({layout:r,entries:[{binding:0,resource:{buffer:e.transformationMatrixBuffer}},{binding:1,resource:e.volumeAtlas.atlasTextureView},{binding:2,resource:e.volumeAtlas.paletteTextureView}]}))(u)),c||(c=((e,t,r)=>bs.createBindGroup({layout:n,entries:[{binding:0,resource:{buffer:e}},{binding:1,resource:{buffer:t}},{binding:2,resource:{buffer:r}}]}))(m,v,g)),l.setPipeline(i),l.setBindGroup(0,s),l.setBindGroup(1,o),l.setBindGroup(2,a),l.setBindGroup(3,c),l.dispatchWorkgroups(Math.ceil(ws[0]/16),Math.ceil(ws[1]/8))}})(),await(async()=>{const e={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},t={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",viewDimension:"2d"}},r={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},n={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Ke,viewDimension:"2d"}},i={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},s={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:12,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},a={binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},c=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s,e,t,n,r,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},i,o,a]}),l=bs.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),u=await bs.createComputePipelineAsync({label:"raymarch g-buffer indirect",layout:bs.createPipelineLayout({bindGroupLayouts:[c,l]}),compute:{module:bs.createShaderModule({code:`\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba8unorm, write>;\n          @group(0) @binding(6) var depthWrite : texture_storage_2d<${Ke}, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(11) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(12) var paletteTex : texture_2d<f32>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${Ye}\n          ${Qe}\n          ${Je}\n          ${et}\n          ${He}\n          ${tt}`}),entryPoint:"bufferMarch"}});let h,d;return(e,t,r,n)=>{h=(e=>bs.createBindGroup({layout:c,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.depthTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:12,resource:e.volumeAtlas.paletteTextureView},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),d=(e=>bs.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:e}}]}))(r),e.setPipeline(u),e.setBindGroup(0,h),e.setBindGroup(1,d),e.dispatchWorkgroupsIndirect(n,0)}})());let n,i,s,o={albedoTexture:null,velocityTexture:null,depthTexture:null,normalTexture:null};return{render:a=>{if(!i){i=bs.createBuffer({size:12,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),n=bs.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const e=new Uint32Array(3);e[0]=1,e[1]=1,e[2]=1,bs.queue.writeBuffer(i,0,e,0,e.length);const{width:t,height:r}=a.outputTextures.finalTexture,o=(c=t/3*(r/3)*4,4,4*Math.ceil(c/4));s=bs.createBuffer({size:o,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}var c;Object.keys(o).forEach((e=>{const t=a.outputTextures[e];null===o[e]&&(o[e]=((e,t)=>new(st(`${t.label}-copy`,t.format,t.usage))(e,t.width,t.height))(bs,t))}));const{commandEncoder:l,timestampWrites:u}=a;l.clearBuffer(i,0,4),l.clearBuffer(n,0,4),l.clearBuffer(s);let h=l.beginComputePass({timestampWrites:u});t(h,a),h.end(),Object.keys(o).forEach((e=>{const t=a.outputTextures[e],r=o[e];((e,t,r)=>{if(t.width!==r.width||t.height!==r.height)throw new Error("Source and destination textures must have the same dimensions");e.copyTextureToTexture({texture:t.texture},{texture:r.texture},{width:t.texture.width,height:t.texture.height,depthOrArrayLayers:1})})(l,t,r)})),h=l.beginComputePass({timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+4,endOfPassWriteIndex:u.endOfPassWriteIndex+4}}),r(h,a,s,i),h.end(),h=l.beginComputePass({timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+6,endOfPassWriteIndex:u.endOfPassWriteIndex+6}}),e(h,a),h.end()},label:"primary rays",timestampLabels:["sparse raymarch","interpolate","full raymarch","world pos reconstruct"]}},ft=async e=>{const t=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n//@group(0) @binding(2) var debugTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\nfn get_debug_colour(index : i32) -> vec4<f32> {\r\n  if(index < 0){\r\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\r\n  }\r\n\r\n  let colours = array(\r\n    vec4<f32>(1.0, 0.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(1.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\r\n  );\r\n  return colours[index % 8];\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n    let pixel = fragUV * vec2<f32>(textureDimensions(myTexture));\r\n    var colour = textureLoad(myTexture, vec2<u32>(pixel),0);\r\n    return colour;\r\n//    return colour;\r\n//    return abs(colour) % 8.0 * 0.125;\r\n//    return colour.gggg * 0.5;\r\n//    return (colour.rrrr * 500.0 % 1.0);\r\n//    return get_debug_colour(i32(colour.a));\r\n}\r\n"}),r=e.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vertex_main"},fragment:{module:t,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]}});return{render:t=>{const n=t.commandEncoder.beginRenderPass({timestampWrites:t.timestampWrites,colorAttachments:[{view:gs.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]}),i=e.createBindGroup({layout:r.getBindGroupLayout(0),entries:[{binding:1,resource:t.outputTextures.finalTexture.view}]});n.setPipeline(r),n.setBindGroup(0,i),n.draw(6),n.end()},label:"fullscreen quad"}};var pt;!function(e){const t=[];e.updateAll=e=>{for(const r of t)r.update(e)},e.register=e=>class extends e{constructor(...e){super(...e),t.push(this)}}}(pt||(pt={}));const mt={duration:.3,delay:0,endDelay:0,repeat:0,easing:"ease"},vt=e=>1e3*e,gt=e=>e/1e3,yt=()=>{},xt=e=>e;function bt(e,t=!0){if(e&&"finished"!==e.playState)try{e.stop?e.stop():(t&&e.commitStyles(),e.cancel())}catch(e){}}const wt=e=>e(),_t=(e,t,r=mt.duration)=>new Proxy({animations:e.map(wt).filter(Boolean),duration:r,options:t},Tt),Tt={get:(e,t)=>{const r=e.animations[0];switch(t){case"duration":return e.duration;case"currentTime":return gt((null==r?void 0:r[t])||0);case"playbackRate":case"playState":return null==r?void 0:r[t];case"finished":return e.finished||(e.finished=Promise.all(e.animations.map(St)).catch(yt)),e.finished;case"stop":return()=>{e.animations.forEach((e=>bt(e)))};case"forEachNative":return t=>{e.animations.forEach((r=>t(r,e)))};default:return void 0===(null==r?void 0:r[t])?void 0:()=>e.animations.forEach((e=>e[t]()))}},set:(e,t,r)=>{switch(t){case"currentTime":r=vt(r);case"playbackRate":for(let n=0;n<e.animations.length;n++)e.animations[n][t]=r;return!0}return!1}},St=e=>e.finished,Pt=e=>"object"==typeof e&&Boolean(e.createAnimation),kt=e=>"number"==typeof e,Et=e=>Array.isArray(e)&&!kt(e[0]),Mt=(e,t,r)=>-r*e+r*t+e,At=(e,t,r)=>t-e==0?1:(r-e)/(t-e);function Ct(e,t){const r=e[e.length-1];for(let n=1;n<=t;n++){const i=At(0,t,n);e.push(Mt(r,1,i))}}const It=(e,t,r)=>Math.min(Math.max(r,e),t);const zt=(e,t,r)=>(((1-3*r+3*t)*e+(3*r-6*t))*e+3*t)*e,Ot=1e-7,Rt=12;function Bt(e,t,r,n){if(e===t&&r===n)return xt;return i=>0===i||1===i?i:zt(function(e,t,r,n,i){let s,o,a=0;do{o=t+(r-t)/2,s=zt(o,n,i)-e,s>0?r=o:t=o}while(Math.abs(s)>Ot&&++a<Rt);return o}(i,0,1,e,r),t,n)}const Ut=e=>"function"==typeof e,Nt=e=>Array.isArray(e)&&kt(e[0]),Dt={ease:Bt(.25,.1,.25,1),"ease-in":Bt(.42,0,1,1),"ease-in-out":Bt(.42,0,.58,1),"ease-out":Bt(0,0,.58,1)},Lt=/\((.*?)\)/;function jt(e){if(Ut(e))return e;if(Nt(e))return Bt(...e);if(Dt[e])return Dt[e];if(e.startsWith("steps")){const t=Lt.exec(e);if(t){const e=t[1].split(",");return((e,t="end")=>r=>{const n=(r="end"===t?Math.min(r,.999):Math.max(r,.001))*e,i="end"===t?Math.floor(n):Math.ceil(n);return It(0,1,i/e)})(parseFloat(e[0]),e[1].trim())}}return xt}class Ft{constructor(e,t=[0,1],{easing:r,duration:n=mt.duration,delay:i=mt.delay,endDelay:s=mt.endDelay,repeat:o=mt.repeat,offset:a,direction:c="normal",autoplay:l=!0}={}){if(this.startTime=null,this.rate=1,this.t=0,this.cancelTimestamp=null,this.easing=xt,this.duration=0,this.totalDuration=0,this.repeat=0,this.playState="idle",this.finished=new Promise(((e,t)=>{this.resolve=e,this.reject=t})),r=r||mt.easing,Pt(r)){const e=r.createAnimation(t);r=e.easing,t=e.keyframes||t,n=e.duration||n}this.repeat=o,this.easing=Et(r)?xt:jt(r),this.updateDuration(n);const u=function(e,t=function(e){const t=[0];return Ct(t,e-1),t}(e.length),r=xt){const n=e.length,i=n-t.length;return i>0&&Ct(t,i),i=>{let s=0;for(;s<n-2&&!(i<t[s+1]);s++);let o=It(0,1,At(t[s],t[s+1],i));const a=function(e,t){return Et(e)?e[((e,t,r)=>{const n=t-e;return((r-e)%n+n)%n+e})(0,e.length,t)]:e}(r,s);return o=a(o),Mt(e[s],e[s+1],o)}}(t,a,Et(r)?r.map(jt):xt);this.tick=t=>{var r;let n=0;n=void 0!==this.pauseTime?this.pauseTime:(t-this.startTime)*this.rate,this.t=n,n/=1e3,n=Math.max(n-i,0),"finished"===this.playState&&void 0===this.pauseTime&&(n=this.totalDuration);const o=n/this.duration;let a=Math.floor(o),l=o%1;!l&&o>=1&&(l=1),1===l&&a--;const h=a%2;("reverse"===c||"alternate"===c&&h||"alternate-reverse"===c&&!h)&&(l=1-l);const d=n>=this.totalDuration?1:Math.min(l,1),f=u(this.easing(d));e(f),void 0===this.pauseTime&&("finished"===this.playState||n>=this.totalDuration+s)?(this.playState="finished",null===(r=this.resolve)||void 0===r||r.call(this,f)):"idle"!==this.playState&&(this.frameRequestId=requestAnimationFrame(this.tick))},l&&this.play()}play(){const e=performance.now();this.playState="running",void 0!==this.pauseTime?this.startTime=e-this.pauseTime:this.startTime||(this.startTime=e),this.cancelTimestamp=this.startTime,this.pauseTime=void 0,this.frameRequestId=requestAnimationFrame(this.tick)}pause(){this.playState="paused",this.pauseTime=this.t}finish(){this.playState="finished",this.tick(0)}stop(){var e;this.playState="idle",void 0!==this.frameRequestId&&cancelAnimationFrame(this.frameRequestId),null===(e=this.reject)||void 0===e||e.call(this,!1)}cancel(){this.stop(),this.tick(this.cancelTimestamp)}reverse(){this.rate*=-1}commitStyles(){}updateDuration(e){this.duration=e,this.totalDuration=e*(this.repeat+1)}get currentTime(){return this.t}set currentTime(e){void 0!==this.pauseTime||0===this.rate?this.pauseTime=e:this.startTime=performance.now()-e/this.rate}get playbackRate(){return this.rate}set playbackRate(e){this.rate=e}}class Gt{setAnimation(e){this.animation=e,null==e||e.finished.then((()=>this.clearAnimation())).catch((()=>{}))}clearAnimation(){this.animation=this.generator=void 0}}const qt=new WeakMap;function Vt(e){return qt.has(e)||qt.set(e,{transforms:[],values:new Map}),qt.get(e)}const Wt=["","X","Y","Z"],Yt={x:"translateX",y:"translateY",z:"translateZ"},Ht={syntax:"<angle>",initialValue:"0deg",toDefaultUnit:e=>e+"deg"},$t={translate:{syntax:"<length-percentage>",initialValue:"0px",toDefaultUnit:e=>e+"px"},rotate:Ht,scale:{syntax:"<number>",initialValue:1,toDefaultUnit:xt},skew:Ht},Xt=new Map,Zt=e=>`--motion-${e}`,Kt=["x","y","z"];["translate","scale","rotate","skew"].forEach((e=>{Wt.forEach((t=>{Kt.push(e+t),Xt.set(Zt(e+t),$t[e])}))}));const Qt=(e,t)=>Kt.indexOf(e)-Kt.indexOf(t),Jt=new Set(Kt),er=e=>Jt.has(e),tr=e=>e.sort(Qt).reduce(rr,"").trim(),rr=(e,t)=>`${e} ${t}(var(${Zt(t)}))`,nr=e=>e.startsWith("--"),ir=new Set,sr=(e,t)=>document.createElement("div").animate(e,t),or={cssRegisterProperty:()=>"undefined"!=typeof CSS&&Object.hasOwnProperty.call(CSS,"registerProperty"),waapi:()=>Object.hasOwnProperty.call(Element.prototype,"animate"),partialKeyframes:()=>{try{sr({opacity:[1]})}catch(e){return!1}return!0},finished:()=>Boolean(sr({opacity:[0,1]},{duration:.001}).finished),linearEasing:()=>{try{sr({opacity:0},{easing:"linear(0, 1)"})}catch(e){return!1}return!0}},ar={},cr={};for(const e in or)cr[e]=()=>(void 0===ar[e]&&(ar[e]=or[e]()),ar[e]);const lr=(e,t)=>Ut(e)?cr.linearEasing()?`linear(${((e,t)=>{let r="";const n=Math.round(t/.015);for(let t=0;t<n;t++)r+=e(At(0,n-1,t))+", ";return r.substring(0,r.length-2)})(e,t)})`:mt.easing:Nt(e)?ur(e):e,ur=([e,t,r,n])=>`cubic-bezier(${e}, ${t}, ${r}, ${n})`;function hr(e){return Yt[e]&&(e=Yt[e]),er(e)?Zt(e):e}const dr=(e,t)=>{t=hr(t);let r=nr(t)?e.style.getPropertyValue(t):getComputedStyle(e)[t];if(!r&&0!==r){const e=Xt.get(t);e&&(r=e.initialValue)}return r},fr=(e,t,r)=>{t=hr(t),nr(t)?e.style.setProperty(t,r):e.style[t]=r},pr=e=>"string"==typeof e;function mr(e,t){var r;let n=(null==t?void 0:t.toDefaultUnit)||xt;const i=e[e.length-1];if(pr(i)){const e=(null===(r=i.match(/(-?[\d.]+)([a-z%]*)/))||void 0===r?void 0:r[2])||"";e&&(n=t=>t+e)}return n}function vr(e,t,r,n={},i){const s=window.__MOTION_DEV_TOOLS_RECORD,o=!1!==n.record&&s;let a,{duration:c=mt.duration,delay:l=mt.delay,endDelay:u=mt.endDelay,repeat:h=mt.repeat,easing:d=mt.easing,persist:f=!1,direction:p,offset:m,allowWebkitAcceleration:v=!1,autoplay:g=!0}=n;const y=Vt(e),x=er(t);let b=cr.waapi();x&&((e,t)=>{Yt[t]&&(t=Yt[t]);const{transforms:r}=Vt(e);var n,i;i=t,-1===(n=r).indexOf(i)&&n.push(i),e.style.transform=tr(r)})(e,t);const w=hr(t),_=function(e,t){return e.has(t)||e.set(t,new Gt),e.get(t)}(y.values,w),T=Xt.get(w);return bt(_.animation,!(Pt(d)&&_.generator)&&!1!==n.record),()=>{const y=()=>{var t,r;return null!==(r=null!==(t=dr(e,w))&&void 0!==t?t:null==T?void 0:T.initialValue)&&void 0!==r?r:0};let S=function(e,t){for(let r=0;r<e.length;r++)null===e[r]&&(e[r]=r?e[r-1]:t());return e}((e=>Array.isArray(e)?e:[e])(r),y);const P=mr(S,T);if(Pt(d)){const e=d.createAnimation(S,"opacity"!==t,y,w,_);d=e.easing,S=e.keyframes||S,c=e.duration||c}if(nr(w)&&(cr.cssRegisterProperty()?function(e){if(!ir.has(e)){ir.add(e);try{const{syntax:t,initialValue:r}=Xt.has(e)?Xt.get(e):{};CSS.registerProperty({name:e,inherits:!1,syntax:t,initialValue:r})}catch(e){}}}(w):b=!1),x&&!cr.linearEasing()&&(Ut(d)||Et(d)&&d.some(Ut))&&(b=!1),b){T&&(S=S.map((e=>kt(e)?T.toDefaultUnit(e):e))),1!==S.length||cr.partialKeyframes()&&!o||S.unshift(y());const t={delay:vt(l),duration:vt(c),endDelay:vt(u),easing:Et(d)?void 0:lr(d,c),direction:p,iterations:h+1,fill:"both"};a=e.animate({[w]:S,offset:m,easing:Et(d)?d.map((e=>lr(e,c))):void 0},t),a.finished||(a.finished=new Promise(((e,t)=>{a.onfinish=e,a.oncancel=t})));const r=S[S.length-1];a.finished.then((()=>{f||(fr(e,w,r),a.cancel())})).catch(yt),v||(a.playbackRate=1.000001)}else if(i&&x)S=S.map((e=>"string"==typeof e?parseFloat(e):e)),1===S.length&&S.unshift(parseFloat(y())),a=new i((t=>{fr(e,w,P?P(t):t)}),S,Object.assign(Object.assign({},n),{duration:c,easing:d}));else{const t=S[S.length-1];fr(e,w,T&&kt(t)?T.toDefaultUnit(t):t)}return o&&s(e,t,S,{duration:c,delay:l,easing:d,repeat:h,offset:m},"motion-one"),_.setAnimation(a),a&&!g&&a.pause(),a}}const gr=(e,t)=>e[t]?Object.assign(Object.assign({},e),e[t]):Object.assign({},e);function yr(e,t,r){return Ut(e)?e(t,r):e}const xr=(br=Ft,function(e,t,r={}){const n=(e=function(e,t){return"string"==typeof e?e=document.querySelectorAll(e):e instanceof Element&&(e=[e]),Array.from(e||[])}(e)).length;Boolean(n),Boolean(t);const i=[];for(let s=0;s<n;s++){const o=e[s];for(const e in t){const a=gr(r,e);a.delay=yr(a.delay,s,n);const c=vr(o,e,t[e],a,br);i.push(c)}}return _t(i,r,r.duration)});var br;function wr(e,t={}){return _t([()=>{const r=new Ft(e,[0,1],t);return r.finished.catch((()=>{})),r}],t,t.duration)}function _r(e,t,r){return(Ut(e)?wr:xr)(e,t,r)}function Tr(e,t,r){const n=Math.max(t-5,0);return i=r-e(n),(s=t-n)?i*(1e3/s):0;var i,s}function Sr(e){return kt(e)&&!isNaN(e)}function Pr(e){return pr(e)?parseFloat(e):e}const kr=function(e){const t=new WeakMap;return(e={})=>{const r=new Map,n=(t=0,n=100,i=0,s=!1)=>{const o=`${t}-${n}-${i}-${s}`;return r.has(o)||r.set(o,(({from:e=0,velocity:t=0,power:r=.8,decay:n=.325,bounceDamping:i,bounceStiffness:s,changeTarget:o,min:a,max:c,restDistance:l=.5,restSpeed:u})=>{n=vt(n);const h={hasReachedTarget:!1,done:!1,current:e,target:e},d=e=>void 0===a?c:void 0===c||Math.abs(a-e)<Math.abs(c-e)?a:c;let f=r*t;const p=e+f,m=void 0===o?p:o(p);h.target=m,m!==p&&(f=m-e);const v=e=>-f*Math.exp(-e/n),g=e=>m+v(e),y=e=>{const t=v(e),r=g(e);h.done=Math.abs(t)<=l,h.current=h.done?m:r};let x,b;const w=e=>{var t;t=h.current,(void 0!==a&&t<a||void 0!==c&&t>c)&&(x=e,b=(({stiffness:e=100,damping:t=10,mass:r=1,from:n=0,to:i=1,velocity:s=0,restSpeed:o,restDistance:a}={})=>{s=s?gt(s):0;const c={done:!1,hasReachedTarget:!1,current:n,target:i},l=i-n,u=Math.sqrt(e/r)/1e3,h=((e=100,t=10,r=1)=>t/(2*Math.sqrt(e*r)))(e,t,r),d=Math.abs(l)<5;let f;if(o||(o=d?.01:2),a||(a=d?.005:.5),h<1){const e=u*Math.sqrt(1-h*h);f=t=>i-Math.exp(-h*u*t)*((h*u*l-s)/e*Math.sin(e*t)+l*Math.cos(e*t))}else f=e=>i-Math.exp(-u*e)*(l+(u*l-s)*e);return e=>{c.current=f(e);const t=0===e?s:Tr(f,e,c.current),r=Math.abs(t)<=o,l=Math.abs(i-c.current)<=a;var u,h,d;return c.done=r&&l,c.hasReachedTarget=(u=n,h=i,d=c.current,u<h&&d>=h||u>h&&d<=h),c}})({from:h.current,to:d(h.current),velocity:Tr(g,e,h.current),damping:i,stiffness:s,restDistance:l,restSpeed:u}))};return w(0),e=>{let t=!1;return b||void 0!==x||(t=!0,y(e),w(e)),void 0!==x&&e>x?(h.hasReachedTarget=!0,b(e-x)):(h.hasReachedTarget=!1,!t&&y(e),h)}})(Object.assign({from:t,to:n,velocity:i},e))),r.get(o)},i=(e,r)=>(t.has(e)||t.set(e,function(e,t=xt){let r,n=10,i=e(0);const s=[t(i.current)];for(;!i.done&&n<1e4;)i=e(n),s.push(t(i.done?i.target:i.current)),void 0===r&&i.hasReachedTarget&&(r=n),n+=10;const o=n-10;return 1===s.length&&s.push(i.current),{keyframes:s,duration:o/1e3,overshootDuration:(null!=r?r:o)/1e3}}(e,r)),t.get(e));return{createAnimation:(e,t=!0,r,s,o)=>{let a,c,l,u=0,h=xt;const d=e.length;if(t)if(h=mr(e,s?Xt.get(hr(s)):void 0),l=Pr(e[d-1]),d>1&&null!==e[0])c=Pr(e[0]);else{const e=null==o?void 0:o.generator;if(e){const{animation:t,generatorStartTime:r}=o,n=(null==t?void 0:t.startTime)||r||0,i=(null==t?void 0:t.currentTime)||performance.now()-n,s=e(i).current;c=s,u=Tr((t=>e(t).current),i,s)}else r&&(c=Pr(r()))}if(Sr(c)&&Sr(l)){const e=n(c,l,u,null==s?void 0:s.includes("scale"));a=Object.assign(Object.assign({},i(e,h)),{easing:"linear"}),o&&(o.generator=e,o.generatorStartTime=performance.now())}return a||(a={easing:"ease",duration:i(n(0,100)).overshootDuration}),a}}}}();var Er=function(e,t,r,n){var i,s=arguments.length,o=s<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,r,n);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,r,o):i(t,r))||o);return s>3&&o&&Object.defineProperty(t,r,o),o};let Mr=class{value;target;constructor(e){this.value=e,this.target=e}update(){_r((e=>{this.value=te.lerp(this.value,this.target,e)}),{easing:kr({velocity:2e-4*Ss})})}};Mr=Er([pt.register],Mr);let Ar=class{value;target;constructor(e){this.value=e,this.target=e}update(){_r((e=>{this.value=this.value+(this.target-this.value)*e}),{easing:kr({velocity:2e-4*Ss})})}};Ar=Er([pt.register],Ar);let Cr=class{value;target;constructor(e){this.value=e,this.target=e}update(){_r((e=>{this.value=Ge.slerp(this.value,this.target,e)}),{easing:kr({velocity:2e-4*Ss})})}};Cr=Er([pt.register],Cr);const Ir=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength,zr={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array},bool:{numElements:0,align:1,size:0,type:"bool",View:Uint32Array}},Or={...zr,"atomic<i32>":zr.i32,"atomic<u32>":zr.u32,"vec2<i32>":zr.vec2i,"vec2<u32>":zr.vec2u,"vec2<f32>":zr.vec2f,"vec2<f16>":zr.vec2h,"vec3<i32>":zr.vec3i,"vec3<u32>":zr.vec3u,"vec3<f32>":zr.vec3f,"vec3<f16>":zr.vec3h,"vec4<i32>":zr.vec4i,"vec4<u32>":zr.vec4u,"vec4<f32>":zr.vec4f,"vec4<f16>":zr.vec4h,"mat2x2<f32>":zr.mat2x2f,"mat2x2<f16>":zr.mat2x2h,"mat3x2<f32>":zr.mat3x2f,"mat3x2<f16>":zr.mat3x2h,"mat4x2<f32>":zr.mat4x2f,"mat4x2<f16>":zr.mat4x2h,"mat2x3<f32>":zr.mat2x3f,"mat2x3<f16>":zr.mat2x3h,"mat3x3<f32>":zr.mat3x3f,"mat3x3<f16>":zr.mat3x3h,"mat4x3<f32>":zr.mat4x3f,"mat4x3<f16>":zr.mat4x3h,"mat2x4<f32>":zr.mat2x4f,"mat2x4<f16>":zr.mat2x4h,"mat3x4<f32>":zr.mat3x4f,"mat3x4<f16>":zr.mat3x4h,"mat4x4<f32>":zr.mat4x4f,"mat4x4<f16>":zr.mat4x4h},Rr=(Br=Or,Object.keys(Br));var Br,Ur,Nr,Dr,Lr,jr;!function(e=[],t){const r=new Set;for(const n of Rr){const i=Or[n];r.has(i)||(r.add(i),i.flatten=e.includes(n)?t:!t)}}(),new WeakMap;class Fr{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class Gr{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(qr.instance);for(const r of e)r instanceof Array?this.searchBlock(r,t):r.search(t);t(Vr.instance)}}}class qr extends Gr{}qr.instance=new qr;class Vr extends Gr{}Vr.instance=new Vr;class Wr extends Gr{constructor(){super()}}class Yr extends Wr{constructor(e,t,r,n){super(),this.name=e,this.args=t,this.returnType=r,this.body=n}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}}class Hr extends Wr{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class $r extends Wr{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Xr extends Wr{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class Zr extends Wr{constructor(e,t,r,n){super(),this.init=e,this.condition=t,this.increment=r,this.body=n}get astNodeType(){return"for"}search(e){var t,r,n;null===(t=this.init)||void 0===t||t.search(e),null===(r=this.condition)||void 0===r||r.search(e),null===(n=this.increment)||void 0===n||n.search(e),this.searchBlock(this.body,e)}}class Kr extends Wr{constructor(e,t,r,n,i){super(),this.name=e,this.type=t,this.storage=r,this.access=n,this.value=i}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class Qr extends Wr{constructor(e,t,r){super(),this.name=e,this.type=t,this.value=r}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Jr extends Wr{constructor(e,t,r,n,i){super(),this.name=e,this.type=t,this.storage=r,this.access=n,this.value=i}get astNodeType(){return"let"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class en extends Wr{constructor(e,t,r,n,i){super(),this.name=e,this.type=t,this.storage=r,this.access=n,this.value=i}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}!function(e){e.increment="++",e.decrement="--"}(Ur||(Ur={})),function(e){e.parse=function(t){const r=t;if("parse"==r)throw new Error("Invalid value for IncrementOperator");return e[r]}}(Ur||(Ur={}));class tn extends Wr{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(Nr||(Nr={})),function(e){e.parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t}}(Nr||(Nr={}));class rn extends Wr{constructor(e,t,r){super(),this.operator=e,this.variable=t,this.value=r}get astNodeType(){return"assign"}search(e){this.value.search(e)}}class nn extends Wr{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}}class sn extends Wr{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class on extends Wr{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class an extends Wr{constructor(e,t,r,n){super(),this.condition=e,this.body=t,this.elseif=r,this.else=n}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class cn extends Wr{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class ln extends Wr{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class un extends Wr{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class hn extends Wr{constructor(){super()}get astNodeType(){return"discard"}}class dn extends Wr{constructor(){super()}get astNodeType(){return"break"}}class fn extends Wr{constructor(){super()}get astNodeType(){return"continue"}}class pn extends Wr{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class mn extends pn{constructor(e,t){super(e),this.members=t}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class vn extends pn{constructor(e,t,r){super(e),this.format=t,this.access=r}get astNodeType(){return"template"}}class gn extends pn{constructor(e,t,r,n){super(e),this.storage=t,this.type=r,this.access=n}get astNodeType(){return"pointer"}}class yn extends pn{constructor(e,t,r,n){super(e),this.attributes=t,this.format=r,this.count=n}get astNodeType(){return"array"}get isArray(){return!0}}class xn extends pn{constructor(e,t,r){super(e),this.format=t,this.access=r}get astNodeType(){return"sampler"}}class bn extends Gr{constructor(){super()}}class wn extends bn{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class _n extends bn{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}}class Tn extends bn{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class Sn extends bn{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this)}}class Pn extends bn{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,r;if(this.initializer instanceof _n){const n=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),i=null===(r=this.initializer.type)||void 0===r?void 0:r.name,s=e.structs.get(i),o=null==s?void 0:s.getMemberIndex(n);if(-1!=o)return this.initializer.args[o].evaluate(e);console.log(o)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class kn extends bn{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class En extends bn{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class Mn extends bn{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}}class An extends bn{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class Cn extends bn{constructor(){super()}}class In extends Cn{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}}class zn extends Cn{constructor(e,t,r){super(),this.operator=e,this.left=t,this.right=r}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class On extends Gr{constructor(){super()}}class Rn extends On{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class Bn extends On{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class Un extends Gr{constructor(e,t,r){super(),this.name=e,this.type=t,this.attributes=r}get astNodeType(){return"argument"}}class Nn extends Gr{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Dn extends Gr{constructor(e,t,r){super(),this.name=e,this.type=t,this.attributes=r}get astNodeType(){return"member"}}class Ln extends Gr{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(Lr||(Lr={}));class jn{constructor(e,t,r){this.name=e,this.type=t,this.rule=r}toString(){return this.name}}class Fn{}Dr=Fn,Fn.none=new jn("",Lr.reserved,""),Fn.eof=new jn("EOF",Lr.token,""),Fn.reserved={asm:new jn("asm",Lr.reserved,"asm"),bf16:new jn("bf16",Lr.reserved,"bf16"),do:new jn("do",Lr.reserved,"do"),enum:new jn("enum",Lr.reserved,"enum"),f16:new jn("f16",Lr.reserved,"f16"),f64:new jn("f64",Lr.reserved,"f64"),handle:new jn("handle",Lr.reserved,"handle"),i8:new jn("i8",Lr.reserved,"i8"),i16:new jn("i16",Lr.reserved,"i16"),i64:new jn("i64",Lr.reserved,"i64"),mat:new jn("mat",Lr.reserved,"mat"),premerge:new jn("premerge",Lr.reserved,"premerge"),regardless:new jn("regardless",Lr.reserved,"regardless"),typedef:new jn("typedef",Lr.reserved,"typedef"),u8:new jn("u8",Lr.reserved,"u8"),u16:new jn("u16",Lr.reserved,"u16"),u64:new jn("u64",Lr.reserved,"u64"),unless:new jn("unless",Lr.reserved,"unless"),using:new jn("using",Lr.reserved,"using"),vec:new jn("vec",Lr.reserved,"vec"),void:new jn("void",Lr.reserved,"void")},Fn.keywords={array:new jn("array",Lr.keyword,"array"),atomic:new jn("atomic",Lr.keyword,"atomic"),bool:new jn("bool",Lr.keyword,"bool"),f32:new jn("f32",Lr.keyword,"f32"),i32:new jn("i32",Lr.keyword,"i32"),mat2x2:new jn("mat2x2",Lr.keyword,"mat2x2"),mat2x3:new jn("mat2x3",Lr.keyword,"mat2x3"),mat2x4:new jn("mat2x4",Lr.keyword,"mat2x4"),mat3x2:new jn("mat3x2",Lr.keyword,"mat3x2"),mat3x3:new jn("mat3x3",Lr.keyword,"mat3x3"),mat3x4:new jn("mat3x4",Lr.keyword,"mat3x4"),mat4x2:new jn("mat4x2",Lr.keyword,"mat4x2"),mat4x3:new jn("mat4x3",Lr.keyword,"mat4x3"),mat4x4:new jn("mat4x4",Lr.keyword,"mat4x4"),ptr:new jn("ptr",Lr.keyword,"ptr"),sampler:new jn("sampler",Lr.keyword,"sampler"),sampler_comparison:new jn("sampler_comparison",Lr.keyword,"sampler_comparison"),struct:new jn("struct",Lr.keyword,"struct"),texture_1d:new jn("texture_1d",Lr.keyword,"texture_1d"),texture_2d:new jn("texture_2d",Lr.keyword,"texture_2d"),texture_2d_array:new jn("texture_2d_array",Lr.keyword,"texture_2d_array"),texture_3d:new jn("texture_3d",Lr.keyword,"texture_3d"),texture_cube:new jn("texture_cube",Lr.keyword,"texture_cube"),texture_cube_array:new jn("texture_cube_array",Lr.keyword,"texture_cube_array"),texture_multisampled_2d:new jn("texture_multisampled_2d",Lr.keyword,"texture_multisampled_2d"),texture_storage_1d:new jn("texture_storage_1d",Lr.keyword,"texture_storage_1d"),texture_storage_2d:new jn("texture_storage_2d",Lr.keyword,"texture_storage_2d"),texture_storage_2d_array:new jn("texture_storage_2d_array",Lr.keyword,"texture_storage_2d_array"),texture_storage_3d:new jn("texture_storage_3d",Lr.keyword,"texture_storage_3d"),texture_depth_2d:new jn("texture_depth_2d",Lr.keyword,"texture_depth_2d"),texture_depth_2d_array:new jn("texture_depth_2d_array",Lr.keyword,"texture_depth_2d_array"),texture_depth_cube:new jn("texture_depth_cube",Lr.keyword,"texture_depth_cube"),texture_depth_cube_array:new jn("texture_depth_cube_array",Lr.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new jn("texture_depth_multisampled_2d",Lr.keyword,"texture_depth_multisampled_2d"),texture_external:new jn("texture_external",Lr.keyword,"texture_external"),u32:new jn("u32",Lr.keyword,"u32"),vec2:new jn("vec2",Lr.keyword,"vec2"),vec3:new jn("vec3",Lr.keyword,"vec3"),vec4:new jn("vec4",Lr.keyword,"vec4"),bitcast:new jn("bitcast",Lr.keyword,"bitcast"),block:new jn("block",Lr.keyword,"block"),break:new jn("break",Lr.keyword,"break"),case:new jn("case",Lr.keyword,"case"),continue:new jn("continue",Lr.keyword,"continue"),continuing:new jn("continuing",Lr.keyword,"continuing"),default:new jn("default",Lr.keyword,"default"),discard:new jn("discard",Lr.keyword,"discard"),else:new jn("else",Lr.keyword,"else"),enable:new jn("enable",Lr.keyword,"enable"),fallthrough:new jn("fallthrough",Lr.keyword,"fallthrough"),false:new jn("false",Lr.keyword,"false"),fn:new jn("fn",Lr.keyword,"fn"),for:new jn("for",Lr.keyword,"for"),function:new jn("function",Lr.keyword,"function"),if:new jn("if",Lr.keyword,"if"),let:new jn("let",Lr.keyword,"let"),const:new jn("const",Lr.keyword,"const"),loop:new jn("loop",Lr.keyword,"loop"),while:new jn("while",Lr.keyword,"while"),private:new jn("private",Lr.keyword,"private"),read:new jn("read",Lr.keyword,"read"),read_write:new jn("read_write",Lr.keyword,"read_write"),return:new jn("return",Lr.keyword,"return"),storage:new jn("storage",Lr.keyword,"storage"),switch:new jn("switch",Lr.keyword,"switch"),true:new jn("true",Lr.keyword,"true"),alias:new jn("alias",Lr.keyword,"alias"),type:new jn("type",Lr.keyword,"type"),uniform:new jn("uniform",Lr.keyword,"uniform"),var:new jn("var",Lr.keyword,"var"),override:new jn("override",Lr.keyword,"override"),workgroup:new jn("workgroup",Lr.keyword,"workgroup"),write:new jn("write",Lr.keyword,"write"),r8unorm:new jn("r8unorm",Lr.keyword,"r8unorm"),r8snorm:new jn("r8snorm",Lr.keyword,"r8snorm"),r8uint:new jn("r8uint",Lr.keyword,"r8uint"),r8sint:new jn("r8sint",Lr.keyword,"r8sint"),r16uint:new jn("r16uint",Lr.keyword,"r16uint"),r16sint:new jn("r16sint",Lr.keyword,"r16sint"),r16float:new jn("r16float",Lr.keyword,"r16float"),rg8unorm:new jn("rg8unorm",Lr.keyword,"rg8unorm"),rg8snorm:new jn("rg8snorm",Lr.keyword,"rg8snorm"),rg8uint:new jn("rg8uint",Lr.keyword,"rg8uint"),rg8sint:new jn("rg8sint",Lr.keyword,"rg8sint"),r32uint:new jn("r32uint",Lr.keyword,"r32uint"),r32sint:new jn("r32sint",Lr.keyword,"r32sint"),r32float:new jn("r32float",Lr.keyword,"r32float"),rg16uint:new jn("rg16uint",Lr.keyword,"rg16uint"),rg16sint:new jn("rg16sint",Lr.keyword,"rg16sint"),rg16float:new jn("rg16float",Lr.keyword,"rg16float"),rgba8unorm:new jn("rgba8unorm",Lr.keyword,"rgba8unorm"),rgba8unorm_srgb:new jn("rgba8unorm_srgb",Lr.keyword,"rgba8unorm_srgb"),rgba8snorm:new jn("rgba8snorm",Lr.keyword,"rgba8snorm"),rgba8uint:new jn("rgba8uint",Lr.keyword,"rgba8uint"),rgba8sint:new jn("rgba8sint",Lr.keyword,"rgba8sint"),bgra8unorm:new jn("bgra8unorm",Lr.keyword,"bgra8unorm"),bgra8unorm_srgb:new jn("bgra8unorm_srgb",Lr.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new jn("rgb10a2unorm",Lr.keyword,"rgb10a2unorm"),rg11b10float:new jn("rg11b10float",Lr.keyword,"rg11b10float"),rg32uint:new jn("rg32uint",Lr.keyword,"rg32uint"),rg32sint:new jn("rg32sint",Lr.keyword,"rg32sint"),rg32float:new jn("rg32float",Lr.keyword,"rg32float"),rgba16uint:new jn("rgba16uint",Lr.keyword,"rgba16uint"),rgba16sint:new jn("rgba16sint",Lr.keyword,"rgba16sint"),rgba16float:new jn("rgba16float",Lr.keyword,"rgba16float"),rgba32uint:new jn("rgba32uint",Lr.keyword,"rgba32uint"),rgba32sint:new jn("rgba32sint",Lr.keyword,"rgba32sint"),rgba32float:new jn("rgba32float",Lr.keyword,"rgba32float"),static_assert:new jn("static_assert",Lr.keyword,"static_assert")},Fn.tokens={decimal_float_literal:new jn("decimal_float_literal",Lr.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new jn("hex_float_literal",Lr.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new jn("int_literal",Lr.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new jn("uint_literal",Lr.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new jn("ident",Lr.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new jn("and",Lr.token,"&"),and_and:new jn("and_and",Lr.token,"&&"),arrow:new jn("arrow ",Lr.token,"->"),attr:new jn("attr",Lr.token,"@"),attr_left:new jn("attr_left",Lr.token,"[["),attr_right:new jn("attr_right",Lr.token,"]]"),forward_slash:new jn("forward_slash",Lr.token,"/"),bang:new jn("bang",Lr.token,"!"),bracket_left:new jn("bracket_left",Lr.token,"["),bracket_right:new jn("bracket_right",Lr.token,"]"),brace_left:new jn("brace_left",Lr.token,"{"),brace_right:new jn("brace_right",Lr.token,"}"),colon:new jn("colon",Lr.token,":"),comma:new jn("comma",Lr.token,","),equal:new jn("equal",Lr.token,"="),equal_equal:new jn("equal_equal",Lr.token,"=="),not_equal:new jn("not_equal",Lr.token,"!="),greater_than:new jn("greater_than",Lr.token,">"),greater_than_equal:new jn("greater_than_equal",Lr.token,">="),shift_right:new jn("shift_right",Lr.token,">>"),less_than:new jn("less_than",Lr.token,"<"),less_than_equal:new jn("less_than_equal",Lr.token,"<="),shift_left:new jn("shift_left",Lr.token,"<<"),modulo:new jn("modulo",Lr.token,"%"),minus:new jn("minus",Lr.token,"-"),minus_minus:new jn("minus_minus",Lr.token,"--"),period:new jn("period",Lr.token,"."),plus:new jn("plus",Lr.token,"+"),plus_plus:new jn("plus_plus",Lr.token,"++"),or:new jn("or",Lr.token,"|"),or_or:new jn("or_or",Lr.token,"||"),paren_left:new jn("paren_left",Lr.token,"("),paren_right:new jn("paren_right",Lr.token,")"),semicolon:new jn("semicolon",Lr.token,";"),star:new jn("star",Lr.token,"*"),tilde:new jn("tilde",Lr.token,"~"),underscore:new jn("underscore",Lr.token,"_"),xor:new jn("xor",Lr.token,"^"),plus_equal:new jn("plus_equal",Lr.token,"+="),minus_equal:new jn("minus_equal",Lr.token,"-="),times_equal:new jn("times_equal",Lr.token,"*="),division_equal:new jn("division_equal",Lr.token,"/="),modulo_equal:new jn("modulo_equal",Lr.token,"%="),and_equal:new jn("and_equal",Lr.token,"&="),or_equal:new jn("or_equal",Lr.token,"|="),xor_equal:new jn("xor_equal",Lr.token,"^="),shift_right_equal:new jn("shift_right_equal",Lr.token,">>="),shift_left_equal:new jn("shift_left_equal",Lr.token,"<<=")},Fn.storage_class=[Dr.keywords.function,Dr.keywords.private,Dr.keywords.workgroup,Dr.keywords.uniform,Dr.keywords.storage],Fn.access_mode=[Dr.keywords.read,Dr.keywords.write,Dr.keywords.read_write],Fn.sampler_type=[Dr.keywords.sampler,Dr.keywords.sampler_comparison],Fn.sampled_texture_type=[Dr.keywords.texture_1d,Dr.keywords.texture_2d,Dr.keywords.texture_2d_array,Dr.keywords.texture_3d,Dr.keywords.texture_cube,Dr.keywords.texture_cube_array],Fn.multisampled_texture_type=[Dr.keywords.texture_multisampled_2d],Fn.storage_texture_type=[Dr.keywords.texture_storage_1d,Dr.keywords.texture_storage_2d,Dr.keywords.texture_storage_2d_array,Dr.keywords.texture_storage_3d],Fn.depth_texture_type=[Dr.keywords.texture_depth_2d,Dr.keywords.texture_depth_2d_array,Dr.keywords.texture_depth_cube,Dr.keywords.texture_depth_cube_array,Dr.keywords.texture_depth_multisampled_2d],Fn.texture_external_type=[Dr.keywords.texture_external],Fn.any_texture_type=[...Dr.sampled_texture_type,...Dr.multisampled_texture_type,...Dr.storage_texture_type,...Dr.depth_texture_type,...Dr.texture_external_type],Fn.texel_format=[Dr.keywords.r8unorm,Dr.keywords.r8snorm,Dr.keywords.r8uint,Dr.keywords.r8sint,Dr.keywords.r16uint,Dr.keywords.r16sint,Dr.keywords.r16float,Dr.keywords.rg8unorm,Dr.keywords.rg8snorm,Dr.keywords.rg8uint,Dr.keywords.rg8sint,Dr.keywords.r32uint,Dr.keywords.r32sint,Dr.keywords.r32float,Dr.keywords.rg16uint,Dr.keywords.rg16sint,Dr.keywords.rg16float,Dr.keywords.rgba8unorm,Dr.keywords.rgba8unorm_srgb,Dr.keywords.rgba8snorm,Dr.keywords.rgba8uint,Dr.keywords.rgba8sint,Dr.keywords.bgra8unorm,Dr.keywords.bgra8unorm_srgb,Dr.keywords.rgb10a2unorm,Dr.keywords.rg11b10float,Dr.keywords.rg32uint,Dr.keywords.rg32sint,Dr.keywords.rg32float,Dr.keywords.rgba16uint,Dr.keywords.rgba16sint,Dr.keywords.rgba16float,Dr.keywords.rgba32uint,Dr.keywords.rgba32sint,Dr.keywords.rgba32float],Fn.const_literal=[Dr.tokens.int_literal,Dr.tokens.uint_literal,Dr.tokens.decimal_float_literal,Dr.tokens.hex_float_literal,Dr.keywords.true,Dr.keywords.false],Fn.literal_or_ident=[Dr.tokens.ident,Dr.tokens.int_literal,Dr.tokens.uint_literal,Dr.tokens.decimal_float_literal,Dr.tokens.hex_float_literal],Fn.element_count_expression=[Dr.tokens.int_literal,Dr.tokens.uint_literal,Dr.tokens.ident],Fn.template_types=[Dr.keywords.vec2,Dr.keywords.vec3,Dr.keywords.vec4,Dr.keywords.mat2x2,Dr.keywords.mat2x3,Dr.keywords.mat2x4,Dr.keywords.mat3x2,Dr.keywords.mat3x3,Dr.keywords.mat3x4,Dr.keywords.mat4x2,Dr.keywords.mat4x3,Dr.keywords.mat4x4,Dr.keywords.atomic,Dr.keywords.bitcast,...Dr.any_texture_type],Fn.attribute_name=[Dr.tokens.ident,Dr.keywords.block],Fn.assignment_operators=[Dr.tokens.equal,Dr.tokens.plus_equal,Dr.tokens.minus_equal,Dr.tokens.times_equal,Dr.tokens.division_equal,Dr.tokens.modulo_equal,Dr.tokens.and_equal,Dr.tokens.or_equal,Dr.tokens.xor_equal,Dr.tokens.shift_right_equal,Dr.tokens.shift_left_equal],Fn.increment_operators=[Dr.tokens.plus_plus,Dr.tokens.minus_minus];class Gn{constructor(e,t,r){this.type=e,this.lexeme=t,this.line=r}toString(){return this.lexeme}isTemplateType(){return-1!=Fn.template_types.indexOf(this.type)}isArrayType(){return this.type==Fn.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class qn{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new Gn(Fn.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}let t=Fn.none;for(;;){let r=this._findType(e);const n=this._peekAhead();if(">"==e&&(">"==n||"="==n)){let e=!1,t=this._tokens.length-1;for(let r=0;r<5&&t>=0;++r,--t)if(this._tokens[t].type===Fn.tokens.less_than){t>0&&this._tokens[t-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(r),!0}if(r===Fn.none){let n=e,i=0;const s=2;for(let e=0;e<s;++e)if(n+=this._peekAhead(e),r=this._findType(n),r!==Fn.none){i=e;break}if(r===Fn.none)return t!==Fn.none&&(this._current--,this._addToken(t),!0);e=n,this._current+=i+1}if(t=r,this._isAtEnd())break;e+=this._advance()}return t!==Fn.none&&(this._addToken(t),!0)}_findType(e){for(const t in Fn.keywords){const r=Fn.keywords[t];if(this._match(e,r.rule))return r}for(const t in Fn.tokens){const r=Fn.tokens[t];if(this._match(e,r.rule))return r}return Fn.none}_match(e,t){if("string"==typeof t){if(t==e)return!0}else{const r=t.exec(e);if(r&&0==r.index&&r[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new Gn(e,t,this._line))}}class Vn{constructor(){this._tokens=[],this._current=0,this._context=new Fr}parse(e){this._initialize(e);let t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}return t}_initialize(e){if(e)if("string"==typeof e){const t=new qn(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return console.error(e,t),{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==Fn.eof}_match(e){if(e instanceof jn)return!!this._check(e)&&(this._advance(),!0);for(let t=0,r=e.length;t<r;++t){const r=e[t];if(this._check(r))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){let r=t.type;return-1!=e.indexOf(r)}return t.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(Fn.tokens.semicolon)&&!this._isAtEnd(););if(this._match(Fn.keywords.alias)){const e=this._type_alias();return this._consume(Fn.tokens.semicolon,"Expected ';'"),e}if(this._match(Fn.keywords.enable)){const e=this._enable_directive();return this._consume(Fn.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(Fn.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(Fn.tokens.semicolon,"Expected ';'."),t}if(this._check(Fn.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(Fn.tokens.semicolon,"Expected ';'."),t}if(this._check(Fn.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(Fn.tokens.semicolon,"Expected ';'."),t}if(this._check(Fn.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(Fn.tokens.semicolon,"Expected ';'."),t}if(this._check(Fn.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(Fn.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(Fn.keywords.fn))return null;const e=this._consume(Fn.tokens.ident,"Expected function name.").toString();this._consume(Fn.tokens.paren_left,"Expected '(' for function arguments.");const t=[];if(!this._check(Fn.tokens.paren_right))do{if(this._check(Fn.tokens.paren_right))break;const e=this._attribute(),r=this._consume(Fn.tokens.ident,"Expected argument name.").toString();this._consume(Fn.tokens.colon,"Expected ':' for argument type.");const n=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=n,t.push(new Un(r,i,e)))}while(this._match(Fn.tokens.comma));this._consume(Fn.tokens.paren_right,"Expected ')' after function arguments.");let r=null;if(this._match(Fn.tokens.arrow)){const e=this._attribute();r=this._type_decl(),null!=r&&(r.attributes=e)}const n=this._compound_statement();return new Yr(e,t,r,n)}_compound_statement(){const e=[];for(this._consume(Fn.tokens.brace_left,"Expected '{' for block.");!this._check(Fn.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(Fn.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(Fn.tokens.semicolon)&&!this._isAtEnd(););if(this._check(Fn.keywords.if))return this._if_statement();if(this._check(Fn.keywords.switch))return this._switch_statement();if(this._check(Fn.keywords.loop))return this._loop_statement();if(this._check(Fn.keywords.for))return this._for_statement();if(this._check(Fn.keywords.while))return this._while_statement();if(this._check(Fn.keywords.continuing))return this._continuing_statement();if(this._check(Fn.keywords.static_assert))return this._static_assert_statement();if(this._check(Fn.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(Fn.keywords.return)?this._return_statement():this._check([Fn.keywords.var,Fn.keywords.let,Fn.keywords.const])?this._variable_statement():this._match(Fn.keywords.discard)?new hn:this._match(Fn.keywords.break)?new dn:this._match(Fn.keywords.continue)?new fn:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(Fn.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(Fn.keywords.static_assert))return null;let e=this._optional_paren_expression();return new Hr(e)}_while_statement(){if(!this._match(Fn.keywords.while))return null;let e=this._optional_paren_expression();const t=this._compound_statement();return new $r(e,t)}_continuing_statement(){if(!this._match(Fn.keywords.continuing))return null;const e=this._compound_statement();return new Xr(e)}_for_statement(){if(!this._match(Fn.keywords.for))return null;this._consume(Fn.tokens.paren_left,"Expected '('.");const e=this._check(Fn.tokens.semicolon)?null:this._for_init();this._consume(Fn.tokens.semicolon,"Expected ';'.");const t=this._check(Fn.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(Fn.tokens.semicolon,"Expected ';'.");const r=this._check(Fn.tokens.paren_right)?null:this._for_increment();this._consume(Fn.tokens.paren_right,"Expected ')'.");const n=this._compound_statement();return new Zr(e,t,r,n)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(Fn.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(Fn.tokens.equal)&&(t=this._short_circuit_or_expression()),new Kr(e.name,e.type,e.storage,e.access,t)}if(this._match(Fn.keywords.let)){const e=this._consume(Fn.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(Fn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Fn.tokens.equal,"Expected '=' for let.");const r=this._short_circuit_or_expression();return new Jr(e,t,null,null,r)}if(this._match(Fn.keywords.const)){const e=this._consume(Fn.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(Fn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Fn.tokens.equal,"Expected '=' for const.");const r=this._short_circuit_or_expression();return new en(e,t,null,null,r)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(Fn.increment_operators))return this._current=e,null;const r=this._consume(Fn.increment_operators,"Expected increment operator");return new tn(r.type===Fn.tokens.plus_plus?Ur.increment:Ur.decrement,t)}_assignment_statement(){let e=null;if(this._check(Fn.tokens.brace_right))return null;let t=this._match(Fn.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const r=this._consume(Fn.assignment_operators,"Expected assignment operator."),n=this._short_circuit_or_expression();return new rn(Nr.parse(r.lexeme),e,n)}_func_call_statement(){if(!this._check(Fn.tokens.ident))return null;const e=this._current,t=this._consume(Fn.tokens.ident,"Expected function name."),r=this._argument_expression_list();return null===r?(this._current=e,null):new nn(t.lexeme,r)}_loop_statement(){if(!this._match(Fn.keywords.loop))return null;this._consume(Fn.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let r of t)e.push(r);else e.push(t);t=this._statement()}let r=null;return this._match(Fn.keywords.continuing)&&(r=this._compound_statement()),this._consume(Fn.tokens.brace_right,"Expected '}' for loop."),new sn(e,r)}_switch_statement(){if(!this._match(Fn.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(Fn.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(Fn.tokens.brace_right,"Expected '}' for switch."),new on(e,t)}_switch_body(){const e=[];if(this._match(Fn.keywords.case)){const t=this._case_selectors();this._match(Fn.tokens.colon),this._consume(Fn.tokens.brace_left,"Exected '{' for switch case.");const r=this._case_body();this._consume(Fn.tokens.brace_right,"Exected '}' for switch case."),e.push(new Rn(t,r))}if(this._match(Fn.keywords.default)){this._match(Fn.tokens.colon),this._consume(Fn.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(Fn.tokens.brace_right,"Exected '}' for switch default."),e.push(new Bn(t))}if(this._check([Fn.keywords.default,Fn.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){var e,t,r,n;const i=[null!==(t=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==t?t:""];for(;this._match(Fn.tokens.comma);)i.push(null!==(n=null===(r=this._shift_expression())||void 0===r?void 0:r.evaluate(this._context).toString())&&void 0!==n?n:"");return i}_case_body(){if(this._match(Fn.keywords.fallthrough))return this._consume(Fn.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(Fn.keywords.if))return null;const e=this._optional_paren_expression(),t=this._compound_statement();let r=[];this._match_elseif()&&(r=this._elseif_statement(r));let n=null;return this._match(Fn.keywords.else)&&(n=this._compound_statement()),new an(e,t,r,n)}_match_elseif(){return this._tokens[this._current].type===Fn.keywords.else&&this._tokens[this._current+1].type===Fn.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),r=this._compound_statement();return e.push(new Nn(t,r)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(Fn.keywords.return))return null;const e=this._short_circuit_or_expression();return new cn(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(Fn.tokens.or_or);)e=new zn(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(Fn.tokens.and_and);)e=new zn(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(Fn.tokens.or);)e=new zn(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(Fn.tokens.xor);)e=new zn(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(Fn.tokens.and);)e=new zn(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([Fn.tokens.equal_equal,Fn.tokens.not_equal])?new zn(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([Fn.tokens.less_than,Fn.tokens.greater_than,Fn.tokens.less_than_equal,Fn.tokens.greater_than_equal]);)e=new zn(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([Fn.tokens.shift_left,Fn.tokens.shift_right]);)e=new zn(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([Fn.tokens.plus,Fn.tokens.minus]);)e=new zn(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([Fn.tokens.star,Fn.tokens.forward_slash,Fn.tokens.modulo]);)e=new zn(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([Fn.tokens.minus,Fn.tokens.bang,Fn.tokens.tilde,Fn.tokens.star,Fn.tokens.and])?new In(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(Fn.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(Fn.tokens.bracket_right,"Expected ']'.");const t=this._postfix_expression();return t&&(e.postfix=t),e}if(this._match(Fn.tokens.period)){const e=this._consume(Fn.tokens.ident,"Expected member name."),t=this._postfix_expression(),r=new wn(e.lexeme);return t&&(r.postfix=t),r}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(Fn.tokens.ident)){const e=this._previous().toString();if(this._check(Fn.tokens.paren_left)){const t=this._argument_expression_list(),r=this._getStruct(e);return null!=r?new _n(r,t):new Tn(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new Pn(e,t.value)}return new Sn(e)}if(this._match(Fn.const_literal))return new kn(parseFloat(this._previous().toString()));if(this._check(Fn.tokens.paren_left))return this._paren_expression();if(this._match(Fn.keywords.bitcast)){this._consume(Fn.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(Fn.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new En(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new Mn(e,t)}_argument_expression_list(){if(!this._match(Fn.tokens.paren_left))return null;const e=[];do{if(this._check(Fn.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(Fn.tokens.comma));return this._consume(Fn.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(Fn.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(Fn.tokens.paren_right),new An([e])}_paren_expression(){this._consume(Fn.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(Fn.tokens.paren_right,"Expected ')'."),new An([e])}_struct_decl(){if(!this._match(Fn.keywords.struct))return null;const e=this._consume(Fn.tokens.ident,"Expected name for struct.").toString();this._consume(Fn.tokens.brace_left,"Expected '{' for struct body.");const t=[];for(;!this._check(Fn.tokens.brace_right);){const e=this._attribute(),r=this._consume(Fn.tokens.ident,"Expected variable name.").toString();this._consume(Fn.tokens.colon,"Expected ':' for struct member type.");const n=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=n),this._check(Fn.tokens.brace_right)?this._match(Fn.tokens.comma):this._consume(Fn.tokens.comma,"Expected ',' for struct member."),t.push(new Dn(r,i,e))}this._consume(Fn.tokens.brace_right,"Expected '}' after struct body.");const r=new mn(e,t);return this._context.structs.set(e,r),r}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(Fn.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(Fn.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(Fn.keywords.const))return null;const e=this._consume(Fn.tokens.ident,"Expected variable name");let t=null;if(this._match(Fn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let r=null;if(this._match(Fn.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof _n)r=e;else if(e instanceof Pn&&e.initializer instanceof _n)r=e.initializer;else try{const t=e.evaluate(this._context);r=new kn(t)}catch(t){r=e}}const n=new en(e.toString(),t,"","",r);return this._context.constants.set(n.name,n),n}_global_let_decl(){if(!this._match(Fn.keywords.let))return null;const e=this._consume(Fn.tokens.ident,"Expected variable name");let t=null;if(this._match(Fn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let r=null;return this._match(Fn.tokens.equal)&&(r=this._const_expression()),new Jr(e.toString(),t,"","",r)}_const_expression(){if(this._match(Fn.const_literal))return new wn(this._previous().toString());const e=this._type_decl();this._consume(Fn.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(Fn.tokens.paren_right)&&(t.push(this._const_expression()),this._check(Fn.tokens.comma));)this._advance();return this._consume(Fn.tokens.paren_right,"Expected ')'."),new _n(e,t)}_variable_decl(){if(!this._match(Fn.keywords.var))return null;let e="",t="";this._match(Fn.tokens.less_than)&&(e=this._consume(Fn.storage_class,"Expected storage_class.").toString(),this._match(Fn.tokens.comma)&&(t=this._consume(Fn.access_mode,"Expected access_mode.").toString()),this._consume(Fn.tokens.greater_than,"Expected '>'."));const r=this._consume(Fn.tokens.ident,"Expected variable name");let n=null;if(this._match(Fn.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}return new Kr(r.toString(),n,e,t,null)}_override_decl(){if(!this._match(Fn.keywords.override))return null;const e=this._consume(Fn.tokens.ident,"Expected variable name");let t=null;if(this._match(Fn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new Qr(e.toString(),t,null)}_enable_directive(){const e=this._consume(Fn.tokens.ident,"identity expected.");return new ln(e.toString())}_type_alias(){const e=this._consume(Fn.tokens.ident,"identity expected.");this._consume(Fn.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const r=new un(e.toString(),t);return this._context.aliases.set(r.name,r),r}_type_decl(){if(this._check([Fn.tokens.ident,...Fn.texel_format,Fn.keywords.bool,Fn.keywords.f32,Fn.keywords.i32,Fn.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new pn(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(Fn.template_types)){let e=this._advance().toString(),t=null,r=null;return this._match(Fn.tokens.less_than)&&(t=this._type_decl(),r=null,this._match(Fn.tokens.comma)&&(r=this._consume(Fn.access_mode,"Expected access_mode for pointer").toString()),this._consume(Fn.tokens.greater_than,"Expected '>' for type.")),new vn(e,t,r)}if(this._match(Fn.keywords.ptr)){let e=this._previous().toString();this._consume(Fn.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(Fn.storage_class,"Expected storage_class for pointer");this._consume(Fn.tokens.comma,"Expected ',' for pointer.");const r=this._type_decl();let n=null;return this._match(Fn.tokens.comma)&&(n=this._consume(Fn.access_mode,"Expected access_mode for pointer").toString()),this._consume(Fn.tokens.greater_than,"Expected '>' for pointer."),new gn(e,t.toString(),r,n)}const t=this._attribute();if(this._match(Fn.keywords.array)){let e=null,r=-1;const n=this._previous();if(this._match(Fn.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";this._match(Fn.tokens.comma)&&(t=this._shift_expression().evaluate(this._context).toString()),this._consume(Fn.tokens.greater_than,"Expected '>' for array."),r=t?parseInt(t):0}return new yn(n.toString(),t,e,r)}return null}_texture_sampler_types(){if(this._match(Fn.sampler_type))return new xn(this._previous().toString(),null,null);if(this._match(Fn.depth_texture_type))return new xn(this._previous().toString(),null,null);if(this._match(Fn.sampled_texture_type)||this._match(Fn.multisampled_texture_type)){const e=this._previous();this._consume(Fn.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(Fn.tokens.greater_than,"Expected '>' for sampler type."),new xn(e.toString(),t,null)}if(this._match(Fn.storage_texture_type)){const e=this._previous();this._consume(Fn.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(Fn.texel_format,"Invalid texel format.").toString();this._consume(Fn.tokens.comma,"Expected ',' after texel format.");const r=this._consume(Fn.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(Fn.tokens.greater_than,"Expected '>' for sampler type."),new xn(e.toString(),t,r)}return null}_attribute(){let e=[];for(;this._match(Fn.tokens.attr);){const t=this._consume(Fn.attribute_name,"Expected attribute name"),r=new Ln(t.toString(),null);if(this._match(Fn.tokens.paren_left)){if(r.value=this._consume(Fn.literal_or_ident,"Expected attribute value").toString(),this._check(Fn.tokens.comma)){this._advance();do{const e=this._consume(Fn.literal_or_ident,"Expected attribute value").toString();r.value instanceof Array||(r.value=[r.value]),r.value.push(e)}while(this._match(Fn.tokens.comma))}this._consume(Fn.tokens.paren_right,"Expected ')'")}e.push(r)}for(;this._match(Fn.tokens.attr_left);){if(!this._check(Fn.tokens.attr_right))do{const t=this._consume(Fn.attribute_name,"Expected attribute name"),r=new Ln(t.toString(),null);if(this._match(Fn.tokens.paren_left)){if(r.value=[this._consume(Fn.literal_or_ident,"Expected attribute value").toString()],this._check(Fn.tokens.comma)){this._advance();do{const e=this._consume(Fn.literal_or_ident,"Expected attribute value").toString();r.value.push(e)}while(this._match(Fn.tokens.comma))}this._consume(Fn.tokens.paren_right,"Expected ')'")}e.push(r)}while(this._match(Fn.tokens.comma));this._consume(Fn.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class Wn{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class Yn{constructor(e,t,r){this.name=e,this.type=t,this.attributes=r,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class Hn extends Wn{constructor(e,t){super(e,t),this.members=[],this.align=0}get isStruct(){return!0}}class $n extends Wn{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class Xn extends Wn{constructor(e,t,r,n){super(e,r),this.format=t,this.access=n}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(jr||(jr={}));class Zn{constructor(e,t,r,n,i,s,o){this.name=e,this.type=t,this.group=r,this.binding=n,this.attributes=i,this.resourceType=s,this.access=o}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class Kn{constructor(e,t){this.name=e,this.type=t}}class Qn{constructor(e,t){this.align=e,this.size=t}}class Jn{constructor(e,t,r,n){this.name=e,this.type=t,this.locationType=r,this.location=n,this.interpolation=null}}class ei{constructor(e,t,r,n){this.name=e,this.type=t,this.locationType=r,this.location=n}}class ti{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.name=e,this.stage=t}}class ri{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class ni{constructor(e,t,r,n){this.name=e,this.type=t,this.attributes=r,this.id=n}}class ii{constructor(e){this.resources=null,this.node=e}}class si{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new ri,this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new Vn).parse(e);for(const e of t)e instanceof Yr&&this._functions.set(e.name,new ii(e));for(const e of t)if(e instanceof mn){const t=this._getTypeInfo(e,null);t instanceof Hn&&this.structs.push(t)}else if(e instanceof un)this.aliases.push(this._getAliasInfo(e));else if(e instanceof Qr){const t=e,r=this._getAttributeNum(t.attributes,"id",0),n=null!=t.type?this._getTypeInfo(t.type,t.attributes):null;this.overrides.push(new ni(t.name,n,t.attributes,r))}else if(this._isUniformVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new Zn(t.name,i,r,n,t.attributes,jr.Uniform,t.access);this.uniforms.push(s)}else if(this._isStorageVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new Zn(t.name,i,r,n,t.attributes,s?jr.StorageTexture:jr.Storage,t.access);this.storage.push(o)}else if(this._isTextureVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new Zn(t.name,i,r,n,t.attributes,s?jr.StorageTexture:jr.Texture,t.access);s?this.storage.push(o):this.textures.push(o)}else if(this._isSamplerVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new Zn(t.name,i,r,n,t.attributes,jr.Sampler,t.access);this.samplers.push(s)}else if(e instanceof Yr){const t=this._getAttribute(e,"vertex"),r=this._getAttribute(e,"fragment"),n=this._getAttribute(e,"compute"),i=t||r||n;if(i){const t=new ti(e.name,null==i?void 0:i.name);t.inputs=this._getInputs(e.args),t.outputs=this._getOutputs(e.returnType),t.resources=this._findResources(e),this.entry[i.name].push(t)}}}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_findResources(e){const t=[],r=this,n=[];return e.search((e=>{if(e instanceof qr)n.push({});else if(e instanceof Vr)n.pop();else if(e instanceof Kr){if(n.length>0){const t=e;n[n.length-1][t.name]=t}}else if(e instanceof Jr){if(n.length>0){const t=e;n[n.length-1][t.name]=t}}else if(e instanceof Sn){const i=e;if(n.length>0&&n[n.length-1][i.name])return;const s=r._findResource(i.name);s&&t.push(s)}else if(e instanceof Tn){const n=e,i=r._functions.get(n.name);i&&(null===i.resources&&(i.resources=r._findResources(i.node)),t.push(...i.resources))}})),[...new Map(t.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,r){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),r>=e[t].length&&(e[t].length=r+1)}for(const r of this.uniforms)t(r.group,r.binding),e[r.group][r.binding]=r;for(const r of this.storage)t(r.group,r.binding),e[r.group][r.binding]=r;for(const r of this.textures)t(r.group,r.binding),e[r.group][r.binding]=r;for(const r of this.samplers)t(r.group,r.binding),e[r.group][r.binding]=r;return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof mn)this._getStructOutputs(e,t);else{const r=this._getOutputInfo(e);null!==r&&t.push(r)}return t}_getStructOutputs(e,t){for(const r of e.members)if(r.type instanceof mn)this._getStructOutputs(r.type,t);else{const e=this._getAttribute(r,"location")||this._getAttribute(r,"builtin");if(null!==e){const n=this._getTypeInfo(r.type,r.type.attributes),i=this._parseInt(e.value),s=new ei(r.name,n,e.name,i);t.push(s)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const r=this._getTypeInfo(e,e.attributes),n=this._parseInt(t.value);return new ei("",r,t.name,n)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const r of e)if(r.type instanceof mn)this._getStructInputs(r.type,t);else{const e=this._getInputInfo(r);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const r of e.members)if(r.type instanceof mn)this._getStructInputs(r.type,t);else{const e=this._getInputInfo(r);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const r=this._getAttribute(e,"interpolation"),n=this._getTypeInfo(e.type,e.attributes),i=this._parseInt(t.value),s=new Jn(e.name,n,t.name,i);return null!==r&&(s.interpolation=this._parseString(r.value)),s}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new Kn(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof yn){const r=e,n=this._getTypeInfo(r.format,r.attributes),i=new $n(r.name,t);return i.format=n,i.count=r.count,this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof mn){const r=e,n=new Hn(r.name,t);for(const e of r.members){const t=this._getTypeInfo(e.type,e.attributes);n.members.push(new Yn(e.name,t,e.attributes))}return this._types.set(e,n),this._updateTypeInfo(n),n}if(e instanceof xn){const r=e,n=r.format instanceof pn,i=r.format?n?this._getTypeInfo(r.format,null):new Wn(r.format,null):null,s=new Xn(r.name,i,t,r.access);return this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof vn){const r=e,n=r.format?this._getTypeInfo(r.format,null):null,i=new Xn(r.name,n,t,r.access);return this._types.set(e,i),this._updateTypeInfo(i),i}const r=new Wn(e.name,t);return this._types.set(e,r),this._updateTypeInfo(r),r}_updateTypeInfo(e){var t,r;const n=this._getTypeSize(e);if(e.size=null!==(t=null==n?void 0:n.size)&&void 0!==t?t:0,e instanceof $n){const t=this._getTypeSize(e.format);e.stride=null!==(r=null==t?void 0:t.size)&&void 0!==r?r:0,this._updateTypeInfo(e.format)}e instanceof Hn&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let r=0,n=0,i=0,s=0;for(let o=0,a=e.members.length;o<a;++o){const a=e.members[o],c=this._getTypeSize(a);if(!c)continue;null!==(t=this._getAlias(a.type.name))&&void 0!==t||a.type;const l=c.align,u=c.size;r=this._roundUp(l,r+n),n=u,i=r,s=Math.max(s,l),a.offset=r,a.size=u,this._updateTypeInfo(a.type)}e.size=this._roundUp(s,i+n),e.align=s}_getTypeSize(e){var t;if(null==e)return null;const r=this._getAttributeNum(e.attributes,"size",0),n=this._getAttributeNum(e.attributes,"align",0);if(e instanceof Yn&&(e=e.type),e instanceof Wn){const t=this._getAlias(e.name);null!==t&&(e=t)}{const t=si._typeInfo[e.name];if(void 0!==t){const i="f16"===e.format?2:1;return new Qn(Math.max(n,t.align/i),Math.max(r,t.size/i))}}{const t=si._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const i="h"===e.name[e.name.length-1]?2:1;return new Qn(Math.max(n,t.align/i),Math.max(r,t.size/i))}}if(e instanceof $n){let i=e,s=8,o=8;const a=this._getTypeSize(i.format);return null!==a&&(o=a.size,s=a.align),o=i.count*this._getAttributeNum(null!==(t=null==e?void 0:e.attributes)&&void 0!==t?t:null,"stride",this._roundUp(s,o)),r&&(o=r),new Qn(Math.max(n,s),Math.max(r,o))}if(e instanceof Hn){let t=0,i=0,s=0,o=0,a=0;for(const r of e.members){const e=this._getTypeSize(r.type);null!==e&&(t=Math.max(e.align,t),s=this._roundUp(e.align,s+o),o=e.size,a=s)}return i=this._roundUp(t,a+o),new Qn(Math.max(n,t),Math.max(r,i))}return null}_isUniformVar(e){return e instanceof Kr&&"uniform"==e.storage}_isStorageVar(e){return e instanceof Kr&&"storage"==e.storage}_isTextureVar(e){return e instanceof Kr&&null!==e.type&&-1!=si._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof Kr&&null!==e.type&&-1!=si._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const r=e;if(!r||!r.attributes)return null;const n=r.attributes;for(let e of n)if(e.name==t)return e;return null}_getAttributeNum(e,t,r){if(null===e)return r;for(let n of e)if(n.name==t){let e=null!==n&&null!==n.value?n.value:r;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):r}return r}_roundUp(e,t){return Math.ceil(t/e)*e}}function oi(e,t){const r=function(e){return Array.isArray(e)||Ir(e)?[...e,1,1].slice(0,3):function(e){return[e.width,e.height||1,e.depthOrArrayLayers||1]}(e)}(e),n=Math.max(...r.slice(0,"3d"===t?3:2));return 1+Math.log2(n)|0}si._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},si._textureTypes=Fn.any_texture_type.map((e=>e.name)),si._samplerTypes=Fn.sampler_type.map((e=>e.name));const ai=new WeakMap;const ci=new Map([[Int8Array,{formats:["sint8","snorm8"],defaultForType:1}],[Uint8Array,{formats:["uint8","unorm8"],defaultForType:1}],[Int16Array,{formats:["sint16","snorm16"],defaultForType:1}],[Uint16Array,{formats:["uint16","unorm16"],defaultForType:1}],[Int32Array,{formats:["sint32","snorm32"],defaultForType:0}],[Uint32Array,{formats:["uint32","unorm32"],defaultForType:0}],[Float32Array,{formats:["float32","float32"],defaultForType:0}]]);function li(e){return Ir(e)||Array.isArray(e)||function(e){const t=e;return Ir(t.data)||Array.isArray(t.data)}(e)}function ui(e){switch(e){case"1d":return"1d";case"3d":return"3d";default:return"2d"}}new Map([...ci.entries()].map((([e,{formats:[t,r]}])=>[[t,e],[r,e]])).flat());const hi={"8snorm":Int8Array,"8unorm":Uint8Array,"8sint":Int8Array,"8uint":Uint8Array,"16snorm":Int16Array,"16unorm":Uint16Array,"16sint":Int16Array,"16uint":Uint16Array,"32snorm":Int32Array,"32unorm":Uint32Array,"32sint":Int32Array,"32uint":Uint32Array,"16float":Uint16Array,"32float":Float32Array},di=/([a-z]+)(\d+)([a-z]+)/;function fi(e){const[,t,r,n]=di.exec(e),i=t.length,s=parseInt(r)/8;return{channels:t,numChannels:i,bytesPerChannel:s,bytesPerElement:i*s,Type:hi[`${r}${n}`]}}function pi(e,t,r,n={}){r.forEach(((r,i)=>{const s=[0,0,i+(n.baseArrayLayer||0)];if(li(r))!function(e,t,r,n){const i=function(e,t){if(Ir(e))return e;const{Type:r}=fi(t);return new r(e)}(r.data||r,t.format),s=function(e,t){return[e.width,e.height,e.depthOrArrayLayers].map((e=>Math.max(1,Math.floor(e/1))))}(t),{bytesPerElement:o}=fi(t.format),a=n.origin||[0,0,0];e.queue.writeTexture({texture:t,origin:a},i,{bytesPerRow:o*s[0],rowsPerImage:s[1]},s)}(e,t,r,{origin:s});else{const i=r,{flipY:o,premultipliedAlpha:a,colorSpace:c}=n;e.queue.copyExternalImageToTexture({source:i,flipY:o},{texture:t,premultipliedAlpha:a,colorSpace:c,origin:s},mi(i,n))}})),t.mipLevelCount>1&&function(e,t,r){let n=ai.get(e);n||(n={pipelineByFormatAndView:{},moduleByViewType:{}},ai.set(e,n));let{sampler:i,uniformBuffer:s,uniformValues:o}=n;const{pipelineByFormatAndView:a,moduleByViewType:c}=n;r=r||function(e){switch(e.dimension){case"1d":return"1d";case"3d":return"3d";default:return e.depthOrArrayLayers>1?"2d-array":"2d"}}(t);let l=c[r];if(!l){const t=function(e){let t,r;switch(e){case"2d":t="texture_2d<f32>",r="textureSample(ourTexture, ourSampler, fsInput.texcoord)";break;case"2d-array":t="texture_2d_array<f32>",r="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              fsInput.texcoord,\n              uni.layer)";break;case"cube":t="texture_cube<f32>",r="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1))";break;case"cube-array":t="texture_cube_array<f32>",r="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1), uni.layer)";break;default:throw new Error(`unsupported view: ${e}`)}return`\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n          var pos = array<vec2f, 3>(\n            vec2f(-1.0, -1.0),\n            vec2f(-1.0,  3.0),\n            vec2f( 3.0, -1.0),\n          );\n\n          var vsOutput: VSOutput;\n          let xy = pos[vertexIndex];\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n          return vsOutput;\n        }\n\n        struct Uniforms {\n          layer: u32,\n        };\n\n        @group(0) @binding(0) var ourSampler: sampler;\n        @group(0) @binding(1) var ourTexture: ${t};\n        @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni.layer; // make sure this is used so all pipelines have the same bindings\n          return ${r};\n        }\n      `}(r);l=e.createShaderModule({label:`mip level generation for ${r}`,code:t}),c[r]=l}i||(i=e.createSampler({minFilter:"linear",magFilter:"linear"}),s=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=new Uint32Array(1),Object.assign(n,{sampler:i,uniformBuffer:s,uniformValues:o}));const u=`${t.format}.${r}`;a[u]||(a[u]=e.createRenderPipeline({label:`mip level generator pipeline for ${r}`,layout:"auto",vertex:{module:l,entryPoint:"vs"},fragment:{module:l,entryPoint:"fs",targets:[{format:t.format}]}}));const h=a[u];for(let n=1;n<t.mipLevelCount;++n)for(let a=0;a<t.depthOrArrayLayers;++a){o[0]=a,e.queue.writeBuffer(s,0,o);const c=e.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:i},{binding:1,resource:t.createView({dimension:r,baseMipLevel:n-1,mipLevelCount:1})},{binding:2,resource:{buffer:s}}]}),l={label:"mip gen renderPass",colorAttachments:[{view:t.createView({dimension:"2d",baseMipLevel:n,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},u=e.createCommandEncoder({label:"mip gen encoder"}),d=u.beginRenderPass(l);d.setPipeline(h),d.setBindGroup(0,c),d.draw(3),d.end();const f=u.finish();e.queue.submit([f])}}(e,t)}function mi(e,t){if(e instanceof HTMLVideoElement)return[e.videoWidth,e.videoHeight,1];{const r=e,{width:n,height:i}=r;if(n>0&&i>0&&!li(e))return[n,i,1];const s=t.format||"rgba8unorm",{bytesPerElement:o,bytesPerChannel:a}=fi(s),c=Ir(e)||Array.isArray(e)?e:e.data;return function(e,t,r,n="2d"){if(r%1!=0)throw new Error("can't guess dimensions");if(e||t){if(t){if(!e&&(e=r/t)%1)throw new Error("can't guess dimensions")}else if((t=r/e)%1)throw new Error("can't guess dimensions")}else{const i=Math.sqrt(r/("cube"===n?6:1));i%1==0?(e=i,t=i):(e=r,t=1)}const i=r/e/t;if(i%1)throw new Error("can't guess dimensions");return[e,t,i]}(n,i,(Ir(c)?c.byteLength:c.length*a)/o)}}async function vi(e,t,r={}){const n=await Promise.all(t.map((e=>async function(e,t={}){const r=await fetch(e),n=await r.blob(),i={...t,...void 0!==t.colorSpaceConversion&&{colorSpaceConversion:"none"}};return await createImageBitmap(n,i)}(e))));return function(e,t,r={}){const n=mi(t[0],r);n[2]=n[2]>1?n[2]:t.length;const i=e.createTexture({dimension:ui(r.dimension),format:r.format||"rgba8unorm",mipLevelCount:r.mipLevelCount?r.mipLevelCount:r.mips?oi(n):1,size:n,usage:(r.usage??0)|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return pi(e,i,t,r),i}(e,n,r)}async function gi(e,t,r={}){return vi(e,[t],r)}const yi=e=>{let t=te.create(1/0,1/0,1/0),r=te.create(-1/0,-1/0,-1/0);for(const{AABB:n}of e)t=te.min(n.min,t),r=te.max(n.max,r);return{min:t,max:r}},xi=e=>{const t=yi(e),r=(t.max[0]-t.min[0])*(t.max[1]-t.min[1])*(t.max[2]-t.min[2]);return e.length*r},bi=(44,16,16*Math.ceil(2.75));class wi{#a;#c;#l;#u;#h;constructor(e,t){this.#a=e,this.#l=t.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#c=[],this.#d(this.#l,0),console.log(this.#c),this.#f()}get gpuBuffer(){const e=this.#a.createBuffer({size:this.#h.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),t=this.#a.createCommandEncoder();return t.copyBufferToBuffer(this.#h,0,e,0,this.#h.size),this.#a.queue.submit([t.finish()]),e.mapAsync(GPUMapMode.READ).then((()=>{new Float32Array(e.getMappedRange())})),this.#h}update(e){this.#l=e.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#u=0,this.#c=[],this.#d(this.#l,0),this.#f()}#d(e,t){if(0===this.#l.length)return;if(1===e.length)return void(this.#c[t]={leftChildIndex:this.#l.indexOf(e[0]),rightChildIndex:-1,objectCount:1,AABBMax:e[0].AABB.max,AABBMin:e[0].AABB.min});const r=yi(e);let n=-1,i=-1;const{left:s,right:o}=(e=>{let t=1/0,r=-1;const n=Math.floor(e.length/2);for(let i=1;i<e.length;i++){const s=e.slice(0,i),o=e.slice(i),a=xi(s)+xi(o),c=1*Math.abs(i-n)+1*a;c<t&&(t=c,r=i)}return{left:e.slice(0,r),right:e.slice(r)}})(e);s.length>0&&(n=++this.#u,this.#d(s,n)),o.length>0&&(i=++this.#u,this.#d(o,i)),this.#c[t]={leftChildIndex:n,rightChildIndex:i,objectCount:e.length,AABBMax:r.max,AABBMin:r.min}}#f(){return this.#h=this.#a.createBuffer({size:Math.max(this.#c.length,1)*bi,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1,label:"bvh buffer"}),this.#c.forEach(((e,t)=>{const r=t*bi,n=new ArrayBuffer(bi),i=new DataView(n);i.setInt32(0,e.leftChildIndex,!0),i.setInt32(4,e.rightChildIndex,!0),i.setUint32(8,e.objectCount,!0),i.setFloat32(16,e.AABBMin[0],!0),i.setFloat32(20,e.AABBMin[1],!0),i.setFloat32(24,e.AABBMin[2],!0),i.setFloat32(32,e.AABBMax[0],!0),i.setFloat32(36,e.AABBMax[1],!0),i.setFloat32(40,e.AABBMax[2],!0),this.#a.queue.writeBuffer(this.#h,r,n,0,bi)})),this.#h}}const _i="clear",Ti=async()=>{const e=bs.createShaderModule({code:"\n    struct VertexOutput {\n      @builtin(position) position : vec4f,\n    }\n    @vertex\n    fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n      var output : VertexOutput;\n      return output;\n    }\n    @fragment\n    fn fragment_main(@builtin(position) position : vec4f) -> @location(0) vec4<f32> {\n        return vec4(0.0);\n    }"}),t=bs.createRenderPipeline({label:_i,layout:"auto",vertex:{module:e,entryPoint:"vertex_main"},fragment:{module:e,entryPoint:"fragment_main",targets:[{format:Xe}]}});return{render:e=>{const r=e.commandEncoder.beginRenderPass({label:_i,timestampWrites:e.timestampWrites,colorAttachments:[{view:e.outputTextures.finalTexture.view,loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});r.setPipeline(t),r.draw(6),r.end()},label:_i}};function Si(e,t){let r=0,n=1/t,i=e;for(;i>0;)r+=n*(i%t),i=Math.floor(i/t),n/=t;return r}let Pi,ki=!1;class Ei extends e{position;rotation;scale;#p;constructor(e,t,r){super(),this.position=e,this.rotation=t,this.scale=r,this.#p=ge.identity()}get transform(){let e=ge.identity();return ge.translate(e,this.position,e),ge.multiply(e,ge.fromQuat(this.rotation),e),ge.scale(e,this.scale,e),e}get previousTransform(){return this.#p}set previousTransform(e){this.#p=e}get direction(){return te.transformQuat(te.create(0,0,1),this.rotation)}get right(){return te.transformQuat(te.create(1,0,0),this.rotation)}get left(){return te.transformQuat(te.create(-1,0,0),this.rotation)}get up(){return te.transformQuat(te.create(0,1,0),this.rotation)}get down(){return te.transformQuat(te.create(0,-1,0),this.rotation)}}class Mi extends e{size;atlasLocation;paletteIndex;octreeBufferIndex;name;constructor({size:e,atlasLocation:t,paletteIndex:r,octreeBufferIndex:n,name:i}){super(),this.size=e,this.atlasLocation=t,this.paletteIndex=r,this.octreeBufferIndex=n,this.name=i}}const Ai=(e,t)=>{const r=te.create(e.size[0]/2,e.size[1]/2,e.size[2]/2);return(e=>{let t=te.create(1/0,1/0,1/0),r=te.create(-1/0,-1/0,-1/0);for(const n of e)t=te.min(t,n),r=te.max(r,n);return{min:t,max:r}})([te.create(-r[0],-r[1],-r[2]),te.create(-r[0],-r[1],r[2]),te.create(-r[0],r[1],-r[2]),te.create(-r[0],r[1],r[2]),te.create(r[0],-r[1],-r[2]),te.create(r[0],-r[1],r[2]),te.create(r[0],r[1],-r[2]),te.create(r[0],r[1],r[2])].map((e=>te.transformMat4(e,t.transform))))},Ci="const MAX_COARSE_RAY_STEPS = 64;\r\n\r\nfn rayMarchCoarse(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>) -> bool {\r\n    let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\r\n    var voxelSize = vec3<f32>(1.0);\r\n    var objectPos = objectRayOrigin;\r\n    var currentIndex = vec3<i32>(round(objectPos));\r\n    var tDelta = voxelSize / abs(objectRayDirection);\r\n    var tIncrement = min(tDelta.x, min(tDelta.y, tDelta.z));\r\n\r\n    for(var i = 0; i < MAX_COARSE_RAY_STEPS; i++)\r\n    {\r\n      let samplePosition = objectPos + voxelObject.atlasLocation;\r\n      let uv = samplePosition / vec3<f32>(textureDimensions(voxels));\r\n      let mipSample0 = textureSampleLevel(voxels, nearestSampler, uv, 0.0);\r\n\r\n      if(mipSample0.a > 0.0){\r\n          return true;\r\n      }\r\n\r\n      objectPos += objectRayDirection * tIncrement;\r\n      currentIndex = vec3<i32>(round(objectPos));\r\n//      if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n//          break;\r\n//      }\r\n    }\r\n    return false;\r\n}\r\n\r\nfn rayMarchTransformedCoarse(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> bool {\r\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz;\r\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n    return rayMarchCoarse(voxelObject, objectRayDirection, objectRayOrigin);\r\n}\r\n\r\n// Used for shadows, return first hit\r\nfn rayMarchBVHCoarse(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxDistance: f32) -> bool {\r\n  // Create a stack to store the nodes to visit\r\n      var stack = stack_new();\r\n      stack_push(&stack, 0);\r\n\r\n      var iterations = 0;\r\n      var nodeIndex = 0;\r\n\r\n      while (stack.head > 0u && iterations < 32) {\r\n        let node = bvhNodes[nodeIndex];\r\n        if(node.objectCount == 0){\r\n          nodeIndex = stack_pop(&stack);\r\n        }\r\n        // valid leaf, raymarch it\r\n        else if(node.objectCount == 1){\r\n            // Raymarch the voxel object if it's a leaf node\r\n            let voxelObject = voxelObjects[node.leftIndex]; // left index represents the voxel object index for leaf nodes\r\n            let AABBDist = getDistanceToNode(rayOrigin, rayDirection, node);\r\n            if(rayMarchTransformedCoarse(voxelObject, rayDirection, rayOrigin + rayDirection * AABBDist)){\r\n              return true;\r\n            }\r\n            // Pop the stack and continue\r\n            nodeIndex = stack_pop(&stack);\r\n        }\r\n        else{\r\n          let leftDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.leftIndex]);\r\n          let rightDist = getDistanceToNode(rayOrigin, rayDirection, bvhNodes[node.rightIndex]);\r\n          let hitLeft = leftDist >= 0.0 && leftDist < maxDistance;\r\n          let hitRight = rightDist >= 0.0 && rightDist < maxDistance;\r\n          if(hitLeft){\r\n            var nearIndex = node.leftIndex;\r\n            // We hit both left and right, choose the closest one\r\n            if(hitRight){\r\n              if(leftDist < rightDist){\r\n                // left is closer, push right to stack\r\n                stack_push(&stack, node.rightIndex);\r\n              } else {\r\n                // right is closer, push left to stack\r\n                stack_push(&stack, node.leftIndex);\r\n                nearIndex = node.rightIndex;\r\n              }\r\n            }\r\n            nodeIndex = nearIndex;\r\n          }\r\n          // We only hit the right Node\r\n          else if(hitRight){\r\n            nodeIndex = node.rightIndex;\r\n          }\r\n          // We didn't hit any node, pop the stack\r\n          else{\r\n            nodeIndex = stack_pop(&stack);\r\n          }\r\n        }\r\n\r\n        iterations += 1;\r\n      }\r\n\r\n      return false;\r\n}",Ii="// Constants\r\nconst infinity : f32 = 99999999.0;\r\n\r\n// Utility functions\r\nfn degreesToRadians(degrees : f32) -> f32 {\r\n    return degrees * (3.1415926535897932385 / 180.0);\r\n}\r\n\r\nfn unitVector(v : vec3<f32>) -> vec3<f32> {\r\n    return v / length(v);\r\n}\r\n\r\nfn lengthSquared(v : vec3<f32>) -> f32 {\r\n    return v.x * v.x + v.y * v.y + v.z * v.z;\r\n}\r\n\r\nfn random(co : vec2<f32>) -> f32 {\r\n    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nfn randomMinMax(co : vec2<f32>, min : f32, max : f32) -> f32 {\r\n    return min + (max - min) * random(co);\r\n}\r\n\r\nfn randomFloat3(co : vec2<f32>) -> vec3<f32> {\r\n    return vec3<f32>(random(co), random(co * 2.0), random(co * 3.0));\r\n}\r\n\r\nfn randomFloat3MinMax(co : vec2<f32>, min : f32, max : f32) -> vec3<f32> {\r\n    return vec3<f32>(randomMinMax(co, min, max), randomMinMax(co * 2.0, min, max), randomMinMax(co * 3.0, min, max));\r\n}\r\n\r\nfn randomInUnitSphere(co : vec2<f32>) -> vec3<f32> {\r\n    var p : vec3<f32> = randomFloat3MinMax(co, -1.0, 1.0);\r\n    while (lengthSquared(p) < 1.0) {\r\n        p = randomFloat3MinMax(co, -1.0, 1.0);\r\n    }\r\n    return p;\r\n}\r\n\r\nfn randomInUnitDisk(seed : vec2<f32>) -> vec2<f32> {\r\n    let r = sqrt(random(seed));\r\n    let theta = 2.0 * 3.14159265359 * random(vec2<f32>(seed.y, seed.x));\r\n    return vec2<f32>(cos(theta), sin(theta)) * r;\r\n}\r\n\r\nfn randomInPlanarUnitDisk(seed : vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let disk = randomInUnitDisk(seed);\r\n    var diskNormal = cross(normal, vec3<f32>(0.0, 1.0, 0.0));\r\n    if (length(diskNormal) < 0.01) {\r\n        diskNormal = cross(normal, vec3<f32>(1.0, 0.0, 0.0));\r\n    }\r\n    diskNormal = normalize(diskNormal);\r\n    let diskTangent = cross(diskNormal, normal);\r\n    return disk.x * diskTangent + disk.y * diskNormal;\r\n}\r\n\r\nfn reflect(v : vec3<f32>, n : vec3<f32>) -> vec3<f32> {\r\n    return v - 2.0 * dot(v, n) * n;\r\n}\r\n\r\nfn randomUnitVector(co : vec2<f32>) -> vec3<f32> {\r\n    return unitVector(randomInUnitSphere(co));\r\n}\r\n\r\nfn nearZero(e : vec3<f32>) -> bool {\r\n    const s : f32 = 1e-8;\r\n    return (abs(e.x) < s) && (abs(e.y) < s) && (abs(e.z) < s);\r\n}\r\n\r\nfn randomInHemisphere(co : vec2<f32>, normal : vec3<f32>) -> vec3<f32> {\r\n    let inUnitSphere = randomUnitVector(co);\r\n    if (dot(inUnitSphere, normal) > 0.0) {\r\n        return inUnitSphere;\r\n    }\r\n    return -inUnitSphere;\r\n}\r\n\r\nfn randomAlongVector(co : vec2<f32>, direction : vec3<f32>) -> vec3<f32> {\r\n    return normalize(direction) * random(co);\r\n}\r\n\r\n// Function to perturb the normal vector within the hemisphere\r\nfn perturbDirection(normal: vec3<f32>, scatterAmount: f32, co: vec2<f32>) -> vec3<f32> {\r\n    // Generate a random vector in a hemisphere\r\n    let hemisphereVector : vec3<f32> = randomInHemisphere(co, normal);\r\n\r\n    // Combine the perturbation with the original normal\r\n    let perturbedDir : vec3<f32> = normalize(normal + scatterAmount * hemisphereVector);\r\n\r\n    return perturbedDir;\r\n}\r\n\r\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\r\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\r\nfn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\n\r\nfn perlinNoise3(P: vec3<f32>) -> f32 {\r\n    var Pi0 : vec3<f32> = floor(P); // Integer part for indexing\r\n    var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1\r\n    Pi0 = Pi0 % vec3<f32>(289.);\r\n    Pi1 = Pi1 % vec3<f32>(289.);\r\n    let Pf0 = fract(P); // Fractional part for interpolation\r\n    let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.\r\n    let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    let iy = vec4<f32>(Pi0.yy, Pi1.yy);\r\n    let iz0 = Pi0.zzzz;\r\n    let iz1 = Pi1.zzzz;\r\n\r\n    let ixy = permute4(permute4(ix) + iy);\r\n    let ixy0 = permute4(ixy + iz0);\r\n    let ixy1 = permute4(ixy + iz1);\r\n\r\n    var gx0: vec4<f32> = ixy0 / 7.;\r\n    var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;\r\n    gx0 = fract(gx0);\r\n    var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\r\n    var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));\r\n    gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);\r\n    gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);\r\n\r\n    var gx1: vec4<f32> = ixy1 / 7.;\r\n    var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;\r\n    gx1 = fract(gx1);\r\n    var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\r\n    var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));\r\n    gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);\r\n    gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);\r\n\r\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\r\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\r\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\r\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\r\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\r\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\r\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\r\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\r\n\r\n    let norm0 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 = g000 * norm0.x;\r\n    g010 = g010 * norm0.y;\r\n    g100 = g100 * norm0.z;\r\n    g110 = g110 * norm0.w;\r\n    let norm1 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 = g001 * norm1.x;\r\n    g011 = g011 * norm1.y;\r\n    g101 = g101 * norm1.z;\r\n    g111 = g111 * norm1.w;\r\n\r\n    let n000 = dot(g000, Pf0);\r\n    let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\r\n    let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\r\n    let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\r\n    let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\r\n    let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\r\n    let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\r\n    let n111 = dot(g111, Pf1);\r\n\r\n    var fade_xyz: vec3<f32> = fade3(Pf0);\r\n    let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix\r\n    let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);\r\n    let n_yz = mix(n_z.xy, n_z.zw, vec2f(f32(fade_xyz.y))); // simplify after chrome bug fix\r\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 2.2 * n_xyz;\r\n}",zi="struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};",Oi={binding:9,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Ri={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},Bi={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Ui={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Xe}},Ni={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Di={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},Li={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},ji={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},Fi={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Gi={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},qi={binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Vi={binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Wi={binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},Yi={binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},Hi={binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},$i={binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},Xi={binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},Zi={binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},Ki={binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},Qi={binding:19,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},Ji="diffuse",es=[Ri,Bi,Ui,Ni,Di,Li,ji,Fi,Gi,qi,Vi,Wi,Yi,Hi,$i,Xi,Zi,Ki,Qi],ts=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32,\n  elapsed: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${Xe}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(9) var intermediaryTexture : texture_2d<f32>;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\n\nconst DOWNSCALE = 1;\n${zi}\n${Ii}\n${Ye}\n${Qe}\n${Je}\n${et}\n${Ci}\n${He}\n\r\n// TODO: offset in object space instead of world space to scale with object size\r\nfn diffuseRay(worldPos: vec3<f32>, shadowRayDirection: vec3<f32>, normal: vec3<f32>, voxelObjectSize: f32) -> bool {\r\n  let rayOrigin = worldPos  + normal * 0.005;\r\n  return rayMarchBVHShadows(rayOrigin, shadowRayDirection, 0).hit;\r\n}\r\n\r\nfn shadowRay(worldPos: vec3<f32>, shadowRayDirection: vec3<f32>, normal: vec3<f32>, voxelObjectSize: f32) -> bool {\r\n  let rayOrigin = worldPos + normal * 0.005;\r\n  return rayMarchBVHShadows(rayOrigin, shadowRayDirection, 0).hit;\r\n}\r\n\r\n\r\nconst SUN_COLOR = vec3(0.6,0.5,0.4) * 100.0;\r\nconst MOON_COLOR = vec3<f32>(0.5, 0.5, 1.0);\r\nconst MIN_RADIANCE = 0.5;\r\nconst SUBPIXEL_SAMPLE_POSITIONS: array<vec2<f32>, 8> = array<vec2<f32>, 8>(\r\n  vec2<f32>(0.25, 0.25),\r\n  vec2<f32>(0.75, 0.25),\r\n  vec2<f32>(0.25, 0.75),\r\n  vec2<f32>(0.75, 0.75),\r\n  vec2<f32>(0.125, 0.125),\r\n  vec2<f32>(0.375, 0.125),\r\n  vec2<f32>(0.625, 0.125),\r\n  vec2<f32>(0.875, 0.125)\r\n);\r\nconst BLUE_NOISE_SIZE = 511;\r\nconst SUN_DIRECTION: vec3<f32> = vec3<f32>(1.0,-1.0,-1.0);\r\nconst SKY_COLOUR: vec3<f32> = vec3<f32>(0.6, 0.8, 0.9);\r\nconst SHADOW_ACNE_OFFSET: f32 = 0.001;\r\nconst SCATTER_AMOUNT: f32 = 0.03;\r\nconst POSITION_SCATTER_AMOUNT: f32 = 0.02;\r\n\r\nstruct Light {\r\n  direction: vec3<f32>,\r\n  colour: vec3<f32>,\r\n};\r\n\r\nstruct BufferRay {\r\n  pixel : vec2<u32>,\r\n  direction : vec3<f32>,\r\n  origin : vec3<f32>,\r\n  lightColour : vec3<f32>,\r\n};\r\n\r\nfn randomInCosineWeightedHemisphere(r: vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n  let r1 = 2.0 * PI * r.x;\r\n  let r2 = r.y;\r\n  let r2s = sqrt(r2);\r\n  let w = normal;\r\n  let u = normalize(cross((select(vec3<f32>(1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0),abs(w.x) > 0.1)), w));\r\n  let v = cross(w, u);\r\n  return normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.0 - r2));\r\n}\r\n\r\nconst SAMPLES_PER_PIXEL = 1u;\r\nconst SAMPLE_OFFSETS: array<vec2<i32>, 4> = array<vec2<i32>, 4>(\r\n  vec2<i32>(0, 0),\r\n  vec2<i32>(1, 1),\r\n  vec2<i32>(0, 1),\r\n  vec2<i32>(1, 0),\r\n);\r\n\r\nfn tracePixel(outputPixel:vec2<i32>, downscaleFactor: i32, blueNoiseOffset: vec2<i32>) -> vec3<f32>{\r\n  let pixel = outputPixel * downscaleFactor;\r\n  let uv = (vec2<f32>(outputPixel) + vec2(0.5)) / vec2<f32>(textureDimensions(outputTex));\r\n  var normalSample = textureLoad(normalTex, pixel, 0).rgb;\r\n  let worldPosSample = textureLoad(worldPosTex, pixel, 0);\r\n  let voxelObject = voxelObjects[i32(worldPosSample.a)];\r\n  let axisScales = getScaleFromMatrix(voxelObject.transform);\r\n  let voxelObjectScale = axisScales.x * axisScales.y * axisScales.z;\r\n\r\n  let depthSample = textureLoad(depthTex, pixel, 0).r;\r\n  if(depthSample < 0.00001){ // SKY\r\n    return vec3(0.0);\r\n  }\r\n  let rayDirection = calculateRayDirection(uv, viewProjections.inverseViewProjection);\r\n  var worldPos = worldPosSample.rgb;\r\n  var samplePixel = pixel;\r\n  samplePixel.x += i32(time.frame) * 32;\r\n  samplePixel.y += i32(time.frame) * 16;\r\n  var blueNoisePixel = ((samplePixel / downscaleFactor) + blueNoiseOffset) % BLUE_NOISE_SIZE;\r\n  if(time.frame % 2 == 0){\r\n    blueNoisePixel.y = BLUE_NOISE_SIZE - blueNoisePixel.y;\r\n  }\r\n  if(time.frame % 3 == 0){\r\n    blueNoisePixel.x = BLUE_NOISE_SIZE - blueNoisePixel.x;\r\n  }\r\n  var r = textureLoad(blueNoiseTex, blueNoisePixel, 0).rg;\r\n  let sampleWorldPos = worldPos + randomInPlanarUnitDisk(r, normalSample) * POSITION_SCATTER_AMOUNT;\r\n  var radiance = vec3(MIN_RADIANCE);\r\n\r\n  // Calculate the probability of sampling the sun\r\n//  let sunProbability = 0.0;\r\n  let sunProbability = clamp(dot(normalSample, sunDirection) * 0.5, 0.0, 1.0) * 0.5;\r\n//  let sunProbability = select(0.0, select(0.2, 0.5, uv.x > 0.66), uv.x > 0.33);\r\n  // Calculate the probability of sampling the diffuse light\r\n  let diffuseProbability = 1.0 - sunProbability;\r\n\r\n  let maxDiffuseIntensity = vec3(4.0);\r\n  let maxSunIntensity = vec3(32.0);\r\n\r\n// TODO: push to buffer instead and evaluate in a separate pass\r\n  if(r.x < sunProbability){\r\n    let shadowRayDirection = sunDirection + randomInCosineWeightedHemisphere(r, sunDirection) * SCATTER_AMOUNT;\r\n    if(!shadowRay(sampleWorldPos, shadowRayDirection, normalSample, voxelObjectScale)){\r\n      let viewDirection = normalize(cameraPosition - worldPos);\r\n      let diffuse = max(dot(normalSample, sunDirection), 0.0);\r\n      let specular = pow(max(dot(normalSample, normalize(sunDirection + viewDirection)), 0.0), 32.0);\r\n      let lightIntensity = clamp(SUN_COLOR * (diffuse + specular), vec3(MIN_RADIANCE), maxSunIntensity);\r\n      radiance = lightIntensity;\r\n    }\r\n  } else{\r\n     var diffuseDirection = randomInCosineWeightedHemisphere(r, normalSample);\r\n     if(!diffuseRay(sampleWorldPos, diffuseDirection, normalSample, voxelObjectScale)){\r\n//          let sky = textureSampleLevel(skyCube, linearSampler, diffuseDirection, 0.0) * 2.0;\r\n          let sky = vec4(2.0);\r\n          radiance = clamp(vec3(sky.rgb), vec3(MIN_RADIANCE), maxDiffuseIntensity);\r\n      }\r\n  }\r\n\r\n  return radiance;\r\n\r\n}\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\r\n  let result = tracePixel(pixel, 1, vec2(0));\r\n  textureStore(outputTex, pixel, vec4(result, 1.0));\r\n}\r\n\r\n\r\n@group(1) @binding(0) var<storage, read_write> shadowRayBuffer : array<vec2<u32>>;\r\n\r\n// 2x2 grid of offsets\r\nconst RAY_OFFSETS = array<vec2<u32>, 4>(\r\n  vec2<u32>(0,0),\r\n  vec2<u32>(1, 0),\r\n  vec2<u32>(0, 1),\r\n  vec2<u32>(1, 1)\r\n);\r\n\r\n@compute @workgroup_size(128, 1, 1)\r\nfn bufferMarch(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n) {\r\n  let bufferIndex = GlobalInvocationID.x / 4;\r\n  let localRayIndex = GlobalInvocationID.x % 4;\r\n  let pixel = shadowRayBuffer[bufferIndex];\r\n  let offsetPixel = pixel + RAY_OFFSETS[localRayIndex];\r\n  let result = tracePixel(vec2<i32>(offsetPixel), 1, vec2(0));\r\n  textureStore(outputTex, offsetPixel, vec4(result, 1.0));\r\n}\r\n\r\nconst PI = 3.1415926535897932384626433832795;\r\n\r\nfn polarToCartesian(angle: f32, radius: f32) -> vec2<f32> {\r\n  let radians = angle * PI / 180.0;\r\n  let x = radius * cos(radians);\r\n  let y = radius * sin(radians);\r\n  return vec2<f32>(x, y);\r\n}\r\n\r\nfn calculateVariance(neighborhood: array<vec3<f32>, 9>) -> f32 {\r\n    var mean: vec3<f32> = vec3<f32>(0.0);\r\n    var variance: f32 = 0.0;\r\n    // Calculate the mean\r\n    for (var i = 0; i < 9; i = i + 1) {\r\n        mean = mean + neighborhood[i];\r\n    }\r\n    mean = mean / 9.0;\r\n    // Calculate the variance\r\n    for (var i = 0; i < 9; i = i + 1) {\r\n        var diff = length(neighborhood[i] - mean);\r\n        variance = variance + diff * diff;\r\n    }\r\n\r\n    return variance / 9.0;\r\n}\r\n\r\n\r\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\r\n    vec2<i32>(-1, -1),\r\n    vec2<i32>(0, -1),\r\n    vec2<i32>(1, -1),\r\n    vec2<i32>(-1, 0),\r\n    vec2<i32>(1, 0),\r\n    vec2<i32>(-1, 1),\r\n    vec2<i32>(0, 1),\r\n    vec2<i32>(1, 1)\r\n);\r\n\r\nconst DEPTH_SENSITIVITY = 10000.0;\r\nconst BLUR_RADIUS = 2.0;\r\nconst GOLDEN_RATIO = 1.61803398875;\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn composite(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = vec2<i32>(GlobalInvocationID.xy);\r\n  let shadowRef = textureLoad(intermediaryTexture, pixel, 0);\r\n  let albedoRef = textureLoad(albedoTex, pixel, 0);\r\n\r\n  textureStore(outputTex, pixel, shadowRef * albedoRef);\r\n}\r\n`,rs=async()=>{const e=bs.createBindGroupLayout({entries:es}),t=bs.createComputePipeline({label:Ji,layout:bs.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:bs.createShaderModule({code:ts}),entryPoint:"main"}});let r,n,i,s,o,a,c,l,u,h,d=bs.createSampler({magFilter:"nearest",minFilter:"nearest"}),f=bs.createSampler({magFilter:"linear",minFilter:"linear"});const p=await(async()=>{const e=bs.createBindGroupLayout({entries:[...es,Oi]}),t=await bs.createComputePipelineAsync({label:"diffuse - composite",layout:bs.createPipelineLayout({bindGroupLayouts:[e]}),compute:{module:bs.createShaderModule({code:ts}),entryPoint:"composite"}});let r;return(n,i,s,o,a)=>{r||(r=((t,r,n)=>bs.createBindGroup({layout:e,entries:[...t,{binding:2,resource:r},{binding:9,resource:n}]}))(i,o,a)),n.setPipeline(t),n.setBindGroup(0,r),n.dispatchWorkgroups(Math.ceil(s.width/16),Math.ceil(s.height/8))}})();return{render:m=>{const{outputTextures:v,timestampWrites:g,viewProjectionMatricesBuffer:y,volumeAtlas:x,cameraPositionBuffer:b,transformationMatrixBuffer:w,sunDirectionBuffer:_,blueNoiseTextureView:T,timeBuffer:S,bvhBuffer:P,commandEncoder:k}=m;if(r||(r=bs.createTexture({size:[v.finalTexture.width,v.finalTexture.height,1],format:v.finalTexture.format,usage:v.finalTexture.usage}),n=r.createView()),!i){const e={size:[v.finalTexture.width,v.finalTexture.height,1],mipLevelCount:2,format:v.finalTexture.format,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST};i=bs.createTexture(e),a=bs.createTexture(e),u=bs.createTexture(e),c=a.createView({baseMipLevel:0,mipLevelCount:1}),s=i.createView({baseMipLevel:0,mipLevelCount:1}),h=u.createView({baseMipLevel:0,mipLevelCount:1}),o=i.createView({baseMipLevel:1,mipLevelCount:1}),l=a.createView({baseMipLevel:1,mipLevelCount:1})}k.copyTextureToTexture({texture:v.finalTexture.texture},{texture:r},{width:v.finalTexture.width,height:v.finalTexture.height,depthOrArrayLayers:1});const E=[{binding:0,resource:v.depthTexture.view},{binding:1,resource:n},{binding:3,resource:{buffer:y}},{binding:4,resource:x.atlasTextureView},{binding:5,resource:{buffer:b}},{binding:6,resource:{buffer:w}},{binding:7,resource:{buffer:_}},{binding:8,resource:f},{binding:10,resource:v.normalTexture.view},{binding:11,resource:T},{binding:12,resource:{buffer:S}},{binding:13,resource:d},{binding:14,resource:v.velocityTexture.view},{binding:15,resource:{buffer:P}},{binding:16,resource:v.worldPositionTexture.view},{binding:17,resource:v.albedoTexture.view},{binding:18,resource:v.skyTexture.createView({dimension:"cube"})},{binding:19,resource:{buffer:x.octreeBuffer}}],M={layout:e,entries:[...E,{binding:2,resource:s}]};let A=k.beginComputePass({label:"shadow trace",timestampWrites:g});const C=bs.createBindGroup(M);A.setPipeline(t),A.setBindGroup(0,C);const I=Math.ceil(v.finalTexture.width/16),z=Math.ceil(v.finalTexture.height/8);A.dispatchWorkgroups(I,z),A.end(),A=k.beginComputePass({label:"shadow composite",timestampWrites:{querySet:g.querySet,beginningOfPassWriteIndex:g.beginningOfPassWriteIndex+8,endOfPassWriteIndex:g.endOfPassWriteIndex+8}}),p(A,E,v.finalTexture.texture,v.finalTexture.view,s),A.end()},label:Ji,timestampLabels:["shadow trace","shadow interpolate","full res shadow","shadow denoise","shadow composite"]}},ns="const PI\t \t= 3.141592;\r\nconst EPSILON_NRM = 0.0001; // TODO: use resolution to normalize\r\n\r\nstruct Time {\r\n  frame: u32,\r\n  deltaTime: f32,\r\n  elapsed: f32\r\n};\r\n\r\n// Cloud parameters\r\nconst EARTH_RADIUS = 6300e3;\r\nconst CLOUD_START = 600.0;\r\nconst CLOUD_HEIGHT = 600.0;\r\nconst SUN_POWER = vec3(0.6,0.5,0.4) * 800.0;\r\nconst LOW_SCATTER = vec3(0.6,0.4,0.3)  * 10.0;\r\nconst MAX_DISTANCE = 10000.0;\r\n\r\n@group(0) @binding(0) var depth : texture_2d<f32>;\r\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\r\n@group(0) @binding(2) var outputTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\r\n@group(0) @binding(4) var<uniform> sunDirection : vec3<f32>;\r\n@group(0) @binding(5) var<uniform> time : Time;\r\n@group(0) @binding(6) var blueNoiseTex : texture_2d<f32>;\r\n@group(0) @binding(7) var pebbleTex : texture_2d<f32>;\r\n@group(0) @binding(8) var linearSampler : sampler;\r\n@group(0) @binding(9) var<uniform> cameraPosition : vec3<f32>;\r\n@group(0) @binding(10) var worldPosTex : texture_2d<f32>;\r\n@group(1) @binding(1) var skyCube : texture_cube<f32>;\r\n@group(1) @binding(2) var skyCubeWrite : texture_storage_2d_array<rgba16float, write>;\r\n@group(1) @binding(3) var lastSkyCube : texture_2d_array<f32>;\r\n\r\n\r\n\r\n// Noise generation functions (by iq)\r\nfn hash( n: f32 ) -> f32\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfn hash2( p: vec2<f32> ) -> f32 {\r\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\r\n}\r\n\r\nfn sampleBlueNoise( uv: vec2<f32> ) -> vec2<f32>\r\n{\r\n    return textureSampleLevel(blueNoiseTex, linearSampler, uv, 0.0).rg;\r\n}\r\n\r\nfn samplePebbles( uv: vec2<f32> ) -> f32\r\n{\r\n  return textureSampleLevel(pebbleTex, linearSampler, uv, 0.0).r;\r\n}\r\n\r\nfn noise3( x:vec3<f32> ) -> f32\r\n{\r\n  var p = floor(x);\r\n  var f = fract(x);\r\n  f = f*f*(3.0 - 2.0 *f);\r\n\tlet uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tlet rg = sampleBlueNoise((uv+0.5)/256.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfn noise2( p:vec2<f32> ) -> f32\r\n{\r\n  let i = floor( p );\r\n  var f = fract( p );\r\n\tf = f*f*(3.0 - 2.0*f);\r\n  return -1.0+2.0*mix( mix( hash2( i + vec2(0.0,0.0) ),\r\n                     hash2( i + vec2(1.0,0.0) ), f.x),\r\n                mix( hash2( i + vec2(0.0,1.0) ),\r\n                     hash2( i + vec2(1.0,1.0) ), f.x), f.y);\r\n}\r\n\r\nfn fbm( p: vec3<f32> ) -> f32\r\n{\r\n    var pCopy = p;\r\n    let m = mat3x3<f32>( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n    var f = 0.5000*noise3( pCopy );\r\n    pCopy = m*pCopy*2.02;\r\n    f += 0.2500*noise3( pCopy );\r\n    pCopy = m*pCopy*2.03;\r\n    f += 0.1250*noise3( pCopy );\r\n    return f;\r\n}\r\n\r\nfn intersectSphere(origin: vec3<f32>, dir: vec3<f32>, spherePos: vec3<f32>, sphereRad: f32) -> f32\r\n{\r\n\tlet oc = origin - spherePos;\r\n\tlet b = 2.0 * dot(dir, oc);\r\n\tlet c = dot(oc, oc) - sphereRad*sphereRad;\r\n\tlet disc = b * b - 4.0 * c;\r\n\tif (disc < 0.0)\r\n\t{\r\n\t  return -1.0;\r\n\t}\r\n\r\n//    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\r\n  let q = (-b + select(sqrt(disc), -sqrt(disc), b < 0.0)) / 2.0;\r\n\tvar t0 = q;\r\n\tvar t1 = c / q;\r\n\tif (t0 > t1) {\r\n\t\tvar temp = t0;\r\n\t\tt0 = t1;\r\n\t\tt1 = temp;\r\n\t}\r\n\tif (t1 < 0.0){\r\n\t  return -1.0;\r\n\t}\r\n\r\n  return select(t0, t1, t0 < 0.0);\r\n}\r\n\r\n// TODO: pass time buffer\r\n\r\n// return the density of clouds at a given point, and height\r\nfn clouds(p: vec3<f32>, t: f32) -> vec2<f32>\r\n{\r\n    var pCopy = p;\r\n    let atmoHeight = length(p - vec3(0.0, -EARTH_RADIUS, 0.0)) - EARTH_RADIUS;\r\n    let cloudHeight = clamp((atmoHeight-CLOUD_START)/(CLOUD_HEIGHT), 0.0, 1.0);\r\n    pCopy.z += t*40;\r\n    let largeWeather = clamp((samplePebbles(-0.00005*pCopy.zx) - 0.18)*5.0, 0.0, 2.0);\r\n    //let largeWeather = 1.0;\r\n    pCopy.x += t*32;\r\n    var weather = largeWeather*max(0.0,samplePebbles(0.0002*pCopy.zx) - 0.28)/0.72;\r\n    weather *= smoothstep(0.0, 0.5, cloudHeight) * smoothstep(0.5,1.0, cloudHeight);\r\n    let cloudShape = pow(weather, 0.3+1.5*smoothstep(0.2, 0.5, cloudHeight));\r\n    if(cloudShape <= 0.0){\r\n        return vec2(0.0, cloudHeight);\r\n    }\r\n    pCopy.x += t*48;\r\n\t  var den= max(0.0, cloudShape - 0.7*fbm(p*.01));\r\n    if(den <= 0.0){\r\n        return vec2(0.0, cloudHeight);\r\n    }\r\n    pCopy.y += t*60;\r\n    den= max(0.0, den - 0.2*fbm(p*0.05));\r\n    return vec2(largeWeather*0.2*min(1.0, 5.0*den), cloudHeight);\r\n}\r\n\r\n// From https://www.shadertoy.com/view/4sjBDG\r\nfn numericalMieFit( costh: f32) -> f32\r\n{\r\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\r\n    // the low intensity behavior.\r\n    var bestParams = array<f32, 10>();\r\n    bestParams[0]=9.805233e-06;\r\n    bestParams[1]=-6.500000e+01;\r\n    bestParams[2]=-5.500000e+01;\r\n    bestParams[3]=8.194068e-01;\r\n    bestParams[4]=1.388198e-01;\r\n    bestParams[5]=-8.370334e+01;\r\n    bestParams[6]=7.810083e+00;\r\n    bestParams[7]=2.054747e-03;\r\n    bestParams[8]=2.600563e-02;\r\n    bestParams[9]=-4.552125e-12;\r\n\r\n    var p1 = costh + bestParams[3];\r\n    let expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));\r\n    let expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);\r\n    return dot(expValues, expValWeight);\r\n}\r\n\r\nfn lightRay(p: vec3<f32>, phaseFunction: f32, dC: f32, mu: f32, sun_direction: vec3<f32>, cloudHeight: f32, t: f32) -> f32\r\n{\r\n    let nbSampleLight = 6;\r\n\t  let zMaxl         = 200.;\r\n    let stepL         = zMaxl/f32(nbSampleLight);\r\n    var pCopy = p;\r\n    var cloudHeightCopy = 0.0;\r\n\r\n    var lighRayDen = 0.0;\r\n    pCopy += sun_direction*stepL*hash(dot(pCopy, vec3(12.256, 2.646, 6.356)) + t * 4);\r\n    for(var j=0; j<nbSampleLight; j++)\r\n    {\r\n        let cloudsResult = clouds( pCopy + sun_direction*f32(j)*stepL, time.elapsed);\r\n        lighRayDen += cloudsResult.x;\r\n        cloudHeightCopy = cloudsResult.y;\r\n    }\r\n    let scatterAmount = mix(0.008, 1.0, smoothstep(0.0,0.96, mu));\r\n    let beersLaw = exp(-stepL*lighRayDen)+0.5*scatterAmount*exp(-0.1*stepL*lighRayDen)+scatterAmount*0.4*exp(-0.02*stepL*lighRayDen);\r\n    return beersLaw * phaseFunction * mix(0.05 + 1.5*pow(min(1.0, dC*8.5), 0.3+5.5*cloudHeightCopy), 1.0, clamp(lighRayDen*0.4, 0.0, 1.0));\r\n}\r\n\r\n\r\nfn Schlick (f0: f32, VoH: f32 ) -> f32\r\n{\r\n\treturn f0+(1.-f0)*pow(1.0-VoH,5.0);\r\n}\r\n\r\nfn skyRay(org: vec3<f32>, dir: vec3<f32>,sun_direction: vec3<f32>) -> vec3<f32>\r\n{\r\n\r\n  let ATM_START = EARTH_RADIUS+CLOUD_START;\r\n\tlet ATM_END = ATM_START+CLOUD_HEIGHT;\r\n\r\n  let nbSample = 8;\r\n  var color = vec3(0.0);\r\n  let distToAtmStart = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_START);\r\n  let distToAtmEnd = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_END);\r\n  var p = org + distToAtmStart * dir;\r\n\r\n  let stepS = (distToAtmEnd-distToAtmStart) / f32(nbSample);\r\n  var T = 1.;\r\n  let mu = dot(sun_direction, dir);\r\n  let phaseFunction = numericalMieFit(mu);\r\n  p += dir*stepS*hash(dot(dir, vec3(12.256, 2.646, 6.356)) + time.elapsed * 4);\r\n  if(dir.y > 0.01){\r\n    for(var i=0; i<nbSample; i++)\r\n    {\r\n      if(distance(p, org) > MAX_DISTANCE){\r\n        break;\r\n      }\r\n      let cloudResult = clouds(p, time.elapsed);\r\n      let cloudHeight = cloudResult.y;\r\n      let density = cloudResult.x;\r\n      if(density>0.)\r\n      {\r\n        let intensity = lightRay(p, phaseFunction, density, mu, sun_direction, cloudHeight, time.elapsed);\r\n        let ambient = (0.5 + 0.6*cloudHeight)*vec3(0.2, 0.5, 1.0)*6.5 + vec3(0.8) * max(0.0, 1.0 - 2.0*cloudHeight);\r\n        var radiance = ambient + SUN_POWER*intensity;\r\n        radiance*=density;\r\n        color += T*(radiance - radiance * exp(-density * stepS)) / density;   // By Seb Hillaire\r\n        T *= exp(-density*stepS);\r\n        if( T <= 0.05){\r\n          break;\r\n        }\r\n      }\r\n      p += dir*stepS;\r\n    }\r\n  }\r\n\r\n  let pC = org + intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_END+1000.0)*dir;\r\n  // high clouds\r\n  color += T*vec3(3.0)*max(0.0, fbm(vec3(1.0, 1.0, 1.8)*pC*0.002) - 0.4);\r\n\r\n\tvar background = 6.0*mix(vec3(0.2, 0.52, 1.0), vec3(0.8, 0.95, 1.0), pow(0.5+0.5*mu, 15.0))+mix(vec3(3.5), vec3(0.0), min(1.0, 2.3*dir.y));\r\n  background += T*vec3(1e4*smoothstep(0.9998, 1.0, mu));\r\n  color += background * T;\r\n\r\n  return color;\r\n}\r\n\r\nfn D_GGX(r: f32,  NoH: f32, h: vec3<f32>) -> f32\r\n{\r\n    let a = NoH * r;\r\n    let k = r / ((1.0 - NoH * NoH) + a * a);\r\n    return k * k * (1.0 / PI);\r\n}\r\n\r\nfn HenyeyGreenstein(mu: f32, inG: f32) -> f32\r\n{\r\n\treturn (1.-inG * inG)/(pow(1.+inG*inG - 2.0 * inG*mu, 1.5)*4.0* PI);\r\n}\r\n\r\nfn tonemapACES( x: vec3<f32> ) -> vec3<f32>\r\n{\r\n    let a = 2.51;\r\n    let b = 0.03;\r\n    let c = 2.43;\r\n    let d = 0.59;\r\n    let e = 0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\n\r\nfn sample_sky(rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> vec3<f32> {\r\n    return skyRay(rayOrigin, rayDirection,sunDirection);\r\n}\r\n\r\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\r\n\r\n// Function to mimic the ease_out_expo function\r\nfn ease_out_expo(x: f32) -> f32 {\r\n    let t: f32 = x;\r\n    let b: f32 = 0.0;\r\n    let c: f32 = 1.0;\r\n    let d: f32 = 1.0; // Set the duration within the function\r\n    let intermediate_result: f32 = c * (-pow(2.0, -10.0 * t / d) + 1.0) + b;\r\n    return select(intermediate_result, b + c, t == d);\r\n}\r\n\r\nconst SKY_COLOUR: vec3<f32> = vec3<f32>(0.6, 0.8, 0.9);\r\nconst START_DISTANCE: f32 = 0.0;\r\nconst FOG_DENSITY: f32 = 0.01;\r\nconst NEAR: f32 = 0.5;\r\nconst FAR: f32 = 10000.0;\r\n\r\nfn rotateY(v: vec3<f32>, angle: f32) -> vec3<f32> {\r\n    let s = sin(angle);\r\n    let c = cos(angle);\r\n    return vec3<f32>(\r\n        v.x * c - v.z * s,\r\n        v.y,\r\n        v.x * s + v.z * c\r\n    );\r\n}\r\n\r\nfn rotateX(v: vec3<f32>, angle: f32) -> vec3<f32> {\r\n    let s = sin(angle);\r\n    let c = cos(angle);\r\n    return vec3<f32>(\r\n        v.x,\r\n        v.y * c - v.z * s,\r\n        v.y * s + v.z * c\r\n    );\r\n}\r\n\r\n// Rotate ray around the y axis, incrementally increasing the x rotation to form a spiral patttern\r\nfn spiralBlurCubeSample(rayDirection: vec3<f32>) -> vec4<f32>\r\n{\r\n  var weights = 0.0;\r\n  var output = vec4(0.0);\r\n  for(var i = 0; i < 6; i++){\r\n    var r = rayDirection.xy + vec2(f32(i) * 0.0001);\r\n    var sampleRayDirection = mix(rayDirection,randomInHemisphere(r, rayDirection),0.003);\r\n    output += textureSampleLevel(skyCube, linearSampler, sampleRayDirection, 0.0);\r\n    weights += 1.0;\r\n  }\r\n  return output / weights;\r\n}\r\n\r\nconst NEAR_PLANE = 0.5;\r\nconst FAR_PLANE = 10000.0;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n    let resolution = textureDimensions(depth);\r\n    let pixel = GlobalInvocationID.xy;\r\n    var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\r\n    let rayDirection = calculateRayDirection(uv,viewProjections.inverseViewProjection);\r\n    let rayOrigin = cameraPosition;\r\n//    let sky = textureSampleLevel(skyCube, linearSampler, rayDirection, 0.0).rgb;\r\n    let sky = spiralBlurCubeSample(rayDirection).rgb;\r\n\r\n    var color = sky;\r\n    let reversedDepth = textureLoad(depth, pixel, 0).r;\r\n\r\n    if(reversedDepth < 0.0001){\r\n      let output = vec4(color, 1);\r\n      textureStore(outputTex, pixel, output);\r\n      return;\r\n    }\r\n\r\n}\r\n\r\nfn getDebugColor(index: u32) -> vec4<f32> {\r\n  let colors = array<vec4<f32>, 8>(\r\n    vec4<f32>(1.0, 0.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(1.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(0.5, 0.5, 0.5, 1.0)\r\n  );\r\n  return colors[index % 8];\r\n}\r\n\r\nfn getCubeRayDirection(uv: vec2<f32>, faceIndex: u32) -> vec3<f32>\r\n{\r\n  let uMapped = uv.x * 2.0 - 1.0;\r\n  let vMapped = uv.y * 2.0 - 1.0;\r\n\r\n  switch(faceIndex)\r\n  {\r\n    case 0{return vec3<f32>(1.0, -vMapped, -uMapped);}\r\n    case 1{return vec3<f32>(-1.0, -vMapped, uMapped);}\r\n    case 2{return vec3<f32>(uMapped, 1.0, vMapped);}\r\n    case 3{return vec3<f32>(uMapped, -1.0, -vMapped);}\r\n    case 4{return vec3<f32>(uMapped, -vMapped, 1.0);}\r\n    case 5{return vec3<f32>(-uMapped, -vMapped, -1.0);}\r\n    default{return vec3<f32>(0.0);}\r\n  }\r\n}\r\n\r\nfn getFramePixelOffset() -> vec2<u32>\r\n{\r\n  let frameIndex = time.frame % 4;\r\n  let x = frameIndex % 2;\r\n  let y = frameIndex / 2;\r\n  return vec2<u32>(x, y);\r\n}\r\n\r\nconst offsets = array<vec2<i32>,8>(\r\n  vec2(-1,-1), vec2(-1, 1),\r\n\tvec2(1, -1), vec2(1, 1),\r\n\tvec2(1, 0), vec2(0, -1),\r\n\tvec2(0, 1), vec2(-1, 0)\r\n);\r\n\r\nfn RGBToYCoCg( RGB: vec3<f32> ) -> vec3<f32>\r\n{\r\n\tlet Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\r\n\tlet Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\r\n\tlet Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\r\n\treturn vec3(Y, Co, Cg);\r\n}\r\n\r\nfn YCoCgToRGB( YCoCg: vec3<f32> ) -> vec3<f32>\r\n{\r\n\tlet Y= YCoCg.x;\r\n\tlet Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\r\n\tlet Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\r\n\tlet R= Y + Co-Cg;\r\n\tlet G= Y + Cg;\r\n\tlet B= Y - Co-Cg;\r\n\treturn vec3(R,G,B);\r\n}\r\n\r\nconst gaussianWeights = array<f32, 25>(\r\n  0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\r\n  0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\r\n  0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\r\n  0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\r\n  0.003765, 0.015019, 0.023792, 0.015019, 0.003765\r\n);\r\n\r\n\r\nconst gaussianOffsets = array<vec2<i32>, 25>(\r\n  vec2(-2, -2), vec2(-1, -2), vec2(0, -2), vec2(1, -2), vec2(2, -2),\r\n  vec2(-2, -1), vec2(-1, -1), vec2(0, -1), vec2(1, -1), vec2(2, -1),\r\n  vec2(-2, 0), vec2(-1, 0), vec2(0, 0), vec2(1, 0), vec2(2, 0),\r\n  vec2(-2, 1), vec2(-1, 1), vec2(0, 1), vec2(1, 1), vec2(2, 1),\r\n  vec2(-2, 2), vec2(-1, 2), vec2(0, 2), vec2(1, 2), vec2(2, 2)\r\n);\r\n\r\nfn gaussianBlurHistorySample( pixel: vec2<u32>, cubeFaceIndex: u32 ) -> vec3<f32>\r\n{\r\n  let textureSize = textureDimensions(lastSkyCube).xy;\r\n  var color = vec3<f32>(0.0);\r\n  var weights = 0.0;\r\n  for(var i = 0; i < 25; i++)\r\n  {\r\n    let samplePixel = vec2<i32>(pixel) + gaussianOffsets[i];\r\n    if(any(samplePixel < vec2(0)) || any(samplePixel >= vec2<i32>(textureSize))){\r\n      continue;\r\n    }\r\n    color += RGBToYCoCg(textureLoad(lastSkyCube, samplePixel, cubeFaceIndex, 0).rgb) * gaussianWeights[i];\r\n    weights += gaussianWeights[i];\r\n  }\r\n\r\n  return color / weights;\r\n}\r\n\r\nfn polarToCartesian(angle: f32, radius: f32) -> vec2<f32> {\r\n  let radians = angle * PI / 180.0;\r\n  let x = radius * cos(radians);\r\n  let y = radius * sin(radians);\r\n  return vec2<f32>(x, y);\r\n}\r\n\r\nfn spiralBlurHistorySample( pixel: vec2<u32>, cubeFaceIndex: u32 ) -> vec3<f32>\r\n{\r\n  var weights = 0.0;\r\n  var output = vec3<f32>(0.0);\r\n   let textureSize = textureDimensions(lastSkyCube).xy;\r\n  for(var i = 0; i <= 6; i++){\r\n      let angle = (i % 6) * 60; // 0, 90, 180, 270\r\n      let radius = (i + 1) / 2;\r\n      let samplePixel = vec2<i32>(pixel) + vec2<i32>(polarToCartesian(f32(angle), f32(radius)));\r\n      if(any(samplePixel < vec2(0)) || any(samplePixel >= vec2<i32>(textureSize))){\r\n        continue;\r\n      }\r\n      output += RGBToYCoCg(textureLoad(lastSkyCube, samplePixel, cubeFaceIndex, 0).rgb);\r\n      weights += 1.0;\r\n    }\r\n\r\n    return output / weights;\r\n}\r\n\r\nconst HISTORY_BLEND = 0.8;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn writeToCube(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let cubeFaceIndex = GlobalInvocationID.z;\r\n  var pixel = GlobalInvocationID.xy;\r\n  pixel *= 2;\r\n  pixel += getFramePixelOffset();\r\n  var rayDirection = getCubeRayDirection(vec2<f32>(pixel) / vec2<f32>(textureDimensions(skyCubeWrite).xy), cubeFaceIndex);\r\n  rayDirection = normalize(rayDirection);\r\n  let sky = sample_sky(rayDirection, cameraPosition);\r\n  let mu = dot(sunDirection, rayDirection);\r\n  let fogDistance = intersectSphere(cameraPosition, rayDirection, vec3(0.0, -EARTH_RADIUS, 0.0), EARTH_RADIUS+160.0);\r\n  let fogPhase = 0.5*HenyeyGreenstein(mu, 0.7)+0.5*HenyeyGreenstein(mu, -0.6);\r\n  var colour = sky;\r\n  colour = mix(fogPhase*0.1*LOW_SCATTER*SUN_POWER+10.0*vec3(0.55, 0.8, 1.0), colour, exp(-0.0003*fogDistance));\r\n  let newSample = colour;\r\n  var history = textureLoad(lastSkyCube, pixel, cubeFaceIndex, 0).rgb;\r\n  colour = mix(newSample, history, HISTORY_BLEND);\r\n  textureStore(skyCubeWrite, pixel, cubeFaceIndex, vec4(colour,1));\r\n}",is=async()=>{const e={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},t={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},r={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Xe}},n={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},i={binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},o={binding:6,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},a={binding:7,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},c={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},l={binding:9,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},u={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},h={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Ze,viewDimension:"2d-array"}},d={binding:3,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d-array"}},f={binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},p=bs.createBindGroupLayout({entries:[e,t,r,n,i,s,o,a,c,l,f]}),m=bs.createBindGroupLayout({entries:[u]}),v=bs.createBindGroupLayout({entries:[h,d]}),g=bs.createComputePipeline({layout:bs.createPipelineLayout({bindGroupLayouts:[p,m]}),compute:{module:bs.createShaderModule({code:`${He}${Ii}${Ye}${ns}`}),entryPoint:"main"}}),y=bs.createComputePipeline({layout:bs.createPipelineLayout({bindGroupLayouts:[p,v]}),compute:{module:bs.createShaderModule({code:`${He}${Ii}${Ye}${ns}`}),entryPoint:"writeToCube"}});let x;const b=bs.createSampler({minFilter:"linear",magFilter:"linear",addressModeU:"repeat",addressModeV:"repeat"}),w=await gi(bs,"pebbles.png",{usage:GPUTextureUsage.COPY_SRC}),_=await gi(bs,"rgba-noise.png",{usage:GPUTextureUsage.COPY_SRC}),T=bs.createTexture({size:[640,640,6],format:Ze,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING});return{render:({commandEncoder:e,outputTextures:t,timestampWrites:r,viewProjectionMatricesBuffer:n,sunDirectionBuffer:i,timeBuffer:s,cameraPositionBuffer:o})=>{x||(x=bs.createTexture({size:[t.finalTexture.width,t.finalTexture.height,1],format:Xe,usage:it})),e.copyTextureToTexture({texture:t.finalTexture.texture},{texture:x},{width:t.finalTexture.width,height:t.finalTexture.height,depthOrArrayLayers:1});const a=bs.createBindGroup({layout:p,entries:[{binding:0,resource:t.depthTexture.view},{binding:1,resource:x.createView()},{binding:2,resource:t.finalTexture.view},{binding:3,resource:{buffer:n}},{binding:4,resource:{buffer:i}},{binding:5,resource:{buffer:s}},{binding:6,resource:_.createView()},{binding:7,resource:w.createView()},{binding:8,resource:b},{binding:9,resource:{buffer:o}},{binding:10,resource:t.worldPositionTexture.view}]}),c=e.beginComputePass({timestampWrites:r});c.setPipeline(y),c.setBindGroup(0,a),c.setBindGroup(1,bs.createBindGroup({layout:v,entries:[{binding:2,resource:t.skyTexture.createView({dimension:"2d-array"})},{binding:3,resource:T.createView({dimension:"2d-array"})}]})),c.dispatchWorkgroups(t.skyTexture.width/16,t.skyTexture.height/16,6),c.setPipeline(g),c.setBindGroup(0,a),c.setBindGroup(1,bs.createBindGroup({layout:m,entries:[{binding:1,resource:t.skyTexture.createView({dimension:"cube"})}]}));const l=t.depthTexture.width,u=t.depthTexture.height,h=Math.ceil(l/8),d=Math.ceil(u/8);c.dispatchWorkgroups(h,d),c.end(),e.copyTextureToTexture({texture:t.skyTexture},{texture:T},{width:t.skyTexture.width,height:t.skyTexture.height,depthOrArrayLayers:t.skyTexture.depthOrArrayLayers})},label:"sky"}},ss={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},os={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},as={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Xe}},cs={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},ls={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},us={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},hs={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},ds={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},fs={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},ps=(GPUShaderStage.COMPUTE,[ss,os,as,cs,ls,us,hs,ds,fs,{binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},{binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}}]),ms=async()=>(async({shaderCode:e,entryPoint:t,label:r})=>{const n=bs.createBindGroupLayout({entries:ps}),i=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${Xe}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\n${zi}\n${Ii}\n${Ye}\n${Qe}\n${Je}\n${et}\n${Ci}\n${e}`,s=bs.createComputePipeline({layout:bs.createPipelineLayout({bindGroupLayouts:[n]}),compute:{module:bs.createShaderModule({code:i}),entryPoint:t}});let o,a,c,l=bs.createSampler({magFilter:"nearest",minFilter:"nearest"}),u=bs.createSampler({magFilter:"linear",minFilter:"linear"});return{render:({commandEncoder:e,outputTextures:t,timestampWrites:r,viewProjectionMatricesBuffer:i,volumeAtlas:h,cameraPositionBuffer:d,transformationMatrixBuffer:f,sunDirectionBuffer:p,blueNoiseTextureView:m,timeBuffer:v,bvhBuffer:g})=>{if(o||(o=bs.createTexture({size:[t.finalTexture.width,t.finalTexture.height,1],format:t.finalTexture.format,usage:t.finalTexture.usage}),a=o.createView()),e.copyTextureToTexture({texture:t.finalTexture.texture},{texture:o},{width:t.finalTexture.width,height:t.finalTexture.height,depthOrArrayLayers:1}),!c){const e=[{binding:0,resource:t.depthTexture.view},{binding:1,resource:a},{binding:2,resource:t.finalTexture.view},{binding:3,resource:{buffer:i}},{binding:4,resource:h.atlasTextureView},{binding:5,resource:{buffer:d}},{binding:6,resource:{buffer:f}},{binding:7,resource:{buffer:p}},{binding:8,resource:u},{binding:10,resource:t.normalTexture.view},{binding:11,resource:m},{binding:12,resource:{buffer:v}},{binding:13,resource:l},{binding:14,resource:t.velocityTexture.view},{binding:15,resource:{buffer:g}},{binding:16,resource:t.worldPositionTexture.view},{binding:17,resource:t.albedoTexture.view},{binding:18,resource:t.skyTexture.createView({dimension:"cube"})}],r={layout:n,entries:e};c=bs.createBindGroup(r)}const y=e.beginComputePass({timestampWrites:r});y.setPipeline(s),y.setBindGroup(0,c),y.dispatchWorkgroups(Math.ceil(t.finalTexture.width/8),Math.ceil(t.finalTexture.height/8)),y.end()},label:r}})({shaderCode:"fn uncharted2_tonemap_partial(x: vec3<f32>) -> vec3<f32>\r\n{\r\n    let A = 0.15f;\r\n    let B = 0.50f;\r\n    let C = 0.10f;\r\n    let D = 0.20f;\r\n    let E = 0.02f;\r\n    let F = 0.30f;\r\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\r\n}\r\n\r\nfn luminance(v: vec3<f32>) -> f32\r\n{\r\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn reverse_aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(v*(c-e)-b))/(a-v*(d-e)), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn uncharted2_filmic(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let exposure_bias = 0.7f;\r\n    let curr = uncharted2_tonemap_partial(v * exposure_bias);\r\n    let W = vec3(11.2f);\r\n    let white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\r\n    return curr * white_scale;\r\n}\r\n\r\nfn reinhard_jodie(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let l = luminance(v);\r\n    let tv = v / (1.0f + v);\r\n    return mix(v / (1.0f + l), tv, tv);\r\n}\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  let inputSample = textureLoad(inputTex, pixel, 0);\r\n  let toneMapped = uncharted2_filmic(inputSample.rgb);\r\n//  let gammaCorrected = pow(toneMapped, vec3(1.0f / 0.3f));\r\n  textureStore(outputTex,pixel,vec4(toneMapped,1));\r\n}",entryPoint:"main",label:"tonemap"}),vs=new class{#m;#v;#g;#y;constructor(){this.#m=new Ar(1),this.#v=new Ar(0),this.#g=new Ar(0),this.#y=new Ar(.8)}set targetScale(e){this.#m.target=e}set targetTranslateX(e){this.#v.target=e}set targetRotateY(e){this.#g.target=e}set targetSunRotateY(e){this.#y.target=e}get targetScale(){return this.#m.target}get targetTranslateX(){return this.#v.target}get targetRotateY(){return this.#g.target}get targetSunRotateY(){return this.#y.target}get sunRotateY(){return this.#y.value}get scale(){return this.#m.value}get translateX(){return this.#v.value}};let gs,ys,xs,bs,ws=C.create(4,4),_s=0,Ts=_s,Ss=0,Ps=0;const ks=new class{gui;timingsFolder;passesFolder;constructor(){}log(e){}setupDebugControls(e){}},Es=(()=>{let e={};const t=t=>{const r=e[t];return r?r.reduce(((e,t)=>e+t))/r.length:0};return{addSample:(t,r)=>{e[t]||(e[t]=[]),e[t].push(r)>50&&e[t].shift()},clearEntry:t=>{e[t]&&(e[t]=[0])},toString:()=>Object.keys(e).map((e=>`${e}: ${t(e).toFixed(2)}ms`)).join("\n"),toHTML:()=>Object.keys(e).map((e=>`<div class="debug-row">\n                    <div>\n                        ${e}\n                    </div>\n                   <div>${t(e).toFixed(2)}ms</div>\n                </div>`)).join("\n"),getAverages:()=>Object.keys(e).reduce(((e,r)=>(e[r]=t(r),e)),{})}})();Es.addSample("frame time",0);let Ms,As,Cs,Is,zs,Os,Rs,Bs,Us,Ns,Ds,Ls,js,Fs,Gs,qs,Vs,Ws,Ys,Hs,$s,Xs,Zs,Ks=ge.create();As=Array.from({length:200}).map((()=>({position:[-80*Math.random(),50*Math.random(),-200*Math.random()],size:4,color:te.normalize(te.create(Math.random(),Math.random(),Math.random()))})));const Qs=async(e,t,r,n)=>{if(bs=e,xs=t,!navigator.gpu)throw new Error("WebGPU not supported");eo=((e,t,r)=>{const n=new Float32Array(t),i=e.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"camera position"});return We(i,t),i})(bs,[0,0,0,0]),Js(bs),Ws=new wi(bs,n.map((e=>Ai(r.getComponents(e).get(Mi),r.getComponents(e).get(Ei))))),Ms=bs.createTexture({label:"sky texture",dimension:"2d",size:[640,640,6],format:Ze,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),Cs=await Promise.all([Ti(),dt(),rs(),is(),ms(),ft(bs)]),Zs=Cs.reduce(((e,t)=>t.timestampLabels?e.concat(t.timestampLabels):e.concat(t.label)),[]),ys=document.getElementById("webgpu-canvas"),ys.style.imageRendering="pixelated",gs=ys.getContext("webgpu"),gs.configure({device:bs,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT}),$s=bs.createSampler({magFilter:"linear",minFilter:"linear"}),Xs=bs.createSampler({magFilter:"nearest",minFilter:"nearest"}),bs.features.has("timestamp-query")&&(Ys=bs.createQuerySet({type:"timestamp",count:1e3}),Hs=bs.createBuffer({label:"timestamp query",size:8*Ys.count,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}));const{clientWidth:i,clientHeight:s}=ys.parentElement,o=C.create(1*i,1*s);ws=C.mulScalar(o,1),ys.width=o[0],ys.height=o[1],ys.style.transform="scale(1)"},Js=async e=>{const t=await gi(e,"blue-noise-rg.png",{usage:GPUTextureUsage.COPY_SRC});Ns=t.createView()};let eo;setInterval((()=>{ks.log(Es.getAverages())}),500);let to=0;const ro=(e,t,r,n,i)=>{if(!bs||!Cs||!xs)return;const s=bs.createCommandEncoder();0===_s&&(_s=e),s.pushDebugGroup("frame");const o=e-_s;Ss=o-Ts,Es.addSample("frame time",Ss),Ts=o,Ps++,((e,t)=>{const r=function(e,t,r,n,i,s){const o=2*Math.tan(n/2)*s,a=o*i,c=2/t,l=2/r;return[(Si(e,2)-.5)*c*a,(Si(e,3)-.5)*l*o]}(Ps,ws[0],ws[1],"fieldOfView"in e.config?e.config.fieldOfView:90,ws[0]/ws[1],"near"in e.config?e.config.near:.1),n=function(e,t){const r=new Float32Array(e);return r[8]+=t[0],r[9]+=t[1],r}(e.projectionMatrix,r),i=(e=>{const t=e.position;return ge.lookAt(t,te.add(t,e.direction),e.up)})(t),s=ge.mul(n,i);qs=new Float32Array([...s,...Ks,...ge.invert(s),...ge.invert(Ks),...n,...ge.invert(n)]),Fs||(Fs=bs.createBuffer({size:qs.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"view matrices buffer"})),bs.queue.writeBuffer(Fs,0,qs.buffer,0,qs.length*Float32Array.BYTES_PER_ELEMENT);const o=ge.mul((a=n,ge.invert(a)),s);var a;const c=ge.invert(o);Vs=new Float32Array(ge.getTranslation(c)),bs.queue.writeBuffer(eo,0,Vs.buffer,0,Vs.length*Float32Array.BYTES_PER_ELEMENT),Ks=s})(r,n),((e,t,r)=>{const n=r.map((e=>{return r=t.getComponents(e).get(Mi),[...(n=t.getComponents(e).get(Ei)).transform,...ge.invert(n.transform),...n.previousTransform,...ge.invert(n.previousTransform),...r.size,0,...r.atlasLocation,r.paletteIndex,0,0,0,r.octreeBufferIndex];var r,n})).flat(),i=new Float32Array(n).byteLength;js&&i===js.size||(js=e.createBuffer({size:i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"voxel objects buffer"})),e.queue.writeBuffer(js,0,new Float32Array(n).buffer,0,n.length*Float32Array.BYTES_PER_ELEMENT)})(bs,t,i),Ds||(Ds=Ve([Ps,0,0],"time buffer")),bs.queue.writeBuffer(Ds,4,new Float32Array([Ss])),bs.queue.writeBuffer(Ds,0,new Uint32Array([Ps])),bs.queue.writeBuffer(Ds,8,new Float32Array([Ts/1e3])),Ls?qe(Ls,[ws[0],ws[1]]):Ls=Ve([ws[0],ws[1]]),(()=>{const e=ge.identity();ge.rotateY(e,vs.sunRotateY,e);const t=te.normalize(te.transformMat4(te.create(0,.5,-.8),e));Gs?We(Gs,[t[0],t[1],t[2]]):Gs=Ve([t[0],t[1],t[2]],"sun buffer")})(),to!==i.length&&Ws.update(i.map((e=>Ai(t.getComponents(e).get(Mi),t.getComponents(e).get(Ei))))),to=i.length,zs=new ot(bs,ws[0],ws[1]),Is=new at(bs,ws[0],ws[1]),Rs=new ct(bs,ws[0],ws[1]),Bs=new lt(bs,ws[0],ws[1]),Os=new ht(bs,ws[0],ws[1]),Us=new ut(bs,ws[0],ws[1]);let a=0;Cs.forEach(((e,o)=>{const{render:c,label:l}=e;let u;bs.features.has("timestamp-query")&&s.clearBuffer(Hs),bs.features.has("timestamp-query")&&(u={querySet:Ys,beginningOfPassWriteIndex:a,endOfPassWriteIndex:a+1}),l&&s.pushDebugGroup(l),c({enabled:document.getElementById(`flag-${l}`)?.checked,commandEncoder:s,resolutionBuffer:Ls,timeBuffer:Ds,outputTextures:{finalTexture:Os,albedoTexture:zs,normalTexture:Is,depthTexture:Rs,skyTexture:Ms,velocityTexture:Bs,worldPositionTexture:Us},cameraPositionBuffer:eo,volumeAtlas:xs,transformationMatrixBuffer:js,viewProjectionMatricesArray:qs,viewProjectionMatricesBuffer:Fs,timestampWrites:u,sunDirectionBuffer:Gs,blueNoiseTextureView:Ns,bvhBuffer:Ws.gpuBuffer,lights:As,linearSampler:$s,nearestSampler:Xs,camera:r,cameraTransform:n,renderableEntities:i,ecs:t}),a+=Zs?.length>0?2*Zs.length:2,l&&s.popDebugGroup()})),s.popDebugGroup(),bs.features.has("timestamp-query")&&(async(e,t,r)=>{const n=r.size;Pi||(Pi=bs.createBuffer({size:n,label:"gpu read buffer",usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}));const i=bs.createCommandEncoder();if(ki)return;ki=!0,i.resolveQuerySet(t,0,t.count,r,0),i.copyBufferToBuffer(r,0,Pi,0,n),bs.queue.submit([i.finish()]),await bs.queue.onSubmittedWorkDone(),await Pi.mapAsync(GPUMapMode.READ).finally((()=>{ki=!1}));const s=Pi.getMappedRange(),o=new BigInt64Array(s),a=[];o.forEach((e=>{a.push(Number(e)/1e6)})),a.reduce(((e,t,r)=>(r%2==0&&e.push(a[r+1]-t),e)),[]).forEach(((t,r)=>{Es.addSample(e[r],t)})),Pi.unmap()})(Zs,Ys,Hs),bs.queue.submit([s.finish()])};class no extends e{config;constructor(e){super(),this.config=e}get projectionMatrix(){return"size"in this.config?ge.ortho(-ws[0]/this.config.size,ws[0]/this.config.size,-ws[1]/this.config.size,ws[1]/this.config.size,this.config.size,-this.config.size):ge.perspective(this.config.fieldOfView,ws[0]/ws[1],this.config.near,this.config.far)}}class io{index;dataView;constructor(e){this.dataView=new DataView(e),this.index=0}readUint8(){const e=this.dataView.getUint8(this.index);return this.index++,e}readUint32(){const e=this.dataView.getUint32(this.index,!0);return this.index+=4,e}readFloat32(){const e=this.dataView.getFloat32(this.index,!0);return this.index+=4,e}skip(e){this.index+=e}}const so=e=>0===e,oo=e=>[1&e?1:0,2&e?1:0,4&e?1:0];let ao=0;class co{nodes;#x;#b;constructor(e){var t;this.nodes=[],this.#x=0,this.#b=(t=e.SIZE,Math.ceil(Math.log2(Math.max(...t)))),this.#d(e,0,[0,0,0],0),ao/=this.nodes.length,console.log(`Average first child index: ${ao}`)}#w(e=8){return this.#x+=e,this.#x-(e-1)}#d(e,t,r,n){if(1===e.SIZE[0]){const n=e.XYZI[0].c;return void(this.nodes[t]={red:e.RGBA[n].r,green:e.RGBA[n].g,blue:e.RGBA[n].b,x:r[0],y:r[1],z:r[2]})}const i=Array.from({length:8},(()=>null)),s=n+1,o=(e=>Math.pow(2,Math.ceil(Math.log2(e))))(Math.max(...e.SIZE)),a=o/2;for(let t=0;t<8;t++){const n=oo(t),s=r[0]+n[0]*a,o=r[1]+n[1]*a,c=r[2]+n[2]*a,l=e.XYZI.filter((e=>e.x>=s&&e.x<s+a&&e.y>=o&&e.y<o+a&&e.z>=c&&e.z<c+a));l.length>0&&(i[t]={SIZE:[a,a,a],XYZI:l,RGBA:e.RGBA,VOX:l.length})}let c=0;const l=i.reduce(((e,t,r)=>t?(c=r+1,e|1<<r):e),0),u=this.#w(c),h=u-t;i.forEach(((e,t)=>{if(e){const n=u+t,i=oo(t),o=r[0]+i[0]*a,c=r[1]+i[1]*a,l=r[2]+i[2]*a;this.#d(e,n,[o,c,l],s)}})),ao+=u,this.nodes[t]={firstChildIndex:h,childMask:l,voxels:{...e,SIZE:[o,o,o]},x:r[0],y:r[1],z:r[2],size:o,leafMask:0}}get totalSize(){return 8*this.nodes.length}}const lo=async(e,t,r)=>{console.time(`Fetch ${e}`);const n=await fetch(e);console.timeEnd(`Fetch ${e}`);const i=(e=>{console.time("convert vxm");const t=new io(e);let r,n=[],i="",s=[];if(i=String.fromCodePoint(t.readUint8(),t.readUint8(),t.readUint8(),t.readUint8()),"VXMC"!==i&&"VXMA"!==i)throw new Error(`Incorrect magic: ${i}`);if(i[3].charCodeAt(0)>="0".charCodeAt(0)&&i[3].charCodeAt(0)<="9".charCodeAt(0))r=i[3].charCodeAt(0)-"0".charCodeAt(0);else{if(!(i[3].charCodeAt(0)>="A".charCodeAt(0)&&i[3].charCodeAt(0)<="C".charCodeAt(0)))throw new Error("Unsupported version found");r=10+i[3].charCodeAt(0)-"A".charCodeAt(0)}if(r<11||r>12)throw new Error(`Could not load vxm file: Unsupported version found (${r})`);let o=[0,0,0];o[0]=t.readUint32(),o[1]=t.readUint32(),o[2]=t.readUint32();let a=[.5,0,.5];if(a[0]=t.readFloat32(),a[1]=t.readFloat32(),a[2]=t.readFloat32(),t.readUint8()>0){let e=0,r=0;t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32(),e=t.readUint32(),r=t.readUint32();let n=e*r;t.skip(4*n)}r>=8&&t.skip(16);let c=t.readUint32();for(let e=0;e<c;++e){let e=t.readUint32(),r=t.readUint32();if(e>2048||r>2048)throw new Error("Size of texture exceeds the max allowed value");let n=t.readUint32();t.skip(n);for(let e=0;e<6;++e){let e=t.readUint32();e>262144&&console.warn(`Size of quads exceeds the max allowed value: ${e}`);let r=4*e*20;t.skip(r)}}t.skip(1024),t.skip(1024);let l=t.readUint8();for(let e=0;e<l;++e)t.skip(1024),t.readUint8(),t.readUint8();let u=t.readUint8();for(let e=0;e<u;++e){let r=t.readUint8(),i=t.readUint8(),s=t.readUint8(),o=t.readUint8();o=1===t.readUint8()?2:255,n[e]={r:s,g:i,b:r,a:o}}let h=1;r>=12&&(h=t.readUint8());let d={min:te.create(9999,9999,9999),max:te.create(0,0,0)};for(let e=0;e<h;++e){let n=0,i=!0,a="";if(r>=12){for(;;){const e=t.readUint8();if(so(e))break;a=`${a}${String.fromCharCode(e)}`}i=t.readUint8()>0}else a=`Layer ${e}`;for(;;){let e=t.readUint8();if(0===e)break;let r=t.readUint8();if(255!==r)if(r>=u)n+=e;else{for(let t=n;t<n+e;t++){let e=Math.floor(t/(o[1]*o[2])),n=Math.floor(t/o[2]%o[1]),i=Math.floor(t%o[2]);d.min=te.min(d.min,[e,n,i]),d.max=te.max(d.max,[e,n,i]),s.push({x:e,y:n,z:i,c:r})}n+=e}else n+=e}}s=s.map((({x:e,y:t,z:r,c:n})=>({x:e-d.min[0],y:t-d.min[1],z:r-d.min[2],c:n})));const f=te.sub(d.max,d.min);return console.timeEnd("convert vxm"),{VOX:s.length,SIZE:[f[0]+1,f[1]+1,f[2]+1],XYZI:s,RGBA:n}})(await n.arrayBuffer());console.time(`Create texture from voxels for ${e}`);let s=await(async(e,t)=>{const r=e.createTexture({size:{width:t.SIZE[0],height:t.SIZE[1],depthOrArrayLayers:t.SIZE[2]},format:$e,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:4}),n=r.width*r.height*r.depthOrArrayLayers,i=e.createBuffer({size:4*n*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.STORAGE}),s=e.createBuffer({size:256*t.SIZE[2],usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.UNIFORM,label:"voxels buffer"}),o=Array.from({length:t.SIZE[2]},((e,t)=>t));for(let t=0;t<o.length;t++)e.queue.writeBuffer(s,256*t,new Uint32Array([o[t]]).buffer);for(let r=0;r<t.XYZI.length;r++){const{x:n,y:s,z:o,c:l}=t.XYZI[r],u=(a=t.SIZE,(c=[n,s,o])[0]+c[1]*a[0]+c[2]*(a[0]*a[1]));e.queue.writeBuffer(i,16*u,new Uint32Array([n,s,o,l]).buffer)}var a,c;const l=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"storage"}}]}),u=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[l]}),vertex:{module:e.createShaderModule({code:"\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n          }\n          \n          @vertex\n          fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            const pos = array(\n              vec2( 1.0,  1.0),\n              vec2( 1.0, -1.0),\n              vec2(-1.0, -1.0),\n              vec2( 1.0,  1.0),\n              vec2(-1.0, -1.0),\n              vec2(-1.0,  1.0),\n            );\n            var output : VertexOutput;\n            output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n            return output;\n          }"}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:"\n          @group(0) @binding(0) var<uniform> zIndex: u32;\n          @group(0) @binding(1) var<storage, read_write> voxelBuffer: array<vec4<u32>>;\n          \n          override sizeX: u32;\n          override sizeY: u32;\n          override sizeZ: u32;\n           \n          fn convert3DTo1D(size: vec3<u32>, position: vec3<u32>) -> u32 {\n            return position.x + position.y * size.x + position.z * (size.x * size.y);\n          }\n          \n          @fragment\n          fn fragment_main(@builtin(position) position : vec4<f32>) -> @location(0) vec4<f32> { \n            let voxelPosition = vec3(position.xy, f32(zIndex));\n            let voxelIndex = convert3DTo1D(vec3<u32>(sizeX, sizeY, sizeZ), vec3<u32>(voxelPosition));\n            let voxel = voxelBuffer[voxelIndex];\n            let normalisedPaletteIndex = f32(voxel.a) / 255.0;\n            return vec4(normalisedPaletteIndex,0,0,0);\n          }\n        "}),entryPoint:"fragment_main",targets:[{format:$e}],constants:{sizeX:t.SIZE[0],sizeY:t.SIZE[1],sizeZ:t.SIZE[2]}}}),h=e.createCommandEncoder();for(let t=0;t<r.depthOrArrayLayers;t++){const n=e.createBindGroup({label:"create-texture-from-voxels",layout:l,entries:[{binding:0,resource:{buffer:s,offset:256*t,size:4}},{binding:1,resource:{buffer:i}}]}),o=h.beginRenderPass({colorAttachments:[{view:r.createView({baseArrayLayer:t,arrayLayerCount:1,mipLevelCount:1,dimension:"2d"}),loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});o.setPipeline(u),o.setBindGroup(0,n),o.draw(6),o.end()}e.queue.submit([h.finish()]),await e.queue.onSubmittedWorkDone();const d=n/1024/1024;return console.log(`Created texture of size ${d.toFixed(3)} MB`),r})(t,i);console.timeEnd(`Create texture from voxels for ${e}`),console.time(`Create octree for ${e}`);const o=(e=>{const t=new ArrayBuffer(e.totalSize),r=new DataView(t);return e.nodes.forEach(((e,t)=>{"red"in e?((e,t,r)=>{e.setUint16(8*t,0,!0),e.setUint8(8*t+2,r.red),e.setUint8(8*t+3,r.green),e.setUint8(8*t+4,r.blue),e.setUint8(8*t+5,r.x),e.setUint8(8*t+6,r.y),e.setUint8(8*t+7,r.z)})(r,t,e):((e,t,r)=>{console.assert(r.firstChildIndex<2**24-1,`First child index of ${r.firstChildIndex} is too large to fit in 3 bytes`),e.setUint32(8*t,r.firstChildIndex,!0),e.setUint8(8*t+3,r.childMask),e.setUint8(8*t+4,r.x),e.setUint8(8*t+5,r.y),e.setUint8(8*t+6,r.z),e.setUint8(8*t+7,r.size),0===t&&console.log(r.size)})(r,t,e)})),console.debug(`Created octree of size ${(e.totalSize/1048576).toFixed(3)} MB`),t})(new co(i));console.timeEnd(`Create octree for ${e}`),console.time(`Create palette texture for ${e}`);const a=await(async(e,t)=>{const r=e.createTexture({size:{width:256,height:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,dimension:"2d",mipLevelCount:1}),n=e.createBuffer({label:"palette buffer",size:1024,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});t.RGBA.forEach((({r:t,g:r,b:i,a:s},o)=>{const a=new Uint8Array([t,r,i,s]);e.queue.writeBuffer(n,4*o,a)}));const i=e.createCommandEncoder();return i.copyBufferToTexture({buffer:n},{texture:r},[255,1,1]),e.queue.submit([i.finish()]),await e.queue.onSubmittedWorkDone(),r})(t,i);console.timeEnd(`Create palette texture for ${e}`),await r.addVolume(s,a,e,o)},uo=async(e,t,r,n)=>{t.dictionary[n]||await lo(n,e,t);const{size:i,location:s,paletteIndex:o,octreeOffset:a}=t.dictionary[n];return new Mi({name:r,size:i,atlasLocation:s,paletteIndex:o,octreeBufferIndex:a})},ho=async(e,t,r)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const n=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");const r=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:t.mipLevelCount}),n=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let i=0;i<t.depthOrArrayLayers>>e;i++)n.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:i}},{texture:r,mipLevel:e,origin:{x:0,y:0,z:i}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([n.finish()]),await e.queue.onSubmittedWorkDone(),r})(e,t),i=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),s=e.createBuffer({size:256*t.depthOrArrayLayers,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.UNIFORM,label:"z indices buffer"}),o=Array.from({length:t.depthOrArrayLayers},((e,t)=>t));for(let t=0;t<o.length;t++)e.queue.writeBuffer(s,256*t,new Uint32Array([o[t]]).buffer);const a=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[i]}),vertex:{module:e.createShaderModule({code:"\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n          }\n          const pos = array(\n              vec2( 1.0,  1.0),\n              vec2( 1.0, -1.0),\n              vec2(-1.0, -1.0),\n              vec2( 1.0,  1.0),\n              vec2(-1.0, -1.0),\n              vec2(-1.0,  1.0),\n            );\n          @vertex\n          fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            var output : VertexOutput;\n            output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n            return output;\n          }"}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:"\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> zIndex: u32;\n          @fragment\r\nfn fragment_main(@builtin(position) position : vec4<f32>) -> @location(0) vec4<f32> {\r\n  let srcTexel = vec3(vec2<u32>(position.xy),zIndex);\r\n  var colours = array<f32, 8>();\r\n  var isOctantEmpty = true;\r\n  for(var x = u32(0); x < 2; x++){\r\n    for(var y = u32(0); y < 2; y++){\r\n      for(var z = u32(0); z < 2; z++){\r\n        let voxelX = srcTexel.x * 2 + x;\r\n        let voxelY = srcTexel.y * 2 + y;\r\n        let voxelZ = srcTexel.z * 2 + z;\r\n        var voxelId = vec3<u32>(voxelX,voxelY,voxelZ);\r\n        var voxel = textureLoad(voxels,voxelId,0).r;\r\n        if(voxel > 0){\r\n          var index = x + y * 2 + z * 4;\r\n          colours[index] = voxel;\r\n          isOctantEmpty = false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // If all voxels in the octant are empty, keep it blank\r\n  if(isOctantEmpty){\r\n    discard;\r\n  }\r\n\r\n  // Get the most common colour in the octant\r\n  var mostCommonColour = f32(0);\r\n  var mostCommonColourCount = u32(0);\r\n  for(var i = u32(0); i < 8; i = i + 1u){\r\n    var colour = colours[i];\r\n    var count = u32(0);\r\n    for(var j = u32(0); j < 8; j = j + 1u){\r\n      if(colour > 0 && colour == colours[j]){\r\n        count++;\r\n      }\r\n    }\r\n    if(count > mostCommonColourCount){\r\n      mostCommonColour = colour;\r\n      mostCommonColourCount = count;\r\n    }\r\n  }\r\n\r\n  return vec4(mostCommonColour, 0,0,0);\r\n}\r\n\r\n\n        "}),entryPoint:"fragment_main",targets:[{format:t.format}]}}),c=e.createCommandEncoder(),l=Math.max(1,t.depthOrArrayLayers>>r);for(let o=0;o<l;o++){const l=e.createBindGroup({layout:i,entries:[{binding:0,resource:t.createView({label:`${r} mip level of volume texture`,dimension:"3d",baseMipLevel:r-1,mipLevelCount:1})},{binding:1,resource:{buffer:s,offset:256*o,size:4}}]}),u=c.beginRenderPass({colorAttachments:[{view:n.createView({label:"volume slice for rendering mips",baseArrayLayer:o,arrayLayerCount:1,baseMipLevel:r,mipLevelCount:1,dimension:"2d-array"}),loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});u.setPipeline(a),u.setBindGroup(0,l),u.draw(6),u.end()}return e.queue.submit([c.finish()]),await e.queue.onSubmittedWorkDone(),await(async(e,t)=>{if("2d"!==t.dimension)throw new Error("Input texture should be a 2D texture");const r=e.createTexture({size:{width:t.width,height:t.height,depthOrArrayLayers:t.depthOrArrayLayers},format:t.format,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d",mipLevelCount:t.mipLevelCount}),n=e.createCommandEncoder();for(let e=0;e<t.mipLevelCount;e++)for(let i=0;i<t.depthOrArrayLayers>>e;i++)n.copyTextureToTexture({texture:t,mipLevel:e,origin:{x:0,y:0,z:i}},{texture:r,mipLevel:e,origin:{x:0,y:0,z:i}},{width:t.width>>e,height:t.height>>e,depthOrArrayLayers:1});return e.queue.submit([n.finish()]),await e.queue.onSubmittedWorkDone(),r})(e,n)},fo={format:$e,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d"},po=(e,t)=>Math.ceil(e/t)*t,mo=Math.pow(2,3),vo=mo,go=256;class yo{#_={};#T;#S;#a;#P;#k;#E;constructor(e){this.#a=e,this.#T=e.createTexture({size:{width:vo,height:vo,depthOrArrayLayers:vo},...fo,label:"Volume atlas containing ",mipLevelCount:4}),this.#S=e.createTexture({size:{width:go,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1}),this.#P=this.#T.createView(),this.#k=this.#S.createView(),this.#E=e.createBuffer({size:0,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,label:"Octree buffer"})}get dictionary(){return this.#_}addVolume=async(e,t,r,n)=>{if(this.#_[r])throw new Error(`Error adding volume to atlas: volume with label ${r} already exists`);const i=this.#a.createCommandEncoder(),{width:s,height:o,depthOrArrayLayers:a}=e,c=po(s,mo),l=po(o,mo),u=po(a,mo),h=this.#T.width+c;if(h>this.#a.limits.maxTextureDimension3D)throw new Error(`Error adding volume to atlas: adding volume would exceed device max texture dimension of ${this.#a.limits.maxTextureDimension3D}`);const d=Math.max(this.#T.height,l),f=Math.max(this.#T.depthOrArrayLayers,u),p=this.#a.createTexture({size:{width:h,height:d,depthOrArrayLayers:f},mipLevelCount:this.#T.mipLevelCount,...fo,label:`${this.#T.label}, ${e.label||"unnamed volume"}`}),m=this.#T.width;i.copyTextureToTexture({texture:this.#T},{texture:p},{width:this.#T.width,height:this.#T.height,depthOrArrayLayers:this.#T.depthOrArrayLayers}),i.copyTextureToTexture({texture:e,mipLevel:0,origin:{x:0,y:0,z:0}},{texture:p,mipLevel:0,origin:{x:m,y:0,z:0}},{width:e.width,height:e.height,depthOrArrayLayers:e.depthOrArrayLayers}),this.#T=p;const v=this.#S.height;this.#_[r]={location:[m,0,0],size:[s,o,a],paletteIndex:v,octreeOffset:this.#E.size,octreeSizeBytes:n.byteLength,textureSizeBytes:e.width*e.height*e.depthOrArrayLayers};const g=this.#a.createTexture({size:{width:go,height:this.#S.height+1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1});i.copyTextureToTexture({texture:this.#S},{texture:g},{width:go,height:this.#S.height,depthOrArrayLayers:1}),i.copyTextureToTexture({texture:t},{texture:g,origin:{x:0,y:v,z:0}},{width:go,height:1,depthOrArrayLayers:1}),this.#S=g;const y=this.#a.createBuffer({label:"Octree buffer",size:this.#E.size+n.byteLength,usage:this.#E.usage});i.copyBufferToBuffer(this.#E,0,y,0,this.#E.size),this.#a.queue.writeBuffer(y,this.#E.size,n),this.#a.queue.submit([i.finish()]),await this.#a.queue.onSubmittedWorkDone(),this.#E=y,this.#E.unmap(),this.#T=await(async(e,t)=>{if("3d"!==t.dimension)throw new Error("Input texture should be a 3D texture");let r=t;for(let n=1;n<t.mipLevelCount;n++)r=await ho(e,r,n);return r})(this.#a,this.#T),this.#P=this.#T.createView(),this.#k=this.#S.createView()};get atlasTextureView(){return this.#P}get paletteTextureView(){return this.#k}get octreeBuffer(){return this.#E}}class xo extends e{device;volumeAtlas}class bo{pressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1," ":!1,shift:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1})),window.addEventListener("blur",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))})),window.addEventListener("contextmenu",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))}))}}class wo extends e{speed=.1;rotationSpeed=.003}class _o{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new So);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new So);const r=this.elements,n=e.x,i=e.y,s=e.z;return t.x=r[0]*n+r[1]*i+r[2]*s,t.y=r[3]*n+r[4]*i+r[5]*s,t.z=r[6]*n+r[7]*i+r[8]*s,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new _o);const r=this.elements,n=e.elements,i=t.elements,s=r[0],o=r[1],a=r[2],c=r[3],l=r[4],u=r[5],h=r[6],d=r[7],f=r[8],p=n[0],m=n[1],v=n[2],g=n[3],y=n[4],x=n[5],b=n[6],w=n[7],_=n[8];return i[0]=s*p+o*g+a*b,i[1]=s*m+o*y+a*w,i[2]=s*v+o*x+a*_,i[3]=c*p+l*g+u*b,i[4]=c*m+l*y+u*w,i[5]=c*v+l*x+u*_,i[6]=h*p+d*g+f*b,i[7]=h*m+d*y+f*w,i[8]=h*v+d*x+f*_,t}scale(e,t){void 0===t&&(t=new _o);const r=this.elements,n=t.elements;for(let t=0;3!==t;t++)n[3*t+0]=e.x*r[3*t+0],n[3*t+1]=e.y*r[3*t+1],n[3*t+2]=e.z*r[3*t+2];return t}solve(e,t){void 0===t&&(t=new So);const r=[];let n,i;for(n=0;n<12;n++)r.push(0);for(n=0;n<3;n++)for(i=0;i<3;i++)r[n+4*i]=this.elements[n+3*i];r[3]=e.x,r[7]=e.y,r[11]=e.z;let s=3;const o=s;let a,c;do{if(n=o-s,0===r[n+4*n])for(i=n+1;i<o;i++)if(0!==r[n+4*i]){a=4;do{c=4-a,r[c+4*n]+=r[c+4*i]}while(--a);break}if(0!==r[n+4*n])for(i=n+1;i<o;i++){const e=r[n+4*i]/r[n+4*n];a=4;do{c=4-a,r[c+4*i]=c<=n?0:r[c+4*i]-r[c+4*n]*e}while(--a)}}while(--s);if(t.z=r[11]/r[10],t.y=(r[7]-r[6]*t.z)/r[5],t.x=(r[3]-r[2]*t.z-r[1]*t.y)/r[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,r){if(void 0===r)return this.elements[t+3*e];this.elements[t+3*e]=r}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new _o);const t=To;let r,n;for(r=0;r<3;r++)for(n=0;n<3;n++)t[r+6*n]=this.elements[r+3*n];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let i=3;const s=i;let o,a;do{if(r=s-i,0===t[r+6*r])for(n=r+1;n<s;n++)if(0!==t[r+6*n]){o=6;do{a=6-o,t[a+6*r]+=t[a+6*n]}while(--o);break}if(0!==t[r+6*r])for(n=r+1;n<s;n++){const e=t[r+6*n]/t[r+6*r];o=6;do{a=6-o,t[a+6*n]=a<=r?0:t[a+6*n]-t[a+6*r]*e}while(--o)}}while(--i);r=2;do{n=r-1;do{const e=t[r+6*n]/t[r+6*r];o=6;do{a=6-o,t[a+6*n]=t[a+6*n]-t[a+6*r]*e}while(--o)}while(n--)}while(--r);r=2;do{const e=1/t[r+6*r];o=6;do{a=6-o,t[a+6*r]=t[a+6*r]*e}while(--o)}while(r--);r=2;do{n=2;do{if(a=t[3+n+6*r],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(r,n,a)}while(n--)}while(r--);return e}setRotationFromQuaternion(e){const t=e.x,r=e.y,n=e.z,i=e.w,s=t+t,o=r+r,a=n+n,c=t*s,l=t*o,u=t*a,h=r*o,d=r*a,f=n*a,p=i*s,m=i*o,v=i*a,g=this.elements;return g[0]=1-(h+f),g[1]=l-v,g[2]=u+m,g[3]=l+v,g[4]=1-(c+f),g[5]=d-p,g[6]=u-m,g[7]=d+p,g[8]=1-(c+h),this}transpose(e){void 0===e&&(e=new _o);const t=this.elements,r=e.elements;let n;return r[0]=t[0],r[4]=t[4],r[8]=t[8],n=t[1],r[1]=t[3],r[3]=n,n=t[2],r[2]=t[6],r[6]=n,n=t[5],r[5]=t[7],r[7]=n,e}}const To=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class So{constructor(e,t,r){void 0===e&&(e=0),void 0===t&&(t=0),void 0===r&&(r=0),this.x=e,this.y=t,this.z=r}cross(e,t){void 0===t&&(t=new So);const r=e.x,n=e.y,i=e.z,s=this.x,o=this.y,a=this.z;return t.x=o*i-a*n,t.y=a*r-s*i,t.z=s*n-o*r,t}set(e,t,r){return this.x=e,this.y=t,this.z=r,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new So(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new So(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new _o([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,r=this.z,n=Math.sqrt(e*e+t*t+r*r);if(n>0){const e=1/n;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return n}unit(e){void 0===e&&(e=new So);const t=this.x,r=this.y,n=this.z;let i=Math.sqrt(t*t+r*r+n*n);return i>0?(i=1/i,e.x=t*i,e.y=r*i,e.z=n*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,r=this.z;return Math.sqrt(e*e+t*t+r*r)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,r=this.y,n=this.z,i=e.x,s=e.y,o=e.z;return Math.sqrt((i-t)*(i-t)+(s-r)*(s-r)+(o-n)*(o-n))}distanceSquared(e){const t=this.x,r=this.y,n=this.z,i=e.x,s=e.y,o=e.z;return(i-t)*(i-t)+(s-r)*(s-r)+(o-n)*(o-n)}scale(e,t){void 0===t&&(t=new So);const r=this.x,n=this.y,i=this.z;return t.x=e*r,t.y=e*n,t.z=e*i,t}vmul(e,t){return void 0===t&&(t=new So),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,r){return void 0===r&&(r=new So),r.x=this.x+e*t.x,r.y=this.y+e*t.y,r.z=this.z+e*t.z,r}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new So),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const r=this.length();if(r>0){const n=Po,i=1/r;n.set(this.x*i,this.y*i,this.z*i);const s=ko;Math.abs(n.x)<.9?(s.set(1,0,0),n.cross(s,e)):(s.set(0,1,0),n.cross(s,e)),n.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,r){const n=this.x,i=this.y,s=this.z;r.x=n+(e.x-n)*t,r.y=i+(e.y-i)*t,r.z=s+(e.z-s)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(Eo),Eo.almostEquals(e,t)}clone(){return new So(this.x,this.y,this.z)}}So.ZERO=new So(0,0,0),So.UNIT_X=new So(1,0,0),So.UNIT_Y=new So(0,1,0),So.UNIT_Z=new So(0,0,1);const Po=new So,ko=new So,Eo=new So;class Mo{constructor(e){void 0===e&&(e={}),this.lowerBound=new So,this.upperBound=new So,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,r,n){const i=this.lowerBound,s=this.upperBound,o=r;i.copy(e[0]),o&&o.vmult(i,i),s.copy(i);for(let t=1;t<e.length;t++){let r=e[t];o&&(o.vmult(r,Ao),r=Ao),r.x>s.x&&(s.x=r.x),r.x<i.x&&(i.x=r.x),r.y>s.y&&(s.y=r.y),r.y<i.y&&(i.y=r.y),r.z>s.z&&(s.z=r.z),r.z<i.z&&(i.z=r.z)}return t&&(t.vadd(i,i),t.vadd(s,s)),n&&(i.x-=n,i.y-=n,i.z-=n,s.x+=n,s.y+=n,s.z+=n),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new Mo).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,r=this.upperBound,n=e.lowerBound,i=e.upperBound,s=n.x<=r.x&&r.x<=i.x||t.x<=i.x&&i.x<=r.x,o=n.y<=r.y&&r.y<=i.y||t.y<=i.y&&i.y<=r.y,a=n.z<=r.z&&r.z<=i.z||t.z<=i.z&&i.z<=r.z;return s&&o&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,r=this.upperBound,n=e.lowerBound,i=e.upperBound;return t.x<=n.x&&r.x>=i.x&&t.y<=n.y&&r.y>=i.y&&t.z<=n.z&&r.z>=i.z}getCorners(e,t,r,n,i,s,o,a){const c=this.lowerBound,l=this.upperBound;e.copy(c),t.set(l.x,c.y,c.z),r.set(l.x,l.y,c.z),n.set(c.x,l.y,l.z),i.set(l.x,c.y,l.z),s.set(c.x,l.y,c.z),o.set(c.x,c.y,l.z),a.copy(l)}toLocalFrame(e,t){const r=Co,n=r[0],i=r[1],s=r[2],o=r[3],a=r[4],c=r[5],l=r[6],u=r[7];this.getCorners(n,i,s,o,a,c,l,u);for(let t=0;8!==t;t++){const n=r[t];e.pointToLocal(n,n)}return t.setFromPoints(r)}toWorldFrame(e,t){const r=Co,n=r[0],i=r[1],s=r[2],o=r[3],a=r[4],c=r[5],l=r[6],u=r[7];this.getCorners(n,i,s,o,a,c,l,u);for(let t=0;8!==t;t++){const n=r[t];e.pointToWorld(n,n)}return t.setFromPoints(r)}overlapsRay(e){const{direction:t,from:r}=e,n=1/t.x,i=1/t.y,s=1/t.z,o=(this.lowerBound.x-r.x)*n,a=(this.upperBound.x-r.x)*n,c=(this.lowerBound.y-r.y)*i,l=(this.upperBound.y-r.y)*i,u=(this.lowerBound.z-r.z)*s,h=(this.upperBound.z-r.z)*s,d=Math.max(Math.max(Math.min(o,a),Math.min(c,l)),Math.min(u,h)),f=Math.min(Math.min(Math.max(o,a),Math.max(c,l)),Math.max(u,h));return!(f<0||d>f)}}const Ao=new So,Co=[new So,new So,new So,new So,new So,new So,new So,new So];class Io{constructor(){this.matrix=[]}get(e,t){let{index:r}=e,{index:n}=t;if(n>r){const e=n;n=r,r=e}return this.matrix[(r*(r+1)>>1)+n-1]}set(e,t,r){let{index:n}=e,{index:i}=t;if(i>n){const e=i;i=n,n=e}this.matrix[(n*(n+1)>>1)+i-1]=r?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class zo{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const r=this._listeners;return void 0===r[e]&&(r[e]=[]),r[e].includes(t)||r[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const r=this._listeners;return!(void 0===r[e]||!r[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const r=this._listeners;if(void 0===r[e])return this;const n=r[e].indexOf(t);return-1!==n&&r[e].splice(n,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let r=0,n=t.length;r<n;r++)t[r].call(this,e)}return this}}class Oo{constructor(e,t,r,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===r&&(r=0),void 0===n&&(n=1),this.x=e,this.y=t,this.z=r,this.w=n}set(e,t,r,n){return this.x=e,this.y=t,this.z=r,this.w=n,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const r=Math.sin(.5*t);return this.x=e.x*r,this.y=e.y*r,this.z=e.z*r,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new So),this.normalize();const t=2*Math.acos(this.w),r=Math.sqrt(1-this.w*this.w);return r<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/r,e.y=this.y/r,e.z=this.z/r),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=Ro,r=Bo;e.tangents(t,r),this.setFromAxisAngle(t,Math.PI)}else{const r=e.cross(t);this.x=r.x,this.y=r.y,this.z=r.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new Oo);const r=this.x,n=this.y,i=this.z,s=this.w,o=e.x,a=e.y,c=e.z,l=e.w;return t.x=r*l+s*o+n*c-i*a,t.y=n*l+s*a+i*o-r*c,t.z=i*l+s*c+r*a-n*o,t.w=s*l-r*o-n*a-i*c,t}inverse(e){void 0===e&&(e=new Oo);const t=this.x,r=this.y,n=this.z,i=this.w;this.conjugate(e);const s=1/(t*t+r*r+n*n+i*i);return e.x*=s,e.y*=s,e.z*=s,e.w*=s,e}conjugate(e){return void 0===e&&(e=new Oo),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new So);const r=e.x,n=e.y,i=e.z,s=this.x,o=this.y,a=this.z,c=this.w,l=c*r+o*i-a*n,u=c*n+a*r-s*i,h=c*i+s*n-o*r,d=-s*r-o*n-a*i;return t.x=l*c+d*-s+u*-a-h*-o,t.y=u*c+d*-o+h*-s-l*-a,t.z=h*c+d*-a+l*-o-u*-s,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let r,n,i;void 0===t&&(t="YZX");const s=this.x,o=this.y,a=this.z,c=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=s*o+a*c;if(e>.499&&(r=2*Math.atan2(s,c),n=Math.PI/2,i=0),e<-.499&&(r=-2*Math.atan2(s,c),n=-Math.PI/2,i=0),void 0===r){const t=s*s,l=o*o,u=a*a;r=Math.atan2(2*o*c-2*s*a,1-2*l-2*u),n=Math.asin(2*e),i=Math.atan2(2*s*c-2*o*a,1-2*t-2*u)}}e.y=r,e.z=n,e.x=i}setFromEuler(e,t,r,n){void 0===n&&(n="XYZ");const i=Math.cos(e/2),s=Math.cos(t/2),o=Math.cos(r/2),a=Math.sin(e/2),c=Math.sin(t/2),l=Math.sin(r/2);return"XYZ"===n?(this.x=a*s*o+i*c*l,this.y=i*c*o-a*s*l,this.z=i*s*l+a*c*o,this.w=i*s*o-a*c*l):"YXZ"===n?(this.x=a*s*o+i*c*l,this.y=i*c*o-a*s*l,this.z=i*s*l-a*c*o,this.w=i*s*o+a*c*l):"ZXY"===n?(this.x=a*s*o-i*c*l,this.y=i*c*o+a*s*l,this.z=i*s*l+a*c*o,this.w=i*s*o-a*c*l):"ZYX"===n?(this.x=a*s*o-i*c*l,this.y=i*c*o+a*s*l,this.z=i*s*l-a*c*o,this.w=i*s*o+a*c*l):"YZX"===n?(this.x=a*s*o+i*c*l,this.y=i*c*o+a*s*l,this.z=i*s*l-a*c*o,this.w=i*s*o-a*c*l):"XZY"===n&&(this.x=a*s*o-i*c*l,this.y=i*c*o-a*s*l,this.z=i*s*l+a*c*o,this.w=i*s*o+a*c*l),this}clone(){return new Oo(this.x,this.y,this.z,this.w)}slerp(e,t,r){void 0===r&&(r=new Oo);const n=this.x,i=this.y,s=this.z,o=this.w;let a,c,l,u,h,d=e.x,f=e.y,p=e.z,m=e.w;return c=n*d+i*f+s*p+o*m,c<0&&(c=-c,d=-d,f=-f,p=-p,m=-m),1-c>1e-6?(a=Math.acos(c),l=Math.sin(a),u=Math.sin((1-t)*a)/l,h=Math.sin(t*a)/l):(u=1-t,h=t),r.x=u*n+h*d,r.y=u*i+h*f,r.z=u*s+h*p,r.w=u*o+h*m,r}integrate(e,t,r,n){void 0===n&&(n=new Oo);const i=e.x*r.x,s=e.y*r.y,o=e.z*r.z,a=this.x,c=this.y,l=this.z,u=this.w,h=.5*t;return n.x+=h*(i*u+s*l-o*c),n.y+=h*(s*u+o*a-i*l),n.z+=h*(o*u+i*c-s*a),n.w+=h*(-i*a-s*c-o*l),n}}const Ro=new So,Bo=new So;class Uo{constructor(e){void 0===e&&(e={}),this.id=Uo.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,r,n){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}Uo.idCounter=0,Uo.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class No{constructor(e){void 0===e&&(e={}),this.position=new So,this.quaternion=new Oo,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return No.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return No.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new So),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,r,n){return void 0===n&&(n=new So),r.vsub(e,n),t.conjugate(Do),Do.vmult(n,n),n}static pointToWorldFrame(e,t,r,n){return void 0===n&&(n=new So),t.vmult(r,n),n.vadd(e,n),n}static vectorToWorldFrame(e,t,r){return void 0===r&&(r=new So),e.vmult(t,r),r}static vectorToLocalFrame(e,t,r,n){return void 0===n&&(n=new So),t.w*=-1,t.vmult(r,n),t.w*=-1,n}}const Do=new Oo;class Lo extends Uo{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:r=[],normals:n=[],axes:i,boundingSphereRadius:s}=e;super({type:Uo.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=r,this.faceNormals=n,0===this.faceNormals.length&&this.computeNormals(),s?this.boundingSphereRadius=s:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,r=this.uniqueEdges;r.length=0;const n=new So;for(let i=0;i!==e.length;i++){const s=e[i],o=s.length;for(let e=0;e!==o;e++){const i=(e+1)%o;t[s[e]].vsub(t[s[i]],n),n.normalize();let a=!1;for(let e=0;e!==r.length;e++)if(r[e].almostEquals(n)||r[e].almostEquals(n)){a=!0;break}a||r.push(n.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new So;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const r=this.vertices[this.faces[e][0]];if(t.dot(r)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const r=this.faces[e],n=this.vertices[r[0]],i=this.vertices[r[1]],s=this.vertices[r[2]];Lo.computeNormal(n,i,s,t)}static computeNormal(e,t,r,n){const i=new So,s=new So;t.vsub(e,s),r.vsub(t,i),i.cross(s,n),n.isZero()||n.normalize()}clipAgainstHull(e,t,r,n,i,s,o,a,c){const l=new So;let u=-1,h=-Number.MAX_VALUE;for(let e=0;e<r.faces.length;e++){l.copy(r.faceNormals[e]),i.vmult(l,l);const t=l.dot(s);t>h&&(h=t,u=e)}const d=[];for(let e=0;e<r.faces[u].length;e++){const t=r.vertices[r.faces[u][e]],s=new So;s.copy(t),i.vmult(s,s),n.vadd(s,s),d.push(s)}u>=0&&this.clipFaceAgainstHull(s,e,t,d,o,a,c)}findSeparatingAxis(e,t,r,n,i,s,o,a){const c=new So,l=new So,u=new So,h=new So,d=new So,f=new So;let p=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let o=0;o!==m.uniqueAxes.length;o++){r.vmult(m.uniqueAxes[o],c);const a=m.testSepAxis(c,e,t,r,n,i);if(!1===a)return!1;a<p&&(p=a,s.copy(c))}else{const a=o?o.length:m.faces.length;for(let l=0;l<a;l++){const a=o?o[l]:l;c.copy(m.faceNormals[a]),r.vmult(c,c);const u=m.testSepAxis(c,e,t,r,n,i);if(!1===u)return!1;u<p&&(p=u,s.copy(c))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){i.vmult(e.uniqueAxes[o],l);const a=m.testSepAxis(l,e,t,r,n,i);if(!1===a)return!1;a<p&&(p=a,s.copy(l))}else{const o=a?a.length:e.faces.length;for(let c=0;c<o;c++){const o=a?a[c]:c;l.copy(e.faceNormals[o]),i.vmult(l,l);const u=m.testSepAxis(l,e,t,r,n,i);if(!1===u)return!1;u<p&&(p=u,s.copy(l))}}for(let o=0;o!==m.uniqueEdges.length;o++){r.vmult(m.uniqueEdges[o],h);for(let o=0;o!==e.uniqueEdges.length;o++)if(i.vmult(e.uniqueEdges[o],d),h.cross(d,f),!f.almostZero()){f.normalize();const o=m.testSepAxis(f,e,t,r,n,i);if(!1===o)return!1;o<p&&(p=o,s.copy(f))}}return n.vsub(t,u),u.dot(s)>0&&s.negate(s),!0}testSepAxis(e,t,r,n,i,s){Lo.project(this,e,r,n,jo),Lo.project(t,e,i,s,Fo);const o=jo[0],a=jo[1],c=Fo[0],l=Fo[1];if(o<l||c<a)return!1;const u=o-l,h=c-a;return u<h?u:h}calculateLocalInertia(e,t){const r=new So,n=new So;this.computeLocalAABB(n,r);const i=r.x-n.x,s=r.y-n.y,o=r.z-n.z;t.x=1/12*e*(2*s*2*s+2*o*2*o),t.y=1/12*e*(2*i*2*i+2*o*2*o),t.z=1/12*e*(2*s*2*s+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],r=this.faceNormals[e],n=this.vertices[t[0]];return-r.dot(n)}clipFaceAgainstHull(e,t,r,n,i,s,o){const a=new So,c=new So,l=new So,u=new So,h=new So,d=new So,f=new So,p=new So,m=this,v=n,g=[];let y=-1,x=Number.MAX_VALUE;for(let t=0;t<m.faces.length;t++){a.copy(m.faceNormals[t]),r.vmult(a,a);const n=a.dot(e);n<x&&(x=n,y=t)}if(y<0)return;const b=m.faces[y];b.connectedFaces=[];for(let e=0;e<m.faces.length;e++)for(let t=0;t<m.faces[e].length;t++)-1!==b.indexOf(m.faces[e][t])&&e!==y&&-1===b.connectedFaces.indexOf(e)&&b.connectedFaces.push(e);const w=b.length;for(let e=0;e<w;e++){const n=m.vertices[b[e]],i=m.vertices[b[(e+1)%w]];n.vsub(i,c),l.copy(c),r.vmult(l,l),t.vadd(l,l),u.copy(this.faceNormals[y]),r.vmult(u,u),t.vadd(u,u),l.cross(u,h),h.negate(h),d.copy(n),r.vmult(d,d),t.vadd(d,d);const s=b.connectedFaces[e];f.copy(this.faceNormals[s]);const o=this.getPlaneConstantOfFace(s);p.copy(f),r.vmult(p,p);const a=o-p.dot(t);for(this.clipFaceAgainstPlane(v,g,p,a);v.length;)v.shift();for(;g.length;)v.push(g.shift())}f.copy(this.faceNormals[y]);const _=this.getPlaneConstantOfFace(y);p.copy(f),r.vmult(p,p);const T=_-p.dot(t);for(let e=0;e<v.length;e++){let t=p.dot(v[e])+T;if(t<=i&&(console.log(`clamped: depth=${t} to minDist=${i}`),t=i),t<=s){const r=v[e];if(t<=1e-6){const e={point:r,normal:p,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,r,n){let i,s;const o=e.length;if(o<2)return t;let a=e[e.length-1],c=e[0];i=r.dot(a)+n;for(let l=0;l<o;l++){if(c=e[l],s=r.dot(c)+n,i<0)if(s<0){const e=new So;e.copy(c),t.push(e)}else{const e=new So;a.lerp(c,i/(i-s),e),t.push(e)}else if(s<0){const e=new So;a.lerp(c,i/(i-s),e),t.push(e),t.push(c)}a=c,i=s}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new So);const r=this.vertices,n=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(r[i],n[i]),e.vadd(n[i],n[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const r=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let n=0;n<this.vertices.length;n++){const i=r[n];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new So);const r=this.faceNormals,n=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(r[i],n[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let r=0;r!==t.length;r++){const n=t[r].lengthSquared();n>e&&(e=n)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,r,n){const i=this.vertices;let s,o,a,c,l,u,h=new So;for(let r=0;r<i.length;r++){h.copy(i[r]),t.vmult(h,h),e.vadd(h,h);const n=h;(void 0===s||n.x<s)&&(s=n.x),(void 0===c||n.x>c)&&(c=n.x),(void 0===o||n.y<o)&&(o=n.y),(void 0===l||n.y>l)&&(l=n.y),(void 0===a||n.z<a)&&(a=n.z),(void 0===u||n.z>u)&&(u=n.z)}r.set(s,o,a),n.set(c,l,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new So);const t=this.vertices;for(let r=0;r<t.length;r++)e.vadd(t[r],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const r=this.vertices.length,n=this.vertices;if(t){for(let e=0;e<r;e++){const r=n[e];t.vmult(r,r)}for(let e=0;e<this.faceNormals.length;e++){const r=this.faceNormals[e];t.vmult(r,r)}}if(e)for(let t=0;t<r;t++){const r=n[t];r.vadd(e,r)}}pointIsInside(e){const t=this.vertices,r=this.faces,n=this.faceNormals,i=new So;this.getAveragePointLocal(i);for(let s=0;s<this.faces.length;s++){let o=n[s];const a=t[r[s][0]],c=new So;e.vsub(a,c);const l=o.dot(c),u=new So;i.vsub(a,u);const h=o.dot(u);if(l<0&&h>0||l>0&&h<0)return!1}return-1}static project(e,t,r,n,i){const s=e.vertices.length,o=Go;let a=0,c=0;const l=qo,u=e.vertices;l.setZero(),No.vectorToLocalFrame(r,n,t,o),No.pointToLocalFrame(r,n,l,l);const h=l.dot(o);c=a=u[0].dot(o);for(let e=1;e<s;e++){const t=u[e].dot(o);t>a&&(a=t),t<c&&(c=t)}if(c-=h,a-=h,c>a){const e=c;c=a,a=e}i[0]=a,i[1]=c}}const jo=[],Fo=[],Go=(new So,new So),qo=new So;class Vo extends Uo{constructor(e){super({type:Uo.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,r=this.halfExtents.z,n=So,i=[new n(-e,-t,-r),new n(e,-t,-r),new n(e,t,-r),new n(-e,t,-r),new n(-e,-t,r),new n(e,-t,r),new n(e,t,r),new n(-e,t,r)],s=[new n(0,0,1),new n(0,1,0),new n(1,0,0)],o=new Lo({vertices:i,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:s});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new So),Vo.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,r){const n=e;r.x=1/12*t*(2*n.y*2*n.y+2*n.z*2*n.z),r.y=1/12*t*(2*n.x*2*n.x+2*n.z*2*n.z),r.z=1/12*t*(2*n.y*2*n.y+2*n.x*2*n.x)}getSideNormals(e,t){const r=e,n=this.halfExtents;if(r[0].set(n.x,0,0),r[1].set(0,n.y,0),r[2].set(0,0,n.z),r[3].set(-n.x,0,0),r[4].set(0,-n.y,0),r[5].set(0,0,-n.z),void 0!==t)for(let e=0;e!==r.length;e++)t.vmult(r[e],r[e]);return r}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,r){const n=this.halfExtents,i=[[n.x,n.y,n.z],[-n.x,n.y,n.z],[-n.x,-n.y,n.z],[-n.x,-n.y,-n.z],[n.x,-n.y,-n.z],[n.x,n.y,-n.z],[-n.x,n.y,-n.z],[n.x,-n.y,n.z]];for(let n=0;n<i.length;n++)Wo.set(i[n][0],i[n][1],i[n][2]),t.vmult(Wo,Wo),e.vadd(Wo,Wo),r(Wo.x,Wo.y,Wo.z)}calculateWorldAABB(e,t,r,n){const i=this.halfExtents;Yo[0].set(i.x,i.y,i.z),Yo[1].set(-i.x,i.y,i.z),Yo[2].set(-i.x,-i.y,i.z),Yo[3].set(-i.x,-i.y,-i.z),Yo[4].set(i.x,-i.y,-i.z),Yo[5].set(i.x,i.y,-i.z),Yo[6].set(-i.x,i.y,-i.z),Yo[7].set(i.x,-i.y,i.z);const s=Yo[0];t.vmult(s,s),e.vadd(s,s),n.copy(s),r.copy(s);for(let i=1;i<8;i++){const s=Yo[i];t.vmult(s,s),e.vadd(s,s);const o=s.x,a=s.y,c=s.z;o>n.x&&(n.x=o),a>n.y&&(n.y=a),c>n.z&&(n.z=c),o<r.x&&(r.x=o),a<r.y&&(r.y=a),c<r.z&&(r.z=c)}}}const Wo=new So,Yo=[new So,new So,new So,new So,new So,new So,new So,new So];class Ho extends zo{constructor(e){void 0===e&&(e={}),super(),this.id=Ho.idCounter++,this.index=-1,this.world=null,this.vlambda=new So,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new So,this.previousPosition=new So,this.interpolatedPosition=new So,this.initPosition=new So,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new So,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new So,this.force=new So;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Ho.STATIC:Ho.DYNAMIC,typeof e.type==typeof Ho.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Ho.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new So,this.quaternion=new Oo,this.initQuaternion=new Oo,this.previousQuaternion=new Oo,this.interpolatedQuaternion=new Oo,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new So,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new So,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new So,this.invInertia=new So,this.invInertiaWorld=new _o,this.invMassSolve=0,this.invInertiaSolve=new So,this.invInertiaWorldSolve=new _o,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new So(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new So(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new Mo,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new So,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=Ho.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Ho.SLEEPING&&this.dispatchEvent(Ho.wakeupEvent)}sleep(){this.sleepState=Ho.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,r=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),n=this.sleepSpeedLimit**2;t===Ho.AWAKE&&r<n?(this.sleepState=Ho.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Ho.sleepyEvent)):t===Ho.SLEEPY&&r>n?this.wakeUp():t===Ho.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Ho.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Ho.SLEEPING||this.type===Ho.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new So),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new So),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new So),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new So),this.quaternion.vmult(e,t),t}addShape(e,t,r){const n=new So,i=new Oo;return t&&n.copy(t),r&&i.copy(r),this.shapes.push(e),this.shapeOffsets.push(n),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,r=e.length;let n=0;for(let i=0;i!==r;i++){const r=e[i];r.updateBoundingSphereRadius();const s=t[i].length(),o=r.boundingSphereRadius;s+o>n&&(n=s+o)}this.boundingRadius=n}updateAABB(){const e=this.shapes,t=this.shapeOffsets,r=this.shapeOrientations,n=e.length,i=$o,s=Xo,o=this.quaternion,a=this.aabb,c=Zo;for(let l=0;l!==n;l++){const n=e[l];o.vmult(t[l],i),i.vadd(this.position,i),o.mult(r[l],s),n.calculateWorldAABB(i,s,c.lowerBound,c.upperBound),0===l?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=Ko,r=Qo;e.setRotationFromQuaternion(this.quaternion),e.transpose(r),e.scale(t,e),e.mmult(r,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new So),this.type!==Ho.DYNAMIC)return;this.sleepState===Ho.SLEEPING&&this.wakeUp();const r=Jo;t.cross(e,r),this.force.vadd(e,this.force),this.torque.vadd(r,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new So),this.type!==Ho.DYNAMIC)return;const r=ea,n=ta;this.vectorToWorldFrame(e,r),this.vectorToWorldFrame(t,n),this.applyForce(r,n)}applyTorque(e){this.type===Ho.DYNAMIC&&(this.sleepState===Ho.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new So),this.type!==Ho.DYNAMIC)return;this.sleepState===Ho.SLEEPING&&this.wakeUp();const r=t,n=ra;n.copy(e),n.scale(this.invMass,n),this.velocity.vadd(n,this.velocity);const i=na;r.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new So),this.type!==Ho.DYNAMIC)return;const r=ia,n=sa;this.vectorToWorldFrame(e,r),this.vectorToWorldFrame(t,n),this.applyImpulse(r,n)}updateMassProperties(){const e=oa;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,r=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Vo.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!r?1/t.x:0,t.y>0&&!r?1/t.y:0,t.z>0&&!r?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const r=new So;return e.vsub(this.position,r),this.angularVelocity.cross(r,t),this.velocity.vadd(t,t),t}integrate(e,t,r){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Ho.DYNAMIC&&this.type!==Ho.KINEMATIC||this.sleepState===Ho.SLEEPING)return;const n=this.velocity,i=this.angularVelocity,s=this.position,o=this.force,a=this.torque,c=this.quaternion,l=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,d=l*e;n.x+=o.x*d*h.x,n.y+=o.y*d*h.y,n.z+=o.z*d*h.z;const f=u.elements,p=this.angularFactor,m=a.x*p.x,v=a.y*p.y,g=a.z*p.z;i.x+=e*(f[0]*m+f[1]*v+f[2]*g),i.y+=e*(f[3]*m+f[4]*v+f[5]*g),i.z+=e*(f[6]*m+f[7]*v+f[8]*g),s.x+=n.x*e,s.y+=n.y*e,s.z+=n.z*e,c.integrate(this.angularVelocity,e,this.angularFactor,c),t&&(r?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Ho.idCounter=0,Ho.COLLIDE_EVENT_NAME="collide",Ho.DYNAMIC=1,Ho.STATIC=2,Ho.KINEMATIC=4,Ho.AWAKE=0,Ho.SLEEPY=1,Ho.SLEEPING=2,Ho.wakeupEvent={type:"wakeup"},Ho.sleepyEvent={type:"sleepy"},Ho.sleepEvent={type:"sleep"};const $o=new So,Xo=new Oo,Zo=new Mo,Ko=new _o,Qo=new _o,Jo=(new _o,new So),ea=new So,ta=new So,ra=new So,na=new So,ia=new So,sa=new So,oa=new So;class aa{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,r){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&Ho.STATIC)&&e.sleepState!==Ho.SLEEPING||0==(t.type&Ho.STATIC)&&t.sleepState!==Ho.SLEEPING)}intersectionTest(e,t,r,n){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,r,n):this.doBoundingSphereBroadphase(e,t,r,n)}doBoundingSphereBroadphase(e,t,r,n){const i=ca;t.position.vsub(e.position,i);const s=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<s&&(r.push(e),n.push(t))}doBoundingBoxBroadphase(e,t,r,n){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(r.push(e),n.push(t))}makePairsUnique(e,t){const r=la,n=ua,i=ha,s=e.length;for(let r=0;r!==s;r++)n[r]=e[r],i[r]=t[r];e.length=0,t.length=0;for(let e=0;e!==s;e++){const t=n[e].id,s=i[e].id,o=t<s?`${t},${s}`:`${s},${t}`;r[o]=e,r.keys.push(o)}for(let s=0;s!==r.keys.length;s++){const s=r.keys.pop(),o=r[s];e.push(n[o]),t.push(i[o]),delete r[s]}}setWorld(e){}static boundingSphereCheck(e,t){const r=new So;e.position.vsub(t.position,r);const n=e.shapes[0],i=t.shapes[0];return Math.pow(n.boundingSphereRadius+i.boundingSphereRadius,2)>r.lengthSquared()}aabbQuery(e,t,r){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const ca=new So;new So,new Oo,new So;const la={keys:[]},ua=[],ha=[];new So,new So,new So;class da extends aa{constructor(){super()}collisionPairs(e,t,r){const n=e.bodies,i=n.length;let s,o;for(let e=0;e!==i;e++)for(let i=0;i!==e;i++)s=n[e],o=n[i],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,t,r)}aabbQuery(e,t,r){void 0===r&&(r=[]);for(let n=0;n<e.bodies.length;n++){const i=e.bodies[n];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&r.push(i)}return r}}class fa{constructor(){this.rayFromWorld=new So,this.rayToWorld=new So,this.hitNormalWorld=new So,this.hitPointWorld=new So,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,r,n,i,s,o){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(r),this.hitPointWorld.copy(n),this.shape=i,this.body=s,this.distance=o}}let pa,ma,va,ga,ya,xa,ba;pa=Uo.types.SPHERE,ma=Uo.types.PLANE,va=Uo.types.BOX,ga=Uo.types.CYLINDER,ya=Uo.types.CONVEXPOLYHEDRON,xa=Uo.types.HEIGHTFIELD,ba=Uo.types.TRIMESH;class wa{get[pa](){return this._intersectSphere}get[ma](){return this._intersectPlane}get[va](){return this._intersectBox}get[ga](){return this._intersectConvex}get[ya](){return this._intersectConvex}get[xa](){return this._intersectHeightfield}get[ba](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new So),void 0===t&&(t=new So),this.from=e.clone(),this.to=t.clone(),this.direction=new So,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=wa.ANY,this.result=new fa,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||wa.ANY,this.result=t.result||new fa,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(_a),Ta.length=0,e.broadphase.aabbQuery(e,_a,Ta),this.intersectBodies(Ta),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const r=this.checkCollisionResponse;if(r&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const n=ka,i=Ea;for(let t=0,s=e.shapes.length;t<s;t++){const s=e.shapes[t];if((!r||s.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],i),e.quaternion.vmult(e.shapeOffsets[t],n),n.vadd(e.position,n),this.intersectShape(s,i,n,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,r=e.length;!this.result.shouldStop&&t<r;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,r,n){const i=function(e,t,r){r.vsub(e,$a);const n=$a.dot(t);t.scale(n,Xa),Xa.vadd(e,Xa);return r.distanceTo(Xa)}(this.from,this.direction,r);if(i>e.boundingSphereRadius)return;const s=this[e.type];s&&s.call(this,e,t,r,n,e)}_intersectBox(e,t,r,n,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,r,n,i)}_intersectPlane(e,t,r,n,i){const s=this.from,o=this.to,a=this.direction,c=new So(0,0,1);t.vmult(c,c);const l=new So;s.vsub(r,l);const u=l.dot(c);if(o.vsub(r,l),u*l.dot(c)>0)return;if(s.distanceTo(o)<u)return;const h=c.dot(a);if(Math.abs(h)<this.precision)return;const d=new So,f=new So,p=new So;s.vsub(r,d);const m=-c.dot(d)/h;a.scale(m,f),s.vadd(f,p),this.reportIntersection(c,p,i,n,-1)}getAABB(e){const{lowerBound:t,upperBound:r}=e,n=this.to,i=this.from;t.x=Math.min(n.x,i.x),t.y=Math.min(n.y,i.y),t.z=Math.min(n.z,i.z),r.x=Math.max(n.x,i.x),r.y=Math.max(n.y,i.y),r.z=Math.max(n.z,i.z)}_intersectHeightfield(e,t,r,n,i){e.data,e.elementSize;const s=Ra;s.from.copy(this.from),s.to.copy(this.to),No.pointToLocalFrame(r,t,s.from,s.from),No.pointToLocalFrame(r,t,s.to,s.to),s.updateDirection();const o=Ba;let a,c,l,u;a=c=0,l=u=e.data.length-1;const h=new Mo;s.getAABB(h),e.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,o,!0),a=Math.max(a,o[0]),c=Math.max(c,o[1]),e.getIndexOfPosition(h.upperBound.x,h.upperBound.y,o,!0),l=Math.min(l,o[0]+1),u=Math.min(u,o[1]+1);for(let o=a;o<l;o++)for(let a=c;a<u;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(o,a,h),h.overlapsRay(s)){if(e.getConvexTrianglePillar(o,a,!1),No.pointToWorldFrame(r,t,e.pillarOffset,Oa),this._intersectConvex(e.pillarConvex,t,Oa,n,i,za),this.result.shouldStop)return;e.getConvexTrianglePillar(o,a,!0),No.pointToWorldFrame(r,t,e.pillarOffset,Oa),this._intersectConvex(e.pillarConvex,t,Oa,n,i,za)}}}_intersectSphere(e,t,r,n,i){const s=this.from,o=this.to,a=e.radius,c=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2,l=2*((o.x-s.x)*(s.x-r.x)+(o.y-s.y)*(s.y-r.y)+(o.z-s.z)*(s.z-r.z)),u=l**2-4*c*((s.x-r.x)**2+(s.y-r.y)**2+(s.z-r.z)**2-a**2),h=Ua,d=Na;if(!(u<0))if(0===u)s.lerp(o,u,h),h.vsub(r,d),d.normalize(),this.reportIntersection(d,h,i,n,-1);else{const e=(-l-Math.sqrt(u))/(2*c),t=(-l+Math.sqrt(u))/(2*c);if(e>=0&&e<=1&&(s.lerp(o,e,h),h.vsub(r,d),d.normalize(),this.reportIntersection(d,h,i,n,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(s.lerp(o,t,h),h.vsub(r,d),d.normalize(),this.reportIntersection(d,h,i,n,-1))}}_intersectConvex(e,t,r,n,i,s){const o=Da,a=La,c=s&&s.faceList||null,l=e.faces,u=e.vertices,h=e.faceNormals,d=this.direction,f=this.from,p=this.to,m=f.distanceTo(p),v=c?c.length:l.length,g=this.result;for(let e=0;!g.shouldStop&&e<v;e++){const s=c?c[e]:e,p=l[s],v=h[s],y=t,x=r;a.copy(u[p[0]]),y.vmult(a,a),a.vadd(x,a),a.vsub(f,a),y.vmult(v,o);const b=d.dot(o);if(Math.abs(b)<this.precision)continue;const w=o.dot(a)/b;if(!(w<0)){d.scale(w,Ma),Ma.vadd(f,Ma),Aa.copy(u[p[0]]),y.vmult(Aa,Aa),x.vadd(Aa,Aa);for(let e=1;!g.shouldStop&&e<p.length-1;e++){Ca.copy(u[p[e]]),Ia.copy(u[p[e+1]]),y.vmult(Ca,Ca),y.vmult(Ia,Ia),x.vadd(Ca,Ca),x.vadd(Ia,Ia);const t=Ma.distanceTo(f);!wa.pointInTriangle(Ma,Aa,Ca,Ia)&&!wa.pointInTriangle(Ma,Ca,Aa,Ia)||t>m||this.reportIntersection(o,Ma,i,n,s)}}}}_intersectTrimesh(e,t,r,n,i,s){const o=ja,a=Ya,c=Ha,l=La,u=Fa,h=Ga,d=qa,f=Wa,p=Va,m=e.indices;e.vertices;const v=this.from,g=this.to,y=this.direction;c.position.copy(r),c.quaternion.copy(t),No.vectorToLocalFrame(r,t,y,u),No.pointToLocalFrame(r,t,v,h),No.pointToLocalFrame(r,t,g,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,d.vsub(h,u),u.normalize();const x=h.distanceSquared(d);e.tree.rayQuery(this,c,a);for(let s=0,c=a.length;!this.result.shouldStop&&s!==c;s++){const c=a[s];e.getNormal(c,o),e.getVertex(m[3*c],Aa),Aa.vsub(h,l);const d=u.dot(o),v=o.dot(l)/d;if(v<0)continue;u.scale(v,Ma),Ma.vadd(h,Ma),e.getVertex(m[3*c+1],Ca),e.getVertex(m[3*c+2],Ia);const g=Ma.distanceSquared(h);!wa.pointInTriangle(Ma,Ca,Aa,Ia)&&!wa.pointInTriangle(Ma,Aa,Ca,Ia)||g>x||(No.vectorToWorldFrame(t,o,p),No.pointToWorldFrame(r,t,Ma,f),this.reportIntersection(p,f,i,n,c))}a.length=0}reportIntersection(e,t,r,n,i){const s=this.from,o=this.to,a=s.distanceTo(t),c=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(c.hitFaceIndex=void 0!==i?i:-1,this.mode){case wa.ALL:this.hasHit=!0,c.set(s,o,e,t,r,n,a),c.hasHit=!0,this.callback(c);break;case wa.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(s,o,e,t,r,n,a));break;case wa.ANY:this.hasHit=!0,c.hasHit=!0,c.set(s,o,e,t,r,n,a),c.shouldStop=!0}}static pointInTriangle(e,t,r,n){n.vsub(t,$a),r.vsub(t,Sa),e.vsub(t,Pa);const i=$a.dot($a),s=$a.dot(Sa),o=$a.dot(Pa),a=Sa.dot(Sa),c=Sa.dot(Pa);let l,u;return(l=a*o-s*c)>=0&&(u=i*c-s*o)>=0&&l+u<i*a-s*s}}wa.CLOSEST=1,wa.ANY=2,wa.ALL=4;const _a=new Mo,Ta=[],Sa=new So,Pa=new So,ka=new So,Ea=new Oo,Ma=new So,Aa=new So,Ca=new So,Ia=new So;new So,new fa;const za={faceList:[0]},Oa=new So,Ra=new wa,Ba=[],Ua=new So,Na=new So,Da=new So,La=(new So,new So,new So),ja=new So,Fa=new So,Ga=new So,qa=new So,Va=new So,Wa=new So;new Mo;const Ya=[],Ha=new No,$a=new So,Xa=new So;class Za{static defaults(e,t){void 0===e&&(e={});for(let r in t)r in e||(e[r]=t[r]);return e}}class Ka{constructor(e,t,r){void 0===r&&(r={}),r=Za.defaults(r,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=Ka.idCounter++,this.collideConnected=r.collideConnected,r.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}Ka.idCounter=0;class Qa{constructor(){this.spatial=new So,this.rotational=new So}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class Ja{constructor(e,t,r,n){void 0===r&&(r=-1e6),void 0===n&&(n=1e6),this.id=Ja.idCounter++,this.minForce=r,this.maxForce=n,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new Qa,this.jacobianElementB=new Qa,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,r){const n=t,i=e,s=r;this.a=4/(s*(1+4*n)),this.b=4*n/(1+4*n),this.eps=4/(s*s*i*(1+4*n))}computeB(e,t,r){const n=this.computeGW();return-this.computeGq()*e-n*t-this.computeGiMf()*r}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,r=this.bi,n=this.bj,i=r.position,s=n.position;return e.spatial.dot(i)+t.spatial.dot(s)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,r=this.bi,n=this.bj,i=r.velocity,s=n.velocity,o=r.angularVelocity,a=n.angularVelocity;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,r=this.bi,n=this.bj,i=r.vlambda,s=n.vlambda,o=r.wlambda,a=n.wlambda;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,r=this.bi,n=this.bj,i=r.force,s=r.torque,o=n.force,a=n.torque,c=r.invMassSolve,l=n.invMassSolve;return i.scale(c,ec),o.scale(l,tc),r.invInertiaWorldSolve.vmult(s,rc),n.invInertiaWorldSolve.vmult(a,nc),e.multiplyVectors(ec,rc)+t.multiplyVectors(tc,nc)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,r=this.bi,n=this.bj,i=r.invMassSolve,s=n.invMassSolve,o=r.invInertiaWorldSolve,a=n.invInertiaWorldSolve;let c=i+s;return o.vmult(e.rotational,ic),c+=ic.dot(e.rotational),a.vmult(t.rotational,ic),c+=ic.dot(t.rotational),c}addToWlambda(e){const t=this.jacobianElementA,r=this.jacobianElementB,n=this.bi,i=this.bj,s=sc;n.vlambda.addScaledVector(n.invMassSolve*e,t.spatial,n.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,r.spatial,i.vlambda),n.invInertiaWorldSolve.vmult(t.rotational,s),n.wlambda.addScaledVector(e,s,n.wlambda),i.invInertiaWorldSolve.vmult(r.rotational,s),i.wlambda.addScaledVector(e,s,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Ja.idCounter=0;const ec=new So,tc=new So,rc=new So,nc=new So,ic=new So,sc=new So;class oc extends Ja{constructor(e,t,r){void 0===r&&(r=1e6),super(e,t,0,r),this.restitution=0,this.ri=new So,this.rj=new So,this.ni=new So}computeB(e){const t=this.a,r=this.b,n=this.bi,i=this.bj,s=this.ri,o=this.rj,a=ac,c=cc,l=n.velocity,u=n.angularVelocity;n.force,n.torque;const h=i.velocity,d=i.angularVelocity;i.force,i.torque;const f=lc,p=this.jacobianElementA,m=this.jacobianElementB,v=this.ni;s.cross(v,a),o.cross(v,c),v.negate(p.spatial),a.negate(p.rotational),m.spatial.copy(v),m.rotational.copy(c),f.copy(i.position),f.vadd(o,f),f.vsub(n.position,f),f.vsub(s,f);const g=v.dot(f),y=this.restitution+1;return-g*t-(y*h.dot(v)-y*l.dot(v)+d.dot(c)-u.dot(a))*r-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=uc,t=hc,r=dc,n=fc,i=pc;return this.bi.position.vadd(this.ri,r),this.bj.position.vadd(this.rj,n),this.bi.getVelocityAtWorldPoint(r,e),this.bj.getVelocityAtWorldPoint(n,t),e.vsub(t,i),this.ni.dot(i)}}const ac=new So,cc=new So,lc=new So,uc=new So,hc=new So,dc=new So,fc=new So,pc=new So;new So,new So,new So,new So,new So,new So,new So,new So,new So,new So;class mc extends Ja{constructor(e,t,r){super(e,t,-r,r),this.ri=new So,this.rj=new So,this.t=new So}computeB(e){this.a;const t=this.b;this.bi,this.bj;const r=this.ri,n=this.rj,i=vc,s=gc,o=this.t;r.cross(o,i),n.cross(o,s);const a=this.jacobianElementA,c=this.jacobianElementB;return o.negate(a.spatial),i.negate(a.rotational),c.spatial.copy(o),c.rotational.copy(s),-this.computeGW()*t-e*this.computeGiMf()}}const vc=new So,gc=new So;class yc{constructor(e,t,r){r=Za.defaults(r,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=yc.idCounter++,this.materials=[e,t],this.friction=r.friction,this.restitution=r.restitution,this.contactEquationStiffness=r.contactEquationStiffness,this.contactEquationRelaxation=r.contactEquationRelaxation,this.frictionEquationStiffness=r.frictionEquationStiffness,this.frictionEquationRelaxation=r.frictionEquationRelaxation}}yc.idCounter=0;class xc{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=xc.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}xc.idCounter=0,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new wa,new So,new So,new So,new So(1,0,0),new So(0,1,0),new So(0,0,1),new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new So,new Mo,new So,new Mo,new So,new So,new So,new So,new So,new So,new So,new Mo,new So,new No,new Mo;class bc{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,r=t.indexOf(e);-1!==r&&t.splice(r,1)}removeAllEquations(){this.equations.length=0}}class wc extends bc{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let r=0;const n=this.iterations,i=this.tolerance*this.tolerance,s=this.equations,o=s.length,a=t.bodies,c=a.length,l=e;let u,h,d,f,p,m;if(0!==o)for(let e=0;e!==c;e++)a[e].updateSolveMassProperties();const v=Tc,g=Sc,y=_c;v.length=o,g.length=o,y.length=o;for(let e=0;e!==o;e++){const t=s[e];y[e]=0,g[e]=t.computeB(l),v[e]=1/t.computeC()}if(0!==o){for(let e=0;e!==c;e++){const t=a[e],r=t.vlambda,n=t.wlambda;r.set(0,0,0),n.set(0,0,0)}for(r=0;r!==n;r++){f=0;for(let e=0;e!==o;e++){const t=s[e];u=g[e],h=v[e],m=y[e],p=t.computeGWlambda(),d=h*(u-p-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),y[e]+=d,f+=d>0?d:-d,t.addToWlambda(d)}if(f*f<i)break}for(let e=0;e!==c;e++){const t=a[e],r=t.velocity,n=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),r.vadd(t.vlambda,r),t.wlambda.vmul(t.angularFactor,t.wlambda),n.vadd(t.wlambda,n)}let e=s.length;const t=1/l;for(;e--;)s[e].multiplier=y[e]*t}return r}}const _c=[],Tc=[],Sc=[];Ho.STATIC;class Pc{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class kc extends Pc{constructor(){super(...arguments),this.type=So}constructObject(){return new So}}const Ec=Uo.types.SPHERE,Mc=Uo.types.SPHERE|Uo.types.PLANE,Ac=Uo.types.BOX|Uo.types.BOX,Cc=Uo.types.SPHERE|Uo.types.BOX,Ic=Uo.types.PLANE|Uo.types.BOX,zc=Uo.types.CONVEXPOLYHEDRON,Oc=Uo.types.SPHERE|Uo.types.CONVEXPOLYHEDRON,Rc=Uo.types.PLANE|Uo.types.CONVEXPOLYHEDRON,Bc=Uo.types.BOX|Uo.types.CONVEXPOLYHEDRON,Uc=Uo.types.SPHERE|Uo.types.HEIGHTFIELD,Nc=Uo.types.BOX|Uo.types.HEIGHTFIELD,Dc=Uo.types.CONVEXPOLYHEDRON|Uo.types.HEIGHTFIELD,Lc=Uo.types.PARTICLE|Uo.types.SPHERE,jc=Uo.types.PLANE|Uo.types.PARTICLE,Fc=Uo.types.BOX|Uo.types.PARTICLE,Gc=Uo.types.PARTICLE|Uo.types.CONVEXPOLYHEDRON,qc=Uo.types.CYLINDER,Vc=Uo.types.SPHERE|Uo.types.CYLINDER,Wc=Uo.types.PLANE|Uo.types.CYLINDER,Yc=Uo.types.BOX|Uo.types.CYLINDER,Hc=Uo.types.CONVEXPOLYHEDRON|Uo.types.CYLINDER,$c=Uo.types.HEIGHTFIELD|Uo.types.CYLINDER,Xc=Uo.types.PARTICLE|Uo.types.CYLINDER,Zc=Uo.types.SPHERE|Uo.types.TRIMESH,Kc=Uo.types.PLANE|Uo.types.TRIMESH;class Qc{get[Ec](){return this.sphereSphere}get[Mc](){return this.spherePlane}get[Ac](){return this.boxBox}get[Cc](){return this.sphereBox}get[Ic](){return this.planeBox}get[zc](){return this.convexConvex}get[Oc](){return this.sphereConvex}get[Rc](){return this.planeConvex}get[Bc](){return this.boxConvex}get[Uc](){return this.sphereHeightfield}get[Nc](){return this.boxHeightfield}get[Dc](){return this.convexHeightfield}get[Lc](){return this.sphereParticle}get[jc](){return this.planeParticle}get[Fc](){return this.boxParticle}get[Gc](){return this.convexParticle}get[qc](){return this.convexConvex}get[Vc](){return this.sphereConvex}get[Wc](){return this.planeConvex}get[Yc](){return this.boxConvex}get[Hc](){return this.convexConvex}get[$c](){return this.heightfieldCylinder}get[Xc](){return this.particleCylinder}get[Zc](){return this.sphereTrimesh}get[Kc](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new kc,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,r,n,i,s){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=e,o.bj=t):o=new oc(e,t),o.enabled=e.collisionResponse&&t.collisionResponse&&r.collisionResponse&&n.collisionResponse;const a=this.currentContactMaterial;o.restitution=a.restitution,o.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=r.material||e.material,l=n.material||t.material;return c&&l&&c.restitution>=0&&l.restitution>=0&&(o.restitution=c.restitution*l.restitution),o.si=i||r,o.sj=s||n,o}createFrictionEquationsFromContact(e,t){const r=e.bi,n=e.bj,i=e.si,s=e.sj,o=this.world,a=this.currentContactMaterial;let c=a.friction;const l=i.material||r.material,u=s.material||n.material;if(l&&u&&l.friction>=0&&u.friction>=0&&(c=l.friction*u.friction),c>0){const i=c*(o.frictionGravity||o.gravity).length();let s=r.invMass+n.invMass;s>0&&(s=1/s);const l=this.frictionEquationPool,u=l.length?l.pop():new mc(r,n,i*s),h=l.length?l.pop():new mc(r,n,i*s);return u.bi=h.bi=r,u.bj=h.bj=n,u.minForce=h.minForce=-i*s,u.maxForce=h.maxForce=i*s,u.ri.copy(e.ri),u.rj.copy(e.rj),h.ri.copy(e.ri),h.rj.copy(e.rj),e.ni.tangents(u.t,h.t),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),u.enabled=h.enabled=e.enabled,t.push(u,h),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const r=this.frictionResult[this.frictionResult.length-2],n=this.frictionResult[this.frictionResult.length-1];Jc.setZero(),el.setZero(),tl.setZero();const i=t.bi;t.bj;for(let r=0;r!==e;r++)t=this.result[this.result.length-1-r],t.bi!==i?(Jc.vadd(t.ni,Jc),el.vadd(t.ri,el),tl.vadd(t.rj,tl)):(Jc.vsub(t.ni,Jc),el.vadd(t.rj,el),tl.vadd(t.ri,tl));const s=1/e;el.scale(s,r.ri),tl.scale(s,r.rj),n.ri.copy(r.ri),n.rj.copy(r.rj),Jc.normalize(),Jc.tangents(r.t,n.t)}getContacts(e,t,r,n,i,s,o){this.contactPointPool=i,this.frictionEquationPool=o,this.result=n,this.frictionResult=s;const a=il,c=sl,l=rl,u=nl;for(let n=0,i=e.length;n!==i;n++){const i=e[n],s=t[n];let o=null;i.material&&s.material&&(o=r.getContactMaterial(i.material,s.material)||null);const h=i.type&Ho.KINEMATIC&&s.type&Ho.STATIC||i.type&Ho.STATIC&&s.type&Ho.KINEMATIC||i.type&Ho.KINEMATIC&&s.type&Ho.KINEMATIC;for(let e=0;e<i.shapes.length;e++){i.quaternion.mult(i.shapeOrientations[e],a),i.quaternion.vmult(i.shapeOffsets[e],l),l.vadd(i.position,l);const t=i.shapes[e];for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],c),s.quaternion.vmult(s.shapeOffsets[e],u),u.vadd(s.position,u);const n=s.shapes[e];if(!(t.collisionFilterMask&n.collisionFilterGroup&&n.collisionFilterMask&t.collisionFilterGroup))continue;if(l.distanceTo(u)>t.boundingSphereRadius+n.boundingSphereRadius)continue;let d=null;t.material&&n.material&&(d=r.getContactMaterial(t.material,n.material)||null),this.currentContactMaterial=d||o||r.defaultContactMaterial;const f=this[t.type|n.type];if(f){let e=!1;e=t.type<n.type?f.call(this,t,n,l,u,a,c,i,s,t,n,h):f.call(this,n,t,u,l,c,a,s,i,t,n,h),e&&h&&(r.shapeOverlapKeeper.set(t.id,n.id),r.bodyOverlapKeeper.set(i.id,s.id))}}}}}sphereSphere(e,t,r,n,i,s,o,a,c,l,u){if(u)return r.distanceSquared(n)<(e.radius+t.radius)**2;const h=this.createContactEquation(o,a,e,t,c,l);n.vsub(r,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(r,h.ri),h.ri.vsub(o.position,h.ri),h.rj.vadd(n,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,r,n,i,s,o,a,c,l,u){const h=this.createContactEquation(o,a,e,t,c,l);if(h.ni.set(0,0,1),s.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),r.vsub(n,Sl),h.ni.scale(h.ni.dot(Sl),Pl),Sl.vsub(Pl,h.rj),-Sl.dot(h.ni)<=e.radius){if(u)return!0;const e=h.ri,t=h.rj;e.vadd(r,e),e.vsub(o.position,e),t.vadd(n,t),t.vsub(a.position,t),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,r,n,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,r,n,i,s,o,a,e,t,u)}sphereBox(e,t,r,n,i,s,o,a,c,l,u){const h=this.v3pool,d=Rl;r.vsub(n,Cl),t.getSideNormals(d,s);const f=e.radius;let p=!1;const m=Ul,v=Nl,g=Dl;let y=null,x=0,b=0,w=0,_=null;for(let e=0,t=d.length;e!==t&&!1===p;e++){const t=Il;t.copy(d[e]);const r=t.length();t.normalize();const n=Cl.dot(t);if(n<r+f&&n>0){const i=zl,s=Ol;i.copy(d[(e+1)%3]),s.copy(d[(e+2)%3]);const o=i.length(),a=s.length();i.normalize(),s.normalize();const c=Cl.dot(i),l=Cl.dot(s);if(c<o&&c>-o&&l<a&&l>-a){const e=Math.abs(n-r-f);if((null===_||e<_)&&(_=e,b=c,w=l,y=r,m.copy(t),v.copy(i),g.copy(s),x++,u))return!0}}}if(x){p=!0;const i=this.createContactEquation(o,a,e,t,c,l);m.scale(-f,i.ri),i.ni.copy(m),i.ni.negate(i.ni),m.scale(y,m),v.scale(b,v),m.vadd(v,m),g.scale(w,g),m.vadd(g,i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(n,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}let T=h.get();const S=Bl;for(let i=0;2!==i&&!p;i++)for(let s=0;2!==s&&!p;s++)for(let h=0;2!==h&&!p;h++)if(T.set(0,0,0),i?T.vadd(d[0],T):T.vsub(d[0],T),s?T.vadd(d[1],T):T.vsub(d[1],T),h?T.vadd(d[2],T):T.vsub(d[2],T),n.vadd(T,S),S.vsub(r,S),S.lengthSquared()<f*f){if(u)return!0;p=!0;const i=this.createContactEquation(o,a,e,t,c,l);i.ri.copy(S),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(f,i.ri),i.rj.copy(T),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(n,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}h.release(T),T=null;const P=h.get(),k=h.get(),E=h.get(),M=h.get(),A=h.get(),C=d.length;for(let i=0;i!==C&&!p;i++)for(let s=0;s!==C&&!p;s++)if(i%3!=s%3){d[s].cross(d[i],P),P.normalize(),d[i].vadd(d[s],k),E.copy(r),E.vsub(k,E),E.vsub(n,E);const h=E.dot(P);P.scale(h,M);let m=0;for(;m===i%3||m===s%3;)m++;A.copy(r),A.vsub(M,A),A.vsub(k,A),A.vsub(n,A);const v=Math.abs(h),g=A.length();if(v<d[m].length()&&g<f){if(u)return!0;p=!0;const i=this.createContactEquation(o,a,e,t,c,l);k.vadd(M,i.rj),i.rj.copy(i.rj),A.negate(i.ni),i.ni.normalize(),i.ri.copy(i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(r,i.ri),i.ri.normalize(),i.ri.scale(f,i.ri),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(n,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}h.release(P,k,E,M,A)}planeBox(e,t,r,n,i,s,o,a,c,l,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,r,n,i,s,o,a,e,t,u)}convexConvex(e,t,r,n,i,s,o,a,c,l,u,h,d){const f=Jl;if(!(r.distanceTo(n)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,r,i,n,s,f,h,d)){const h=[],d=eu;e.clipAgainstHull(r,i,t,n,s,f,-100,100,h);let p=0;for(let i=0;i!==h.length;i++){if(u)return!0;const s=this.createContactEquation(o,a,e,t,c,l),m=s.ri,v=s.rj;f.negate(s.ni),h[i].normal.negate(d),d.scale(h[i].depth,d),h[i].point.vadd(d,m),v.copy(h[i].point),m.vsub(r,m),v.vsub(n,v),m.vadd(r,m),m.vsub(o.position,m),v.vadd(n,v),v.vsub(a.position,v),this.result.push(s),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}}sphereConvex(e,t,r,n,i,s,o,a,c,l,u){const h=this.v3pool;r.vsub(n,Ll);const d=t.faceNormals,f=t.faces,p=t.vertices,m=e.radius;let v=!1;for(let i=0;i!==p.length;i++){const h=p[i],d=ql;s.vmult(h,d),n.vadd(d,d);const f=Gl;if(d.vsub(r,f),f.lengthSquared()<m*m){if(u)return!0;v=!0;const i=this.createContactEquation(o,a,e,t,c,l);return i.ri.copy(f),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(m,i.ri),d.vsub(n,i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(n,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),void this.createFrictionEquationsFromContact(i,this.frictionResult)}}for(let i=0,g=f.length;i!==g&&!1===v;i++){const g=d[i],y=f[i],x=Vl;s.vmult(g,x);const b=Wl;s.vmult(p[y[0]],b),b.vadd(n,b);const w=Yl;x.scale(-m,w),r.vadd(w,w);const _=Hl;w.vsub(b,_);const T=_.dot(x),S=$l;if(r.vsub(b,S),T<0&&S.dot(x)>0){const i=[];for(let e=0,t=y.length;e!==t;e++){const t=h.get();s.vmult(p[y[e]],t),n.vadd(t,t),i.push(t)}if(Al(i,x,r)){if(u)return!0;v=!0;const s=this.createContactEquation(o,a,e,t,c,l);x.scale(-m,s.ri),x.negate(s.ni);const d=h.get();x.scale(-T,d);const f=h.get();x.scale(-m,f),r.vsub(n,s.rj),s.rj.vadd(f,s.rj),s.rj.vadd(d,s.rj),s.rj.vadd(n,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(r,s.ri),s.ri.vsub(o.position,s.ri),h.release(d),h.release(f),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return}for(let d=0;d!==y.length;d++){const f=h.get(),v=h.get();s.vmult(p[y[(d+1)%y.length]],f),s.vmult(p[y[(d+2)%y.length]],v),n.vadd(f,f),n.vadd(v,v);const g=jl;v.vsub(f,g);const x=Fl;g.unit(x);const b=h.get(),w=h.get();r.vsub(f,w);const _=w.dot(x);x.scale(_,b),b.vadd(f,b);const T=h.get();if(b.vsub(r,T),_>0&&_*_<g.lengthSquared()&&T.lengthSquared()<m*m){if(u)return!0;const s=this.createContactEquation(o,a,e,t,c,l);b.vsub(n,s.rj),b.vsub(r,s.ni),s.ni.normalize(),s.ni.scale(m,s.ri),s.rj.vadd(n,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(r,s.ri),s.ri.vsub(o.position,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return h.release(f),h.release(v),h.release(b),h.release(T),void h.release(w)}h.release(f),h.release(v),h.release(b),h.release(T),h.release(w)}for(let e=0,t=i.length;e!==t;e++)h.release(i[e])}}}planeConvex(e,t,r,n,i,s,o,a,c,l,u){const h=Xl,d=Zl;d.set(0,0,1),i.vmult(d,d);let f=0;const p=Kl;for(let i=0;i!==t.vertices.length;i++)if(h.copy(t.vertices[i]),s.vmult(h,h),n.vadd(h,h),h.vsub(r,p),d.dot(p)<=0){if(u)return!0;const i=this.createContactEquation(o,a,e,t,c,l),s=Ql;d.scale(d.dot(p),s),h.vsub(s,s),s.vsub(r,i.ri),i.ni.copy(d),h.vsub(n,i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(n,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(i,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}boxConvex(e,t,r,n,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,r,n,i,s,o,a,e,t,u)}sphereHeightfield(e,t,r,n,i,s,o,a,c,l,u){const h=t.data,d=e.radius,f=t.elementSize,p=pu,m=fu;No.pointToLocalFrame(n,s,r,m);let v=Math.floor((m.x-d)/f)-1,g=Math.ceil((m.x+d)/f)+1,y=Math.floor((m.y-d)/f)-1,x=Math.ceil((m.y+d)/f)+1;if(g<0||x<0||v>h.length||y>h[0].length)return;v<0&&(v=0),g<0&&(g=0),y<0&&(y=0),x<0&&(x=0),v>=h.length&&(v=h.length-1),g>=h.length&&(g=h.length-1),x>=h[0].length&&(x=h[0].length-1),y>=h[0].length&&(y=h[0].length-1);const b=[];t.getRectMinMax(v,y,g,x,b);const w=b[0],_=b[1];if(m.z-d>_||m.z+d<w)return;const T=this.result;for(let c=v;c<g;c++)for(let l=y;l<x;l++){const h=T.length;let d=!1;if(t.getConvexTrianglePillar(c,l,!1),No.pointToWorldFrame(n,s,t.pillarOffset,p),r.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,r,p,i,s,o,a,e,t,u)),u&&d)return!0;if(t.getConvexTrianglePillar(c,l,!0),No.pointToWorldFrame(n,s,t.pillarOffset,p),r.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,r,p,i,s,o,a,e,t,u)),u&&d)return!0;if(T.length-h>2)return}}boxHeightfield(e,t,r,n,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,r,n,i,s,o,a,e,t,u)}convexHeightfield(e,t,r,n,i,s,o,a,c,l,u){const h=t.data,d=t.elementSize,f=e.boundingSphereRadius,p=hu,m=du,v=uu;No.pointToLocalFrame(n,s,r,v);let g=Math.floor((v.x-f)/d)-1,y=Math.ceil((v.x+f)/d)+1,x=Math.floor((v.y-f)/d)-1,b=Math.ceil((v.y+f)/d)+1;if(y<0||b<0||g>h.length||x>h[0].length)return;g<0&&(g=0),y<0&&(y=0),x<0&&(x=0),b<0&&(b=0),g>=h.length&&(g=h.length-1),y>=h.length&&(y=h.length-1),b>=h[0].length&&(b=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const w=[];t.getRectMinMax(g,x,y,b,w);const _=w[0],T=w[1];if(!(v.z-f>T||v.z+f<_))for(let c=g;c<y;c++)for(let l=x;l<b;l++){let h=!1;if(t.getConvexTrianglePillar(c,l,!1),No.pointToWorldFrame(n,s,t.pillarOffset,p),r.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,r,p,i,s,o,a,null,null,u,m,null)),u&&h)return!0;if(t.getConvexTrianglePillar(c,l,!0),No.pointToWorldFrame(n,s,t.pillarOffset,p),r.distanceTo(p)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,r,p,i,s,o,a,null,null,u,m,null)),u&&h)return!0}}sphereParticle(e,t,r,n,i,s,o,a,c,l,u){const h=iu;if(h.set(0,0,1),n.vsub(r,h),h.lengthSquared()<=e.radius*e.radius){if(u)return!0;const r=this.createContactEquation(a,o,t,e,c,l);h.normalize(),r.rj.copy(h),r.rj.scale(e.radius,r.rj),r.ni.copy(h),r.ni.negate(r.ni),r.ri.set(0,0,0),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}planeParticle(e,t,r,n,i,s,o,a,c,l,u){const h=tu;h.set(0,0,1),o.quaternion.vmult(h,h);const d=ru;if(n.vsub(o.position,d),h.dot(d)<=0){if(u)return!0;const r=this.createContactEquation(a,o,t,e,c,l);r.ni.copy(h),r.ni.negate(r.ni),r.ri.set(0,0,0);const i=nu;h.scale(h.dot(n),i),n.vsub(i,i),r.rj.copy(i),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}boxParticle(e,t,r,n,i,s,o,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,r,n,i,s,o,a,e,t,u)}convexParticle(e,t,r,n,i,s,o,a,c,l,u){let h=-1;const d=au,f=lu;let p=null;const m=ou;if(m.copy(n),m.vsub(r,m),i.conjugate(su),su.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(r,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let t=0,r=e.faces.length;t!==r;t++){const r=[e.worldVertices[e.faces[t][0]]],i=e.worldFaceNormals[t];n.vsub(r[0],cu);const s=-i.dot(cu);if(null===p||Math.abs(s)<Math.abs(p)){if(u)return!0;p=s,h=t,d.copy(i)}}if(-1!==h){const i=this.createContactEquation(a,o,t,e,c,l);d.scale(p,f),f.vadd(n,f),f.vsub(r,f),i.rj.copy(f),d.negate(i.ni),i.ri.set(0,0,0);const s=i.ri,u=i.rj;s.vadd(n,s),s.vsub(a.position,s),u.vadd(r,u),u.vsub(o.position,u),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,r,n,i,s,o,a,c,l,u){return this.convexHeightfield(t,e,n,r,s,i,a,o,c,l,u)}particleCylinder(e,t,r,n,i,s,o,a,c,l,u){return this.convexParticle(t,e,n,r,s,i,a,o,c,l,u)}sphereTrimesh(e,t,r,n,i,s,o,a,c,l,u){const h=fl,d=pl,f=ml,p=vl,m=gl,v=yl,g=_l,y=dl,x=ul,b=Tl;No.pointToLocalFrame(n,s,r,m);const w=e.radius;g.lowerBound.set(m.x-w,m.y-w,m.z-w),g.upperBound.set(m.x+w,m.y+w,m.z+w),t.getTrianglesInAABB(g,b);const _=hl,T=e.radius*e.radius;for(let i=0;i<b.length;i++)for(let h=0;h<3;h++)if(t.getVertex(t.indices[3*b[i]+h],_),_.vsub(m,x),x.lengthSquared()<=T){if(y.copy(_),No.pointToWorldFrame(n,s,y,_),_.vsub(r,x),u)return!0;let i=this.createContactEquation(o,a,e,t,c,l);i.ni.copy(x),i.ni.normalize(),i.ri.copy(i.ni),i.ri.scale(e.radius,i.ri),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),i.rj.copy(_),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}for(let i=0;i<b.length;i++)for(let g=0;g<3;g++){t.getVertex(t.indices[3*b[i]+g],h),t.getVertex(t.indices[3*b[i]+(g+1)%3],d),d.vsub(h,f),m.vsub(d,v);const y=v.dot(f);m.vsub(h,v);let x=v.dot(f);if(x>0&&y<0&&(m.vsub(h,v),p.copy(f),p.normalize(),x=v.dot(p),p.scale(x,v),v.vadd(h,v),v.distanceTo(m)<e.radius)){if(u)return!0;const i=this.createContactEquation(o,a,e,t,c,l);v.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),No.pointToWorldFrame(n,s,v,v),v.vsub(a.position,i.rj),No.vectorToWorldFrame(s,i.ni,i.ni),No.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}const S=xl,P=bl,k=wl,E=ll;for(let i=0,h=b.length;i!==h;i++){t.getTriangleVertices(b[i],S,P,k),t.getNormal(b[i],E),m.vsub(S,v);let h=v.dot(E);if(E.scale(h,v),m.vsub(v,v),h=v.distanceTo(m),wa.pointInTriangle(v,S,P,k)&&h<e.radius){if(u)return!0;let i=this.createContactEquation(o,a,e,t,c,l);v.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(r,i.ri),i.ri.vsub(o.position,i.ri),No.pointToWorldFrame(n,s,v,v),v.vsub(a.position,i.rj),No.vectorToWorldFrame(s,i.ni,i.ni),No.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}b.length=0}planeTrimesh(e,t,r,n,i,s,o,a,c,l,u){const h=new So,d=ol;d.set(0,0,1),i.vmult(d,d);for(let i=0;i<t.vertices.length/3;i++){t.getVertex(i,h);const f=new So;f.copy(h),No.pointToWorldFrame(n,s,f,h);const p=al;if(h.vsub(r,p),d.dot(p)<=0){if(u)return!0;const r=this.createContactEquation(o,a,e,t,c,l);r.ni.copy(d);const n=cl;d.scale(p.dot(d),n),h.vsub(n,n),r.ri.copy(n),r.ri.vsub(o.position,r.ri),r.rj.copy(h),r.rj.vsub(a.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}}}const Jc=new So,el=new So,tl=new So,rl=new So,nl=new So,il=new Oo,sl=new Oo,ol=new So,al=new So,cl=new So,ll=new So,ul=new So;new So;const hl=new So,dl=new So,fl=new So,pl=new So,ml=new So,vl=new So,gl=new So,yl=new So,xl=new So,bl=new So,wl=new So,_l=new Mo,Tl=[],Sl=new So,Pl=new So,kl=new So,El=new So,Ml=new So;function Al(e,t,r){let n=null;const i=e.length;for(let s=0;s!==i;s++){const o=e[s],a=kl;e[(s+1)%i].vsub(o,a);const c=El;a.cross(t,c);const l=Ml;r.vsub(o,l);const u=c.dot(l);if(!(null===n||u>0&&!0===n||u<=0&&!1===n))return!1;null===n&&(n=u>0)}return!0}const Cl=new So,Il=new So,zl=new So,Ol=new So,Rl=[new So,new So,new So,new So,new So,new So],Bl=new So,Ul=new So,Nl=new So,Dl=new So,Ll=new So,jl=new So,Fl=new So,Gl=new So,ql=new So,Vl=new So,Wl=new So,Yl=new So,Hl=new So,$l=new So;new So,new So;const Xl=new So,Zl=new So,Kl=new So,Ql=new So,Jl=new So,eu=new So,tu=new So,ru=new So,nu=new So,iu=new So,su=new Oo,ou=new So;new So;const au=new So,cu=new So,lu=new So,uu=new So,hu=new So,du=[0],fu=new So,pu=new So;class mu{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const r=t;t=e,e=r}return e<<16|t}set(e,t){const r=this.getKey(e,t),n=this.current;let i=0;for(;r>n[i];)i++;if(r!==n[i]){for(let e=n.length-1;e>=i;e--)n[e+1]=n[e];n[i]=r}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const r=this.current,n=this.previous,i=r.length,s=n.length;let o=0;for(let t=0;t<i;t++){let i=!1;const s=r[t];for(;s>n[o];)o++;i=s===n[o],i||vu(e,s)}o=0;for(let e=0;e<s;e++){let i=!1;const s=n[e];for(;s>r[o];)o++;i=r[o]===s,i||vu(t,s)}}}function vu(e,t){e.push((4294901760&t)>>16,65535&t)}const gu=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class yu{constructor(){this.data={keys:[]}}get(e,t){const r=gu(e,t);return this.data[r]}set(e,t,r){const n=gu(e,t);this.get(e,t)||this.data.keys.push(n),this.data[n]=r}delete(e,t){const r=gu(e,t),n=this.data.keys.indexOf(r);-1!==n&&this.data.keys.splice(n,1),delete this.data[r]}reset(){const e=this.data,t=e.keys;for(;t.length>0;)delete e[t.pop()]}}class xu extends zo{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new So,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new So,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new da,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new wc,this.constraints=[],this.narrowphase=new Qc(this),this.collisionMatrix=new Io,this.collisionMatrixPrevious=new Io,this.bodyOverlapKeeper=new mu,this.shapeOverlapKeeper=new mu,this.contactmaterials=[],this.contactMaterialTable=new yu,this.defaultMaterial=new xc("default"),this.defaultContactMaterial=new yc(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,r){r instanceof fa?this.raycastClosest(e,t,{skipBackfaces:!0},r):this.raycastAll(e,t,{skipBackfaces:!0},r)}raycastAll(e,t,r,n){return void 0===r&&(r={}),r.mode=wa.ALL,r.from=e,r.to=t,r.callback=n,bu.intersectWorld(this,r)}raycastAny(e,t,r,n){return void 0===r&&(r={}),r.mode=wa.ANY,r.from=e,r.to=t,r.result=n,bu.intersectWorld(this,r)}raycastClosest(e,t,r,n){return void 0===r&&(r={}),r.mode=wa.CLOSEST,r.from=e,r.to=t,r.result=n,bu.intersectWorld(this,r)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Ho&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,r=this.bodies,n=r.indexOf(e);if(-1!==n){r.splice(n,1);for(let e=0;e!==r.length;e++)r[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let r=0;r<t.length;r++){const n=t[r].shapes;for(let t=0;t<n.length;t++){const r=n[t];if(r.id===e)return r}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const r=wu.now()/1e3;if(this.lastCallTime){const n=r-this.lastCallTime;this.step(e,n,t)}else this.step(e,void 0,t);this.lastCallTime=r}step(e,t,r){if(void 0===r&&(r=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const n=wu.now();let i=0;for(;this.accumulator>=e&&i<r&&(this.internalStep(e),this.accumulator-=e,i++,!(wu.now()-n>1e3*e)););this.accumulator=this.accumulator%e;const s=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,s,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,s,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,r=Eu,n=Mu,i=this.bodies.length,s=this.bodies,o=this.solver,a=this.gravity,c=this.doProfiling,l=this.profile,u=Ho.DYNAMIC;let h=-1/0;const d=this.constraints,f=ku;a.length();const p=a.x,m=a.y,v=a.z;let g=0;for(c&&(h=wu.now()),g=0;g!==i;g++){const e=s[g];if(e.type===u){const t=e.force,r=e.mass;t.x+=r*p,t.y+=r*m,t.z+=r*v}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();c&&(h=wu.now()),r.length=0,n.length=0,this.broadphase.collisionPairs(this,r,n),c&&(l.broadphase=wu.now()-h);let y=d.length;for(g=0;g!==y;g++){const e=d[g];if(!e.collideConnected)for(let t=r.length-1;t>=0;t-=1)(e.bodyA===r[t]&&e.bodyB===n[t]||e.bodyB===r[t]&&e.bodyA===n[t])&&(r.splice(t,1),n.splice(t,1))}this.collisionMatrixTick(),c&&(h=wu.now());const x=Pu,b=t.length;for(g=0;g!==b;g++)x.push(t[g]);t.length=0;const w=this.frictionEquations.length;for(g=0;g!==w;g++)f.push(this.frictionEquations[g]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(r,n,this,t,x,this.frictionEquations,f),c&&(l.narrowphase=wu.now()-h),c&&(h=wu.now()),g=0;g<this.frictionEquations.length;g++)o.addEquation(this.frictionEquations[g]);const _=t.length;for(let e=0;e!==_;e++){const r=t[e],n=r.bi,i=r.bj,s=r.si,a=r.sj;let c;c=n.material&&i.material&&this.getContactMaterial(n.material,i.material)||this.defaultContactMaterial,c.friction,n.material&&i.material&&(n.material.friction>=0&&i.material.friction>=0&&(n.material.friction,i.material.friction),n.material.restitution>=0&&i.material.restitution>=0&&(r.restitution=n.material.restitution*i.material.restitution)),o.addEquation(r),n.allowSleep&&n.type===Ho.DYNAMIC&&n.sleepState===Ho.SLEEPING&&i.sleepState===Ho.AWAKE&&i.type!==Ho.STATIC&&i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(n.wakeUpAfterNarrowphase=!0),i.allowSleep&&i.type===Ho.DYNAMIC&&i.sleepState===Ho.SLEEPING&&n.sleepState===Ho.AWAKE&&n.type!==Ho.STATIC&&n.velocity.lengthSquared()+n.angularVelocity.lengthSquared()>=2*n.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(n,i,!0),this.collisionMatrixPrevious.get(n,i)||(Su.body=i,Su.contact=r,n.dispatchEvent(Su),Su.body=n,i.dispatchEvent(Su)),this.bodyOverlapKeeper.set(n.id,i.id),this.shapeOverlapKeeper.set(s.id,a.id)}for(this.emitContactEvents(),c&&(l.makeContactConstraints=wu.now()-h,h=wu.now()),g=0;g!==i;g++){const e=s[g];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(y=d.length,g=0;g!==y;g++){const e=d[g];e.update();for(let t=0,r=e.equations.length;t!==r;t++){const r=e.equations[t];o.addEquation(r)}}o.solve(e,this),c&&(l.solve=wu.now()-h),o.removeAllEquations();const T=Math.pow;for(g=0;g!==i;g++){const t=s[g];if(t.type&u){const r=T(1-t.linearDamping,e),n=t.velocity;n.scale(r,n);const i=t.angularVelocity;if(i){const r=T(1-t.angularDamping,e);i.scale(r,i)}}}this.dispatchEvent(Tu),c&&(h=wu.now());const S=this.stepnumber%(this.quatNormalizeSkip+1)==0,P=this.quatNormalizeFast;for(g=0;g!==i;g++)s[g].integrate(e,S,P);this.clearForces(),this.broadphase.dirty=!0,c&&(l.integrate=wu.now()-h),this.stepnumber+=1,this.dispatchEvent(_u);let k=!0;if(this.allowSleep)for(k=!1,g=0;g!==i;g++){const e=s[g];e.sleepTick(this.time),e.sleepState!==Ho.SLEEPING&&(k=!0)}this.hasActiveBodies=k}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(Au,Cu),e){for(let e=0,t=Au.length;e<t;e+=2)Iu.bodyA=this.getBodyById(Au[e]),Iu.bodyB=this.getBodyById(Au[e+1]),this.dispatchEvent(Iu);Iu.bodyA=Iu.bodyB=null}if(t){for(let e=0,t=Cu.length;e<t;e+=2)zu.bodyA=this.getBodyById(Cu[e]),zu.bodyB=this.getBodyById(Cu[e+1]),this.dispatchEvent(zu);zu.bodyA=zu.bodyB=null}Au.length=Cu.length=0;const r=this.hasAnyEventListener("beginShapeContact"),n=this.hasAnyEventListener("endShapeContact");if((r||n)&&this.shapeOverlapKeeper.getDiff(Au,Cu),r){for(let e=0,t=Au.length;e<t;e+=2){const t=this.getShapeById(Au[e]),r=this.getShapeById(Au[e+1]);Ou.shapeA=t,Ou.shapeB=r,t&&(Ou.bodyA=t.body),r&&(Ou.bodyB=r.body),this.dispatchEvent(Ou)}Ou.bodyA=Ou.bodyB=Ou.shapeA=Ou.shapeB=null}if(n){for(let e=0,t=Cu.length;e<t;e+=2){const t=this.getShapeById(Cu[e]),r=this.getShapeById(Cu[e+1]);Ru.shapeA=t,Ru.shapeB=r,t&&(Ru.bodyA=t.body),r&&(Ru.bodyB=r.body),this.dispatchEvent(Ru)}Ru.bodyA=Ru.bodyB=Ru.shapeA=Ru.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let r=0;r!==t;r++){const t=e[r];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new Mo;const bu=new wa,wu=globalThis.performance||{};if(!wu.now){let e=Date.now();wu.timing&&wu.timing.navigationStart&&(e=wu.timing.navigationStart),wu.now=()=>Date.now()-e}new So;const _u={type:"postStep"},Tu={type:"preStep"},Su={type:Ho.COLLIDE_EVENT_NAME,body:null,contact:null},Pu=[],ku=[],Eu=[],Mu=[],Au=[],Cu=[],Iu={type:"beginContact",bodyA:null,bodyB:null},zu={type:"endContact",bodyA:null,bodyB:null},Ou={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Ru={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Bu=new class{lastTime=0;entities=new Map;systems=new Map;nextEntityID=0;entitiesToDestroy=new Array;addEntity(){let e=this.nextEntityID;return this.nextEntityID++,this.entities.set(e,new r),e}removeEntity(e){this.entitiesToDestroy.push(e)}addComponent(e,t){this.entities.get(e).add(t),this.checkE(e)}addComponents(e,...t){for(let r of t)this.addComponent(e,r)}getComponents(e){return this.entities.get(e)}removeComponent(e,t){this.entities.get(e).delete(t),this.checkE(e)}addSystem(e){if(0==e.componentsRequired.size)return console.warn("System not added: empty Components list."),void console.warn(e);e.ecs=this,this.systems.set(e,new Set);for(let t of this.entities.keys())this.checkES(t,e)}removeSystem(e){this.systems.delete(e)}update(e){let t=e-this.lastTime;for(let[r,n]of this.systems.entries())r.update(n,e,t);for(;this.entitiesToDestroy.length>0;)this.destroyEntity(this.entitiesToDestroy.pop());this.lastTime=e}destroyEntity(e){this.entities.delete(e);for(let t of this.systems.values())t.delete(e)}checkE(e){for(let t of this.systems.keys())this.checkES(e,t)}checkES(e,t){let r=this.entities.get(e),n=t.componentsRequired;r.hasAll(n)?this.systems.get(t).add(e):this.systems.get(t).delete(e)}getEntitiesithComponent(e){let t=new Set;for(let[r,n]of this.entities)n.has(e)&&t.add(r);return t}};Bu.addSystem(new class extends t{componentsRequired=new Set([Mi,Ei]);constructor(){super(),(async()=>{const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});let t;console.log(e);try{t=await e.requestDevice({requiredFeatures:["timestamp-query"],requiredLimits:{maxColorAttachmentBytesPerSample:64}})}catch(r){console.warn("Timestamp query or 64 byte colour attachment not supported, falling back"),t=await e.requestDevice()}return t})().then((async e=>{const t=new yo(e),r=(e=>{const t=e.getEntitiesithComponent(xo).values().next().value;return e.getComponents(t).get(xo)})(this.ecs);r.device=e,r.volumeAtlas=t;const n=await uo(e,t,"Dragon","./Tavern/dragon.vxm");await uo(e,t,"TeaPot","./Tavern/teapot.vxm");for(let e=-1200;e<=1200;e+=150)for(let t=0;t<=1200;t+=150){const r=this.ecs.addEntity();Math.random(),this.ecs.addComponent(r,new Mi(n)),this.ecs.addComponent(r,new Ei([e+50*Math.random(),0,t+50*Math.random()],Ge.identity(),[1,1,1]))}Qs(e,t,this.ecs,[])}))}update(e,t){const r=this.ecs.getEntitiesithComponent(no).values().next().value,n=this.ecs.getComponents(r),i=n.get(no),s=n.get(Ei);ro(t,this.ecs,i,s,Array.from(e))}}),Bu.addSystem(new class extends t{keyboardControls=new bo;componentsRequired=new Set([Ei,wo]);update(e,t,r){for(const t of e){const e=this.ecs.getComponents(t),n=e.get(Ei),i=e.get(wo),s=i.speed*r,o=i.rotationSpeed*r;this.keyboardControls.pressed.a&&(n.position=te.add(n.position,te.mulScalar(n.left,s))),this.keyboardControls.pressed.d&&(n.position=te.add(n.position,te.mulScalar(n.right,s))),this.keyboardControls.pressed.w&&(n.position=te.add(n.position,te.mulScalar(n.direction,s))),this.keyboardControls.pressed.s&&(n.position=te.sub(n.position,te.mulScalar(n.direction,s))),this.keyboardControls.pressed.q&&(n.rotation=Ge.rotateY(n.rotation,-o)),this.keyboardControls.pressed.e&&(n.rotation=Ge.rotateY(n.rotation,o)),this.keyboardControls.pressed[" "]&&(n.position=te.add(n.position,te.mulScalar(n.up,s))),this.keyboardControls.pressed.shift&&(n.position=te.add(n.position,te.mulScalar(n.down,s)))}}});const Uu=Bu.addEntity();Bu.addComponent(Uu,new xo),Bu.addComponent(Uu,new class extends e{world=new xu({gravity:new So(0,-150,0)});constructor(){super()}});const Nu=Bu.addEntity();Bu.addComponents(Nu,new no({fieldOfView:Math.PI/180*70,near:.5,far:1e4}),new Ei(te.create(0,50,-120),Ge.fromEuler(0,0,0,"xyz"),te.create(1,1,1)),new wo);const Du=Bu.addEntity();Bu.addComponents(Du,new Ei(te.create(0,0,0),Ge.identity(),te.create(1,1,1)),new wo);const Lu=e=>{Bu.update(e),requestAnimationFrame(Lu)};requestAnimationFrame(Lu)})();