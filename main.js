(()=>{var e={395:e=>{e.exports={scale:[8,8,8],normalisedPivot:[2,0,2],bounds:{min:"1,0,1",max:"2,0,2"},voxels:["1,0,1 100,106,116","1,0,2 100,106,116","2,0,1 100,106,116","2,0,2 100,106,116"]}}},t={};function n(r){var i=t[r];if(void 0!==i)return i.exports;var o=t[r]={exports:{}};return e[r](o,o.exports,n),o.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var r={};(()=>{"use strict";n.d(r,{nS:()=>g,JQ:()=>p,sL:()=>y,Uh:()=>f,ZU:()=>x});const e=(e,t)=>{const n=new Uint32Array(t);f.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)},t=(t,n)=>{const r=new Uint32Array(t),i=f.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:n});return e(i,t),i},i=(e,t)=>{const n=new Float32Array(e),r=f.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return((e,t)=>{const n=new Float32Array(t);f.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)})(r,e),r};class o{x;y;constructor(e,t){this.x=e,this.y=t}get uniformBuffer(){return t([this.x,this.y])}static zero=new o(0,0);static one=new o(1,1);static up=new o(0,1);static down=new o(0,-1);static left=new o(-1,0);static right=new o(1,1);toArray(){return[this.x,this.y]}mul(e){if(e instanceof o)return new o(this.x*e.x,this.y*e.y);if("number"==typeof e)return new o(this.x*e,this.y*e);throw new Error("Can only multiply Vector2 by Vector2 or Number")}add(e){return new o(this.x+e.x,this.y+e.y)}subtract(e){return new o(this.x-e.x,this.y-e.y)}normalize(){const e=Math.sqrt(this.x**2+this.y**2);return new o(this.x/e,this.y/e)}negate(){return new o(-this.x,-this.y)}}class s{x;y;z;constructor(e,t,n){this.x=e,this.y=t,this.z=n}get uniformBuffer(){return t([this.x,this.y,this.z])}static zero=new s(0,0,0);static one=new s(1,1,1);static up=new s(0,1,0);static down=new s(0,-1,0);static left=new s(-1,0,0);static right=new s(1,0,0);toArray(){return[this.x,this.y,this.z]}mul(e){if(e instanceof s)return new s(this.x*e.x,this.y*e.y,this.z*e.z);if("number"==typeof e)return new s(this.x*e,this.y*e,this.z*e);throw new Error("Can only multiply Vector3 by Vector3 or Number")}add(e){return new s(this.x+e.x,this.y+e.y,this.z+e.z)}subtract(e){return new s(this.x-e.x,this.y-e.y,this.z-e.z)}cross(e){return new s(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}normalize(){const e=Math.sqrt(this.x**2+this.y**2+this.z**2);return new s(0!==this.x?this.x/e:0,0!==this.y?this.y/e:0,0!==this.z?this.z/e:0)}negate(){return new s(-this.x,-this.y,-this.z)}rotateAroundAxis(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x*(n+(1-n)*e.x*e.x)+this.y*((1-n)*e.x*e.y-r*e.z)+this.z*((1-n)*e.x*e.z+r*e.y),o=this.x*((1-n)*e.y*e.x+r*e.z)+this.y*(n+(1-n)*e.y*e.y)+this.z*((1-n)*e.y*e.z-r*e.x),a=this.x*((1-n)*e.z*e.x-r*e.y)+this.y*((1-n)*e.z*e.y+r*e.x)+this.z*(n+(1-n)*e.z*e.z);return new s(i,o,a)}}class a{position;targetPosition;velocity;constructor(e){this.position=e.position,this.targetPosition=this.position,this.velocity=s.zero}update(){g.velocity=g.velocity.mul(1-.015*y),this.position=this.position.add(this.velocity.mul(y))}}const c=new class{pressed={w:!1,a:!1,s:!1,d:!1," ":!1,Control:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1}))}},u=new class{velocity=o.zero;animationFrame;constructor(){window.addEventListener("mousemove",(e=>{cancelAnimationFrame(this.animationFrame),this.velocity=new o(e.movementX,e.movementY),this.animationFrame=requestAnimationFrame((()=>{this.velocity=o.zero}))}))}};var l=n(395),d=n.n(l);let f,m,p,x=new o(0,0);const v=performance.now();let h=v,y=0,g=new class extends a{fieldOfView;direction;constructor(e){super({position:e.position}),this.fieldOfView=e.fieldOfView,this.direction=new s(0,0,1)}reset(e){this.position=new s(0,0,-5),this.targetPosition=this.position,this.fieldOfView=e.fieldOfView,this.direction=new s(0,0,1)}get right(){return s.up.cross(this.direction).normalize()}get left(){return this.direction.cross(s.up).normalize()}get up(){return this.direction.cross(this.right).normalize()}get down(){return this.up.negate()}rotateX(e){this.direction=this.direction.rotateAroundAxis(this.right,e)}rotateY(e){this.direction=this.direction.rotateAroundAxis(s.up,e)}}({fieldOfView:90,position:new s(0,0,-32)});new class{constructor(){document.getElementById("reset").addEventListener("click",(e=>{g.reset({fieldOfView:90}),document.getElementById("captures").innerHTML=""})),document.getElementById("capture").addEventListener("click",(e=>{const t=new Image;t.id=performance.now().toString(),t.src=p.toDataURL(),document.getElementById("captures").appendChild(t).addEventListener("click",(e=>{e.target,console.log(e.target)}))}))}},console.log({testModel:d()});void 0!==navigator.gpu?navigator.gpu.requestAdapter().then((n=>{n.requestDevice().then((n=>{f=n;const r=(()=>{let e;return{start:()=>{e=f.createComputePipeline({layout:"auto",compute:{module:f.createShaderModule({code:"\n          // Function to mimic the ease_out_expo function\nfn ease_out_expo(x: f32) -> f32 {\n    let t: f32 = x;\n    let b: f32 = 0.0;\n    let c: f32 = 1.0;\n    let d: f32 = 1.0; // Set the duration within the function\n\n    let intermediate_result: f32 = c * (-pow(2.0, -10.0 * t / d) + 1.0) + b;\n\n    return select(intermediate_result, b + c, t == d);\n\n}\n\nfn sample_sky(rayDirection: vec3<f32>) -> vec3<f32> {\n    //TODO: add this to uniforms\n    let lightDirection = normalize(vec3(1.0,1.0,0.));\n    let y = clamp(ease_out_expo(rayDirection.y * 0.66), 0.0, 1.0);\n//    let y = rayDirection.y;\n    let sunHeight = clamp(lightDirection.y, 0.0, 1.0);\n    let horizon = mix(vec3<f32>(0.95, 0.5, 0.4), vec3<f32>(0.6, 0.8, 1.0), sunHeight);\n    let sky = mix(vec3<f32>(0.55, 0.7, 0.7), vec3<f32>(0.3, 0.6, 0.95), sunHeight);\n    let sunFalloff = 0.8;\n    let sunAmount = 1.0 - ease_out_expo(length(lightDirection - rayDirection) * sunFalloff);\n//    let sunAmount = 1.0 - length(lightDirection - rayDirection) * sunFalloff;\n    let skyColour = mix(horizon, sky, y);\n    let sunColour = mix(vec3<f32>(1.8, 1.6, 1.1), vec3<f32>(1.6, 1.6, 1.4), sunHeight);\n\n    let intensity = clamp(sunHeight, 0.75, 1.0);\n    return mix(skyColour, sunColour, clamp(sunAmount, 0.0, 1.0)) * intensity;\n}struct FrustumCornerDirections {\n  topLeft : vec3<f32>,\n  topRight : vec3<f32>,\n  bottomLeft : vec3<f32>,\n  bottomRight : vec3<f32>\n}\n\nfn calculateRayDirection(uv: vec2<f32>, directions: FrustumCornerDirections) -> vec3<f32> {\n  let topInterpolated = mix(directions.topLeft, directions.topRight, uv.x);\n  let bottomInterpolated = mix(directions.bottomLeft, directions.bottomRight, uv.x);\n  let finalInterpolated = mix(bottomInterpolated, topInterpolated, uv.y);\n  return normalize(finalInterpolated);\n}\n\nfn boxIntersection(\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n    boxSize: vec3<f32>,\n) -> vec4<f32> {\n    let m: vec3<f32> = 1.0 / rd;\n    let n: vec3<f32> = m * ro;\n    let k: vec3<f32> = abs(m) * boxSize;\n\n    let t1: vec3<f32> = -n - k;\n    let t2: vec3<f32> = -n + k;\n\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) {\n        return vec4<f32>(-1.0);\n    }\n\n    var normal = select(\n        step(vec3<f32>(tN), t1),\n        step(t2, vec3<f32>(tF)),\n        tN < 0.0,\n    );\n\n    normal *= -sign(rd);\n\n    return vec4<f32>(tN, normal);\n}\n\n@group(0) @binding(0) var outputTex : texture_storage_2d<rgba8unorm, write>;\n@group(0) @binding(1) var<uniform> time : u32;\n@group(0) @binding(2) var<uniform> resolution : vec2<u32>;\n@group(0) @binding(3) var<uniform> frustumCornerDirections : FrustumCornerDirections;\n@group(0) @binding(4) var<uniform> cameraPosition : vec3<f32>;\n\nconst EPSILON = 0.0001;\nconst BORDER_WIDTH = 0.025;\nconst BOUNDS_SIZE = 16.0;\n\n@compute @workgroup_size(1, 1, 1)\nfn main(\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>\n) {\nlet timeOffset = (sin(f32(time) * 0.001) * 0.5 + 0.5) * 2.0;\n  let pixel = vec2<f32>(f32(WorkGroupID.x), f32(resolution.y - WorkGroupID.y));\n  let uv = pixel / vec2<f32>(resolution);\n  let rayOrigin = cameraPosition;\n  var rayDirection = calculateRayDirection(uv,frustumCornerDirections);\n  var boxSize = vec3<f32>(BOUNDS_SIZE);\n  let intersect = boxIntersection(rayOrigin, rayDirection, boxSize);\n  var colour = sample_sky(rayDirection);\n  let tNear = intersect.x;\n  let startingPos = rayOrigin + (intersect.x + EPSILON)  * rayDirection;\n  if(tNear > 0.0){\n      var pos = startingPos;\n      var normal = vec3(0.0);\n      var maxSteps = 64;\n      var stepsTaken = 0;\n      var voxelSize = 1.0;\n      var voxelStep = sign(rayDirection);\n      var tIntersection = 0.0;\n      var tDelta = vec3(voxelSize / abs(rayDirection));\n      var scaledStartingPoint = pos / voxelSize;\n      var scaledRayOrigin = vec3<f32>(rayOrigin) / voxelSize;\n      var currentIndex = floor(scaledStartingPoint);\n      var voxelOriginDifference = vec3<f32>(currentIndex) - scaledRayOrigin;\n      var clampedVoxelBoundary = (voxelStep * 0.5) + 0.5; // 0 if <= 0, 1 if > 0\n      var tMax = (voxelStep * voxelOriginDifference + clampedVoxelBoundary) * tDelta + EPSILON;\n      var occlusion = false;\n      \n      while(stepsTaken <= maxSteps)\n      {\n        tIntersection = min(min(tMax.x, tMax.y), tMax.z);\n        let mask = vec3(\n            select(0.0, 1.0, tMax.x == tIntersection),\n            select(0.0, 1.0, tMax.y == tIntersection), \n            select(0.0, 1.0, tMax.z == tIntersection)\n        );\n        tMax += mask * tDelta;\n        currentIndex += mask * voxelStep;\n        normal = vec3(mask * -voxelStep);\n        pos = rayOrigin + rayDirection * tIntersection;\n        stepsTaken ++;\n        if(sin(currentIndex.x * 0.25) - sin(currentIndex.z * 0.25) > currentIndex.y * 0.4){\n            occlusion = true;\n            break;\n        }\n      }\n        \n      // Voxel borders\n      let positionInVoxel = fract(pos);\n      let positionInBounds = fract(startingPos / BOUNDS_SIZE);\n      let voxelBorder = step(positionInVoxel, vec3(1 - BORDER_WIDTH)) - step(positionInVoxel, vec3(BORDER_WIDTH));\n      let boundsBorder = step(positionInBounds, vec3(1 - BORDER_WIDTH)) - step(positionInBounds, vec3(BORDER_WIDTH));\n      let isVoxelBorder = step(length(voxelBorder), 1.0);\n      let isBoundsBorder = step(length(boundsBorder), 1.0);\n        var baseColour = clamp(vec3(currentIndex / 4.0), vec3(0.0), vec3(1.0)) + vec3(0.5);\n      if(occlusion){    \n        colour = mix(baseColour,baseColour * 0.5,isVoxelBorder);\n      }\n      colour = mix(colour,vec3(0.0,1.0,0.0),isBoundsBorder);\n     \n  }\n\n  textureStore(outputTex, WorkGroupID.xy, vec4(colour,1));\n}\n"}),entryPoint:"main"}})},render:({commandEncoder:t,timeBuffer:n,resolutionBuffer:r,outputTextureView:o})=>{const a=(e=>{const t=x.x/x.y,n=e.fieldOfView/2,r=Math.tan(n),i=s.up.cross(e.direction).normalize(),o=e.direction.cross(i).normalize().mul(r);return[e.direction.add(o).add(i.mul(-t*r)),e.direction.add(o).add(i.mul(t*r)),e.direction.subtract(o).add(i.mul(-t*r)),e.direction.subtract(o).add(i.mul(t*r))]})(g).flatMap((e=>[...e.toArray(),0])),c=i(a,"frustum corner directions"),u=i(g.position.toArray(),"camera position"),l=t.beginComputePass();l.setPipeline(e);const d=f.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:o},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:r}},{binding:3,resource:{buffer:c}},{binding:4,resource:{buffer:u}}]});l.setBindGroup(0,d),l.dispatchWorkgroups(x.x,x.y),l.end()}}})();((n,r)=>{let i,a,l,d,f,w;p=document.getElementById("webgpu-canvas"),p.addEventListener("click",(async()=>{p.requestPointerLock()})),document.addEventListener("pointerlockchange",(()=>{w=null!==document.pointerLockElement})),m=p.getContext("webgpu");const b=navigator.gpu.getPreferredCanvasFormat();m.configure({device:n,format:b,usage:GPUTextureUsage.RENDER_ATTACHMENT});const z=n.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n}\n\n@vertex\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}\n\n@fragment\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\n//    return vec4(sin(f32(time) * 0.001), 0, 0, 1);\n    return textureSample(myTexture, mySampler, fragUV);\n}\n"}),I=n.createRenderPipeline({layout:"auto",vertex:{module:z,entryPoint:"vertex_main"},fragment:{module:z,entryPoint:"fragment_main",targets:[{format:b}]}}),D=async()=>{const o=performance.now()-v;y=o-h,h=o,w&&(()=>{if(g.rotateY(u.velocity.x*y*.001),g.rotateX(u.velocity.y*y*.001),!document.hasFocus())return;let e=s.zero;c.pressed.a&&(e=e.add(g.left)),c.pressed.d&&(e=e.add(g.right)),c.pressed.w&&(e=e.add(g.direction)),c.pressed.s&&(e=e.subtract(g.direction)),c.pressed[" "]&&(e=e.add(g.up)),c.pressed.Control&&(e=e.add(g.down)),e=e.normalize(),g.velocity=g.velocity.add(e.mul(.001))})(),g.update();const p=n.createCommandEncoder();d?e(d,[h]):d=t([h]),f?e(f,[x.x,x.y]):f=t([x.x,x.y]);const b=(a&&a.destroy(),a=n.createTexture({size:[x.x,x.y,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING}),a.createView());r.forEach((e=>{e.render({commandEncoder:p,timeBuffer:d,resolutionBuffer:f,outputTextureView:b})})),(({commandEncoder:e,outputTextureView:t})=>{const r=e.beginRenderPass({colorAttachments:[{view:m.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]});i=n.createBindGroup({layout:I.getBindGroupLayout(0),entries:[{binding:0,resource:n.createSampler({magFilter:"linear",minFilter:"linear"})},{binding:1,resource:t}]}),r.setPipeline(I),r.setBindGroup(0,i),r.draw(6),r.end()})({commandEncoder:p,outputTextureView:b}),n.queue.submit([p.finish()]),l=requestAnimationFrame(D)};new ResizeObserver((()=>{cancelAnimationFrame(l),(()=>{const{clientWidth:e,clientHeight:t}=p.parentElement;x=new o(e,t),p.width=x.x,p.height=x.y,r.forEach((e=>{e.start()})),l=requestAnimationFrame(D)})()})).observe(p.parentElement)})(f,[r])}))})):console.error("WebGPU not supported")})()})();