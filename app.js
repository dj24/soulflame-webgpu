/*! For license information please see app.js.LICENSE.txt */
(()=>{var e={391:(e,t,n)=>{var r=n(180),i=n(181),s=n(31),o=n(67),a=n(833),l=n(717),c=n(801);c.alea=r,c.xor128=i,c.xorwow=s,c.xorshift7=o,c.xor4096=a,c.tychei=l,e.exports=c},180:function(e,t,n){var r;!function(e,i,s){function o(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new o(e),r=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},717:function(e,t,n){var r;!function(e,i,s){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new o(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},181:function(e,t,n){var r;!function(e,i,s){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new o(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},833:function(e,t,n){var r;!function(e,i,s){function o(e){var t=this;t.next=function(){var e,n,r=t.w,i=t.X,s=t.i;return t.w=r=r+1640531527|0,n=i[s+34&127],e=i[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=i[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,i,s,o,a=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),i=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,i=0==(n=a[127&s]^=r+o)?i+1:0);for(i>=128&&(a[127&(t&&t.length||0)]=-1),i=127,s=512;s>0;--s)r=a[i+34&127],n=a[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,a[i]=r^n;e.w=o,e.X=a,e.i=i}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new o(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.X&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},67:function(e,t,n){var r;!function(e,i,s){function o(e){var t=this;t.next=function(){var e,n,r=t.x,i=t.i;return e=r[i],n=(e^=e>>>7)^e<<24,n^=(e=r[i+1&7])^e>>>10,n^=(e=r[i+3&7])^e>>>3,n^=(e=r[i+4&7])^e<<7,e=r[i+7&7],n^=(e^=e<<13)^e<<9,r[i]=n,t.i=i+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new o(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.x&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},31:function(e,t,n){var r;!function(e,i,s){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new o(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&a(r,n),i.state=function(){return a(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var r;!function(i,s,o){var a,l=256,c=o.pow(l,6),u=o.pow(2,52),h=2*u,d=l-1;function p(e,t,n){var r=[],d=v(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(s)]:null==e?function(){try{var e;return a&&(e=a.randomBytes)?e=e(l):(e=new Uint8Array(l),(i.crypto||i.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=i.navigator,n=t&&t.plugins;return[+new Date,i,n,i.screen,y(s)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,v(y(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(o.random=e,t):e})(x,d,"global"in t?t.global:this==o,t.state)}function f(e){var t,n=e.length,r=this,i=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);i<l;)o[i]=i++;for(i=0;i<l;i++)o[i]=o[s=d&s+e[i%n]+(t=o[i])],o[s]=t;(r.g=function(e){for(var t,n=0,i=r.i,s=r.j,o=r.S;e--;)t=o[i=d&i+1],n=n*l+o[d&(o[i]=o[s=d&s+t])+(o[s]=t)];return r.i=i,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],i=typeof e;if(t&&"object"==i)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==i?e:e+"\0"}function v(e,t){for(var n,r=e+"",i=0;i<r.length;)t[d&i]=d&(n^=19*t[d&i])+r.charCodeAt(i++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(o.random(),s),e.exports){e.exports=p;try{a=n(234)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},192:(e,t,n)=>{"use strict";n.d(t,{yq:()=>m});var r=n(491),i=n(590),s=n(391),o=n.n(s),a=n(627);const l=o()("crystals3"),c=(0,a.Cf)(l),u=(e,t,n,r=1,i=3,s=.5)=>{let o=0,a=0,l=1;for(let u=0;u<i;u++){const i=1<<u;a+=c(e*i*r,t*i*r,n*i*r)*l,o+=l,l*=s}return a/o};function h(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}const d=(e,t)=>t[0]+t[1]*e[0]+t[2]*(e[0]*e[1]);class p{cache;size;getVoxel;constructor(e,t){this.size=t,this.getVoxel=e,this.cache=new Uint8Array(t[0]*t[1]*t[2]*4);let n=!0;for(let r=0;r<t[0];r++)for(let i=0;i<t[1];i++)for(let s=0;s<t[2];s++){const o=d(t,[r,i,s]),a=e(r,i,s);null!==a?(this.cache[4*o]=a.red,this.cache[4*o+1]=a.green,this.cache[4*o+2]=a.blue):n=!1}if(n)for(let e=0;e<t[0];e++)for(let n=0;n<t[1];n++)for(let r=0;r<t[2];r++){const i=d(t,[e,n,r]);this.cache[4*i+4]=1}}get buffer(){return this.cache.buffer}get([e,t,n]){const r=d(this.size,[e,t,n]),i=this.cache[4*r],s=this.cache[4*r+1],o=this.cache[4*r+2],a=1===this.cache[4*r+3];return 0===i&&0===s&&0===o?null:{red:i,green:s,blue:o,solid:a}}}var f=n(300);const m=256;let g,v;const y={createOctreeAndReturnBytes:async(e,t,n)=>{const i=new p(((t,n,r)=>((e,t,n,r)=>{const i=(0+t)/m;if(h((u(e,t,n,.008,3)+1)/2)<i)return null;if(h((u(e,t,n,.001,5)+1)/2)>i){const e=f.eR.lerp([0,255-128*l(),0],[72-16*l(),48,42],Math.max(0,0));return{red:e[0],green:e[1],blue:e[2],solid:!0}}return null})(t+e[0],n+e[1],r+e[2])),t),s=Math.log2(Math.max(...t));v=[i];for(let e=s-1;e>=0;e--){const n=Math.ceil(t[0]/Math.pow(2,s-e)),r=new p(((e,t,n)=>{const r=2*Math.floor(e/2),i=2*Math.floor(t/2),s=2*Math.floor(n/2);let o=0,a=0,l=0,c=0,u=0;for(let e=0;e<2;e++)for(let t=0;t<2;t++)for(let n=0;n<2;n++){const h=v[0].get([r+e,i+t,s+n]);h&&(o+=h.red,a+=h.green,l+=h.blue,c++,h.solid&&u++)}return 0===c?null:{red:o/c,green:a/c,blue:l/c,solid:8===u}}),[n,n,n]);v.unshift(r)}return g=new r.xV(((e,t,n,r)=>v[r].get([e,t,n])),(()=>1),Math.max(...t),n),g.totalSizeBytes+r.ps}};(0,i.p)(y)},491:(e,t,n)=>{"use strict";n.d(t,{ps:()=>r,xV:()=>s});const r=8,i=e=>[1&e?1:0,2&e?1:0,4&e?1:0];class s{nodes;#e;#t;#n;#r;#i;depth;constructor(e,t,n,r){this.nodes=[],this.#e=0,this.#r=new DataView(r),this.#t=e,this.#n=t,this.depth=Math.log2(n),this.#i=n,this.#s(0,[0,0,0],0)}#o(e=8){return this.#e+=e,this.#e-(e-1)}#s(e,t,n){const r=(s=2**(this.depth-n),Math.pow(2,Math.ceil(Math.log2(s))));var s;const l=[t[0]*r,t[1]*r,t[2]*r],c=this.#t(t[0],t[1],t[2],n);if(r<=this.#n(l[0],l[1],l[2])){const{red:n,green:i,blue:s}=c,a={red:n,green:i,blue:s,x:t[0]*r,y:t[1]*r,z:t[2]*r,size:r};return void o(this.#r,e,a)}const u=Array.from({length:8},(()=>0)),h=r/2;for(let e=0;e<8;e++){const n=i(e),s=t[0]*r+n[0]*h,o=t[1]*r+n[1]*h,a=t[2]*r+n[2]*h;for(let t=s;t<s+h;t++)for(let n=o;n<o+h;n++)for(let r=a;r<a+h;r++)this.#t(t,n,r,this.depth)&&u[e]++}let d=0,p=Array.from({length:8},(()=>!1));for(let e=0;e<8;e++){const r=i(e),s=t.map((e=>2*e)),o=s[0]+r[0],a=s[1]+r[1],l=s[2]+r[2];p[e]=null!==this.#t(o,a,l,n+1)}let f=Array.from({length:8},(()=>!1));const m=u.reduce(((e,t,n)=>t>0?(d=n+1,f[n]=!0,e|1<<n):e),0);if(r>64&&console.log(t[0],t[1],t[2],r,p,f,c),u.reduce(((e,t)=>e+t),0)===r**3){const n=l.map((e=>e+r/2)),{red:i,green:s,blue:a}=this.#t(n[0],n[1],n[2],this.depth),c={red:i,green:s,blue:a,x:t[0]*r,y:t[1]*r,z:t[2]*r,size:r};return void o(this.#r,e,c)}const g=this.#o(d),v=g-e;u.forEach(((e,r)=>{if(e){const e=g+r,s=i(r),o=2*t[0]+s[0],a=2*t[1]+s[1],l=2*t[2]+s[2];this.#s(e,[o,a,l],n+1)}}));const y={firstChildIndex:v,childMask:m,x:t[0]*r,y:t[1]*r,z:t[2]*r,size:r};a(this.#r,e,y)}get totalSizeBytes(){return this.#e*r}}const o=(e,t,n)=>{e.setUint8(t*r,0),e.setUint8(t*r+1,n.x),e.setUint8(t*r+2,n.y),e.setUint8(t*r+3,n.z),e.setUint8(t*r+4,n.red),e.setUint8(t*r+5,n.green),e.setUint8(t*r+6,n.blue),e.setUint8(t*r+7,Math.log2(n.size))},a=(e,t,n)=>{console.assert(n.firstChildIndex<2**24-1,`First child index of ${n.firstChildIndex} is too large to fit in 3 bytes`),console.assert(n.x<256,`X position of ${n.x} is too large to fit in 1 byte`),console.assert(n.y<256,`Y position of ${n.y} is too large to fit in 1 byte`),console.assert(n.z<256,`Z position of ${n.z} is too large to fit in 1 byte`),e.setUint8(t*r,n.childMask),e.setUint8(t*r+1,n.x),e.setUint8(t*r+2,n.y),e.setUint8(t*r+3,n.z),e.setUint32(t*r+4,n.firstChildIndex,!0),e.setUint8(t*r+7,Math.log2(n.size))}},234:()=>{},590:(e,t,n)=>{"use strict";n.d(t,{LV:()=>d,p:()=>u});const r=Symbol("Comlink.proxy"),i=Symbol("Comlink.endpoint"),s=Symbol("Comlink.releaseProxy"),o=Symbol("Comlink.finalizer"),a=Symbol("Comlink.thrown"),l=e=>"object"==typeof e&&null!==e||"function"==typeof e,c=new Map([["proxy",{canHandle:e=>l(e)&&e[r],serialize(e){const{port1:t,port2:n}=new MessageChannel;return u(e,t),[n,[n]]},deserialize:e=>(e.start(),d(e))}],["throw",{canHandle:e=>l(e)&&a in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function u(e,t=globalThis,n=["*"]){t.addEventListener("message",(function i(s){if(!s||!s.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:l,type:c,path:d}=Object.assign({path:[]},s.data),p=(s.data.argumentList||[]).map(b);let f;try{const t=d.slice(0,-1).reduce(((e,t)=>e[t]),e),n=d.reduce(((e,t)=>e[t]),e);switch(c){case"GET":f=n;break;case"SET":t[d.slice(-1)[0]]=b(s.data.value),f=!0;break;case"APPLY":f=n.apply(t,p);break;case"CONSTRUCT":f=function(e){return Object.assign(e,{[r]:!0})}(new n(...p));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;u(e,n),f=function(e,t){return x.set(e,t),e}(t,[t])}break;case"RELEASE":f=void 0;break;default:return}}catch(e){f={value:e,[a]:0}}Promise.resolve(f).catch((e=>({value:e,[a]:0}))).then((n=>{const[r,s]=w(n);t.postMessage(Object.assign(Object.assign({},r),{id:l}),s),"RELEASE"===c&&(t.removeEventListener("message",i),h(t),o in e&&"function"==typeof e[o]&&e[o]())})).catch((e=>{const[n,r]=w({value:new TypeError("Unserializable return value"),[a]:0});t.postMessage(Object.assign(Object.assign({},n),{id:l}),r)}))})),t.start&&t.start()}function h(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function d(e,t){return v(e,[],t)}function p(e){if(e)throw new Error("Proxy has been released and is not useable")}function f(e){return _(e,{type:"RELEASE"}).then((()=>{h(e)}))}const m=new WeakMap,g="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(m.get(e)||0)-1;m.set(e,t),0===t&&f(e)}));function v(e,t=[],n=function(){}){let r=!1;const o=new Proxy(n,{get(n,i){if(p(r),i===s)return()=>{!function(e){g&&g.unregister(e)}(o),f(e),r=!0};if("then"===i){if(0===t.length)return{then:()=>o};const n=_(e,{type:"GET",path:t.map((e=>e.toString()))}).then(b);return n.then.bind(n)}return v(e,[...t,i])},set(n,i,s){p(r);const[o,a]=w(s);return _(e,{type:"SET",path:[...t,i].map((e=>e.toString())),value:o},a).then(b)},apply(n,s,o){p(r);const a=t[t.length-1];if(a===i)return _(e,{type:"ENDPOINT"}).then(b);if("bind"===a)return v(e,t.slice(0,-1));const[l,c]=y(o);return _(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:l},c).then(b)},construct(n,i){p(r);const[s,o]=y(i);return _(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:s},o).then(b)}});return function(e,t){const n=(m.get(t)||0)+1;m.set(t,n),g&&g.register(e,t,e)}(o,e),o}function y(e){const t=e.map(w);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const x=new WeakMap;function w(e){for(const[t,n]of c)if(n.canHandle(e)){const[r,i]=n.serialize(e);return[{type:"HANDLER",name:t,value:r},i]}return[{type:"RAW",value:e},x.get(e)||[]]}function b(e){switch(e.type){case"HANDLER":return c.get(e.name).deserialize(e.value);case"RAW":return e.value}}function _(e,t,n){return new Promise((r=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===i&&(e.removeEventListener("message",t),r(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:i},t),n)}))}},627:(e,t,n)=>{"use strict";n.d(t,{Cf:()=>a});const r=1/3,i=1/6,s=e=>0|Math.floor(e),o=new Float64Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]);function a(e=Math.random){const t=function(e){const t=512,n=new Uint8Array(t);for(let e=0;e<256;e++)n[e]=e;for(let t=0;t<255;t++){const r=t+~~(e()*(256-t)),i=n[t];n[t]=n[r],n[r]=i}for(let e=256;e<t;e++)n[e]=n[e-256];return n}(e),n=new Float64Array(t).map((e=>o[e%12*3])),a=new Float64Array(t).map((e=>o[e%12*3+1])),l=new Float64Array(t).map((e=>o[e%12*3+2]));return function(e,o,c){let u,h,d,p;const f=(e+o+c)*r,m=s(e+f),g=s(o+f),v=s(c+f),y=(m+g+v)*i,x=e-(m-y),w=o-(g-y),b=c-(v-y);let _,S,k,T,E,A;x>=w?w>=b?(_=1,S=0,k=0,T=1,E=1,A=0):x>=b?(_=1,S=0,k=0,T=1,E=0,A=1):(_=0,S=0,k=1,T=1,E=0,A=1):w<b?(_=0,S=0,k=1,T=0,E=1,A=1):x<b?(_=0,S=1,k=0,T=0,E=1,A=1):(_=0,S=1,k=0,T=1,E=1,A=0);const P=x-_+i,M=w-S+i,C=b-k+i,z=x-T+2*i,I=w-E+2*i,B=b-A+2*i,O=x-1+3*i,R=w-1+3*i,N=b-1+3*i,U=255&m,D=255&g,L=255&v;let F=.6-x*x-w*w-b*b;if(F<0)u=0;else{const e=U+t[D+t[L]];F*=F,u=F*F*(n[e]*x+a[e]*w+l[e]*b)}let q=.6-P*P-M*M-C*C;if(q<0)h=0;else{const e=U+_+t[D+S+t[L+k]];q*=q,h=q*q*(n[e]*P+a[e]*M+l[e]*C)}let j=.6-z*z-I*I-B*B;if(j<0)d=0;else{const e=U+T+t[D+E+t[L+A]];j*=j,d=j*j*(n[e]*z+a[e]*I+l[e]*B)}let V=.6-O*O-R*R-N*N;if(V<0)p=0;else{const e=U+1+t[D+1+t[L+1]];V*=V,p=V*V*(n[e]*O+a[e]*R+l[e]*N)}return 32*(u+h+d+p)}}},300:(e,t,n)=>{"use strict";n.d(t,{Yu:()=>je,Zc:()=>C,eR:()=>te,pB:()=>ve});let r=1e-6,i=Float32Array;function s(e=0,t=0){const n=new i(2);return void 0!==e&&(n[0]=e,void 0!==t&&(n[1]=t)),n}let o=Float32Array;function a(e,t,n){const r=new o(3);return void 0!==e&&(r[0]=e,void 0!==t&&(r[1]=t,void 0!==n&&(r[2]=n))),r}const l=s;function c(e,t,n){return(n=n||new i(2))[0]=e[0]-t[0],n[1]=e[1]-t[1],n}const u=c;function h(e,t,n){return(n=n||new i(2))[0]=e[0]*t,n[1]=e[1]*t,n}const d=h;function p(e,t){return(t=t||new i(2))[0]=1/e[0],t[1]=1/e[1],t}const f=p;function m(e,t){return e[0]*t[0]+e[1]*t[1]}function g(e){const t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}const v=g;function y(e){const t=e[0],n=e[1];return t*t+n*n}const x=y;function w(e,t){const n=e[0]-t[0],r=e[1]-t[1];return Math.sqrt(n*n+r*r)}const b=w;function _(e,t){const n=e[0]-t[0],r=e[1]-t[1];return n*n+r*r}const S=_;function k(e,t){return(t=t||new i(2))[0]=e[0],t[1]=e[1],t}const T=k;function E(e,t,n){return(n=n||new i(2))[0]=e[0]*t[0],n[1]=e[1]*t[1],n}const A=E;function P(e,t,n){return(n=n||new i(2))[0]=e[0]/t[0],n[1]=e[1]/t[1],n}const M=P;var C=Object.freeze({__proto__:null,create:s,setDefaultType:function(e){const t=i;return i=e,t},fromValues:l,set:function(e,t,n){return(n=n||new i(2))[0]=e,n[1]=t,n},ceil:function(e,t){return(t=t||new i(2))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},floor:function(e,t){return(t=t||new i(2))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},round:function(e,t){return(t=t||new i(2))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},clamp:function(e,t=0,n=1,r){return(r=r||new i(2))[0]=Math.min(n,Math.max(t,e[0])),r[1]=Math.min(n,Math.max(t,e[1])),r},add:function(e,t,n){return(n=n||new i(2))[0]=e[0]+t[0],n[1]=e[1]+t[1],n},addScaled:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},angle:function(e,t){const n=e[0],r=e[1],i=e[0],s=e[1],o=Math.sqrt(n*n+r*r)*Math.sqrt(i*i+s*s),a=o&&m(e,t)/o;return Math.acos(a)},subtract:c,sub:u,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r},lerpV:function(e,t,n,r){return(r=r||new i(2))[0]=e[0]+n[0]*(t[0]-e[0]),r[1]=e[1]+n[1]*(t[1]-e[1]),r},max:function(e,t,n){return(n=n||new i(2))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n},min:function(e,t,n){return(n=n||new i(2))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n},mulScalar:h,scale:d,divScalar:function(e,t,n){return(n=n||new i(2))[0]=e[0]/t,n[1]=e[1]/t,n},inverse:p,invert:f,cross:function(e,t,n){n=n||new o(3);const r=e[0]*t[1]-e[1]*t[0];return n[0]=0,n[1]=0,n[2]=r,n},dot:m,length:g,len:v,lengthSq:y,lenSq:x,distance:w,dist:b,distanceSq:_,distSq:S,normalize:function(e,t){t=t||new i(2);const n=e[0],r=e[1],s=Math.sqrt(n*n+r*r);return s>1e-5?(t[0]=n/s,t[1]=r/s):(t[0]=0,t[1]=0),t},negate:function(e,t){return(t=t||new i(2))[0]=-e[0],t[1]=-e[1],t},copy:k,clone:T,multiply:E,mul:A,divide:P,div:M,random:function(e=1,t){t=t||new i(2);const n=2*Math.random()*Math.PI;return t[0]=Math.cos(n)*e,t[1]=Math.sin(n)*e,t},zero:function(e){return(e=e||new i(2))[0]=0,e[1]=0,e},transformMat4:function(e,t,n){n=n||new i(2);const r=e[0],s=e[1];return n[0]=r*t[0]+s*t[4]+t[12],n[1]=r*t[1]+s*t[5]+t[13],n},transformMat3:function(e,t,n){n=n||new i(2);const r=e[0],s=e[1];return n[0]=t[0]*r+t[4]*s+t[8],n[1]=t[1]*r+t[5]*s+t[9],n}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);const z=a;function I(e,t,n){return(n=n||new o(3))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}const B=I;function O(e,t,n){return(n=n||new o(3))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n}const R=O;function N(e,t){return(t=t||new o(3))[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}const U=N;function D(e,t,n){n=n||new o(3);const r=e[2]*t[0]-e[0]*t[2],i=e[0]*t[1]-e[1]*t[0];return n[0]=e[1]*t[2]-e[2]*t[1],n[1]=r,n[2]=i,n}function L(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function F(e){const t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)}const q=F;function j(e){const t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r}const V=j;function G(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return Math.sqrt(n*n+r*r+i*i)}const W=G;function $(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return n*n+r*r+i*i}const H=$;function Y(e,t){t=t||new o(3);const n=e[0],r=e[1],i=e[2],s=Math.sqrt(n*n+r*r+i*i);return s>1e-5?(t[0]=n/s,t[1]=r/s,t[2]=i/s):(t[0]=0,t[1]=0,t[2]=0),t}function X(e,t){return(t=t||new o(3))[0]=e[0],t[1]=e[1],t[2]=e[2],t}const Z=X;function K(e,t,n){return(n=n||new o(3))[0]=e[0]*t[0],n[1]=e[1]*t[1],n[2]=e[2]*t[2],n}const Q=K;function J(e,t,n){return(n=n||new o(3))[0]=e[0]/t[0],n[1]=e[1]/t[1],n[2]=e[2]/t[2],n}const ee=J;var te=Object.freeze({__proto__:null,create:a,setDefaultType:function(e){const t=o;return o=e,t},fromValues:z,set:function(e,t,n,r){return(r=r||new o(3))[0]=e,r[1]=t,r[2]=n,r},ceil:function(e,t){return(t=t||new o(3))[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},floor:function(e,t){return(t=t||new o(3))[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},round:function(e,t){return(t=t||new o(3))[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},clamp:function(e,t=0,n=1,r){return(r=r||new o(3))[0]=Math.min(n,Math.max(t,e[0])),r[1]=Math.min(n,Math.max(t,e[1])),r[2]=Math.min(n,Math.max(t,e[2])),r},add:function(e,t,n){return(n=n||new o(3))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n},addScaled:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r},angle:function(e,t){const n=e[0],r=e[1],i=e[2],s=e[0],o=e[1],a=e[2],l=Math.sqrt(n*n+r*r+i*i)*Math.sqrt(s*s+o*o+a*a),c=l&&L(e,t)/l;return Math.acos(c)},subtract:I,sub:B,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r[2]=e[2]+n*(t[2]-e[2]),r},lerpV:function(e,t,n,r){return(r=r||new o(3))[0]=e[0]+n[0]*(t[0]-e[0]),r[1]=e[1]+n[1]*(t[1]-e[1]),r[2]=e[2]+n[2]*(t[2]-e[2]),r},max:function(e,t,n){return(n=n||new o(3))[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n[2]=Math.max(e[2],t[2]),n},min:function(e,t,n){return(n=n||new o(3))[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n},mulScalar:O,scale:R,divScalar:function(e,t,n){return(n=n||new o(3))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n},inverse:N,invert:U,cross:D,dot:L,length:F,len:q,lengthSq:j,lenSq:V,distance:G,dist:W,distanceSq:$,distSq:H,normalize:Y,negate:function(e,t){return(t=t||new o(3))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},copy:X,clone:Z,multiply:K,mul:Q,divide:J,div:ee,random:function(e=1,t){t=t||new o(3);const n=2*Math.random()*Math.PI,r=2*Math.random()-1,i=Math.sqrt(1-r*r)*e;return t[0]=Math.cos(n)*i,t[1]=Math.sin(n)*i,t[2]=r*e,t},zero:function(e){return(e=e||new o(3))[0]=0,e[1]=0,e[2]=0,e},transformMat4:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2],a=t[3]*r+t[7]*i+t[11]*s+t[15]||1;return n[0]=(t[0]*r+t[4]*i+t[8]*s+t[12])/a,n[1]=(t[1]*r+t[5]*i+t[9]*s+t[13])/a,n[2]=(t[2]*r+t[6]*i+t[10]*s+t[14])/a,n},transformMat4Upper3x3:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2];return n[0]=r*t[0]+i*t[4]+s*t[8],n[1]=r*t[1]+i*t[5]+s*t[9],n[2]=r*t[2]+i*t[6]+s*t[10],n},transformMat3:function(e,t,n){n=n||new o(3);const r=e[0],i=e[1],s=e[2];return n[0]=r*t[0]+i*t[4]+s*t[8],n[1]=r*t[1]+i*t[5]+s*t[9],n[2]=r*t[2]+i*t[6]+s*t[10],n},transformQuat:function(e,t,n){n=n||new o(3);const r=t[0],i=t[1],s=t[2],a=2*t[3],l=e[0],c=e[1],u=e[2],h=i*u-s*c,d=s*l-r*u,p=r*c-i*l;return n[0]=l+h*a+2*(i*p-s*d),n[1]=c+d*a+2*(s*h-r*p),n[2]=u+p*a+2*(r*d-i*h),n},getTranslation:function(e,t){return(t=t||new o(3))[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const r=4*t;return(n=n||new o(3))[0]=e[r+0],n[1]=e[r+1],n[2]=e[r+2],n},getScaling:function(e,t){t=t||new o(3);const n=e[0],r=e[1],i=e[2],s=e[4],a=e[5],l=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+r*r+i*i),t[1]=Math.sqrt(s*s+a*a+l*l),t[2]=Math.sqrt(c*c+u*u+h*h),t}});let ne=Float32Array;function re(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}const ie=re;function se(e){return(e=e||new ne(16))[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function oe(e,t){t=t||new ne(16);const n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15],y=d*v,x=g*p,w=l*v,b=g*c,_=l*p,S=d*c,k=i*v,T=g*s,E=i*p,A=d*s,P=i*c,M=l*s,C=u*m,z=f*h,I=o*m,B=f*a,O=o*h,R=u*a,N=n*m,U=f*r,D=n*h,L=u*r,F=n*a,q=o*r,j=y*a+b*h+_*m-(x*a+w*h+S*m),V=x*r+k*h+A*m-(y*r+T*h+E*m),G=w*r+T*a+P*m-(b*r+k*a+M*m),W=S*r+E*a+M*h-(_*r+A*a+P*h),$=1/(n*j+o*V+u*G+f*W);return t[0]=$*j,t[1]=$*V,t[2]=$*G,t[3]=$*W,t[4]=$*(x*o+w*u+S*f-(y*o+b*u+_*f)),t[5]=$*(y*n+T*u+E*f-(x*n+k*u+A*f)),t[6]=$*(b*n+k*o+M*f-(w*n+T*o+P*f)),t[7]=$*(_*n+A*o+P*u-(S*n+E*o+M*u)),t[8]=$*(C*c+B*p+O*v-(z*c+I*p+R*v)),t[9]=$*(z*s+N*p+L*v-(C*s+U*p+D*v)),t[10]=$*(I*s+U*c+F*v-(B*s+N*c+q*v)),t[11]=$*(R*s+D*c+q*p-(O*s+L*c+F*p)),t[12]=$*(I*d+R*g+z*l-(O*g+C*l+B*d)),t[13]=$*(D*g+C*i+U*d-(N*d+L*g+z*i)),t[14]=$*(N*l+q*g+B*i-(F*g+I*i+U*l)),t[15]=$*(F*d+O*i+L*l-(D*l+q*d+R*i)),t}const ae=oe;function le(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=e[8],d=e[9],p=e[10],f=e[11],m=e[12],g=e[13],v=e[14],y=e[15],x=t[0],w=t[1],b=t[2],_=t[3],S=t[4],k=t[5],T=t[6],E=t[7],A=t[8],P=t[9],M=t[10],C=t[11],z=t[12],I=t[13],B=t[14],O=t[15];return n[0]=r*x+a*w+h*b+m*_,n[1]=i*x+l*w+d*b+g*_,n[2]=s*x+c*w+p*b+v*_,n[3]=o*x+u*w+f*b+y*_,n[4]=r*S+a*k+h*T+m*E,n[5]=i*S+l*k+d*T+g*E,n[6]=s*S+c*k+p*T+v*E,n[7]=o*S+u*k+f*T+y*E,n[8]=r*A+a*P+h*M+m*C,n[9]=i*A+l*P+d*M+g*C,n[10]=s*A+c*P+p*M+v*C,n[11]=o*A+u*P+f*M+y*C,n[12]=r*z+a*I+h*B+m*O,n[13]=i*z+l*I+d*B+g*O,n[14]=s*z+c*I+p*B+v*O,n[15]=o*z+u*I+f*B+y*O,n}const ce=le;let ue,he,de;function pe(e,t,n){n=n||new ne(16);let r=e[0],i=e[1],s=e[2];const o=Math.sqrt(r*r+i*i+s*s);r/=o,i/=o,s/=o;const a=r*r,l=i*i,c=s*s,u=Math.cos(t),h=Math.sin(t),d=1-u;return n[0]=a+(1-a)*u,n[1]=r*i*d+s*h,n[2]=r*s*d-i*h,n[3]=0,n[4]=r*i*d-s*h,n[5]=l+(1-l)*u,n[6]=i*s*d+r*h,n[7]=0,n[8]=r*s*d+i*h,n[9]=i*s*d-r*h,n[10]=c+(1-c)*u,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}const fe=pe;function me(e,t,n,r){r=r||new ne(16);let i=t[0],s=t[1],o=t[2];const a=Math.sqrt(i*i+s*s+o*o);i/=a,s/=a,o/=a;const l=i*i,c=s*s,u=o*o,h=Math.cos(n),d=Math.sin(n),p=1-h,f=l+(1-l)*h,m=i*s*p+o*d,g=i*o*p-s*d,v=i*s*p-o*d,y=c+(1-c)*h,x=s*o*p+i*d,w=i*o*p+s*d,b=s*o*p-i*d,_=u+(1-u)*h,S=e[0],k=e[1],T=e[2],E=e[3],A=e[4],P=e[5],M=e[6],C=e[7],z=e[8],I=e[9],B=e[10],O=e[11];return r[0]=f*S+m*A+g*z,r[1]=f*k+m*P+g*I,r[2]=f*T+m*M+g*B,r[3]=f*E+m*C+g*O,r[4]=v*S+y*A+x*z,r[5]=v*k+y*P+x*I,r[6]=v*T+y*M+x*B,r[7]=v*E+y*C+x*O,r[8]=w*S+b*A+_*z,r[9]=w*k+b*P+_*I,r[10]=w*T+b*M+_*B,r[11]=w*E+b*C+_*O,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r}const ge=me;var ve=Object.freeze({__proto__:null,setDefaultType:function(e){const t=ne;return ne=e,t},create:function(e,t,n,r,i,s,o,a,l,c,u,h,d,p,f,m){const g=new ne(16);return void 0!==e&&(g[0]=e,void 0!==t&&(g[1]=t,void 0!==n&&(g[2]=n,void 0!==r&&(g[3]=r,void 0!==i&&(g[4]=i,void 0!==s&&(g[5]=s,void 0!==o&&(g[6]=o,void 0!==a&&(g[7]=a,void 0!==l&&(g[8]=l,void 0!==c&&(g[9]=c,void 0!==u&&(g[10]=u,void 0!==h&&(g[11]=h,void 0!==d&&(g[12]=d,void 0!==p&&(g[13]=p,void 0!==f&&(g[14]=f,void 0!==m&&(g[15]=m)))))))))))))))),g},set:function(e,t,n,r,i,s,o,a,l,c,u,h,d,p,f,m,g){return(g=g||new ne(16))[0]=e,g[1]=t,g[2]=n,g[3]=r,g[4]=i,g[5]=s,g[6]=o,g[7]=a,g[8]=l,g[9]=c,g[10]=u,g[11]=h,g[12]=d,g[13]=p,g[14]=f,g[15]=m,g},fromMat3:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=0,t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=0,t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromQuat:function(e,t){t=t||new ne(16);const n=e[0],r=e[1],i=e[2],s=e[3],o=n+n,a=r+r,l=i+i,c=n*o,u=r*o,h=r*a,d=i*o,p=i*a,f=i*l,m=s*o,g=s*a,v=s*l;return t[0]=1-h-f,t[1]=u+v,t[2]=d-g,t[3]=0,t[4]=u-v,t[5]=1-c-f,t[6]=p+m,t[7]=0,t[8]=d+g,t[9]=p-m,t[10]=1-c-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},negate:function(e,t){return(t=t||new ne(16))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t[9]=-e[9],t[10]=-e[10],t[11]=-e[11],t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=-e[15],t},copy:re,clone:ie,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r&&Math.abs(e[4]-t[4])<r&&Math.abs(e[5]-t[5])<r&&Math.abs(e[6]-t[6])<r&&Math.abs(e[7]-t[7])<r&&Math.abs(e[8]-t[8])<r&&Math.abs(e[9]-t[9])<r&&Math.abs(e[10]-t[10])<r&&Math.abs(e[11]-t[11])<r&&Math.abs(e[12]-t[12])<r&&Math.abs(e[13]-t[13])<r&&Math.abs(e[14]-t[14])<r&&Math.abs(e[15]-t[15])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},identity:se,transpose:function(e,t){if((t=t||new ne(16))===e){let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,t}const n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],g=e[14],v=e[15];return t[0]=n,t[1]=o,t[2]=u,t[3]=f,t[4]=r,t[5]=a,t[6]=h,t[7]=m,t[8]=i,t[9]=l,t[10]=d,t[11]=g,t[12]=s,t[13]=c,t[14]=p,t[15]=v,t},inverse:oe,determinant:function(e){const t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],a=e[6],l=e[7],c=e[8],u=e[9],h=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],v=h*g,y=m*d,x=a*g,w=m*l,b=a*d,_=h*l,S=r*g,k=m*i,T=r*d,E=h*i,A=r*l,P=a*i;return t*(v*o+w*u+b*f-(y*o+x*u+_*f))+s*(y*n+S*u+E*f-(v*n+k*u+T*f))+c*(x*n+k*o+A*f-(w*n+S*o+P*f))+p*(_*n+T*o+P*u-(b*n+E*o+A*u))},invert:ae,multiply:le,mul:ce,setTranslation:function(e,t,n){return e!==(n=n||se())&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11]),n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},getTranslation:function(e,t){return(t=t||a())[0]=e[12],t[1]=e[13],t[2]=e[14],t},getAxis:function(e,t,n){const r=4*t;return(n=n||a())[0]=e[r+0],n[1]=e[r+1],n[2]=e[r+2],n},setAxis:function(e,t,n,r){r!==e&&(r=re(e,r));const i=4*n;return r[i+0]=t[0],r[i+1]=t[1],r[i+2]=t[2],r},getScaling:function(e,t){t=t||a();const n=e[0],r=e[1],i=e[2],s=e[4],o=e[5],l=e[6],c=e[8],u=e[9],h=e[10];return t[0]=Math.sqrt(n*n+r*r+i*i),t[1]=Math.sqrt(s*s+o*o+l*l),t[2]=Math.sqrt(c*c+u*u+h*h),t},perspective:function(e,t,n,r,i){i=i||new ne(16);const s=Math.tan(.5*Math.PI-.5*e);if(i[0]=s/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=s,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,r===1/0)i[10]=-1,i[14]=-n;else{const e=1/(n-r);i[10]=r*e,i[14]=r*n*e}return i},ortho:function(e,t,n,r,i,s,o){return(o=o||new ne(16))[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(r-n),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(i-s),o[11]=0,o[12]=(t+e)/(e-t),o[13]=(r+n)/(n-r),o[14]=i/(i-s),o[15]=1,o},frustum:function(e,t,n,r,i,s,o){const a=t-e,l=r-n,c=i-s;return(o=o||new ne(16))[0]=2*i/a,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*i/l,o[6]=0,o[7]=0,o[8]=(e+t)/a,o[9]=(r+n)/l,o[10]=s/c,o[11]=-1,o[12]=0,o[13]=0,o[14]=i*s/c,o[15]=0,o},aim:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(t,e,de),de),Y(D(n,de,ue),ue),Y(D(de,ue,he),he),r[0]=ue[0],r[1]=ue[1],r[2]=ue[2],r[3]=0,r[4]=he[0],r[5]=he[1],r[6]=he[2],r[7]=0,r[8]=de[0],r[9]=de[1],r[10]=de[2],r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r},cameraAim:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(e,t,de),de),Y(D(n,de,ue),ue),Y(D(de,ue,he),he),r[0]=ue[0],r[1]=ue[1],r[2]=ue[2],r[3]=0,r[4]=he[0],r[5]=he[1],r[6]=he[2],r[7]=0,r[8]=de[0],r[9]=de[1],r[10]=de[2],r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r},lookAt:function(e,t,n,r){return r=r||new ne(16),ue=ue||a(),he=he||a(),de=de||a(),Y(I(e,t,de),de),Y(D(n,de,ue),ue),Y(D(de,ue,he),he),r[0]=ue[0],r[1]=he[0],r[2]=de[0],r[3]=0,r[4]=ue[1],r[5]=he[1],r[6]=de[1],r[7]=0,r[8]=ue[2],r[9]=he[2],r[10]=de[2],r[11]=0,r[12]=-(ue[0]*e[0]+ue[1]*e[1]+ue[2]*e[2]),r[13]=-(he[0]*e[0]+he[1]*e[1]+he[2]*e[2]),r[14]=-(de[0]*e[0]+de[1]*e[1]+de[2]*e[2]),r[15]=1,r},translation:function(e,t){return(t=t||new ne(16))[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},translate:function(e,t,n){n=n||new ne(16);const r=t[0],i=t[1],s=t[2],o=e[0],a=e[1],l=e[2],c=e[3],u=e[4],h=e[5],d=e[6],p=e[7],f=e[8],m=e[9],g=e[10],v=e[11],y=e[12],x=e[13],w=e[14],b=e[15];return e!==n&&(n[0]=o,n[1]=a,n[2]=l,n[3]=c,n[4]=u,n[5]=h,n[6]=d,n[7]=p,n[8]=f,n[9]=m,n[10]=g,n[11]=v),n[12]=o*r+u*i+f*s+y,n[13]=a*r+h*i+m*s+x,n[14]=l*r+d*i+g*s+w,n[15]=c*r+p*i+v*s+b,n},rotationX:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateX:function(e,t,n){n=n||new ne(16);const r=e[4],i=e[5],s=e[6],o=e[7],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[4]=h*r+d*a,n[5]=h*i+d*l,n[6]=h*s+d*c,n[7]=h*o+d*u,n[8]=h*a-d*r,n[9]=h*l-d*i,n[10]=h*c-d*s,n[11]=h*u-d*o,e!==n&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationY:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=n,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateY:function(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[8],l=e[9],c=e[10],u=e[11],h=Math.cos(t),d=Math.sin(t);return n[0]=h*r-d*a,n[1]=h*i-d*l,n[2]=h*s-d*c,n[3]=h*o-d*u,n[8]=h*a+d*r,n[9]=h*l+d*i,n[10]=h*c+d*s,n[11]=h*u+d*o,e!==n&&(n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},rotationZ:function(e,t){t=t||new ne(16);const n=Math.cos(e),r=Math.sin(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},rotateZ:function(e,t,n){n=n||new ne(16);const r=e[0],i=e[1],s=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7],h=Math.cos(t),d=Math.sin(t);return n[0]=h*r+d*a,n[1]=h*i+d*l,n[2]=h*s+d*c,n[3]=h*o+d*u,n[4]=h*a-d*r,n[5]=h*l-d*i,n[6]=h*c-d*s,n[7]=h*u-d*o,e!==n&&(n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},axisRotation:pe,rotation:fe,axisRotate:me,rotate:ge,scaling:function(e,t){return(t=t||new ne(16))[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},scale:function(e,t,n){n=n||new ne(16);const r=t[0],i=t[1],s=t[2];return n[0]=r*e[0],n[1]=r*e[1],n[2]=r*e[2],n[3]=r*e[3],n[4]=i*e[4],n[5]=i*e[5],n[6]=i*e[6],n[7]=i*e[7],n[8]=s*e[8],n[9]=s*e[9],n[10]=s*e[10],n[11]=s*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},uniformScaling:function(e,t){return(t=t||new ne(16))[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},uniformScale:function(e,t,n){return(n=n||new ne(16))[0]=t*e[0],n[1]=t*e[1],n[2]=t*e[2],n[3]=t*e[3],n[4]=t*e[4],n[5]=t*e[5],n[6]=t*e[6],n[7]=t*e[7],n[8]=t*e[8],n[9]=t*e[9],n[10]=t*e[10],n[11]=t*e[11],e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n}});let ye=Float32Array;function xe(e,t,n,r){const i=new ye(4);return void 0!==e&&(i[0]=e,void 0!==t&&(i[1]=t,void 0!==n&&(i[2]=n,void 0!==r&&(i[3]=r)))),i}const we=xe;function be(e,t,n){n=n||new ye(4);const r=.5*t,i=Math.sin(r);return n[0]=i*e[0],n[1]=i*e[1],n[2]=i*e[2],n[3]=Math.cos(r),n}function _e(e,t,n){n=n||new ye(4);const r=e[0],i=e[1],s=e[2],o=e[3],a=t[0],l=t[1],c=t[2],u=t[3];return n[0]=r*u+o*a+i*c-s*l,n[1]=i*u+o*l+s*a-r*c,n[2]=s*u+o*c+r*l-i*a,n[3]=o*u-r*a-i*l-s*c,n}const Se=_e;function ke(e,t,n,i){i=i||new ye(4);const s=e[0],o=e[1],a=e[2],l=e[3];let c,u,h=t[0],d=t[1],p=t[2],f=t[3],m=s*h+o*d+a*p+l*f;if(m<0&&(m=-m,h=-h,d=-d,p=-p,f=-f),1-m>r){const e=Math.acos(m),t=Math.sin(e);c=Math.sin((1-n)*e)/t,u=Math.sin(n*e)/t}else c=1-n,u=n;return i[0]=c*s+u*h,i[1]=c*o+u*d,i[2]=c*a+u*p,i[3]=c*l+u*f,i}function Te(e,t){return(t=t||new ye(4))[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}const Ee=Te;function Ae(e,t,n){return(n=n||new ye(4))[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n}const Pe=Ae;function Me(e,t,n){return(n=n||new ye(4))[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n}const Ce=Me;function ze(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Ie(e){const t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)}const Be=Ie;function Oe(e){const t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i}const Re=Oe;function Ne(e,t){t=t||new ye(4);const n=e[0],r=e[1],i=e[2],s=e[3],o=Math.sqrt(n*n+r*r+i*i+s*s);return o>1e-5?(t[0]=n/o,t[1]=r/o,t[2]=i/o,t[3]=s/o):(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}let Ue,De,Le,Fe,qe;var je=Object.freeze({__proto__:null,create:xe,setDefaultType:function(e){const t=ye;return ye=e,t},fromValues:we,set:function(e,t,n,r,i){return(i=i||new ye(4))[0]=e,i[1]=t,i[2]=n,i[3]=r,i},fromAxisAngle:be,toAxisAngle:function(e,t){t=t||a(4);const n=2*Math.acos(e[3]),i=Math.sin(.5*n);return i>r?(t[0]=e[0]/i,t[1]=e[1]/i,t[2]=e[2]/i):(t[0]=1,t[1]=0,t[2]=0),{angle:n,axis:t}},angle:function(e,t){const n=ze(e,t);return Math.acos(2*n*n-1)},multiply:_e,mul:Se,rotateX:function(e,t,n){n=n||new ye(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(r),c=Math.cos(r);return n[0]=i*c+a*l,n[1]=s*c+o*l,n[2]=o*c-s*l,n[3]=a*c-i*l,n},rotateY:function(e,t,n){n=n||new ye(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(r),c=Math.cos(r);return n[0]=i*c-o*l,n[1]=s*c+a*l,n[2]=o*c+i*l,n[3]=a*c-s*l,n},rotateZ:function(e,t,n){n=n||new ye(4);const r=.5*t,i=e[0],s=e[1],o=e[2],a=e[3],l=Math.sin(r),c=Math.cos(r);return n[0]=i*c+s*l,n[1]=s*c-i*l,n[2]=o*c+a*l,n[3]=a*c-o*l,n},slerp:ke,inverse:function(e,t){t=t||new ye(4);const n=e[0],r=e[1],i=e[2],s=e[3],o=n*n+r*r+i*i+s*s,a=o?1/o:0;return t[0]=-n*a,t[1]=-r*a,t[2]=-i*a,t[3]=s*a,t},conjugate:function(e,t){return(t=t||new ye(4))[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},fromMat:function(e,t){t=t||new ye(4);const n=e[0]+e[5]+e[10];if(n>0){const r=Math.sqrt(n+1);t[3]=.5*r;const i=.5/r;t[0]=(e[6]-e[9])*i,t[1]=(e[8]-e[2])*i,t[2]=(e[1]-e[4])*i}else{let n=0;e[5]>e[0]&&(n=1),e[10]>e[4*n+n]&&(n=2);const r=(n+1)%3,i=(n+2)%3,s=Math.sqrt(e[4*n+n]-e[4*r+r]-e[4*i+i]+1);t[n]=.5*s;const o=.5/s;t[3]=(e[4*r+i]-e[4*i+r])*o,t[r]=(e[4*r+n]+e[4*n+r])*o,t[i]=(e[4*i+n]+e[4*n+i])*o}return t},fromEuler:function(e,t,n,r,i){i=i||new ye(4);const s=.5*e,o=.5*t,a=.5*n,l=Math.sin(s),c=Math.cos(s),u=Math.sin(o),h=Math.cos(o),d=Math.sin(a),p=Math.cos(a);switch(r){case"xyz":i[0]=l*h*p+c*u*d,i[1]=c*u*p-l*h*d,i[2]=c*h*d+l*u*p,i[3]=c*h*p-l*u*d;break;case"xzy":i[0]=l*h*p-c*u*d,i[1]=c*u*p-l*h*d,i[2]=c*h*d+l*u*p,i[3]=c*h*p+l*u*d;break;case"yxz":i[0]=l*h*p+c*u*d,i[1]=c*u*p-l*h*d,i[2]=c*h*d-l*u*p,i[3]=c*h*p+l*u*d;break;case"yzx":i[0]=l*h*p+c*u*d,i[1]=c*u*p+l*h*d,i[2]=c*h*d-l*u*p,i[3]=c*h*p-l*u*d;break;case"zxy":i[0]=l*h*p-c*u*d,i[1]=c*u*p+l*h*d,i[2]=c*h*d+l*u*p,i[3]=c*h*p-l*u*d;break;case"zyx":i[0]=l*h*p-c*u*d,i[1]=c*u*p+l*h*d,i[2]=c*h*d-l*u*p,i[3]=c*h*p+l*u*d;break;default:throw new Error(`Unknown rotation order: ${r}`)}return i},copy:Te,clone:Ee,add:function(e,t,n){return(n=n||new ye(4))[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n},subtract:Ae,sub:Pe,mulScalar:Me,scale:Ce,divScalar:function(e,t,n){return(n=n||new ye(4))[0]=e[0]/t,n[1]=e[1]/t,n[2]=e[2]/t,n[3]=e[3]/t,n},dot:ze,lerp:function(e,t,n,r){return(r=r||new ye(4))[0]=e[0]+n*(t[0]-e[0]),r[1]=e[1]+n*(t[1]-e[1]),r[2]=e[2]+n*(t[2]-e[2]),r[3]=e[3]+n*(t[3]-e[3]),r},length:Ie,len:Be,lengthSq:Oe,lenSq:Re,normalize:Ne,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<r&&Math.abs(e[1]-t[1])<r&&Math.abs(e[2]-t[2])<r&&Math.abs(e[3]-t[3])<r},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(e){return(e=e||new ye(4))[0]=0,e[1]=0,e[2]=0,e[3]=1,e},rotationTo:function(e,t,n){n=n||new ye(4),Ue=Ue||a(),De=De||a(1,0,0),Le=Le||a(0,1,0);const r=L(e,t);return r<-.999999?(D(De,e,Ue),q(Ue)<1e-6&&D(Le,e,Ue),Y(Ue,Ue),be(Ue,Math.PI,n),n):r>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(D(e,t,Ue),n[0]=Ue[0],n[1]=Ue[1],n[2]=Ue[2],n[3]=1+r,Ne(n,n))},sqlerp:function(e,t,n,r,i,s){return s=s||new ye(4),Fe=Fe||new ye(4),qe=qe||new ye(4),ke(e,r,i,Fe),ke(t,n,i,qe),ke(Fe,qe,2*i*(1-i),s),s}});Float32Array}},t={};function n(r){var i=t[r];if(void 0!==i)return i.exports;var s=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.u=e=>e+".app.js",n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;n.g.importScripts&&(e=n.g.location+"");var t=n.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");if(r.length)for(var i=r.length-1;i>-1&&(!e||!/^http(s?):/.test(e));)e=r[i--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),n.p=e})(),n.b=document.baseURI||self.location.href,(()=>{"use strict";class e{}class t{ecs}class r{map=new Map;add(e){this.map.set(e.constructor,e)}get(e){return this.map.get(e)}has(e){return this.map.has(e)}hasAll(e){for(let t of e)if(!this.map.has(t))return!1;return!0}delete(e){this.map.delete(e)}}var i=n(300);const s=(e,t)=>{const n=new Uint32Array(e),r=Sr.createBuffer({size:n.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:t});return((e,t)=>{const n=new Uint32Array(t);Sr.queue.writeBuffer(e,0,n.buffer,0,t.length*Uint32Array.BYTES_PER_ELEMENT)})(r,e),r},o=(e,t)=>{if(t instanceof Float32Array)Sr.queue.writeBuffer(e,0,t.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT);else{const n=new Float32Array(t);Sr.queue.writeBuffer(e,0,n.buffer,0,t.length*Float32Array.BYTES_PER_ELEMENT)}},a="// Constants\r\nconst infinity : f32 = 99999999.0;\r\n\r\n// Utility functions\r\nfn degreesToRadians(degrees : f32) -> f32 {\r\n    return degrees * (3.1415926535897932385 / 180.0);\r\n}\r\n\r\nfn unitVector(v : vec3<f32>) -> vec3<f32> {\r\n    return v / length(v);\r\n}\r\n\r\nfn lengthSquared(v : vec3<f32>) -> f32 {\r\n    return v.x * v.x + v.y * v.y + v.z * v.z;\r\n}\r\n\r\nfn random(co : vec2<f32>) -> f32 {\r\n    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nfn randomMinMax(co : vec2<f32>, min : f32, max : f32) -> f32 {\r\n    return min + (max - min) * random(co);\r\n}\r\n\r\nfn randomFloat3(co : vec2<f32>) -> vec3<f32> {\r\n    return vec3<f32>(random(co), random(co * 2.0), random(co * 3.0));\r\n}\r\n\r\nfn randomFloat3MinMax(co : vec2<f32>, min : f32, max : f32) -> vec3<f32> {\r\n    return vec3<f32>(randomMinMax(co, min, max), randomMinMax(co * 2.0, min, max), randomMinMax(co * 3.0, min, max));\r\n}\r\n\r\nfn randomInUnitSphere(co : vec2<f32>) -> vec3<f32> {\r\n    var p : vec3<f32> = randomFloat3MinMax(co, -1.0, 1.0);\r\n    while (lengthSquared(p) < 1.0) {\r\n        p = randomFloat3MinMax(co, -1.0, 1.0);\r\n    }\r\n    return p;\r\n}\r\n\r\nfn randomInUnitDisk(seed : vec2<f32>) -> vec2<f32> {\r\n    let r = sqrt(random(seed));\r\n    let theta = 2.0 * 3.14159265359 * random(vec2<f32>(seed.y, seed.x));\r\n    return vec2<f32>(cos(theta), sin(theta)) * r;\r\n}\r\n\r\nfn randomInPlanarUnitDisk(seed : vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let disk = randomInUnitDisk(seed);\r\n    var diskNormal = cross(normal, vec3<f32>(0.0, 1.0, 0.0));\r\n    if (length(diskNormal) < 0.01) {\r\n        diskNormal = cross(normal, vec3<f32>(1.0, 0.0, 0.0));\r\n    }\r\n    diskNormal = normalize(diskNormal);\r\n    let diskTangent = cross(diskNormal, normal);\r\n    return disk.x * diskTangent + disk.y * diskNormal;\r\n}\r\n\r\nfn reflect(v : vec3<f32>, n : vec3<f32>) -> vec3<f32> {\r\n    return v - 2.0 * dot(v, n) * n;\r\n}\r\n\r\nfn randomUnitVector(co : vec2<f32>) -> vec3<f32> {\r\n    return unitVector(randomInUnitSphere(co));\r\n}\r\n\r\nfn nearZero(e : vec3<f32>) -> bool {\r\n    const s : f32 = 1e-8;\r\n    return (abs(e.x) < s) && (abs(e.y) < s) && (abs(e.z) < s);\r\n}\r\n\r\nfn randomInHemisphere(co : vec2<f32>, normal : vec3<f32>) -> vec3<f32> {\r\n    let inUnitSphere = randomUnitVector(co);\r\n    if (dot(inUnitSphere, normal) > 0.0) {\r\n        return inUnitSphere;\r\n    }\r\n    return -inUnitSphere;\r\n}\r\n\r\nfn randomAlongVector(co : vec2<f32>, direction : vec3<f32>) -> vec3<f32> {\r\n    return normalize(direction) * random(co);\r\n}\r\n\r\n// Function to perturb the normal vector within the hemisphere\r\nfn perturbDirection(normal: vec3<f32>, scatterAmount: f32, co: vec2<f32>) -> vec3<f32> {\r\n    // Generate a random vector in a hemisphere\r\n    let hemisphereVector : vec3<f32> = randomInHemisphere(co, normal);\r\n\r\n    // Combine the perturbation with the original normal\r\n    let perturbedDir : vec3<f32> = normalize(normal + scatterAmount * hemisphereVector);\r\n\r\n    return perturbedDir;\r\n}\r\n\r\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\r\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\r\nfn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\n\r\nfn perlinNoise3(P: vec3<f32>) -> f32 {\r\n    var Pi0 : vec3<f32> = floor(P); // Integer part for indexing\r\n    var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1\r\n    Pi0 = Pi0 % vec3<f32>(289.);\r\n    Pi1 = Pi1 % vec3<f32>(289.);\r\n    let Pf0 = fract(P); // Fractional part for interpolation\r\n    let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.\r\n    let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    let iy = vec4<f32>(Pi0.yy, Pi1.yy);\r\n    let iz0 = Pi0.zzzz;\r\n    let iz1 = Pi1.zzzz;\r\n\r\n    let ixy = permute4(permute4(ix) + iy);\r\n    let ixy0 = permute4(ixy + iz0);\r\n    let ixy1 = permute4(ixy + iz1);\r\n\r\n    var gx0: vec4<f32> = ixy0 / 7.;\r\n    var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;\r\n    gx0 = fract(gx0);\r\n    var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\r\n    var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));\r\n    gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);\r\n    gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);\r\n\r\n    var gx1: vec4<f32> = ixy1 / 7.;\r\n    var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;\r\n    gx1 = fract(gx1);\r\n    var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\r\n    var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));\r\n    gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);\r\n    gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);\r\n\r\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\r\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\r\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\r\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\r\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\r\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\r\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\r\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\r\n\r\n    let norm0 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 = g000 * norm0.x;\r\n    g010 = g010 * norm0.y;\r\n    g100 = g100 * norm0.z;\r\n    g110 = g110 * norm0.w;\r\n    let norm1 = taylorInvSqrt4(\r\n        vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 = g001 * norm1.x;\r\n    g011 = g011 * norm1.y;\r\n    g101 = g101 * norm1.z;\r\n    g111 = g111 * norm1.w;\r\n\r\n    let n000 = dot(g000, Pf0);\r\n    let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\r\n    let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\r\n    let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\r\n    let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\r\n    let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\r\n    let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\r\n    let n111 = dot(g111, Pf1);\r\n\r\n    var fade_xyz: vec3<f32> = fade3(Pf0);\r\n    let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix\r\n    let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);\r\n    let n_yz = mix(n_z.xy, n_z.zw, vec2f(f32(fade_xyz.y))); // simplify after chrome bug fix\r\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 2.2 * n_xyz;\r\n}",l="fn calculateRayDirection(uv: vec2<f32>, inverseProjection: mat4x4<f32>) -> vec3<f32> {\r\n  let clipSpace = vec2(1.0 - uv.x, 1.0 - uv.y) * 2.0 - 1.0;\r\n  let viewRay = vec3<f32>(clipSpace, 1.0);\r\n  let viewRayView = inverseProjection * vec4(viewRay, 1.0);\r\n  return normalize(viewRayView.xyz);\r\n}\r\n\r\nfn normaliseValue(min: f32, max: f32, value: f32) -> f32 {\r\n  return (value - min) / (max - min);\r\n}",c="struct BoxIntersectionResult {\r\n    tNear: f32,\r\n    tFar: f32,\r\n    normal: vec3<f32>,\r\n    isHit: bool,\r\n}\r\n\r\nfn boxIntersection(\r\n    ro: vec3<f32>,\r\n    rd: vec3<f32>,\r\n    boxSize: vec3<f32>,\r\n) -> BoxIntersectionResult {\r\n    var result = BoxIntersectionResult();\r\n    result.isHit = false;\r\n    result.tNear = 0.0;\r\n    result.tFar = 0.0;\r\n\r\n    let offsetRayOrigin = ro - boxSize;\r\n    let m: vec3<f32> = 1.0 / rd;\r\n    let n: vec3<f32> = m * offsetRayOrigin;\r\n    let k: vec3<f32> = abs(m) * boxSize;\r\n    let t1: vec3<f32> = -n - k;\r\n    let t2: vec3<f32> = -n + k;\r\n    let tN: f32 = max(max(t1.x, t1.y), t1.z);\r\n    let tF: f32 = min(min(t2.x, t2.y), t2.z);\r\n    if (tN > tF || tF < 0.0) {\r\n        return result;\r\n    }\r\n    // Check if the ray starts inside the volume\r\n    let insideVolume = tN < 0.0;\r\n    var normal = select(\r\n        step(vec3<f32>(tN), t1),\r\n        step(t2, vec3<f32>(tF)),\r\n        tN < 0.0,\r\n    );\r\n    normal *= -sign(rd);\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    if (insideVolume && dot(normal, rd) < 0.0) {\r\n        return result;\r\n    }\r\n    result.tNear = tN;\r\n    result.tFar = tF;\r\n    result.normal = normal;\r\n    result.isHit = true;\r\n    return result;\r\n}\r\n\r\n\r\nfn cubeIntersection(\r\n    ro: vec3<f32>,  // ray origin\r\n    rd: vec3<f32>,  // ray direction\r\n    cubeHalfSize: f32,  // half the size of the cube\r\n) -> f32 {\r\n    let offsetRayOrigin = ro - cubeHalfSize;\r\n    let m = 1.0/rd; // can precompute if traversing a set of aligned boxes\r\n    let n = m*offsetRayOrigin;   // can precompute if traversing a set of aligned boxes\r\n    let k = abs(m)*cubeHalfSize;\r\n    let t1 = -n - k;\r\n    let t2 = -n + k;\r\n    let tN = max( max( t1.x, t1.y ), t1.z );\r\n    let tF = min( min( t2.x, t2.y ), t2.z );\r\n    if( tN>tF || tF<0.0) {\r\n        return -1.0; // no intersection\r\n    }\r\n    // Check if the intersection is in the correct direction, only if inside the volume\r\n    return max(tN, 0.0);\r\n}\r\n\r\n",u='const EPSILON = 0.001;\r\nconst MAX_RAY_STEPS = 256;\r\nconst FAR_PLANE = 10000.0;\r\nconst NEAR_PLANE = 0.5;\r\nconst STACK_LEN: u32 = 32u;\r\nconst MAX_STEPS = 256;\r\n\r\n// Function to transform a normal vector from object to world space\r\nfn transformNormal(inverseTransform: mat4x4<f32>, normal: vec3<f32>) -> vec3<f32> {\r\n    let worldNormal = normalize((vec4<f32>(normal, 0.0) * inverseTransform).xyz);\r\n    return worldNormal;\r\n}\r\n\r\n// Function to transform an object space position to world space\r\nfn transformPosition(transform: mat4x4<f32>, position: vec3<f32>) -> vec3<f32> {\r\n    let worldPosition = (transform * vec4<f32>(position, 1.0)).xyz;\r\n    return worldPosition;\r\n}\r\n\r\n\r\nstruct VoxelObject {\r\n  transform: mat4x4<f32>,\r\n  inverseTransform: mat4x4<f32>,\r\n  previousTransform: mat4x4<f32>,\r\n  previousInverseTransform: mat4x4<f32>,\r\n  size : vec3<f32>,\r\n  atlasLocation : vec3<f32>,\r\n  paletteIndex : f32,\r\n  octreeBufferIndex: u32\r\n}\r\n\r\nstruct RayMarchResult {\r\n  voxelObjectIndex: i32,\r\n  colour: vec3<f32>,\r\n  normal: vec3<f32>,\r\n  hit: bool,\r\n  t: f32,\r\n  iterations: u32,\r\n}\r\n\r\nfn isInBounds(position: vec3<i32>, size: vec3<i32>) -> bool {\r\n  return all(position >= vec3(0)) && all(position <= size - vec3(1));\r\n}\r\n\r\nfn getBit(value: u32, bitIndex: u32) -> bool {\r\n  return (value & (1u << bitIndex)) != 0;\r\n}\r\n\r\nfn getScaleFromMatrix(transform: mat4x4<f32>) -> vec3<f32> {\r\n  return vec3<f32>(length(transform[0].xyz), length(transform[1].xyz), length(transform[2].xyz));\r\n}\r\n\r\nstruct Stack {\r\n  arr: array<i32, STACK_LEN>,\r\n\thead: u32,\r\n}\r\n\r\nfn stack_new() -> Stack {\r\n    var arr: array<i32, STACK_LEN>;\r\n    return Stack(arr, 0u);\r\n}\r\n\r\nfn stack_push(stack: ptr<function, Stack>, val: i32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stack_pop(stack: ptr<function, Stack>) -> i32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\nstruct StackU32 {\r\n  arr: array<u32, STACK_LEN>,\r\n  head: u32,\r\n}\r\n\r\nfn stacku32_new() -> StackU32 {\r\n    var arr: array<u32, STACK_LEN>;\r\n    return StackU32(arr, 0u);\r\n}\r\n\r\nfn stacku32_push(stack: ptr<function, StackU32>, val: u32) {\r\n    (*stack).arr[(*stack).head] = val;\r\n    (*stack).head += 1u;\r\n}\r\n\r\nfn stacku32_pop(stack: ptr<function, StackU32>) -> u32 {\r\n    (*stack).head -= 1u;\r\n    return (*stack).arr[(*stack).head];\r\n}\r\n\r\n\r\nstruct InternalNode {\r\n  firstChildOffset: u32,\r\n  childMask: u32,\r\n  position: vec3<u32>,\r\n  size: u32,\r\n}\r\n\r\nstruct LeafNode {\r\n  colour: vec3<u32>,\r\n  position: vec3<u32>,\r\n  size: u32,\r\n}\r\n\r\nconst mask8 = 0xFFu;\r\nconst mask16 = 0xFFFFu;\r\nconst mask24 = 0xFFFFFFu;\r\n\r\n// if first child offset is 0, then it is a leaf\r\nfn isLeaf(node:vec2<u32>) -> bool {\r\n  return (node[0] & mask8) == 0;\r\n}\r\n\r\n/**\r\n  * Unpacks a leaf node from a 32 bit integer\r\n  * First 8 bits are the leaf flag (0)\r\n  * The next 8 bits are the x position\r\n  * The next 8 bits are the y position\r\n  * The next 8 bits are the z position\r\n  * The next 8 bits are the red component\r\n  * The next 8 bits are the green component\r\n  * The next 8 bits are the blue component\r\n\r\n  */\r\nfn unpackLeaf(node: vec2<u32>) -> LeafNode {\r\n  var output = LeafNode();\r\n  let first4Bytes = node.x;\r\n  let second4Bytes = node.y;\r\n  let x = (first4Bytes >> 8u) & mask8;\r\n  let y = (first4Bytes >> 16u) & mask8;\r\n  let z = (first4Bytes >> 24u) & mask8;\r\n  let r = second4Bytes & mask8;\r\n  let g = (second4Bytes >> 8u) & mask8;\r\n  let b = (second4Bytes >> 16u) & mask8;\r\n  output.colour = vec3<u32>(r, g, b);\r\n  output.position = vec3<u32>(x, y, z);\r\n  output.size = 1u << ((second4Bytes >> 24u) & mask8);\r\n  return output;\r\n}\r\n\r\n/**\r\n  * Unpacks an internal node from a 32 bit integer\r\n  * First 8 bits are the child mask\r\n  * The next 8 bits are the x position\r\n  * The next 8 bits are the y position\r\n  * The next 8 bits are the z position\r\n  * The next 24 bits are the firstChildOffset\r\n  * The next 8 bits are the size\r\n  */\r\nfn unpackInternal(node: vec2<u32>) -> InternalNode {\r\n  var output = InternalNode();\r\n  let first4Bytes = node.x;\r\n  let second4Bytes = node.y;\r\n  output.childMask = first4Bytes & mask8;\r\n  let x = (first4Bytes >> 8u) & mask8;\r\n  let y = (first4Bytes >> 16u) & mask8;\r\n  let z = (first4Bytes >> 24u) & mask8;\r\n  output.firstChildOffset = second4Bytes & mask24;\r\n  output.position = vec3<u32>(x, y, z);\r\n  output.size = 1u << ((second4Bytes >> 24u) & mask8); // 2 raised to the power of the size\r\n  return output;\r\n}\r\n\r\nfn getNodeSizeAtDepth(rootSize: u32, depth: u32) -> u32 {\r\n  return rootSize >> depth;\r\n}\r\n\r\nfn octantIndexToOffset(index: u32) -> vec3<u32> {\r\n  return vec3<u32>(\r\n    select(0u, 1u, (index & 1u) != 0u),\r\n    select(0u, 1u, (index & 2u) != 0u),\r\n    select(0u, 1u, (index & 4u) != 0u)\r\n  );\r\n}\r\n\r\nfn octantOffsetToIndex(offset: vec3<u32>) -> u32 {\r\n  return offset.x + offset.y * 2u + offset.z * 4u;\r\n}\r\n\r\nfn ceilToPowerOfTwo(value: f32) -> f32 {\r\n  return pow(2.0, ceil(log2(value)));\r\n}\r\n\r\nfn max3(value: vec3<f32>) -> f32 {\r\n  return max(value.x, max(value.y, value.z));\r\n}\r\n\r\nfn planeIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, planeNormal: vec3<f32>, planeDistance: f32) -> f32 {\r\n  return -(dot(rayOrigin,planeNormal)+planeDistance)/dot(rayDirection,planeNormal);\r\n}\r\n\r\nstruct PlaneIntersection {\r\n  tNear: f32,\r\n  side: vec3<i32>\r\n}\r\n\r\n\r\nfn sort3Asc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    min(a, min(b, c)),\r\n    min(max(a, b), max(min(a, b), c)),\r\n    max(a, max(b, c))\r\n  );\r\n}\r\n\r\nfn sort3Desc(a: f32, b: f32, c: f32) -> vec3<f32> {\r\n  return vec3<f32>(\r\n    max(a, max(b, c)),\r\n    max(min(a, b), min(max(a, b), c)),\r\n    min(a, min(b, c))\r\n  );\r\n}\r\n\r\nfn getPlaneIntersections(rayOrigin: vec3<f32>, rayDirection:vec3<f32>, nodeSize: f32) -> vec3<f32> {\r\n    let boxExtents = nodeSize * 0.5;\r\n\r\n    var yPlaneIntersectionTNear = planeIntersection(rayOrigin, rayDirection, vec3(0.0, -1, 0.0), boxExtents);\r\n    var xPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(-1, 0.0, 0.0), boxExtents);\r\n    var zPlaneIntersectionTNear  = planeIntersection(rayOrigin, rayDirection, vec3(0.0, 0.0, -1), boxExtents);\r\n\r\n    // If the intersection is outside the bounds of the node, set it to a large value to ignore it\r\n    let yPlaneHitPosition = rayOrigin + rayDirection * yPlaneIntersectionTNear  - EPSILON;\r\n    if(any(yPlaneHitPosition < vec3(0.0)) || any(yPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      yPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n    let xPlaneHitPosition = rayOrigin + rayDirection * xPlaneIntersectionTNear  - EPSILON;\r\n    if(any(xPlaneHitPosition < vec3(0.0)) || any(xPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      xPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n    let zPlaneHitPosition = rayOrigin + rayDirection * zPlaneIntersectionTNear  - EPSILON;\r\n    if(any(zPlaneHitPosition < vec3(0.0)) || any(zPlaneHitPosition > vec3(f32(nodeSize)))){\r\n      zPlaneIntersectionTNear  = 10000.0;\r\n    }\r\n\r\n    return vec3(xPlaneIntersectionTNear, yPlaneIntersectionTNear, zPlaneIntersectionTNear);\r\n}\r\n\r\nconst DISTANCE_THRESHOLDS =\r\n  array<vec2<f32>, 4>(\r\n    vec2<f32>(2.0, 500),\r\n    vec2<f32>(4.0, 1000),\r\n    vec2<f32>(8.0, 1500),\r\n    vec2<f32>(16.0, 2000)\r\n  );\r\n\r\nfn rayMarchOctree(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>, maxDistance: f32) -> RayMarchResult {\r\n    let halfExtents = voxelObject.size * 0.5;\r\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz + halfExtents;\r\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n    var output = RayMarchResult();\r\n\r\n    // Set the initial t value to the far plane - essentially an out of bounds value\r\n    output.t = FAR_PLANE;\r\n\r\n    // Create a stack to hold the indices of the nodes we need to check\r\n    var stack = stacku32_new();\r\n\r\n    // Push the root node index onto the stack\r\n    stacku32_push(&stack, voxelObject.octreeBufferIndex);\r\n\r\n    // Main loop\r\n    while (stack.head > 0u && output.iterations < MAX_STEPS) {\r\n      output.iterations += 1u;\r\n      let nodeIndex = stacku32_pop(&stack);\r\n      let node = octreeBuffer[nodeIndex];\r\n\r\n      // Get the current nodes data\r\n      let internalNode = unpackInternal(node);\r\n\r\n      // Get the size of the node to get the center for plane intersections\r\n      let nodeSize = f32(internalNode.size);\r\n      let nodeOrigin = vec3<f32>(internalNode.position);\r\n      let nodeRayOrigin = objectRayOrigin - nodeOrigin;\r\n\r\n      if((isLeaf(node) && output.iterations > 1u)){\r\n        // TODO: find out how to get normal without extra intersection\r\n        let leafNode = unpackLeaf(node);\r\n        let nodeIntersection = boxIntersection(nodeRayOrigin, objectRayDirection, vec3(nodeSize * 0.5));\r\n        output.hit = true;\r\n        output.t = nodeIntersection.tNear;\r\n        output.normal = nodeIntersection.normal;\r\n        output.colour = vec3<f32>(leafNode.colour) / 255.0;\r\n//        output.colour = vec3(f32(output.iterations) / 32.0);\r\n        return output;\r\n      }\r\n\r\n      let centerOfChild = vec3(nodeSize * 0.5);\r\n\r\n      // Use planes to find the "inner" intersections\r\n      let planeIntersections = getPlaneIntersections(nodeRayOrigin, objectRayDirection, nodeSize);\r\n\r\n      // Get the closest plane intersection\r\n      let sortedIntersections = sort3Desc(planeIntersections[0], planeIntersections[1], planeIntersections[2]);\r\n\r\n      // Get the side of the planes that the ray is on\r\n      let sideOfPlanes = sign(nodeRayOrigin - centerOfChild);\r\n\r\n      // Push the children onto the stack, furthest first\r\n      for(var i = 0u; i < 3u; i++){\r\n        if(sortedIntersections[i] > maxDistance || sortedIntersections[i] < 0.0){\r\n          continue;\r\n        }\r\n\r\n        var hitPosition = nodeRayOrigin + objectRayDirection * sortedIntersections[i] - sideOfPlanes * EPSILON;\r\n        let hitOctant = vec3<u32>(hitPosition >= centerOfChild);\r\n        let hitIndex = octantOffsetToIndex(hitOctant);\r\n\r\n        // If the child is present, push it onto the stack\r\n        if(getBit(internalNode.childMask, hitIndex)){\r\n           let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\r\n           stacku32_push(&stack, childIndex);\r\n        }\r\n      }\r\n\r\n\r\n      // Check if the ray intersects the node, if not, skip it\r\n      let nodeT = cubeIntersection(nodeRayOrigin, objectRayDirection, nodeSize * 0.5);\r\n      if(nodeT > maxDistance || nodeT < 0.0){\r\n        continue;\r\n      }\r\n      let intersectionPoint = nodeRayOrigin + objectRayDirection * nodeT;\r\n      let hitOctant = vec3<u32>(intersectionPoint >= centerOfChild);\r\n      let hitIndex = octantOffsetToIndex(hitOctant);\r\n\r\n      // If the child is present, push it onto the stack\r\n      if(getBit(internalNode.childMask, hitIndex)){\r\n        let childIndex = nodeIndex + internalNode.firstChildOffset + hitIndex;\r\n        stacku32_push(&stack, childIndex);\r\n      }\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n\r\nconst colours = array<vec3<f32>, 8>(\r\n  vec3<f32>(0.5),\r\n  vec3<f32>(1.0, 0.0, 0.0),\r\n  vec3<f32>(0.0, 1.0, 0.0),\r\n  vec3<f32>(1.0, 1.0, 0.0),\r\n  vec3<f32>(0.0, 0.0, 1.0),\r\n  vec3<f32>(1.0, 0.0, 1.0),\r\n  vec3<f32>(0.0, 1.0, 1.0),\r\n  vec3<f32>(1.0, 1.0, 1.0)\r\n);\r\n\r\nfn debugColourFromIndex(index: i32) -> vec3<f32> {\r\n  return colours[index % 8];\r\n}\r\n',h="const BRICK_SIZE = 8;\r\nconst MAX_BVH_STEPS = 256;\r\n\r\n\r\nstruct BVHNode {\r\n  leftIndex: i32,\r\n  rightIndex: i32,\r\n  objectCount: u32,\r\n  AABBMin: vec3<f32>,\r\n  AABBMax: vec3<f32>,\r\n  parentIndex: i32,\r\n  siblingIndex: i32,\r\n}\r\n\r\nfn nodeRayIntersection(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, node: BVHNode) -> f32 {\r\n  if(all(rayOrigin >= node.AABBMin) && all(rayOrigin <= node.AABBMax)){\r\n    return 0.0;\r\n  }\r\n  let boxSize = (node.AABBMax - node.AABBMin) / 2;\r\n  let intersection = boxIntersection(rayOrigin - node.AABBMin, rayDirection, boxSize);\r\n  if(intersection.isHit){\r\n    return intersection.tNear;\r\n  }\r\n  return -1.0;\r\n}\r\n\r\n// Stack-based BVH traversal\r\nfn rayMarchBVH(rayOrigin: vec3<f32>, rayDirection: vec3<f32>) -> RayMarchResult {\r\n  var closestIntersection = RayMarchResult();\r\n closestIntersection.t = FAR_PLANE;\r\n\r\n  // Create a stack to store the nodes to visit\r\n  var stack = stack_new();\r\n  stack_push(&stack, 0);\r\n\r\n  var iterations = 0;\r\n  var closestRayMarchDistance = FAR_PLANE;\r\n\r\n  while (stack.head > 0u && iterations < MAX_BVH_STEPS) {\r\n    let nodeIndex = stack_pop(&stack);\r\n    let node = bvhNodes[nodeIndex];\r\n    if(node.objectCount > 1){\r\n      let leftNode = bvhNodes[node.leftIndex];\r\n      let rightNode = bvhNodes[node.rightIndex];\r\n      let leftDist = nodeRayIntersection(rayOrigin, rayDirection, leftNode);\r\n      let rightDist = nodeRayIntersection(rayOrigin, rayDirection, rightNode);\r\n      let hitLeft = leftDist >= 0.0 && leftDist < closestIntersection.t;\r\n      let hitRight = rightDist >= 0.0 && rightDist < closestIntersection.t;\r\n      if(hitLeft && hitRight){\r\n        if(leftDist < rightDist){\r\n          // left is closer, push right to stack\r\n          stack_push(&stack, node.rightIndex);\r\n          stack_push(&stack, node.leftIndex);\r\n        } else {\r\n          // right is closer, push left to stack\r\n          stack_push(&stack, node.leftIndex);\r\n          stack_push(&stack, node.rightIndex);\r\n        }\r\n      }\r\n      // We only hit the right Node\r\n      else if(hitRight){\r\n        stack_push(&stack, node.rightIndex);\r\n      }\r\n      else if(hitLeft){\r\n        stack_push(&stack, node.leftIndex);\r\n      }\r\n    }\r\n    // valid leaf, raymarch it\r\n    else if(node.objectCount == 1){\r\n        let voxelObject = voxelObjects[node.leftIndex];\r\n        var rayMarchResult = rayMarchOctree(voxelObject, rayDirection, rayOrigin, 9999.0);\r\n        if(rayMarchResult.hit && rayMarchResult.t < closestIntersection.t){\r\n           closestIntersection = rayMarchResult;\r\n        }\r\n    }\r\n    iterations += 1;\r\n//    closestIntersection.colour += vec3<f32>(0.005);\r\n  }\r\n\r\n  return closestIntersection;\r\n}",d=Symbol(),p=e=>new Proxy(e,{construct:(e,t,n)=>e.prototype!==n.prototype?Reflect.construct(e,t,n):(e[d]||(e[d]=Reflect.construct(e,t,n)),e[d])}),f="rgba16float";const m=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,g=(e,t,n=m)=>{let r=class{#a;#l;#c;#u;#h=t;#d=n;#p=e;constructor(r,i,s){this.#a=r.createTexture({label:e,size:[i,s,1],format:t,usage:n}),this.#l=this.#a.createView({label:e}),this.#c=i,this.#u=s}get texture(){return this.#a}get view(){return this.#l}get width(){return this.#c}get height(){return this.#u}get format(){return this.#h}get usage(){return this.#d}get label(){return this.#p}};return r=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o}([p],r),r},v=g("albedo","rgba16float"),y=g("normal","rgba16float"),x=g("depth","depth32float",GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST),w=g("velocity","rgba16float"),b=g("world position","rgba32float"),_=g("output",f),S=async()=>{const e=await(async()=>{const e={binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},t={binding:9,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},n={binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},r={binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},i={binding:7,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float",viewDimension:"2d"}},s={binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},o={binding:6,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba32float",viewDimension:"2d"}},d={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},p=(GPUShaderStage.COMPUTE,{binding:13,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),f=Sr.createBindGroupLayout({label:"raymarch g-buffer",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},e,{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},d,n,r,i,{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},s,p,o,t]}),m=await Sr.createComputePipelineAsync({label:"raymarch g-buffer",layout:Sr.createPipelineLayout({bindGroupLayouts:[f]}),compute:{module:Sr.createShaderModule({code:`\n          struct Time {\n            frame: u32,\n            deltaTime: f32\n          };\n          @group(0) @binding(0) var voxels : texture_3d<f32>;\n          @group(0) @binding(1) var<uniform> time : Time;\n          @group(0) @binding(2) var<uniform> cameraPosition : vec3<f32>;\n          @group(0) @binding(3) var<storage> voxelObjects : array<VoxelObject>;\n          @group(0) @binding(4) var normalTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(5) var albedoTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(6) var worldPosTex : texture_storage_2d<rgba32float, write>;\n          @group(0) @binding(7) var velocityTex : texture_storage_2d<rgba16float, write>;\n          @group(0) @binding(8) var<uniform> viewProjections : ViewProjectionMatrices;\n          @group(0) @binding(9) var blueNoiseTex : texture_2d<f32>;\n          @group(0) @binding(10) var<storage> bvhNodes: array<BVHNode>;\n          @group(0) @binding(13) var<storage> octreeBuffer : array<vec2<u32>>;\n          ${a}\n          ${l}\n          ${c}\n          ${u}\n          ${h}\n          // TODO: actually make linear\r\nfn distanceToReversedLinearDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n  return (far - cameraDistance) / (far - near);//Reversed\r\n}\r\n\r\nfn reversedLinearDepthToDistance(linearDepth: f32, near: f32, far: f32) -> f32 {\r\n    return far - linearDepth * (far - near); //Reversed\r\n}\r\n\r\nfn distanceToLogarithmicDepth(cameraDistance: f32, near: f32, far: f32) -> f32 {\r\n    return log2(cameraDistance / near + 1.0) / log2(far / near + 1.0);\r\n}\r\n\r\nfn logarithmicDepthToDistance(logDepth: f32, near: f32, far: f32) -> f32 {\r\n    let base = far / near + 1.0;\r\n    return near * (pow(base, logDepth) - 1.0);\r\n}\n          struct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>,\r\n  viewMatrix : mat4x4<f32>,\r\n};\r\n\r\n\r\nfn plainIntersect(ro: vec3<f32>, rd: vec3<f32>, p: vec4<f32>) -> f32 {\r\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\r\n}\r\n\r\nfn getVelocityStatic(worldPos: vec3<f32>, viewProjections:ViewProjectionMatrices) -> vec2<f32>{\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  let clipSpace = vp * vec4(worldPos.xyz, 1.0);\r\n  let previousClipSpace = previousVp * vec4(worldPos.xyz, 1.0);\r\n\r\n  let ndc = clipSpace.xyz / clipSpace.w;\r\n  let previousNdc = previousClipSpace.xyz / previousClipSpace.w;\r\n\r\n  var uv = ndc.xy * 0.5 + 0.5;\r\n  var previousUv = previousNdc.xy * 0.5 + 0.5;\r\n\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getVelocity(objectPos: vec3<f32>, modelMatrix: mat4x4<f32>, previousModelMatrix: mat4x4<f32>, viewProjections: ViewProjectionMatrices) -> vec2<f32> {\r\n  let vp = viewProjections.viewProjection;\r\n  let previousVp = viewProjections.previousViewProjection;\r\n\r\n  // Get current object space position of the current pixel\r\n  let objectClipSpace = vp * modelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let objectNDC = objectClipSpace.xyz / objectClipSpace.w;\r\n\r\n  // Get previous position of the current object space position\r\n  let previousObjectClipSpace = previousVp * previousModelMatrix * vec4(objectPos.xyz, 1.0);\r\n  let previousObjectNDC = previousObjectClipSpace.xyz / previousObjectClipSpace.w;\r\n\r\n  // UV\r\n  var uv = objectNDC.xy * 0.5 + 0.5;\r\n  var previousUv = previousObjectNDC.xy * 0.5 + 0.5;\r\n  uv.y = 1.0 - uv.y;\r\n  previousUv.y = 1.0 - previousUv.y;\r\n\r\n  // Get velocity based on the difference between the current and previous positions\r\n  var velocity = previousUv - uv;\r\n  return velocity;\r\n}\r\n\r\nfn getLeftChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 1;\r\n}\r\n\r\nfn getRightChildIndex(index: i32) -> i32 {\r\n  return index * 2 + 2;\r\n}\r\n\r\nfn getParentIndex(index: i32) -> i32 {\r\n  return (index - 1) / 2;\r\n}\r\n\r\n\r\nfn dirIsNegative(dir: vec3<f32>, axis: i32) -> bool {\r\n  return dir[axis] < 0.0;\r\n}\r\n\r\nfn getDebugColour(index: i32) -> vec3<f32> {\r\n  let colours = array<vec3<f32>, 6>(\r\n    vec3<f32>(1.0, 0.0, 0.0),\r\n    vec3<f32>(0.0, 1.0, 0.0),\r\n    vec3<f32>(0.0, 0.0, 1.0),\r\n    vec3<f32>(1.0, 1.0, 0.0),\r\n    vec3<f32>(1.0, 0.0, 1.0),\r\n    vec3<f32>(0.0, 1.0, 1.0)\r\n  );\r\n  return colours[index % 6];\r\n}\r\n\r\n\r\nfn customNormalize(value: f32, min: f32, max: f32) -> f32 {\r\n    return (value - min) / (max - min);\r\n}\r\n\r\nconst IDENTITY_MATRIX = mat4x4<f32>(\r\n  vec4<f32>(1.0, 0.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 1.0, 0.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\r\n  vec4<f32>(0.0, 0.0, 0.0, 1.0)\r\n);\r\n\r\nfn intersectSphere(origin: vec3<f32>, dir: vec3<f32>, spherePos: vec3<f32>, sphereRad: f32) -> f32\r\n{\r\n\tlet oc = origin - spherePos;\r\n\tlet b = 2.0 * dot(dir, oc);\r\n\tlet c = dot(oc, oc) - sphereRad*sphereRad;\r\n\tlet disc = b * b - 4.0 * c;\r\n\tif (disc < 0.0)\r\n\t{\r\n\t  return -1.0;\r\n\t}\r\n\r\n//    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\r\n  let q = (-b + select(sqrt(disc), -sqrt(disc), b < 0.0)) / 2.0;\r\n\tvar t0 = q;\r\n\tvar t1 = c / q;\r\n\tif (t0 > t1) {\r\n\t\tvar temp = t0;\r\n\t\tt0 = t1;\r\n\t\tt1 = temp;\r\n\t}\r\n\tif (t1 < 0.0){\r\n\t  return -1.0;\r\n\t}\r\n\r\n  return select(t0, t1, t0 < 0.0);\r\n}\r\n\r\nfn skyDomeIntersection(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\r\n    return intersectSphere(ro, rd, vec3<f32>(0.0, 0.0, 0.0), FAR_PLANE);\r\n}\r\n\r\nconst BLUE_NOISE_SIZE = 511;\r\n\r\nfn tracePixel(pixel: vec2<u32>){\r\n   let resolution = textureDimensions(albedoTex);\r\n   var uv = vec2<f32>(pixel) / vec2<f32>(resolution);\r\n   var rayDirection = calculateRayDirection(uv,viewProjections.inverseViewProjection);\r\n\r\n    // DOF\r\n    let blueNoiseOffset = vec2<u32>(0);\r\n    var blueNoisePixel = pixel;\r\n    blueNoisePixel.x += time.frame * 32;\r\n    blueNoisePixel.y += time.frame * 16;\r\n    blueNoisePixel = (blueNoisePixel + blueNoiseOffset) % BLUE_NOISE_SIZE;\r\n    if(time.frame % 2 == 0){\r\n      blueNoisePixel.y = BLUE_NOISE_SIZE - blueNoisePixel.y;\r\n    }\r\n    if(time.frame % 3 == 0){\r\n      blueNoisePixel.x = BLUE_NOISE_SIZE - blueNoisePixel.x;\r\n    }\r\n    var r = textureLoad(blueNoiseTex, blueNoisePixel, 0).rg;\r\n    let aperture = 0.0;\r\n    let focalDistance = 100.0;\r\n    let randomOffset = randomInUnitDisk(r) * aperture;\r\n    let cameraRight = vec3(viewProjections.viewMatrix[0].x, viewProjections.viewMatrix[1].x, viewProjections.viewMatrix[2].x);\r\n    let cameraUp = vec3(viewProjections.viewMatrix[0].y, viewProjections.viewMatrix[1].y, viewProjections.viewMatrix[2].y);\r\n    let rayOrigin = cameraPosition + randomOffset.x * cameraRight + randomOffset.y * cameraUp;\r\n    let focalPoint = cameraPosition + normalize(rayDirection) * focalDistance;\r\n    rayDirection = normalize(focalPoint - rayOrigin);\r\n\r\n    var closestIntersection = RayMarchResult();\r\n    var worldPos = vec3(0.0);\r\n    var normal = vec3(0.0);\r\n    var albedo = vec3(0.0);\r\n    var velocity = vec2(0.0);\r\n    let bvhResult = rayMarchBVH(rayOrigin, rayDirection);\r\n    if(bvhResult.hit){\r\n      let voxelObject = voxelObjects[bvhResult.voxelObjectIndex];\r\n      albedo = bvhResult.colour;\r\n      worldPos = rayOrigin + rayDirection * bvhResult.t;\r\n      normal = transformNormal(voxelObject.inverseTransform,vec3<f32>(bvhResult.normal));\r\n    }\r\n    else{\r\n      albedo = vec3(0.0);\r\n      worldPos = rayOrigin + skyDomeIntersection(rayOrigin, rayDirection) * rayDirection;\r\n    }\r\n    velocity = getVelocityStatic(worldPos, viewProjections);\r\n\r\n    textureStore(albedoTex, pixel, vec4(albedo, 1));\r\n    textureStore(normalTex, pixel, vec4(normal,1));\r\n    textureStore(velocityTex, pixel, vec4(velocity,0,f32(bvhResult.voxelObjectIndex)));\r\n    textureStore(worldPosTex, pixel, vec4(worldPos,bvhResult.t));\r\n}\r\n\r\n@compute @workgroup_size(16, 8, 1)\r\nfn main(\r\n   @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  tracePixel(pixel);\r\n}\r\n\r\n@group(1) @binding(0) var<storage, read> screenRayBuffer : array<vec2<u32>>;\r\n\r\nconst REMAINING_RAY_OFFSETS = array<vec2<u32>, 8>(\r\n  vec2<u32>(0,1),\r\n  vec2<u32>(1,0),\r\n  vec2<u32>(1,1),\r\n  vec2<u32>(2,0),\r\n  vec2<u32>(2,1),\r\n  vec2<u32>(0,2),\r\n  vec2<u32>(1,2),\r\n  vec2<u32>(2,2)\r\n);\r\n\r\n@compute @workgroup_size(64, 1, 1)\r\nfn bufferMarch(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>,\r\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\r\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\r\n) {\r\n  let bufferIndex = GlobalInvocationID.x / 8;\r\n  let localRayIndex = GlobalInvocationID.x % 8;\r\n  let pixel = screenRayBuffer[bufferIndex];\r\n  let offsetPixel = pixel + REMAINING_RAY_OFFSETS[localRayIndex];\r\n\r\n  tracePixel(offsetPixel);\r\n//  textureStore(depthWrite, offsetPixel, vec4(0,0,0,0));\r\n//   textureStore(albedoTex, offsetPixel, vec4(1,0,0,1));\r\n}`}),entryPoint:"main"}});let g;return(e,t)=>{g=(e=>Sr.createBindGroup({layout:f,entries:[{binding:0,resource:e.volumeAtlas.atlasTextureView},{binding:1,resource:{buffer:e.timeBuffer}},{binding:2,resource:{buffer:e.cameraPositionBuffer}},{binding:3,resource:{buffer:e.transformationMatrixBuffer}},{binding:4,resource:e.outputTextures.normalTexture.view},{binding:5,resource:e.outputTextures.albedoTexture.view},{binding:6,resource:e.outputTextures.worldPositionTexture.view},{binding:7,resource:e.outputTextures.velocityTexture.view},{binding:8,resource:{buffer:e.viewProjectionMatricesBuffer}},{binding:9,resource:e.blueNoiseTextureView},{binding:10,resource:{buffer:e.bvhBuffer}},{binding:13,resource:{buffer:e.volumeAtlas.octreeBuffer}}]}))(t),e.setPipeline(m),e.setBindGroup(0,g),e.dispatchWorkgroups(Math.ceil(kr[0]/16),Math.ceil(kr[1]/8))}})();let t,n,r,i={albedoTexture:null,velocityTexture:null,depthTexture:null,normalTexture:null};return{render:s=>{if(!n){n=Sr.createBuffer({size:12,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),t=Sr.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const e=new Uint32Array(3);e[0]=1,e[1]=1,e[2]=1,Sr.queue.writeBuffer(n,0,e,0,e.length);const{width:i,height:a}=s.outputTextures.finalTexture,l=(o=i/3*(a/3)*4,4,4*Math.ceil(o/4));r=Sr.createBuffer({size:l,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}var o;Object.keys(i).forEach((e=>{const t=s.outputTextures[e];null===i[e]&&(i[e]=((e,t)=>new(g(`${t.label}-copy`,t.format,t.usage))(e,t.width,t.height))(Sr,t))}));const{commandEncoder:a,timestampWrites:l}=s;a.clearBuffer(n,0,4),a.clearBuffer(t,0,4),a.clearBuffer(r);let c=a.beginComputePass({timestampWrites:l});e(c,s),c.end()},label:"primary rays",timestampLabels:["full raymarch"]}};class k{constructor(e,t,n,r,i="div"){this.parent=e,this.object=t,this.property=n,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(i),this.domElement.classList.add("controller"),this.domElement.classList.add(r),this.$name=document.createElement("div"),this.$name.classList.add("name"),k.nextNameID=k.nextNameID||0,this.$name.id="lil-gui-name-"+ ++k.nextNameID,this.$widget=document.createElement("div"),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.domElement.addEventListener("keydown",(e=>e.stopPropagation())),this.domElement.addEventListener("keyup",(e=>e.stopPropagation())),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(n)}name(e){return this._name=e,this.$name.textContent=e,this}onChange(e){return this._onChange=e,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(e=!0){return this.disable(!e)}disable(e=!0){return e===this._disabled||(this._disabled=e,this.domElement.classList.toggle("disabled",e),this.$disable.toggleAttribute("disabled",e)),this}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(e){const t=this.parent.add(this.object,this.property,e);return t.name(this._name),this.destroy(),t}min(e){return this}max(e){return this}step(e){return this}decimals(e){return this}listen(e=!0){return this._listening=e,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const e=this.save();e!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=e}getValue(){return this.object[this.property]}setValue(e){return this.getValue()!==e&&(this.object[this.property]=e,this._callOnChange(),this.updateDisplay()),this}updateDisplay(){return this}load(e){return this.setValue(e),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class T extends k{constructor(e,t,n){super(e,t,n,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",(()=>{this.setValue(this.$input.checked),this._callOnFinishChange()})),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function E(e){let t,n;return(t=e.match(/(#|0x)?([a-f0-9]{6})/i))?n=t[2]:(t=e.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?n=parseInt(t[1]).toString(16).padStart(2,0)+parseInt(t[2]).toString(16).padStart(2,0)+parseInt(t[3]).toString(16).padStart(2,0):(t=e.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(n=t[1]+t[1]+t[2]+t[2]+t[3]+t[3]),!!n&&"#"+n}const A={isPrimitive:!0,match:e=>"number"==typeof e,fromHexString:e=>parseInt(e.substring(1),16),toHexString:e=>"#"+e.toString(16).padStart(6,0)},P={isPrimitive:!1,match:e=>Array.isArray(e),fromHexString(e,t,n=1){const r=A.fromHexString(e);t[0]=(r>>16&255)/255*n,t[1]=(r>>8&255)/255*n,t[2]=(255&r)/255*n},toHexString:([e,t,n],r=1)=>A.toHexString(e*(r=255/r)<<16^t*r<<8^n*r<<0)},M={isPrimitive:!1,match:e=>Object(e)===e,fromHexString(e,t,n=1){const r=A.fromHexString(e);t.r=(r>>16&255)/255*n,t.g=(r>>8&255)/255*n,t.b=(255&r)/255*n},toHexString:({r:e,g:t,b:n},r=1)=>A.toHexString(e*(r=255/r)<<16^t*r<<8^n*r<<0)},C=[{isPrimitive:!0,match:e=>"string"==typeof e,fromHexString:E,toHexString:E},A,P,M];class z extends k{constructor(e,t,n,r){var i;super(e,t,n,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(i=this.initialValue,C.find((e=>e.match(i)))),this._rgbScale=r,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",(()=>{this._setValueFromHexString(this.$input.value)})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$text.addEventListener("input",(()=>{const e=E(this.$text.value);e&&this._setValueFromHexString(e)})),this.$text.addEventListener("focus",(()=>{this._textFocused=!0,this.$text.select()})),this.$text.addEventListener("blur",(()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()})),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(e){if(this._format.isPrimitive){const t=this._format.fromHexString(e);this.setValue(t)}else this._format.fromHexString(e,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(e){return this._setValueFromHexString(e),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class I extends k{constructor(e,t,n){super(e,t,n,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",(e=>{e.preventDefault(),this.getValue().call(this.object),this._callOnChange()})),this.$button.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$disable=this.$button}}class B extends k{constructor(e,t,n,r,i,s){super(e,t,n,"number"),this._initInput(),this.min(r),this.max(i);const o=void 0!==s;this.step(o?s:this._getImplicitStep(),o),this.updateDisplay()}decimals(e){return this._decimals=e,this.updateDisplay(),this}min(e){return this._min=e,this._onUpdateMinMax(),this}max(e){return this._max=e,this._onUpdateMinMax(),this}step(e,t=!0){return this._step=e,this._stepExplicit=t,this}updateDisplay(){const e=this.getValue();if(this._hasSlider){let t=(e-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=100*t+"%"}return this._inputFocused||(this.$input.value=void 0===this._decimals?e:e.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),window.matchMedia("(pointer: coarse)").matches&&(this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any")),this.$widget.appendChild(this.$input),this.$disable=this.$input;const e=e=>{const t=parseFloat(this.$input.value);isNaN(t)||(this._snapClampSetValue(t+e),this.$input.value=this.getValue())};let t,n,r,i,s,o=!1;const a=e=>{if(o){const r=e.clientX-t,i=e.clientY-n;Math.abs(i)>5?(e.preventDefault(),this.$input.blur(),o=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(r)>5&&l()}if(!o){const t=e.clientY-r;s-=t*this._step*this._arrowKeyMultiplier(e),i+s>this._max?s=this._max-i:i+s<this._min&&(s=this._min-i),this._snapClampSetValue(i+s)}r=e.clientY},l=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",a),window.removeEventListener("mouseup",l)};this.$input.addEventListener("input",(()=>{let e=parseFloat(this.$input.value);isNaN(e)||(this._stepExplicit&&(e=this._snap(e)),this.setValue(this._clamp(e)))})),this.$input.addEventListener("keydown",(t=>{"Enter"===t.key&&this.$input.blur(),"ArrowUp"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t))),"ArrowDown"===t.code&&(t.preventDefault(),e(this._step*this._arrowKeyMultiplier(t)*-1))})),this.$input.addEventListener("wheel",(t=>{this._inputFocused&&(t.preventDefault(),e(this._step*this._normalizeMouseWheel(t)))}),{passive:!1}),this.$input.addEventListener("mousedown",(e=>{t=e.clientX,n=r=e.clientY,o=!0,i=this.getValue(),s=0,window.addEventListener("mousemove",a),window.addEventListener("mouseup",l)})),this.$input.addEventListener("focus",(()=>{this._inputFocused=!0})),this.$input.addEventListener("blur",(()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()}))}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const e=e=>{const t=this.$slider.getBoundingClientRect();let n=((e,t,n,r,i)=>(e-t)/(n-t)*(this._max-r)+r)(e,t.left,t.right,this._min);this._snapClampSetValue(n)},t=t=>{e(t.clientX)},n=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",t),window.removeEventListener("mouseup",n)};let r,i,s=!1;const o=t=>{t.preventDefault(),this._setDraggingStyle(!0),e(t.touches[0].clientX),s=!1},a=t=>{if(s){const e=t.touches[0].clientX-r,n=t.touches[0].clientY-i;Math.abs(e)>Math.abs(n)?o(t):(window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l))}else t.preventDefault(),e(t.touches[0].clientX)},l=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",a),window.removeEventListener("touchend",l)},c=this._callOnFinishChange.bind(this);let u;this.$slider.addEventListener("mousedown",(r=>{this._setDraggingStyle(!0),e(r.clientX),window.addEventListener("mousemove",t),window.addEventListener("mouseup",n)})),this.$slider.addEventListener("touchstart",(e=>{e.touches.length>1||(this._hasScrollBar?(r=e.touches[0].clientX,i=e.touches[0].clientY,s=!0):o(e),window.addEventListener("touchmove",a,{passive:!1}),window.addEventListener("touchend",l))}),{passive:!1}),this.$slider.addEventListener("wheel",(e=>{if(Math.abs(e.deltaX)<Math.abs(e.deltaY)&&this._hasScrollBar)return;e.preventDefault();const t=this._normalizeMouseWheel(e)*this._step;this._snapClampSetValue(this.getValue()+t),this.$input.value=this.getValue(),clearTimeout(u),u=setTimeout(c,400)}),{passive:!1})}_setDraggingStyle(e,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",e),document.body.classList.toggle("lil-gui-dragging",e),document.body.classList.toggle(`lil-gui-${t}`,e)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(e){let{deltaX:t,deltaY:n}=e;return Math.floor(e.deltaY)!==e.deltaY&&e.wheelDelta&&(t=0,n=-e.wheelDelta/120,n*=this._stepExplicit?1:10),t+-n}_arrowKeyMultiplier(e){let t=this._stepExplicit?1:10;return e.shiftKey?t*=10:e.altKey&&(t/=10),t}_snap(e){const t=Math.round(e/this._step)*this._step;return parseFloat(t.toPrecision(15))}_clamp(e){return e<this._min&&(e=this._min),e>this._max&&(e=this._max),e}_snapClampSetValue(e){this.setValue(this._clamp(this._snap(e)))}get _hasScrollBar(){const e=this.parent.root.$children;return e.scrollHeight>e.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class O extends k{constructor(e,t,n,r){super(e,t,n,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$select.addEventListener("change",(()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()})),this.$select.addEventListener("focus",(()=>{this.$display.classList.add("focus")})),this.$select.addEventListener("blur",(()=>{this.$display.classList.remove("focus")})),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.options(r)}options(e){return this._values=Array.isArray(e)?e:Object.values(e),this._names=Array.isArray(e)?e:Object.keys(e),this.$select.replaceChildren(),this._names.forEach((e=>{const t=document.createElement("option");t.textContent=e,this.$select.appendChild(t)})),this.updateDisplay(),this}updateDisplay(){const e=this.getValue(),t=this._values.indexOf(e);return this.$select.selectedIndex=t,this.$display.textContent=-1===t?e:this._names[t],this}}class R extends k{constructor(e,t,n){super(e,t,n,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("spellcheck","false"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",(()=>{this.setValue(this.$input.value)})),this.$input.addEventListener("keydown",(e=>{"Enter"===e.code&&this.$input.blur()})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let N=!1;class U{constructor({parent:e,autoPlace:t=void 0===e,container:n,width:r,title:i="Controls",closeFolders:s=!1,injectStyles:o=!0,touchStyles:a=!0}={}){if(this.parent=e,this.root=e?e.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",(()=>this.openAnimated(this._closed))),this.$title.addEventListener("keydown",(e=>{"Enter"!==e.code&&"Space"!==e.code||(e.preventDefault(),this.$title.click())})),this.$title.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(i),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add("root"),a&&this.domElement.classList.add("allow-touch-styles"),!N&&o&&(function(e){const t=document.createElement("style");t.innerHTML='.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;\n  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n  background: var(--background-color);\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller > .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: " ";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: "lil-gui";\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-dragging .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-dragging * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui-dragging.lil-gui-vertical * {\n  cursor: ns-resize !important;\n}\n\n.lil-gui .title {\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: "lil-gui";\n  content: "";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  body:not(.lil-gui-dragging) .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: "";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: "Empty";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui label, .lil-gui input, .lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n}\n.lil-gui input {\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input:disabled {\n  opacity: 1;\n}\n.lil-gui input[type=text],\n.lil-gui input[type=number] {\n  padding: var(--widget-padding);\n  -moz-appearance: textfield;\n}\n.lil-gui input[type=text]:focus,\n.lil-gui input[type=number]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  width: var(--checkbox-size);\n  height: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n  cursor: pointer;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: "lil-gui";\n  content: "";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: none;\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: "lil-gui";\n  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");\n}';const n=document.querySelector("head link[rel=stylesheet], head style");n?document.head.insertBefore(t,n):document.head.appendChild(t)}(),N=!0),n?n.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),r&&this.domElement.style.setProperty("--width",r+"px"),this._closeFolders=s}add(e,t,n,r,i){if(Object(n)===n)return new O(this,e,t,n);const s=e[t];switch(typeof s){case"number":return new B(this,e,t,n,r,i);case"boolean":return new T(this,e,t);case"string":return new R(this,e,t);case"function":return new I(this,e,t)}console.error("gui.add failed\n\tproperty:",t,"\n\tobject:",e,"\n\tvalue:",s)}addColor(e,t,n=1){return new z(this,e,t,n)}addFolder(e){const t=new U({parent:this,title:e});return this.root._closeFolders&&t.close(),t}load(e,t=!0){return e.controllers&&this.controllers.forEach((t=>{t instanceof I||t._name in e.controllers&&t.load(e.controllers[t._name])})),t&&e.folders&&this.folders.forEach((t=>{t._title in e.folders&&t.load(e.folders[t._title])})),this}save(e=!0){const t={controllers:{},folders:{}};return this.controllers.forEach((e=>{if(!(e instanceof I)){if(e._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${e._name}"`);t.controllers[e._name]=e.save()}})),e&&this.folders.forEach((e=>{if(e._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${e._title}"`);t.folders[e._title]=e.save()})),t}open(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(e){this._closed!==e&&(this._closed=e,this._callOnOpenClose(this))}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame((()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const n=e=>{e.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",n))};this.$children.addEventListener("transitionend",n);const r=e?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!e),requestAnimationFrame((()=>{this.$children.style.height=r+"px"}))})),this}title(e){return this._title=e,this.$title.textContent=e,this}reset(e=!0){return(e?this.controllersRecursive():this.controllers).forEach((e=>e.reset())),this}onChange(e){return this._onChange=e,this}_callOnChange(e){this.parent&&this.parent._callOnChange(e),void 0!==this._onChange&&this._onChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(e){this.parent&&this.parent._callOnFinishChange(e),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onOpenClose(e){return this._onOpenClose=e,this}_callOnOpenClose(e){this.parent&&this.parent._callOnOpenClose(e),void 0!==this._onOpenClose&&this._onOpenClose.call(this,e)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach((e=>e.destroy()))}controllersRecursive(){let e=Array.from(this.controllers);return this.folders.forEach((t=>{e=e.concat(t.controllersRecursive())})),e}foldersRecursive(){let e=Array.from(this.folders);return this.folders.forEach((t=>{e=e.concat(t.foldersRecursive())})),e}}const D=U,L=async e=>{const t=e.createShaderModule({code:"@group(0) @binding(0) var mySampler : sampler;\r\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\r\n//@group(0) @binding(2) var debugTexture : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  const pos = array(\r\n    vec2( 1.0,  1.0),\r\n    vec2( 1.0, -1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2( 1.0,  1.0),\r\n    vec2(-1.0, -1.0),\r\n    vec2(-1.0,  1.0),\r\n  );\r\n\r\n  const uv = array(\r\n    vec2(1.0, 0.0),\r\n    vec2(1.0, 1.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(1.0, 0.0),\r\n    vec2(0.0, 1.0),\r\n    vec2(0.0, 0.0),\r\n  );\r\n\r\n  var output : VertexOutput;\r\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\r\n  output.fragUV = uv[VertexIndex];\r\n  return output;\r\n}\r\n\r\nfn get_debug_colour(index : i32) -> vec4<f32> {\r\n  if(index < 0){\r\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\r\n  }\r\n\r\n  let colours = array(\r\n    vec4<f32>(1.0, 0.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 0.0, 1.0),\r\n    vec4<f32>(1.0, 0.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\r\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\r\n  );\r\n  return colours[index % 8];\r\n}\r\n\r\n@fragment\r\nfn fragment_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\r\n    let pixel = fragUV * vec2<f32>(textureDimensions(myTexture));\r\n    var colour = textureLoad(myTexture, vec2<u32>(pixel),0);\r\n    return colour;\r\n//    return abs(colour) % 16.0 * 0.0625;\r\n//    return colour.gggg * 0.5;\r\n//    return (colour.rrrr * 500.0 % 1.0);\r\n//    return get_debug_colour(i32(colour.a));\r\n}\r\n"}),n=e.createRenderPipeline({layout:"auto",vertex:{module:t,entryPoint:"vertex_main"},fragment:{module:t,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]}});return{render:t=>{const r=t.commandEncoder.beginRenderPass({timestampWrites:t.timestampWrites,colorAttachments:[{view:wr.getCurrentTexture().createView(),loadOp:"clear",clearValue:[.3,.3,.3,1],storeOp:"store"}]}),i=e.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:1,resource:t.outputTextures.finalTexture.view}]});r.setPipeline(n),r.setBindGroup(0,i),r.draw(6),r.end()},label:"fullscreen quad"}};var F;!function(e){const t=[];e.updateAll=e=>{for(const n of t)n.update(e)},e.register=e=>class extends e{constructor(...e){super(...e),t.push(this)}}}(F||(F={}));const q={duration:.3,delay:0,endDelay:0,repeat:0,easing:"ease"},j=e=>1e3*e,V=e=>e/1e3,G=()=>{},W=e=>e;function $(e,t=!0){if(e&&"finished"!==e.playState)try{e.stop?e.stop():(t&&e.commitStyles(),e.cancel())}catch(e){}}const H=e=>e(),Y=(e,t,n=q.duration)=>new Proxy({animations:e.map(H).filter(Boolean),duration:n,options:t},X),X={get:(e,t)=>{const n=e.animations[0];switch(t){case"duration":return e.duration;case"currentTime":return V((null==n?void 0:n[t])||0);case"playbackRate":case"playState":return null==n?void 0:n[t];case"finished":return e.finished||(e.finished=Promise.all(e.animations.map(Z)).catch(G)),e.finished;case"stop":return()=>{e.animations.forEach((e=>$(e)))};case"forEachNative":return t=>{e.animations.forEach((n=>t(n,e)))};default:return void 0===(null==n?void 0:n[t])?void 0:()=>e.animations.forEach((e=>e[t]()))}},set:(e,t,n)=>{switch(t){case"currentTime":n=j(n);case"playbackRate":for(let r=0;r<e.animations.length;r++)e.animations[r][t]=n;return!0}return!1}},Z=e=>e.finished,K=e=>"object"==typeof e&&Boolean(e.createAnimation),Q=e=>"number"==typeof e,J=e=>Array.isArray(e)&&!Q(e[0]),ee=(e,t,n)=>-n*e+n*t+e,te=(e,t,n)=>t-e==0?1:(n-e)/(t-e);function ne(e,t){const n=e[e.length-1];for(let r=1;r<=t;r++){const i=te(0,t,r);e.push(ee(n,1,i))}}const re=(e,t,n)=>Math.min(Math.max(n,e),t);const ie=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e,se=1e-7,oe=12;function ae(e,t,n,r){if(e===t&&n===r)return W;return i=>0===i||1===i?i:ie(function(e,t,n,r,i){let s,o,a=0;do{o=t+(n-t)/2,s=ie(o,r,i)-e,s>0?n=o:t=o}while(Math.abs(s)>se&&++a<oe);return o}(i,0,1,e,n),t,r)}const le=e=>"function"==typeof e,ce=e=>Array.isArray(e)&&Q(e[0]),ue={ease:ae(.25,.1,.25,1),"ease-in":ae(.42,0,1,1),"ease-in-out":ae(.42,0,.58,1),"ease-out":ae(0,0,.58,1)},he=/\((.*?)\)/;function de(e){if(le(e))return e;if(ce(e))return ae(...e);const t=ue[e];if(t)return t;if(e.startsWith("steps")){const t=he.exec(e);if(t){const e=t[1].split(",");return((e,t="end")=>n=>{const r=(n="end"===t?Math.min(n,.999):Math.max(n,.001))*e,i="end"===t?Math.floor(r):Math.ceil(r);return re(0,1,i/e)})(parseFloat(e[0]),e[1].trim())}}return W}class pe{constructor(e,t=[0,1],{easing:n,duration:r=q.duration,delay:i=q.delay,endDelay:s=q.endDelay,repeat:o=q.repeat,offset:a,direction:l="normal",autoplay:c=!0}={}){if(this.startTime=null,this.rate=1,this.t=0,this.cancelTimestamp=null,this.easing=W,this.duration=0,this.totalDuration=0,this.repeat=0,this.playState="idle",this.finished=new Promise(((e,t)=>{this.resolve=e,this.reject=t})),n=n||q.easing,K(n)){const e=n.createAnimation(t);n=e.easing,t=e.keyframes||t,r=e.duration||r}this.repeat=o,this.easing=J(n)?W:de(n),this.updateDuration(r);const u=function(e,t=function(e){const t=[0];return ne(t,e-1),t}(e.length),n=W){const r=e.length,i=r-t.length;return i>0&&ne(t,i),i=>{let s=0;for(;s<r-2&&!(i<t[s+1]);s++);let o=re(0,1,te(t[s],t[s+1],i));const a=function(e,t){return J(e)?e[((e,t,n)=>{const r=t-e;return((n-e)%r+r)%r+e})(0,e.length,t)]:e}(n,s);return o=a(o),ee(e[s],e[s+1],o)}}(t,a,J(n)?n.map(de):W);this.tick=t=>{var n;let r=0;r=void 0!==this.pauseTime?this.pauseTime:(t-this.startTime)*this.rate,this.t=r,r/=1e3,r=Math.max(r-i,0),"finished"===this.playState&&void 0===this.pauseTime&&(r=this.totalDuration);const o=r/this.duration;let a=Math.floor(o),c=o%1;!c&&o>=1&&(c=1),1===c&&a--;const h=a%2;("reverse"===l||"alternate"===l&&h||"alternate-reverse"===l&&!h)&&(c=1-c);const d=r>=this.totalDuration?1:Math.min(c,1),p=u(this.easing(d));e(p),void 0===this.pauseTime&&("finished"===this.playState||r>=this.totalDuration+s)?(this.playState="finished",null===(n=this.resolve)||void 0===n||n.call(this,p)):"idle"!==this.playState&&(this.frameRequestId=requestAnimationFrame(this.tick))},c&&this.play()}play(){const e=performance.now();this.playState="running",void 0!==this.pauseTime?this.startTime=e-this.pauseTime:this.startTime||(this.startTime=e),this.cancelTimestamp=this.startTime,this.pauseTime=void 0,this.frameRequestId=requestAnimationFrame(this.tick)}pause(){this.playState="paused",this.pauseTime=this.t}finish(){this.playState="finished",this.tick(0)}stop(){var e;this.playState="idle",void 0!==this.frameRequestId&&cancelAnimationFrame(this.frameRequestId),null===(e=this.reject)||void 0===e||e.call(this,!1)}cancel(){this.stop(),this.tick(this.cancelTimestamp)}reverse(){this.rate*=-1}commitStyles(){}updateDuration(e){this.duration=e,this.totalDuration=e*(this.repeat+1)}get currentTime(){return this.t}set currentTime(e){void 0!==this.pauseTime||0===this.rate?this.pauseTime=e:this.startTime=performance.now()-e/this.rate}get playbackRate(){return this.rate}set playbackRate(e){this.rate=e}}class fe{setAnimation(e){this.animation=e,null==e||e.finished.then((()=>this.clearAnimation())).catch((()=>{}))}clearAnimation(){this.animation=this.generator=void 0}}const me=new WeakMap;function ge(e){return me.has(e)||me.set(e,{transforms:[],values:new Map}),me.get(e)}const ve=["","X","Y","Z"],ye={x:"translateX",y:"translateY",z:"translateZ"},xe={syntax:"<angle>",initialValue:"0deg",toDefaultUnit:e=>e+"deg"},we={translate:{syntax:"<length-percentage>",initialValue:"0px",toDefaultUnit:e=>e+"px"},rotate:xe,scale:{syntax:"<number>",initialValue:1,toDefaultUnit:W},skew:xe},be=new Map,_e=e=>`--motion-${e}`,Se=["x","y","z"];["translate","scale","rotate","skew"].forEach((e=>{ve.forEach((t=>{Se.push(e+t),be.set(_e(e+t),we[e])}))}));const ke=(e,t)=>Se.indexOf(e)-Se.indexOf(t),Te=new Set(Se),Ee=e=>Te.has(e),Ae=e=>e.sort(ke).reduce(Pe,"").trim(),Pe=(e,t)=>`${e} ${t}(var(${_e(t)}))`,Me=e=>e.startsWith("--"),Ce=new Set,ze=(e,t)=>document.createElement("div").animate(e,t),Ie={cssRegisterProperty:()=>"undefined"!=typeof CSS&&Object.hasOwnProperty.call(CSS,"registerProperty"),waapi:()=>Object.hasOwnProperty.call(Element.prototype,"animate"),partialKeyframes:()=>{try{ze({opacity:[1]})}catch(e){return!1}return!0},finished:()=>Boolean(ze({opacity:[0,1]},{duration:.001}).finished),linearEasing:()=>{try{ze({opacity:0},{easing:"linear(0, 1)"})}catch(e){return!1}return!0}},Be={},Oe={};for(const e in Ie)Oe[e]=()=>(void 0===Be[e]&&(Be[e]=Ie[e]()),Be[e]);const Re=(e,t)=>le(e)?Oe.linearEasing()?`linear(${((e,t)=>{let n="";const r=Math.round(t/.015);for(let t=0;t<r;t++)n+=e(te(0,r-1,t))+", ";return n.substring(0,n.length-2)})(e,t)})`:q.easing:ce(e)?Ne(e):e,Ne=([e,t,n,r])=>`cubic-bezier(${e}, ${t}, ${n}, ${r})`;function Ue(e){return ye[e]&&(e=ye[e]),Ee(e)?_e(e):e}const De=(e,t)=>{t=Ue(t);let n=Me(t)?e.style.getPropertyValue(t):getComputedStyle(e)[t];if(!n&&0!==n){const e=be.get(t);e&&(n=e.initialValue)}return n},Le=(e,t,n)=>{t=Ue(t),Me(t)?e.style.setProperty(t,n):e.style[t]=n},Fe=e=>"string"==typeof e;function qe(e,t){var n;let r=(null==t?void 0:t.toDefaultUnit)||W;const i=e[e.length-1];if(Fe(i)){const e=(null===(n=i.match(/(-?[\d.]+)([a-z%]*)/))||void 0===n?void 0:n[2])||"";e&&(r=t=>t+e)}return r}function je(e,t,n,r={},i){const s=window.__MOTION_DEV_TOOLS_RECORD,o=!1!==r.record&&s;let a,{duration:l=q.duration,delay:c=q.delay,endDelay:u=q.endDelay,repeat:h=q.repeat,easing:d=q.easing,persist:p=!1,direction:f,offset:m,allowWebkitAcceleration:g=!1,autoplay:v=!0}=r;const y=ge(e),x=Ee(t);let w=Oe.waapi();x&&((e,t)=>{ye[t]&&(t=ye[t]);const{transforms:n}=ge(e);var r,i;i=t,-1===(r=n).indexOf(i)&&r.push(i),e.style.transform=Ae(n)})(e,t);const b=Ue(t),_=function(e,t){return e.has(t)||e.set(t,new fe),e.get(t)}(y.values,b),S=be.get(b);return $(_.animation,!(K(d)&&_.generator)&&!1!==r.record),()=>{const y=()=>{var t,n;return null!==(n=null!==(t=De(e,b))&&void 0!==t?t:null==S?void 0:S.initialValue)&&void 0!==n?n:0};let k=function(e,t){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=n?e[n-1]:t());return e}((e=>Array.isArray(e)?e:[e])(n),y);const T=qe(k,S);if(K(d)){const e=d.createAnimation(k,"opacity"!==t,y,b,_);d=e.easing,k=e.keyframes||k,l=e.duration||l}if(Me(b)&&(Oe.cssRegisterProperty()?function(e){if(!Ce.has(e)){Ce.add(e);try{const{syntax:t,initialValue:n}=be.has(e)?be.get(e):{};CSS.registerProperty({name:e,inherits:!1,syntax:t,initialValue:n})}catch(e){}}}(b):w=!1),x&&!Oe.linearEasing()&&(le(d)||J(d)&&d.some(le))&&(w=!1),w){S&&(k=k.map((e=>Q(e)?S.toDefaultUnit(e):e))),1!==k.length||Oe.partialKeyframes()&&!o||k.unshift(y());const t={delay:j(c),duration:j(l),endDelay:j(u),easing:J(d)?void 0:Re(d,l),direction:f,iterations:h+1,fill:"both"};a=e.animate({[b]:k,offset:m,easing:J(d)?d.map((e=>Re(e,l))):void 0},t),a.finished||(a.finished=new Promise(((e,t)=>{a.onfinish=e,a.oncancel=t})));const n=k[k.length-1];a.finished.then((()=>{p||(Le(e,b,n),a.cancel())})).catch(G),g||(a.playbackRate=1.000001)}else if(i&&x)k=k.map((e=>"string"==typeof e?parseFloat(e):e)),1===k.length&&k.unshift(parseFloat(y())),a=new i((t=>{Le(e,b,T?T(t):t)}),k,Object.assign(Object.assign({},r),{duration:l,easing:d}));else{const t=k[k.length-1];Le(e,b,S&&Q(t)?S.toDefaultUnit(t):t)}return o&&s(e,t,k,{duration:l,delay:c,easing:d,repeat:h,offset:m},"motion-one"),_.setAnimation(a),a&&!v&&a.pause(),a}}const Ve=(e,t)=>e[t]?Object.assign(Object.assign({},e),e[t]):Object.assign({},e);function Ge(e,t,n){return le(e)?e(t,n):e}const We=($e=pe,function(e,t,n={}){const r=(e=function(e,t){return"string"==typeof e?e=document.querySelectorAll(e):e instanceof Element&&(e=[e]),Array.from(e||[])}(e)).length;Boolean(r),Boolean(t);const i=[];for(let s=0;s<r;s++){const o=e[s];for(const e in t){const a=Ve(n,e);a.delay=Ge(a.delay,s,r);const l=je(o,e,t[e],a,$e);i.push(l)}}return Y(i,n,n.duration)});var $e;function He(e,t={}){return Y([()=>{const n=new pe(e,[0,1],t);return n.finished.catch((()=>{})),n}],t,t.duration)}function Ye(e,t,n){return(le(e)?He:We)(e,t,n)}const Xe=5;function Ze(e,t,n){const r=Math.max(t-Xe,0);return i=n-e(r),(s=t-r)?i*(1e3/s):0;var i,s}const Ke=({stiffness:e=100,damping:t=10,mass:n=1,from:r=0,to:i=1,velocity:s=0,restSpeed:o,restDistance:a}={})=>{s=s?V(s):0;const l={done:!1,hasReachedTarget:!1,current:r,target:i},c=i-r,u=Math.sqrt(e/n)/1e3,h=((e=100,t=10,n=1)=>t/(2*Math.sqrt(e*n)))(e,t,n),d=Math.abs(c)<5;let p;if(o||(o=d?.01:2),a||(a=d?.005:.5),h<1){const e=u*Math.sqrt(1-h*h);p=t=>i-Math.exp(-h*u*t)*((h*u*c-s)/e*Math.sin(e*t)+c*Math.cos(e*t))}else p=e=>i-Math.exp(-u*e)*(c+(u*c-s)*e);return e=>{l.current=p(e);const t=0===e?s:Ze(p,e,l.current),n=Math.abs(t)<=o,c=Math.abs(i-l.current)<=a;var u,h,d;return l.done=n&&c,l.hasReachedTarget=(u=r,h=i,d=l.current,u<h&&d>=h||u>h&&d<=h),l}};function Qe(e){return Q(e)&&!isNaN(e)}function Je(e){return Fe(e)?parseFloat(e):e}function et(e){const t=new WeakMap;return(n={})=>{const r=new Map,i=(t=0,i=100,s=0,o=!1)=>{const a=`${t}-${i}-${s}-${o}`;return r.has(a)||r.set(a,e(Object.assign({from:t,to:i,velocity:s},n))),r.get(a)},s=(e,n)=>(t.has(e)||t.set(e,function(e,t=W){let n,r=10,i=e(0);const s=[t(i.current)];for(;!i.done&&r<1e4;)i=e(r),s.push(t(i.done?i.target:i.current)),void 0===n&&i.hasReachedTarget&&(n=r),r+=10;const o=r-10;return 1===s.length&&s.push(i.current),{keyframes:s,duration:o/1e3,overshootDuration:(null!=n?n:o)/1e3}}(e,n)),t.get(e));return{createAnimation:(e,t=!0,n,r,o)=>{let a,l,c,u=0,h=W;const d=e.length;if(t)if(h=qe(e,r?be.get(Ue(r)):void 0),c=Je(e[d-1]),d>1&&null!==e[0])l=Je(e[0]);else{const e=null==o?void 0:o.generator;if(e){const{animation:t,generatorStartTime:n}=o,r=(null==t?void 0:t.startTime)||n||0,i=(null==t?void 0:t.currentTime)||performance.now()-r,s=e(i).current;l=s,u=Ze((t=>e(t).current),i,s)}else n&&(l=Je(n()))}if(Qe(l)&&Qe(c)){const e=i(l,c,u,null==r?void 0:r.includes("scale"));a=Object.assign(Object.assign({},s(e,h)),{easing:"linear"}),o&&(o.generator=e,o.generatorStartTime=performance.now())}return a||(a={easing:"ease",duration:s(i(0,100)).overshootDuration}),a}}}}const tt=et((({from:e=0,velocity:t=0,power:n=.8,decay:r=.325,bounceDamping:i,bounceStiffness:s,changeTarget:o,min:a,max:l,restDistance:c=.5,restSpeed:u})=>{r=j(r);const h={hasReachedTarget:!1,done:!1,current:e,target:e},d=e=>void 0===a?l:void 0===l||Math.abs(a-e)<Math.abs(l-e)?a:l;let p=n*t;const f=e+p,m=void 0===o?f:o(f);h.target=m,m!==f&&(p=m-e);const g=e=>-p*Math.exp(-e/r),v=e=>m+g(e),y=e=>{const t=g(e),n=v(e);h.done=Math.abs(t)<=c,h.current=h.done?m:n};let x,w;const b=e=>{var t;t=h.current,(void 0!==a&&t<a||void 0!==l&&t>l)&&(x=e,w=Ke({from:h.current,to:d(h.current),velocity:Ze(v,e,h.current),damping:i,stiffness:s,restDistance:c,restSpeed:u}))};return b(0),e=>{let t=!1;return w||void 0!==x||(t=!0,y(e),b(e)),void 0!==x&&e>x?(h.hasReachedTarget=!0,w(e-x)):(h.hasReachedTarget=!1,!t&&y(e),h)}}));var nt=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};let rt=class{value;target;constructor(e){this.value=e,this.target=e}update(){Ye((e=>{this.value=i.eR.lerp(this.value,this.target,e)}),{easing:tt({velocity:2e-4*Ar})})}};rt=nt([F.register],rt);let it=class{value;target;constructor(e){this.value=e,this.target=e}update(){Ye((e=>{this.value=this.value+(this.target-this.value)*e}),{easing:tt({velocity:2e-4*Ar})})}};it=nt([F.register],it);let st=class{value;target;constructor(e){this.value=e,this.target=e}update(){Ye((e=>{this.value=i.Yu.slerp(this.value,this.target,e)}),{easing:tt({velocity:2e-4*Ar})})}};st=nt([F.register],st);const ot=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength,at={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array},bool:{numElements:0,align:1,size:0,type:"bool",View:Uint32Array}},lt={...at,"atomic<i32>":at.i32,"atomic<u32>":at.u32,"vec2<i32>":at.vec2i,"vec2<u32>":at.vec2u,"vec2<f32>":at.vec2f,"vec2<f16>":at.vec2h,"vec3<i32>":at.vec3i,"vec3<u32>":at.vec3u,"vec3<f32>":at.vec3f,"vec3<f16>":at.vec3h,"vec4<i32>":at.vec4i,"vec4<u32>":at.vec4u,"vec4<f32>":at.vec4f,"vec4<f16>":at.vec4h,"mat2x2<f32>":at.mat2x2f,"mat2x2<f16>":at.mat2x2h,"mat3x2<f32>":at.mat3x2f,"mat3x2<f16>":at.mat3x2h,"mat4x2<f32>":at.mat4x2f,"mat4x2<f16>":at.mat4x2h,"mat2x3<f32>":at.mat2x3f,"mat2x3<f16>":at.mat2x3h,"mat3x3<f32>":at.mat3x3f,"mat3x3<f16>":at.mat3x3h,"mat4x3<f32>":at.mat4x3f,"mat4x3<f16>":at.mat4x3h,"mat2x4<f32>":at.mat2x4f,"mat2x4<f16>":at.mat2x4h,"mat3x4<f32>":at.mat3x4f,"mat3x4<f16>":at.mat3x4h,"mat4x4<f32>":at.mat4x4f,"mat4x4<f16>":at.mat4x4h},ct=(ut=lt,Object.keys(ut));var ut,ht,dt,pt,ft,mt;!function(e=[],t){const n=new Set;for(const r of ct){const i=lt[r];n.has(i)||(n.add(i),i.flatten=e.includes(r)?t:!t)}}(),new WeakMap;class gt{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class vt{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(yt.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(xt.instance)}}}class yt extends vt{}yt.instance=new yt;class xt extends vt{}xt.instance=new xt;class wt extends vt{constructor(){super()}}class bt extends wt{constructor(e,t,n,r){super(),this.name=e,this.args=t,this.returnType=n,this.body=r}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}}class _t extends wt{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class St extends wt{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class kt extends wt{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class Tt extends wt{constructor(e,t,n,r){super(),this.init=e,this.condition=t,this.increment=n,this.body=r}get astNodeType(){return"for"}search(e){var t,n,r;null===(t=this.init)||void 0===t||t.search(e),null===(n=this.condition)||void 0===n||n.search(e),null===(r=this.increment)||void 0===r||r.search(e),this.searchBlock(this.body,e)}}class Et extends wt{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class At extends wt{constructor(e,t,n){super(),this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Pt extends wt{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"let"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Mt extends wt{constructor(e,t,n,r,i){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=i}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}!function(e){e.increment="++",e.decrement="--"}(ht||(ht={})),function(e){e.parse=function(t){const n=t;if("parse"==n)throw new Error("Invalid value for IncrementOperator");return e[n]}}(ht||(ht={}));class Ct extends wt{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(dt||(dt={})),function(e){e.parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t}}(dt||(dt={}));class zt extends wt{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.value.search(e)}}class It extends wt{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}}class Bt extends wt{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class Ot extends wt{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class Rt extends wt{constructor(e,t,n,r){super(),this.condition=e,this.body=t,this.elseif=n,this.else=r}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class Nt extends wt{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Ut extends wt{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class Dt extends wt{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class Lt extends wt{constructor(){super()}get astNodeType(){return"discard"}}class Ft extends wt{constructor(){super()}get astNodeType(){return"break"}}class qt extends wt{constructor(){super()}get astNodeType(){return"continue"}}class jt extends wt{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class Vt extends jt{constructor(e,t){super(e),this.members=t}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class Gt extends jt{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}}class Wt extends jt{constructor(e,t,n,r){super(e),this.storage=t,this.type=n,this.access=r}get astNodeType(){return"pointer"}}class $t extends jt{constructor(e,t,n,r){super(e),this.attributes=t,this.format=n,this.count=r}get astNodeType(){return"array"}get isArray(){return!0}}class Ht extends jt{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}}class Yt extends vt{constructor(){super()}}class Xt extends Yt{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class Zt extends Yt{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}}class Kt extends Yt{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class Qt extends Yt{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this)}}class Jt extends Yt{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,n;if(this.initializer instanceof Zt){const r=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),i=null===(n=this.initializer.type)||void 0===n?void 0:n.name,s=e.structs.get(i),o=null==s?void 0:s.getMemberIndex(r);if(-1!=o)return this.initializer.args[o].evaluate(e);console.log(o)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class en extends Yt{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class tn extends Yt{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class nn extends Yt{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}}class rn extends Yt{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class sn extends Yt{constructor(){super()}}class on extends sn{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}}class an extends sn{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class ln extends vt{constructor(){super()}}class cn extends ln{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class un extends ln{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class hn extends vt{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}}class dn extends vt{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class pn extends vt{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}}class fn extends vt{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(ft||(ft={}));class mn{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class gn{}pt=gn,gn.none=new mn("",ft.reserved,""),gn.eof=new mn("EOF",ft.token,""),gn.reserved={asm:new mn("asm",ft.reserved,"asm"),bf16:new mn("bf16",ft.reserved,"bf16"),do:new mn("do",ft.reserved,"do"),enum:new mn("enum",ft.reserved,"enum"),f16:new mn("f16",ft.reserved,"f16"),f64:new mn("f64",ft.reserved,"f64"),handle:new mn("handle",ft.reserved,"handle"),i8:new mn("i8",ft.reserved,"i8"),i16:new mn("i16",ft.reserved,"i16"),i64:new mn("i64",ft.reserved,"i64"),mat:new mn("mat",ft.reserved,"mat"),premerge:new mn("premerge",ft.reserved,"premerge"),regardless:new mn("regardless",ft.reserved,"regardless"),typedef:new mn("typedef",ft.reserved,"typedef"),u8:new mn("u8",ft.reserved,"u8"),u16:new mn("u16",ft.reserved,"u16"),u64:new mn("u64",ft.reserved,"u64"),unless:new mn("unless",ft.reserved,"unless"),using:new mn("using",ft.reserved,"using"),vec:new mn("vec",ft.reserved,"vec"),void:new mn("void",ft.reserved,"void")},gn.keywords={array:new mn("array",ft.keyword,"array"),atomic:new mn("atomic",ft.keyword,"atomic"),bool:new mn("bool",ft.keyword,"bool"),f32:new mn("f32",ft.keyword,"f32"),i32:new mn("i32",ft.keyword,"i32"),mat2x2:new mn("mat2x2",ft.keyword,"mat2x2"),mat2x3:new mn("mat2x3",ft.keyword,"mat2x3"),mat2x4:new mn("mat2x4",ft.keyword,"mat2x4"),mat3x2:new mn("mat3x2",ft.keyword,"mat3x2"),mat3x3:new mn("mat3x3",ft.keyword,"mat3x3"),mat3x4:new mn("mat3x4",ft.keyword,"mat3x4"),mat4x2:new mn("mat4x2",ft.keyword,"mat4x2"),mat4x3:new mn("mat4x3",ft.keyword,"mat4x3"),mat4x4:new mn("mat4x4",ft.keyword,"mat4x4"),ptr:new mn("ptr",ft.keyword,"ptr"),sampler:new mn("sampler",ft.keyword,"sampler"),sampler_comparison:new mn("sampler_comparison",ft.keyword,"sampler_comparison"),struct:new mn("struct",ft.keyword,"struct"),texture_1d:new mn("texture_1d",ft.keyword,"texture_1d"),texture_2d:new mn("texture_2d",ft.keyword,"texture_2d"),texture_2d_array:new mn("texture_2d_array",ft.keyword,"texture_2d_array"),texture_3d:new mn("texture_3d",ft.keyword,"texture_3d"),texture_cube:new mn("texture_cube",ft.keyword,"texture_cube"),texture_cube_array:new mn("texture_cube_array",ft.keyword,"texture_cube_array"),texture_multisampled_2d:new mn("texture_multisampled_2d",ft.keyword,"texture_multisampled_2d"),texture_storage_1d:new mn("texture_storage_1d",ft.keyword,"texture_storage_1d"),texture_storage_2d:new mn("texture_storage_2d",ft.keyword,"texture_storage_2d"),texture_storage_2d_array:new mn("texture_storage_2d_array",ft.keyword,"texture_storage_2d_array"),texture_storage_3d:new mn("texture_storage_3d",ft.keyword,"texture_storage_3d"),texture_depth_2d:new mn("texture_depth_2d",ft.keyword,"texture_depth_2d"),texture_depth_2d_array:new mn("texture_depth_2d_array",ft.keyword,"texture_depth_2d_array"),texture_depth_cube:new mn("texture_depth_cube",ft.keyword,"texture_depth_cube"),texture_depth_cube_array:new mn("texture_depth_cube_array",ft.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new mn("texture_depth_multisampled_2d",ft.keyword,"texture_depth_multisampled_2d"),texture_external:new mn("texture_external",ft.keyword,"texture_external"),u32:new mn("u32",ft.keyword,"u32"),vec2:new mn("vec2",ft.keyword,"vec2"),vec3:new mn("vec3",ft.keyword,"vec3"),vec4:new mn("vec4",ft.keyword,"vec4"),bitcast:new mn("bitcast",ft.keyword,"bitcast"),block:new mn("block",ft.keyword,"block"),break:new mn("break",ft.keyword,"break"),case:new mn("case",ft.keyword,"case"),continue:new mn("continue",ft.keyword,"continue"),continuing:new mn("continuing",ft.keyword,"continuing"),default:new mn("default",ft.keyword,"default"),discard:new mn("discard",ft.keyword,"discard"),else:new mn("else",ft.keyword,"else"),enable:new mn("enable",ft.keyword,"enable"),fallthrough:new mn("fallthrough",ft.keyword,"fallthrough"),false:new mn("false",ft.keyword,"false"),fn:new mn("fn",ft.keyword,"fn"),for:new mn("for",ft.keyword,"for"),function:new mn("function",ft.keyword,"function"),if:new mn("if",ft.keyword,"if"),let:new mn("let",ft.keyword,"let"),const:new mn("const",ft.keyword,"const"),loop:new mn("loop",ft.keyword,"loop"),while:new mn("while",ft.keyword,"while"),private:new mn("private",ft.keyword,"private"),read:new mn("read",ft.keyword,"read"),read_write:new mn("read_write",ft.keyword,"read_write"),return:new mn("return",ft.keyword,"return"),storage:new mn("storage",ft.keyword,"storage"),switch:new mn("switch",ft.keyword,"switch"),true:new mn("true",ft.keyword,"true"),alias:new mn("alias",ft.keyword,"alias"),type:new mn("type",ft.keyword,"type"),uniform:new mn("uniform",ft.keyword,"uniform"),var:new mn("var",ft.keyword,"var"),override:new mn("override",ft.keyword,"override"),workgroup:new mn("workgroup",ft.keyword,"workgroup"),write:new mn("write",ft.keyword,"write"),r8unorm:new mn("r8unorm",ft.keyword,"r8unorm"),r8snorm:new mn("r8snorm",ft.keyword,"r8snorm"),r8uint:new mn("r8uint",ft.keyword,"r8uint"),r8sint:new mn("r8sint",ft.keyword,"r8sint"),r16uint:new mn("r16uint",ft.keyword,"r16uint"),r16sint:new mn("r16sint",ft.keyword,"r16sint"),r16float:new mn("r16float",ft.keyword,"r16float"),rg8unorm:new mn("rg8unorm",ft.keyword,"rg8unorm"),rg8snorm:new mn("rg8snorm",ft.keyword,"rg8snorm"),rg8uint:new mn("rg8uint",ft.keyword,"rg8uint"),rg8sint:new mn("rg8sint",ft.keyword,"rg8sint"),r32uint:new mn("r32uint",ft.keyword,"r32uint"),r32sint:new mn("r32sint",ft.keyword,"r32sint"),r32float:new mn("r32float",ft.keyword,"r32float"),rg16uint:new mn("rg16uint",ft.keyword,"rg16uint"),rg16sint:new mn("rg16sint",ft.keyword,"rg16sint"),rg16float:new mn("rg16float",ft.keyword,"rg16float"),rgba8unorm:new mn("rgba8unorm",ft.keyword,"rgba8unorm"),rgba8unorm_srgb:new mn("rgba8unorm_srgb",ft.keyword,"rgba8unorm_srgb"),rgba8snorm:new mn("rgba8snorm",ft.keyword,"rgba8snorm"),rgba8uint:new mn("rgba8uint",ft.keyword,"rgba8uint"),rgba8sint:new mn("rgba8sint",ft.keyword,"rgba8sint"),bgra8unorm:new mn("bgra8unorm",ft.keyword,"bgra8unorm"),bgra8unorm_srgb:new mn("bgra8unorm_srgb",ft.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new mn("rgb10a2unorm",ft.keyword,"rgb10a2unorm"),rg11b10float:new mn("rg11b10float",ft.keyword,"rg11b10float"),rg32uint:new mn("rg32uint",ft.keyword,"rg32uint"),rg32sint:new mn("rg32sint",ft.keyword,"rg32sint"),rg32float:new mn("rg32float",ft.keyword,"rg32float"),rgba16uint:new mn("rgba16uint",ft.keyword,"rgba16uint"),rgba16sint:new mn("rgba16sint",ft.keyword,"rgba16sint"),rgba16float:new mn("rgba16float",ft.keyword,"rgba16float"),rgba32uint:new mn("rgba32uint",ft.keyword,"rgba32uint"),rgba32sint:new mn("rgba32sint",ft.keyword,"rgba32sint"),rgba32float:new mn("rgba32float",ft.keyword,"rgba32float"),static_assert:new mn("static_assert",ft.keyword,"static_assert")},gn.tokens={decimal_float_literal:new mn("decimal_float_literal",ft.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new mn("hex_float_literal",ft.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new mn("int_literal",ft.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new mn("uint_literal",ft.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new mn("ident",ft.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new mn("and",ft.token,"&"),and_and:new mn("and_and",ft.token,"&&"),arrow:new mn("arrow ",ft.token,"->"),attr:new mn("attr",ft.token,"@"),attr_left:new mn("attr_left",ft.token,"[["),attr_right:new mn("attr_right",ft.token,"]]"),forward_slash:new mn("forward_slash",ft.token,"/"),bang:new mn("bang",ft.token,"!"),bracket_left:new mn("bracket_left",ft.token,"["),bracket_right:new mn("bracket_right",ft.token,"]"),brace_left:new mn("brace_left",ft.token,"{"),brace_right:new mn("brace_right",ft.token,"}"),colon:new mn("colon",ft.token,":"),comma:new mn("comma",ft.token,","),equal:new mn("equal",ft.token,"="),equal_equal:new mn("equal_equal",ft.token,"=="),not_equal:new mn("not_equal",ft.token,"!="),greater_than:new mn("greater_than",ft.token,">"),greater_than_equal:new mn("greater_than_equal",ft.token,">="),shift_right:new mn("shift_right",ft.token,">>"),less_than:new mn("less_than",ft.token,"<"),less_than_equal:new mn("less_than_equal",ft.token,"<="),shift_left:new mn("shift_left",ft.token,"<<"),modulo:new mn("modulo",ft.token,"%"),minus:new mn("minus",ft.token,"-"),minus_minus:new mn("minus_minus",ft.token,"--"),period:new mn("period",ft.token,"."),plus:new mn("plus",ft.token,"+"),plus_plus:new mn("plus_plus",ft.token,"++"),or:new mn("or",ft.token,"|"),or_or:new mn("or_or",ft.token,"||"),paren_left:new mn("paren_left",ft.token,"("),paren_right:new mn("paren_right",ft.token,")"),semicolon:new mn("semicolon",ft.token,";"),star:new mn("star",ft.token,"*"),tilde:new mn("tilde",ft.token,"~"),underscore:new mn("underscore",ft.token,"_"),xor:new mn("xor",ft.token,"^"),plus_equal:new mn("plus_equal",ft.token,"+="),minus_equal:new mn("minus_equal",ft.token,"-="),times_equal:new mn("times_equal",ft.token,"*="),division_equal:new mn("division_equal",ft.token,"/="),modulo_equal:new mn("modulo_equal",ft.token,"%="),and_equal:new mn("and_equal",ft.token,"&="),or_equal:new mn("or_equal",ft.token,"|="),xor_equal:new mn("xor_equal",ft.token,"^="),shift_right_equal:new mn("shift_right_equal",ft.token,">>="),shift_left_equal:new mn("shift_left_equal",ft.token,"<<=")},gn.storage_class=[pt.keywords.function,pt.keywords.private,pt.keywords.workgroup,pt.keywords.uniform,pt.keywords.storage],gn.access_mode=[pt.keywords.read,pt.keywords.write,pt.keywords.read_write],gn.sampler_type=[pt.keywords.sampler,pt.keywords.sampler_comparison],gn.sampled_texture_type=[pt.keywords.texture_1d,pt.keywords.texture_2d,pt.keywords.texture_2d_array,pt.keywords.texture_3d,pt.keywords.texture_cube,pt.keywords.texture_cube_array],gn.multisampled_texture_type=[pt.keywords.texture_multisampled_2d],gn.storage_texture_type=[pt.keywords.texture_storage_1d,pt.keywords.texture_storage_2d,pt.keywords.texture_storage_2d_array,pt.keywords.texture_storage_3d],gn.depth_texture_type=[pt.keywords.texture_depth_2d,pt.keywords.texture_depth_2d_array,pt.keywords.texture_depth_cube,pt.keywords.texture_depth_cube_array,pt.keywords.texture_depth_multisampled_2d],gn.texture_external_type=[pt.keywords.texture_external],gn.any_texture_type=[...pt.sampled_texture_type,...pt.multisampled_texture_type,...pt.storage_texture_type,...pt.depth_texture_type,...pt.texture_external_type],gn.texel_format=[pt.keywords.r8unorm,pt.keywords.r8snorm,pt.keywords.r8uint,pt.keywords.r8sint,pt.keywords.r16uint,pt.keywords.r16sint,pt.keywords.r16float,pt.keywords.rg8unorm,pt.keywords.rg8snorm,pt.keywords.rg8uint,pt.keywords.rg8sint,pt.keywords.r32uint,pt.keywords.r32sint,pt.keywords.r32float,pt.keywords.rg16uint,pt.keywords.rg16sint,pt.keywords.rg16float,pt.keywords.rgba8unorm,pt.keywords.rgba8unorm_srgb,pt.keywords.rgba8snorm,pt.keywords.rgba8uint,pt.keywords.rgba8sint,pt.keywords.bgra8unorm,pt.keywords.bgra8unorm_srgb,pt.keywords.rgb10a2unorm,pt.keywords.rg11b10float,pt.keywords.rg32uint,pt.keywords.rg32sint,pt.keywords.rg32float,pt.keywords.rgba16uint,pt.keywords.rgba16sint,pt.keywords.rgba16float,pt.keywords.rgba32uint,pt.keywords.rgba32sint,pt.keywords.rgba32float],gn.const_literal=[pt.tokens.int_literal,pt.tokens.uint_literal,pt.tokens.decimal_float_literal,pt.tokens.hex_float_literal,pt.keywords.true,pt.keywords.false],gn.literal_or_ident=[pt.tokens.ident,pt.tokens.int_literal,pt.tokens.uint_literal,pt.tokens.decimal_float_literal,pt.tokens.hex_float_literal],gn.element_count_expression=[pt.tokens.int_literal,pt.tokens.uint_literal,pt.tokens.ident],gn.template_types=[pt.keywords.vec2,pt.keywords.vec3,pt.keywords.vec4,pt.keywords.mat2x2,pt.keywords.mat2x3,pt.keywords.mat2x4,pt.keywords.mat3x2,pt.keywords.mat3x3,pt.keywords.mat3x4,pt.keywords.mat4x2,pt.keywords.mat4x3,pt.keywords.mat4x4,pt.keywords.atomic,pt.keywords.bitcast,...pt.any_texture_type],gn.attribute_name=[pt.tokens.ident,pt.keywords.block],gn.assignment_operators=[pt.tokens.equal,pt.tokens.plus_equal,pt.tokens.minus_equal,pt.tokens.times_equal,pt.tokens.division_equal,pt.tokens.modulo_equal,pt.tokens.and_equal,pt.tokens.or_equal,pt.tokens.xor_equal,pt.tokens.shift_right_equal,pt.tokens.shift_left_equal],gn.increment_operators=[pt.tokens.plus_plus,pt.tokens.minus_minus];class vn{constructor(e,t,n){this.type=e,this.lexeme=t,this.line=n}toString(){return this.lexeme}isTemplateType(){return-1!=gn.template_types.indexOf(this.type)}isArrayType(){return this.type==gn.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class yn{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new vn(gn.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}let t=gn.none;for(;;){let n=this._findType(e);const r=this._peekAhead();if(">"==e&&(">"==r||"="==r)){let e=!1,t=this._tokens.length-1;for(let n=0;n<5&&t>=0;++n,--t)if(this._tokens[t].type===gn.tokens.less_than){t>0&&this._tokens[t-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(n),!0}if(n===gn.none){let r=e,i=0;const s=2;for(let e=0;e<s;++e)if(r+=this._peekAhead(e),n=this._findType(r),n!==gn.none){i=e;break}if(n===gn.none)return t!==gn.none&&(this._current--,this._addToken(t),!0);e=r,this._current+=i+1}if(t=n,this._isAtEnd())break;e+=this._advance()}return t!==gn.none&&(this._addToken(t),!0)}_findType(e){for(const t in gn.keywords){const n=gn.keywords[t];if(this._match(e,n.rule))return n}for(const t in gn.tokens){const n=gn.tokens[t];if(this._match(e,n.rule))return n}return gn.none}_match(e,t){if("string"==typeof t){if(t==e)return!0}else{const n=t.exec(e);if(n&&0==n.index&&n[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new vn(e,t,this._line))}}class xn{constructor(){this._tokens=[],this._current=0,this._context=new gt}parse(e){this._initialize(e);let t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}return t}_initialize(e){if(e)if("string"==typeof e){const t=new yn(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return console.error(e,t),{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==gn.eof}_match(e){if(e instanceof mn)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const n=e[t];if(this._check(n))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){let n=t.type;return-1!=e.indexOf(n)}return t.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(gn.tokens.semicolon)&&!this._isAtEnd(););if(this._match(gn.keywords.alias)){const e=this._type_alias();return this._consume(gn.tokens.semicolon,"Expected ';'"),e}if(this._match(gn.keywords.enable)){const e=this._enable_directive();return this._consume(gn.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(gn.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(gn.tokens.semicolon,"Expected ';'."),t}if(this._check(gn.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(gn.tokens.semicolon,"Expected ';'."),t}if(this._check(gn.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(gn.tokens.semicolon,"Expected ';'."),t}if(this._check(gn.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(gn.tokens.semicolon,"Expected ';'."),t}if(this._check(gn.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(gn.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(gn.keywords.fn))return null;const e=this._consume(gn.tokens.ident,"Expected function name.").toString();this._consume(gn.tokens.paren_left,"Expected '(' for function arguments.");const t=[];if(!this._check(gn.tokens.paren_right))do{if(this._check(gn.tokens.paren_right))break;const e=this._attribute(),n=this._consume(gn.tokens.ident,"Expected argument name.").toString();this._consume(gn.tokens.colon,"Expected ':' for argument type.");const r=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=r,t.push(new hn(n,i,e)))}while(this._match(gn.tokens.comma));this._consume(gn.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(gn.tokens.arrow)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}const r=this._compound_statement();return new bt(e,t,n,r)}_compound_statement(){const e=[];for(this._consume(gn.tokens.brace_left,"Expected '{' for block.");!this._check(gn.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(gn.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(gn.tokens.semicolon)&&!this._isAtEnd(););if(this._check(gn.keywords.if))return this._if_statement();if(this._check(gn.keywords.switch))return this._switch_statement();if(this._check(gn.keywords.loop))return this._loop_statement();if(this._check(gn.keywords.for))return this._for_statement();if(this._check(gn.keywords.while))return this._while_statement();if(this._check(gn.keywords.continuing))return this._continuing_statement();if(this._check(gn.keywords.static_assert))return this._static_assert_statement();if(this._check(gn.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(gn.keywords.return)?this._return_statement():this._check([gn.keywords.var,gn.keywords.let,gn.keywords.const])?this._variable_statement():this._match(gn.keywords.discard)?new Lt:this._match(gn.keywords.break)?new Ft:this._match(gn.keywords.continue)?new qt:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(gn.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(gn.keywords.static_assert))return null;let e=this._optional_paren_expression();return new _t(e)}_while_statement(){if(!this._match(gn.keywords.while))return null;let e=this._optional_paren_expression();const t=this._compound_statement();return new St(e,t)}_continuing_statement(){if(!this._match(gn.keywords.continuing))return null;const e=this._compound_statement();return new kt(e)}_for_statement(){if(!this._match(gn.keywords.for))return null;this._consume(gn.tokens.paren_left,"Expected '('.");const e=this._check(gn.tokens.semicolon)?null:this._for_init();this._consume(gn.tokens.semicolon,"Expected ';'.");const t=this._check(gn.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(gn.tokens.semicolon,"Expected ';'.");const n=this._check(gn.tokens.paren_right)?null:this._for_increment();this._consume(gn.tokens.paren_right,"Expected ')'.");const r=this._compound_statement();return new Tt(e,t,n,r)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(gn.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(gn.tokens.equal)&&(t=this._short_circuit_or_expression()),new Et(e.name,e.type,e.storage,e.access,t)}if(this._match(gn.keywords.let)){const e=this._consume(gn.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(gn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(gn.tokens.equal,"Expected '=' for let.");const n=this._short_circuit_or_expression();return new Pt(e,t,null,null,n)}if(this._match(gn.keywords.const)){const e=this._consume(gn.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(gn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(gn.tokens.equal,"Expected '=' for const.");const n=this._short_circuit_or_expression();return new Mt(e,t,null,null,n)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(gn.increment_operators))return this._current=e,null;const n=this._consume(gn.increment_operators,"Expected increment operator");return new Ct(n.type===gn.tokens.plus_plus?ht.increment:ht.decrement,t)}_assignment_statement(){let e=null;if(this._check(gn.tokens.brace_right))return null;let t=this._match(gn.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const n=this._consume(gn.assignment_operators,"Expected assignment operator."),r=this._short_circuit_or_expression();return new zt(dt.parse(n.lexeme),e,r)}_func_call_statement(){if(!this._check(gn.tokens.ident))return null;const e=this._current,t=this._consume(gn.tokens.ident,"Expected function name."),n=this._argument_expression_list();return null===n?(this._current=e,null):new It(t.lexeme,n)}_loop_statement(){if(!this._match(gn.keywords.loop))return null;this._consume(gn.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let n of t)e.push(n);else e.push(t);t=this._statement()}let n=null;return this._match(gn.keywords.continuing)&&(n=this._compound_statement()),this._consume(gn.tokens.brace_right,"Expected '}' for loop."),new Bt(e,n)}_switch_statement(){if(!this._match(gn.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(gn.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(gn.tokens.brace_right,"Expected '}' for switch."),new Ot(e,t)}_switch_body(){const e=[];if(this._match(gn.keywords.case)){const t=this._case_selectors();this._match(gn.tokens.colon),this._consume(gn.tokens.brace_left,"Exected '{' for switch case.");const n=this._case_body();this._consume(gn.tokens.brace_right,"Exected '}' for switch case."),e.push(new cn(t,n))}if(this._match(gn.keywords.default)){this._match(gn.tokens.colon),this._consume(gn.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(gn.tokens.brace_right,"Exected '}' for switch default."),e.push(new un(t))}if(this._check([gn.keywords.default,gn.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){var e,t,n,r;const i=[null!==(t=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==t?t:""];for(;this._match(gn.tokens.comma);)i.push(null!==(r=null===(n=this._shift_expression())||void 0===n?void 0:n.evaluate(this._context).toString())&&void 0!==r?r:"");return i}_case_body(){if(this._match(gn.keywords.fallthrough))return this._consume(gn.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(gn.keywords.if))return null;const e=this._optional_paren_expression(),t=this._compound_statement();let n=[];this._match_elseif()&&(n=this._elseif_statement(n));let r=null;return this._match(gn.keywords.else)&&(r=this._compound_statement()),new Rt(e,t,n,r)}_match_elseif(){return this._tokens[this._current].type===gn.keywords.else&&this._tokens[this._current+1].type===gn.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(new dn(t,n)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(gn.keywords.return))return null;const e=this._short_circuit_or_expression();return new Nt(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(gn.tokens.or_or);)e=new an(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(gn.tokens.and_and);)e=new an(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(gn.tokens.or);)e=new an(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(gn.tokens.xor);)e=new an(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(gn.tokens.and);)e=new an(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([gn.tokens.equal_equal,gn.tokens.not_equal])?new an(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([gn.tokens.less_than,gn.tokens.greater_than,gn.tokens.less_than_equal,gn.tokens.greater_than_equal]);)e=new an(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([gn.tokens.shift_left,gn.tokens.shift_right]);)e=new an(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([gn.tokens.plus,gn.tokens.minus]);)e=new an(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([gn.tokens.star,gn.tokens.forward_slash,gn.tokens.modulo]);)e=new an(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([gn.tokens.minus,gn.tokens.bang,gn.tokens.tilde,gn.tokens.star,gn.tokens.and])?new on(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(gn.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(gn.tokens.bracket_right,"Expected ']'.");const t=this._postfix_expression();return t&&(e.postfix=t),e}if(this._match(gn.tokens.period)){const e=this._consume(gn.tokens.ident,"Expected member name."),t=this._postfix_expression(),n=new Xt(e.lexeme);return t&&(n.postfix=t),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(gn.tokens.ident)){const e=this._previous().toString();if(this._check(gn.tokens.paren_left)){const t=this._argument_expression_list(),n=this._getStruct(e);return null!=n?new Zt(n,t):new Kt(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new Jt(e,t.value)}return new Qt(e)}if(this._match(gn.const_literal))return new en(parseFloat(this._previous().toString()));if(this._check(gn.tokens.paren_left))return this._paren_expression();if(this._match(gn.keywords.bitcast)){this._consume(gn.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(gn.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new tn(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new nn(e,t)}_argument_expression_list(){if(!this._match(gn.tokens.paren_left))return null;const e=[];do{if(this._check(gn.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(gn.tokens.comma));return this._consume(gn.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(gn.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(gn.tokens.paren_right),new rn([e])}_paren_expression(){this._consume(gn.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(gn.tokens.paren_right,"Expected ')'."),new rn([e])}_struct_decl(){if(!this._match(gn.keywords.struct))return null;const e=this._consume(gn.tokens.ident,"Expected name for struct.").toString();this._consume(gn.tokens.brace_left,"Expected '{' for struct body.");const t=[];for(;!this._check(gn.tokens.brace_right);){const e=this._attribute(),n=this._consume(gn.tokens.ident,"Expected variable name.").toString();this._consume(gn.tokens.colon,"Expected ':' for struct member type.");const r=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=r),this._check(gn.tokens.brace_right)?this._match(gn.tokens.comma):this._consume(gn.tokens.comma,"Expected ',' for struct member."),t.push(new pn(n,i,e))}this._consume(gn.tokens.brace_right,"Expected '}' after struct body.");const n=new Vt(e,t);return this._context.structs.set(e,n),n}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(gn.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(gn.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(gn.keywords.const))return null;const e=this._consume(gn.tokens.ident,"Expected variable name");let t=null;if(this._match(gn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;if(this._match(gn.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof Zt)n=e;else if(e instanceof Jt&&e.initializer instanceof Zt)n=e.initializer;else try{const t=e.evaluate(this._context);n=new en(t)}catch(t){n=e}}const r=new Mt(e.toString(),t,"","",n);return this._context.constants.set(r.name,r),r}_global_let_decl(){if(!this._match(gn.keywords.let))return null;const e=this._consume(gn.tokens.ident,"Expected variable name");let t=null;if(this._match(gn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;return this._match(gn.tokens.equal)&&(n=this._const_expression()),new Pt(e.toString(),t,"","",n)}_const_expression(){if(this._match(gn.const_literal))return new Xt(this._previous().toString());const e=this._type_decl();this._consume(gn.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(gn.tokens.paren_right)&&(t.push(this._const_expression()),this._check(gn.tokens.comma));)this._advance();return this._consume(gn.tokens.paren_right,"Expected ')'."),new Zt(e,t)}_variable_decl(){if(!this._match(gn.keywords.var))return null;let e="",t="";this._match(gn.tokens.less_than)&&(e=this._consume(gn.storage_class,"Expected storage_class.").toString(),this._match(gn.tokens.comma)&&(t=this._consume(gn.access_mode,"Expected access_mode.").toString()),this._consume(gn.tokens.greater_than,"Expected '>'."));const n=this._consume(gn.tokens.ident,"Expected variable name");let r=null;if(this._match(gn.tokens.colon)){const e=this._attribute();r=this._type_decl(),null!=r&&(r.attributes=e)}return new Et(n.toString(),r,e,t,null)}_override_decl(){if(!this._match(gn.keywords.override))return null;const e=this._consume(gn.tokens.ident,"Expected variable name");let t=null;if(this._match(gn.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new At(e.toString(),t,null)}_enable_directive(){const e=this._consume(gn.tokens.ident,"identity expected.");return new Ut(e.toString())}_type_alias(){const e=this._consume(gn.tokens.ident,"identity expected.");this._consume(gn.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=new Dt(e.toString(),t);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([gn.tokens.ident,...gn.texel_format,gn.keywords.bool,gn.keywords.f32,gn.keywords.i32,gn.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new jt(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(gn.template_types)){let e=this._advance().toString(),t=null,n=null;return this._match(gn.tokens.less_than)&&(t=this._type_decl(),n=null,this._match(gn.tokens.comma)&&(n=this._consume(gn.access_mode,"Expected access_mode for pointer").toString()),this._consume(gn.tokens.greater_than,"Expected '>' for type.")),new Gt(e,t,n)}if(this._match(gn.keywords.ptr)){let e=this._previous().toString();this._consume(gn.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(gn.storage_class,"Expected storage_class for pointer");this._consume(gn.tokens.comma,"Expected ',' for pointer.");const n=this._type_decl();let r=null;return this._match(gn.tokens.comma)&&(r=this._consume(gn.access_mode,"Expected access_mode for pointer").toString()),this._consume(gn.tokens.greater_than,"Expected '>' for pointer."),new Wt(e,t.toString(),n,r)}const t=this._attribute();if(this._match(gn.keywords.array)){let e=null,n=-1;const r=this._previous();if(this._match(gn.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";this._match(gn.tokens.comma)&&(t=this._shift_expression().evaluate(this._context).toString()),this._consume(gn.tokens.greater_than,"Expected '>' for array."),n=t?parseInt(t):0}return new $t(r.toString(),t,e,n)}return null}_texture_sampler_types(){if(this._match(gn.sampler_type))return new Ht(this._previous().toString(),null,null);if(this._match(gn.depth_texture_type))return new Ht(this._previous().toString(),null,null);if(this._match(gn.sampled_texture_type)||this._match(gn.multisampled_texture_type)){const e=this._previous();this._consume(gn.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(gn.tokens.greater_than,"Expected '>' for sampler type."),new Ht(e.toString(),t,null)}if(this._match(gn.storage_texture_type)){const e=this._previous();this._consume(gn.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(gn.texel_format,"Invalid texel format.").toString();this._consume(gn.tokens.comma,"Expected ',' after texel format.");const n=this._consume(gn.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(gn.tokens.greater_than,"Expected '>' for sampler type."),new Ht(e.toString(),t,n)}return null}_attribute(){let e=[];for(;this._match(gn.tokens.attr);){const t=this._consume(gn.attribute_name,"Expected attribute name"),n=new fn(t.toString(),null);if(this._match(gn.tokens.paren_left)){if(n.value=this._consume(gn.literal_or_ident,"Expected attribute value").toString(),this._check(gn.tokens.comma)){this._advance();do{const e=this._consume(gn.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(e)}while(this._match(gn.tokens.comma))}this._consume(gn.tokens.paren_right,"Expected ')'")}e.push(n)}for(;this._match(gn.tokens.attr_left);){if(!this._check(gn.tokens.attr_right))do{const t=this._consume(gn.attribute_name,"Expected attribute name"),n=new fn(t.toString(),null);if(this._match(gn.tokens.paren_left)){if(n.value=[this._consume(gn.literal_or_ident,"Expected attribute value").toString()],this._check(gn.tokens.comma)){this._advance();do{const e=this._consume(gn.literal_or_ident,"Expected attribute value").toString();n.value.push(e)}while(this._match(gn.tokens.comma))}this._consume(gn.tokens.paren_right,"Expected ')'")}e.push(n)}while(this._match(gn.tokens.comma));this._consume(gn.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class wn{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class bn{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class _n extends wn{constructor(e,t){super(e,t),this.members=[],this.align=0}get isStruct(){return!0}}class Sn extends wn{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class kn extends wn{constructor(e,t,n,r){super(e,n),this.format=t,this.access=r}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(mt||(mt={}));class Tn{constructor(e,t,n,r,i,s,o){this.name=e,this.type=t,this.group=n,this.binding=r,this.attributes=i,this.resourceType=s,this.access=o}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class En{constructor(e,t){this.name=e,this.type=t}}class An{constructor(e,t){this.align=e,this.size=t}}class Pn{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r,this.interpolation=null}}class Mn{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r}}class Cn{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.name=e,this.stage=t}}class zn{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class In{constructor(e,t,n,r){this.name=e,this.type=t,this.attributes=n,this.id=r}}class Bn{constructor(e){this.resources=null,this.node=e}}class On{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new zn,this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new xn).parse(e);for(const e of t)e instanceof bt&&this._functions.set(e.name,new Bn(e));for(const e of t)if(e instanceof Vt){const t=this._getTypeInfo(e,null);t instanceof _n&&this.structs.push(t)}else if(e instanceof Dt)this.aliases.push(this._getAliasInfo(e));else if(e instanceof At){const t=e,n=this._getAttributeNum(t.attributes,"id",0),r=null!=t.type?this._getTypeInfo(t.type,t.attributes):null;this.overrides.push(new In(t.name,r,t.attributes,n))}else if(this._isUniformVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new Tn(t.name,i,n,r,t.attributes,mt.Uniform,t.access);this.uniforms.push(s)}else if(this._isStorageVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new Tn(t.name,i,n,r,t.attributes,s?mt.StorageTexture:mt.Storage,t.access);this.storage.push(o)}else if(this._isTextureVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),o=new Tn(t.name,i,n,r,t.attributes,s?mt.StorageTexture:mt.Texture,t.access);s?this.storage.push(o):this.textures.push(o)}else if(this._isSamplerVar(e)){const t=e,n=this._getAttributeNum(t.attributes,"group",0),r=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new Tn(t.name,i,n,r,t.attributes,mt.Sampler,t.access);this.samplers.push(s)}else if(e instanceof bt){const t=this._getAttribute(e,"vertex"),n=this._getAttribute(e,"fragment"),r=this._getAttribute(e,"compute"),i=t||n||r;if(i){const t=new Cn(e.name,null==i?void 0:i.name);t.inputs=this._getInputs(e.args),t.outputs=this._getOutputs(e.returnType),t.resources=this._findResources(e),this.entry[i.name].push(t)}}}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_findResources(e){const t=[],n=this,r=[];return e.search((e=>{if(e instanceof yt)r.push({});else if(e instanceof xt)r.pop();else if(e instanceof Et){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof Pt){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof Qt){const i=e;if(r.length>0&&r[r.length-1][i.name])return;const s=n._findResource(i.name);s&&t.push(s)}else if(e instanceof Kt){const r=e,i=n._functions.get(r.name);i&&(null===i.resources&&(i.resources=n._findResources(i.node)),t.push(...i.resources))}})),[...new Map(t.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,n){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),n>=e[t].length&&(e[t].length=n+1)}for(const n of this.uniforms)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.storage)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.textures)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.samplers)t(n.group,n.binding),e[n.group][n.binding]=n;return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof Vt)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);null!==n&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof Vt)this._getStructOutputs(n.type,t);else{const e=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(null!==e){const r=this._getTypeInfo(n.type,n.type.attributes),i=this._parseInt(e.value),s=new Mn(n.name,r,e.name,i);t.push(s)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getTypeInfo(e,e.attributes),r=this._parseInt(t.value);return new Mn("",n,t.name,r)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const n of e)if(n.type instanceof Vt)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof Vt)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getAttribute(e,"interpolation"),r=this._getTypeInfo(e.type,e.attributes),i=this._parseInt(t.value),s=new Pn(e.name,r,t.name,i);return null!==n&&(s.interpolation=this._parseString(n.value)),s}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new En(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof $t){const n=e,r=this._getTypeInfo(n.format,n.attributes),i=new Sn(n.name,t);return i.format=r,i.count=n.count,this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof Vt){const n=e,r=new _n(n.name,t);for(const e of n.members){const t=this._getTypeInfo(e.type,e.attributes);r.members.push(new bn(e.name,t,e.attributes))}return this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof Ht){const n=e,r=n.format instanceof jt,i=n.format?r?this._getTypeInfo(n.format,null):new wn(n.format,null):null,s=new kn(n.name,i,t,n.access);return this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof Gt){const n=e,r=n.format?this._getTypeInfo(n.format,null):null,i=new kn(n.name,r,t,n.access);return this._types.set(e,i),this._updateTypeInfo(i),i}const n=new wn(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n;const r=this._getTypeSize(e);if(e.size=null!==(t=null==r?void 0:r.size)&&void 0!==t?t:0,e instanceof Sn){const t=this._getTypeSize(e.format);e.stride=null!==(n=null==t?void 0:t.size)&&void 0!==n?n:0,this._updateTypeInfo(e.format)}e instanceof _n&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,r=0,i=0,s=0;for(let o=0,a=e.members.length;o<a;++o){const a=e.members[o],l=this._getTypeSize(a);if(!l)continue;null!==(t=this._getAlias(a.type.name))&&void 0!==t||a.type;const c=l.align,u=l.size;n=this._roundUp(c,n+r),r=u,i=n,s=Math.max(s,c),a.offset=n,a.size=u,this._updateTypeInfo(a.type)}e.size=this._roundUp(s,i+r),e.align=s}_getTypeSize(e){var t;if(null==e)return null;const n=this._getAttributeNum(e.attributes,"size",0),r=this._getAttributeNum(e.attributes,"align",0);if(e instanceof bn&&(e=e.type),e instanceof wn){const t=this._getAlias(e.name);null!==t&&(e=t)}{const t=On._typeInfo[e.name];if(void 0!==t){const i="f16"===e.format?2:1;return new An(Math.max(r,t.align/i),Math.max(n,t.size/i))}}{const t=On._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const i="h"===e.name[e.name.length-1]?2:1;return new An(Math.max(r,t.align/i),Math.max(n,t.size/i))}}if(e instanceof Sn){let i=e,s=8,o=8;const a=this._getTypeSize(i.format);return null!==a&&(o=a.size,s=a.align),o=i.count*this._getAttributeNum(null!==(t=null==e?void 0:e.attributes)&&void 0!==t?t:null,"stride",this._roundUp(s,o)),n&&(o=n),new An(Math.max(r,s),Math.max(n,o))}if(e instanceof _n){let t=0,i=0,s=0,o=0,a=0;for(const n of e.members){const e=this._getTypeSize(n.type);null!==e&&(t=Math.max(e.align,t),s=this._roundUp(e.align,s+o),o=e.size,a=s)}return i=this._roundUp(t,a+o),new An(Math.max(r,t),Math.max(n,i))}return null}_isUniformVar(e){return e instanceof Et&&"uniform"==e.storage}_isStorageVar(e){return e instanceof Et&&"storage"==e.storage}_isTextureVar(e){return e instanceof Et&&null!==e.type&&-1!=On._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof Et&&null!==e.type&&-1!=On._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const r=n.attributes;for(let e of r)if(e.name==t)return e;return null}_getAttributeNum(e,t,n){if(null===e)return n;for(let r of e)if(r.name==t){let e=null!==r&&null!==r.value?r.value:n;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}function Rn(e,t){const n=function(e){return Array.isArray(e)||ot(e)?[...e,1,1].slice(0,3):function(e){return[e.width,e.height||1,e.depthOrArrayLayers||1]}(e)}(e),r=Math.max(...n.slice(0,"3d"===t?3:2));return 1+Math.log2(r)|0}On._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},On._textureTypes=gn.any_texture_type.map((e=>e.name)),On._samplerTypes=gn.sampler_type.map((e=>e.name));const Nn=new WeakMap;const Un=new Map([[Int8Array,{formats:["sint8","snorm8"],defaultForType:1}],[Uint8Array,{formats:["uint8","unorm8"],defaultForType:1}],[Int16Array,{formats:["sint16","snorm16"],defaultForType:1}],[Uint16Array,{formats:["uint16","unorm16"],defaultForType:1}],[Int32Array,{formats:["sint32","snorm32"],defaultForType:0}],[Uint32Array,{formats:["uint32","unorm32"],defaultForType:0}],[Float32Array,{formats:["float32","float32"],defaultForType:0}]]);function Dn(e){return ot(e)||Array.isArray(e)||function(e){const t=e;return ot(t.data)||Array.isArray(t.data)}(e)}function Ln(e){switch(e){case"1d":return"1d";case"3d":return"3d";default:return"2d"}}new Map([...Un.entries()].map((([e,{formats:[t,n]}])=>[[t,e],[n,e]])).flat());const Fn={"8snorm":Int8Array,"8unorm":Uint8Array,"8sint":Int8Array,"8uint":Uint8Array,"16snorm":Int16Array,"16unorm":Uint16Array,"16sint":Int16Array,"16uint":Uint16Array,"32snorm":Int32Array,"32unorm":Uint32Array,"32sint":Int32Array,"32uint":Uint32Array,"16float":Uint16Array,"32float":Float32Array},qn=/([a-z]+)(\d+)([a-z]+)/;function jn(e){const[,t,n,r]=qn.exec(e),i=t.length,s=parseInt(n)/8;return{channels:t,numChannels:i,bytesPerChannel:s,bytesPerElement:i*s,Type:Fn[`${n}${r}`]}}function Vn(e,t,n,r={}){n.forEach(((n,i)=>{const s=[0,0,i+(r.baseArrayLayer||0)];if(Dn(n))!function(e,t,n,r){const i=function(e,t){if(ot(e))return e;const{Type:n}=jn(t);return new n(e)}(n.data||n,t.format),s=function(e,t){return[e.width,e.height,e.depthOrArrayLayers].map((e=>Math.max(1,Math.floor(e/1))))}(t),{bytesPerElement:o}=jn(t.format),a=r.origin||[0,0,0];e.queue.writeTexture({texture:t,origin:a},i,{bytesPerRow:o*s[0],rowsPerImage:s[1]},s)}(e,t,n,{origin:s});else{const i=n,{flipY:o,premultipliedAlpha:a,colorSpace:l}=r;e.queue.copyExternalImageToTexture({source:i,flipY:o},{texture:t,premultipliedAlpha:a,colorSpace:l,origin:s},Gn(i,r))}})),t.mipLevelCount>1&&function(e,t,n){let r=Nn.get(e);r||(r={pipelineByFormatAndView:{},moduleByViewType:{}},Nn.set(e,r));let{sampler:i,uniformBuffer:s,uniformValues:o}=r;const{pipelineByFormatAndView:a,moduleByViewType:l}=r;n=n||function(e){switch(e.dimension){case"1d":return"1d";case"3d":return"3d";default:return e.depthOrArrayLayers>1?"2d-array":"2d"}}(t);let c=l[n];if(!c){const t=function(e){let t,n;switch(e){case"2d":t="texture_2d<f32>",n="textureSample(ourTexture, ourSampler, fsInput.texcoord)";break;case"2d-array":t="texture_2d_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              fsInput.texcoord,\n              uni.layer)";break;case"cube":t="texture_cube<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1))";break;case"cube-array":t="texture_cube_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1), uni.layer)";break;default:throw new Error(`unsupported view: ${e}`)}return`\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n          var pos = array<vec2f, 3>(\n            vec2f(-1.0, -1.0),\n            vec2f(-1.0,  3.0),\n            vec2f( 3.0, -1.0),\n          );\n\n          var vsOutput: VSOutput;\n          let xy = pos[vertexIndex];\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n          return vsOutput;\n        }\n\n        struct Uniforms {\n          layer: u32,\n        };\n\n        @group(0) @binding(0) var ourSampler: sampler;\n        @group(0) @binding(1) var ourTexture: ${t};\n        @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni.layer; // make sure this is used so all pipelines have the same bindings\n          return ${n};\n        }\n      `}(n);c=e.createShaderModule({label:`mip level generation for ${n}`,code:t}),l[n]=c}i||(i=e.createSampler({minFilter:"linear",magFilter:"linear"}),s=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=new Uint32Array(1),Object.assign(r,{sampler:i,uniformBuffer:s,uniformValues:o}));const u=`${t.format}.${n}`;a[u]||(a[u]=e.createRenderPipeline({label:`mip level generator pipeline for ${n}`,layout:"auto",vertex:{module:c,entryPoint:"vs"},fragment:{module:c,entryPoint:"fs",targets:[{format:t.format}]}}));const h=a[u];for(let r=1;r<t.mipLevelCount;++r)for(let a=0;a<t.depthOrArrayLayers;++a){o[0]=a,e.queue.writeBuffer(s,0,o);const l=e.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:i},{binding:1,resource:t.createView({dimension:n,baseMipLevel:r-1,mipLevelCount:1})},{binding:2,resource:{buffer:s}}]}),c={label:"mip gen renderPass",colorAttachments:[{view:t.createView({dimension:"2d",baseMipLevel:r,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},u=e.createCommandEncoder({label:"mip gen encoder"}),d=u.beginRenderPass(c);d.setPipeline(h),d.setBindGroup(0,l),d.draw(3),d.end();const p=u.finish();e.queue.submit([p])}}(e,t)}function Gn(e,t){if(e instanceof HTMLVideoElement)return[e.videoWidth,e.videoHeight,1];{const n=e,{width:r,height:i}=n;if(r>0&&i>0&&!Dn(e))return[r,i,1];const s=t.format||"rgba8unorm",{bytesPerElement:o,bytesPerChannel:a}=jn(s),l=ot(e)||Array.isArray(e)?e:e.data;return function(e,t,n,r="2d"){if(n%1!=0)throw new Error("can't guess dimensions");if(e||t){if(t){if(!e&&(e=n/t)%1)throw new Error("can't guess dimensions")}else if((t=n/e)%1)throw new Error("can't guess dimensions")}else{const i=Math.sqrt(n/("cube"===r?6:1));i%1==0?(e=i,t=i):(e=n,t=1)}const i=n/e/t;if(i%1)throw new Error("can't guess dimensions");return[e,t,i]}(r,i,(ot(l)?l.byteLength:l.length*a)/o)}}async function Wn(e,t,n={}){const r=await Promise.all(t.map((e=>async function(e,t={}){const n=await fetch(e),r=await n.blob(),i={...t,...void 0!==t.colorSpaceConversion&&{colorSpaceConversion:"none"}};return await createImageBitmap(r,i)}(e))));return function(e,t,n={}){const r=Gn(t[0],n);r[2]=r[2]>1?r[2]:t.length;const i=e.createTexture({dimension:Ln(n.dimension),format:n.format||"rgba8unorm",mipLevelCount:n.mipLevelCount?n.mipLevelCount:n.mips?Rn(r):1,size:r,usage:(n.usage??0)|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return Vn(e,i,t,n),i}(e,r,n)}const $n=e=>{let t=i.eR.create(1/0,1/0,1/0),n=i.eR.create(-1/0,-1/0,-1/0);for(const{AABB:r}of e)t=i.eR.min(r.min,t),n=i.eR.max(r.max,n);return{min:t,max:n}},Hn=e=>{const t=$n(e),n=(t.max[0]-t.min[0])*(t.max[1]-t.min[1])*(t.max[2]-t.min[2]);return e.length*n},Yn=(56,16,16*Math.ceil(3.5));class Xn{#f;#m;#g;#v;#y;constructor(e,t){this.#f=e,this.#g=t.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#v=0,this.#m=[],this.#s(this.#g,0,-1,-1),this.#x()}get gpuBuffer(){return this.#y}update(e){this.#g=e.map(((e,t)=>({AABB:e,objectIndex:t}))),this.#v=0,this.#m=[],this.#s(this.#g,0,-1,-1),this.#x()}#s(e,t,n,r){if(0===this.#g.length)return;if(1===e.length)return void(this.#m[t]={leftChildIndex:this.#g.indexOf(e[0]),rightChildIndex:-1,objectCount:1,AABBMax:e[0].AABB.max,AABBMin:e[0].AABB.min,parentIndex:n,siblingIndex:r});const i=$n(e);let s=-1,o=-1;const{left:a,right:l}=(e=>{let t=1/0,n=-1;const r=Math.floor(e.length/2);for(let i=1;i<e.length;i++){const s=e.slice(0,i),o=e.slice(i),a=Hn(s)+Hn(o),l=1*Math.abs(i-r)+1*a;l<t&&(t=l,n=i)}return{left:e.slice(0,n),right:e.slice(n)}})(e);a.length>0&&(s=++this.#v,this.#s(a,s,t,o)),l.length>0&&(o=++this.#v,this.#s(l,o,t,s)),this.#m[t]={leftChildIndex:s,rightChildIndex:o,objectCount:e.length,AABBMax:i.max,AABBMin:i.min,parentIndex:n,siblingIndex:r}}#x(){return this.#y=this.#f.createBuffer({size:Math.max(this.#m.length,1)*Yn,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1,label:"bvh buffer"}),this.#m.forEach(((e,t)=>{const n=t*Yn,r=new ArrayBuffer(Yn),i=new DataView(r);i.setInt32(0,e.leftChildIndex,!0),i.setInt32(4,e.rightChildIndex,!0),i.setUint32(8,e.objectCount,!0),i.setFloat32(16,e.AABBMin[0],!0),i.setFloat32(20,e.AABBMin[1],!0),i.setFloat32(24,e.AABBMin[2],!0),i.setFloat32(32,e.AABBMax[0],!0),i.setFloat32(36,e.AABBMax[1],!0),i.setFloat32(40,e.AABBMax[2],!0),i.setInt32(48,e.parentIndex,!0),i.setInt32(52,e.siblingIndex,!0),this.#f.queue.writeBuffer(this.#y,n,r,0,Yn)})),this.#y}}const Zn="rgba32float",Kn=async e=>{const t=e.createBindGroupLayout({label:"lights-bind-group-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,sampler:{type:"non-filtering"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float"}},{binding:5,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Zn}},{binding:6,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:9,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:11,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}}]}),n=e.createBindGroupLayout({label:"light-config-bind-group-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),r=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),i=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),s=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:Zn}}]}),l=e.createBindGroupLayout({label:"svgf-config-bind-group-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}}]}),d=e.createBindGroupLayout({label:"denoise-bind-group-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:5,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:6,visibility:GPUShaderStage.COMPUTE,sampler:{type:"non-filtering"}}]}),p=e.createPipelineLayout({bindGroupLayouts:[t,n,r]}),f=e.createPipelineLayout({bindGroupLayouts:[t,s]}),m=e.createPipelineLayout({bindGroupLayouts:[t,l]}),g=e.createPipelineLayout({bindGroupLayouts:[o]}),v=e.createPipelineLayout({bindGroupLayouts:[d,l]}),y=e.createComputePipeline({compute:{module:e.createShaderModule({code:"struct SVGFConfig {\r\n          normalSigma: f32,\r\n          depthSigma: f32,\r\n          blueNoiseScale: f32,\r\n          spatialSigma: f32,\r\n        }\r\n\r\n        @group(0) @binding(0) var inputTex : texture_2d<f32>;\r\n        @group(0) @binding(1) var normalTex : texture_2d<f32>;\r\n        @group(0) @binding(2) var worldPosTex : texture_2d<f32>;\r\n        @group(0) @binding(3) var outputTex : texture_storage_2d<rgba16float, write>;\r\n        @group(0) @binding(4) var<uniform> atrousRate : u32;\r\n        @group(0) @binding(5) var linearSampler : sampler;\r\n        @group(0) @binding(6) var nearestSampler : sampler;\r\n\r\n        @group(1) @binding(0) var<uniform> svgfConfig : SVGFConfig;\r\n\r\n        const OFFSETS = array<vec2<i32>, 9>(\r\n            vec2<i32>(-1, -1), vec2<i32>(0, -1), vec2<i32>(1, -1),\r\n            vec2<i32>(-1, 0), vec2<i32>(0, 0), vec2<i32>(1, 0),\r\n            vec2<i32>(-1, 1), vec2<i32>(0, 1), vec2<i32>(1, 1)\r\n        );\r\n\r\n        const WEIGHTS = array<f32, 9>(\r\n            0.0625, 0.125, 0.0625,\r\n            0.125, 0.25, 0.125,\r\n            0.0625, 0.125, 0.0625\r\n        );\r\n\r\n        @compute @workgroup_size(8,8,1)\r\n        fn main(\r\n         @builtin(global_invocation_id) id : vec3<u32>\r\n        ){\r\n            var passInfluence = 1.0 / f32(atrousRate);\r\n            var colour = vec3(0.0);\r\n            var weightSum = 0.00001;\r\n            var resolution = vec2<f32>(textureDimensions(inputTex));\r\n            let uv = (vec2<f32>(id.xy) + vec2(0.5)) / resolution;\r\n            var colourRef = textureLoad(inputTex, id.xy, 0).rgb;\r\n            let normalRef = textureSampleLevel(normalTex, nearestSampler, uv, 0).rgb;\r\n            let worldPosRef = textureSampleLevel(worldPosTex, nearestSampler, uv, 0);\r\n\r\n            let depthRef = worldPosRef.w;\r\n            for(var i = 0; i < 9; i = i + 1){\r\n                let uvOffset = (vec2<f32>(OFFSETS[i]) / resolution) * f32(atrousRate);\r\n                let colourSample = textureSampleLevel(inputTex, linearSampler, uv + uvOffset, 0);\r\n                if(length(colourSample.rgb) < 0.0001){\r\n                    continue;\r\n                }\r\n\r\n                let normal = textureSampleLevel(normalTex, nearestSampler, uv + uvOffset, 0).rgb;\r\n                let normalWeight = exp(-dot(normalRef - normal, normalRef - normal) / (2.0 * svgfConfig.normalSigma * svgfConfig.normalSigma));\r\n\r\n                let worldPos = textureSampleLevel(worldPosTex, nearestSampler, uv + uvOffset, 0);\r\n                let depth = worldPos.w;\r\n\r\n                let depthWeight = exp(-pow(depthRef - depth, 2.0) / (2.0 * svgfConfig.depthSigma * svgfConfig.depthSigma));\r\n\r\n                let weight = normalWeight * depthWeight * WEIGHTS[i];\r\n                colour += colourSample.rgb * weight;\r\n                weightSum += weight;\r\n            }\r\n            colour /= weightSum;\r\n            textureStore(outputTex, id.xy, vec4<f32>(colour, 1.0));\r\n        }"}),entryPoint:"main"},layout:v}),x=e.createComputePipeline({compute:{module:e.createShaderModule({code:"\n        @group(0) @binding(0) var reservoirTex : texture_storage_2d<rgba32float, write>;\n        @compute @workgroup_size(8,8,1)\n        fn main(\n        @builtin(global_invocation_id) id : vec3<u32>\n        ){\n            textureStore(reservoirTex, id.xy, vec4<f32>(0.0, 0.0, 0.0, 0.0));\n        }\n          "}),entryPoint:"main"},layout:g}),w=`\nconst DOWN_SAMPLE_FACTOR = 3;\nconst MAX_SAMPLES = 256;\nconst RESERVOIR_DECAY = 0.5;\n@group(0) @binding(7) var<storage, read> octreeBuffer : array<vec2<u32>>;\n@group(0) @binding(8) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(9) var<storage> bvhNodes: array<BVHNode>;\n\n${c}\n${h}\n${a}\n${u}\n\n\r\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>,\r\n  viewMatrix : mat4x4<f32>,\r\n};\r\n\r\nstruct Time {\r\n  frame: u32,\r\n  deltaTime: f32,\r\n  elapsed: f32\r\n};\r\n\r\nfn convert2DTo1D(width: u32, index2D: vec2<u32>) -> u32 {\r\n    return index2D.y * width + index2D.x;\r\n}\r\n\r\nfn convert1DTo2D(width: u32, index1D: u32) -> vec2<u32> {\r\n    return vec2<u32>(index1D % width, index1D / width);\r\n}\r\n\r\nstruct Light {\r\n  position: vec3<f32>,\r\n  color: vec3<f32>,\r\n};\r\n\r\nstruct LightConfig {\r\n  constantAttenuation: f32,\r\n  linearAttenuation: f32,\r\n  quadraticAttenuation: f32,\r\n  normalSigma: f32\r\n}\r\n\r\n// 8 byte\r\nstruct Reservoir {\r\n  sampleCount: u32,\r\n  weightSum: f32,\r\n  lightWeight: f32,\r\n  lightIndex: u32,\r\n}\r\n\r\nfn getLightWeight(lightPos: vec3<f32>, lightColour: vec3<f32>, worldPos: vec3<f32>, normal: vec3<f32>) -> f32 {\r\n  let lightDir = lightPos - worldPos;\r\n  let d = length(lightDir);\r\n  let attenuation = lightConfig.constantAttenuation + lightConfig.linearAttenuation * d + lightConfig.quadraticAttenuation * d * d;\r\n  let ndotl = dot(normalize(lightDir), normal);\r\n  return (1.0 / attenuation) * length(lightColour) * ndotl;\r\n}\r\n\r\nfn unpackReservoir(reservoir: vec4<f32>) -> Reservoir {\r\n    return Reservoir(\r\n        bitcast<u32>(reservoir.x),\r\n        reservoir.y,\r\n        reservoir.z,\r\n        bitcast<u32>(reservoir.w)\r\n    );\r\n}\r\n\r\n\r\n@group(0) @binding(1) var worldPosTex : texture_2d<f32>;\r\n@group(0) @binding(2) var normalTex : texture_2d<f32>;\r\n@group(0) @binding(3) var<storage, read> lightsBuffer : array<Light>;\r\n@group(0) @binding(4) var outputTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(5) var reservoirTex : texture_storage_2d<rgba32float, write>;\r\n@group(0) @binding(6) var inputTex : texture_2d<f32>;\r\n@group(0) @binding(10) var blueNoiseTex : texture_2d<f32>;\r\n@group(0) @binding(11) var<uniform> time : Time;\r\n@group(0) @binding(12) var<uniform> cameraPosition : vec3<f32>;\r\n\r\n@group(1) @binding(0) var<uniform> lightConfig : LightConfig;\r\n@group(2) @binding(0) var inputReservoirTex : texture_2d<f32>;\r\n\r\nconst CONSTANT_ATTENUATION = 0.0;\r\nconst LINEAR_ATTENUATION = 0.1;\r\nconst QUADRATIC_ATTENUATION = 0.1;\r\nconst LIGHT_COUNT = 32;\r\nconst SAMPLES_PER_FRAME = 8;\r\n\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n    @builtin(global_invocation_id) id : vec3<u32>,\r\n) {\r\n  let frameCycle =u32(DOWN_SAMPLE_FACTOR * DOWN_SAMPLE_FACTOR);\r\n  let frameIndex = time.frame % frameCycle;\r\n  let kernelX = frameIndex % DOWN_SAMPLE_FACTOR;\r\n  let kernelY = (frameIndex / DOWN_SAMPLE_FACTOR) % DOWN_SAMPLE_FACTOR;\r\n  let offsetPixel = id.xy * DOWN_SAMPLE_FACTOR  + vec2<u32>(kernelX, kernelY);\r\n  let worldPosSample = textureLoad(worldPosTex, offsetPixel, 0);\r\n  let worldPos = worldPosSample.xyz;\r\n\r\n  let normal = textureLoad(normalTex, offsetPixel, 0).xyz;\r\n  var blueNoisePixel = vec2<i32>(offsetPixel);\r\n  let frameOffsetX = (i32(time.frame) * 92821 + 71413);  // Large prime numbers for frame variation\r\n  let frameOffsetY = (i32(time.frame) * 13761 + 512);    // Different prime numbers\r\n  blueNoisePixel.x += frameOffsetX;\r\n  blueNoisePixel.y += frameOffsetY;\r\n  let r = textureLoad(blueNoiseTex, blueNoisePixel % 512, 0).xy;\r\n\r\n  var bestWeight = 0.0;\r\n  var weightSum = 0.0;\r\n  var lightIndex = 0u;\r\n  var sampleCount = 0u;\r\n  for(var i = 0; i < SAMPLES_PER_FRAME; i++){\r\n    let iterOffsetX = (i * 193); // Large prime numbers for frame variation\r\n    let iterOffsetY = (i * 257); // Different prime numbers\r\n    let sampleR = textureLoad(blueNoiseTex, (blueNoisePixel + vec2(iterOffsetX, iterOffsetY)) % 512, 0).xy;\r\n    let sampleLightIndex = u32(sampleR.x * f32(LIGHT_COUNT));\r\n    let light = lightsBuffer[sampleLightIndex];\r\n    let lightPos = light.position + randomInUnitSphere(sampleR);\r\n    let weight = getLightWeight(lightPos, light.color, worldPos, normal);\r\n\r\n    weightSum += weight;\r\n    sampleCount++;\r\n\r\n    if(r.y < weight / weightSum){\r\n      lightIndex = sampleLightIndex;\r\n      bestWeight = weight;\r\n    }\r\n  }\r\n\r\n  let light = lightsBuffer[lightIndex];\r\n  let lightDir = light.position + randomInUnitSphere(r) - worldPos;\r\n\r\n  let raymarchResult = rayMarchBVH(worldPos + normal * 0.001, normalize(lightDir));\r\n  if(raymarchResult.hit){\r\n      bestWeight = 0.0;\r\n  }\r\n\r\n  bestWeight = clamp(bestWeight, 0.0, 8.0);\r\n\r\n  var reservoir = vec4(\r\n    bitcast<f32>(SAMPLES_PER_FRAME),\r\n     weightSum,\r\n     bestWeight,\r\n     bitcast<f32>(lightIndex),\r\n  );\r\n\r\n\r\n  if(r.y < bestWeight / weightSum){\r\n    textureStore(reservoirTex, offsetPixel, reservoir);\r\n  }\r\n}`,b=e.createComputePipeline({compute:{module:e.createShaderModule({code:w}),entryPoint:"main"},layout:p}),_=e.createComputePipeline({compute:{module:e.createShaderModule({code:"\n        const DOWN_SAMPLE_FACTOR = 3;\n        struct Light {\r\n  position: vec3<f32>,\r\n  color: vec3<f32>,\r\n};\r\n\r\nstruct Time {\r\n  frame: u32,\r\n  deltaTime: f32,\r\n  elapsed: f32\r\n};\r\n\r\nstruct Reservoir {\r\n  sampleCount: u32,\r\n  weightSum: f32,\r\n  lightWeight: f32,\r\n  lightIndex: u32,\r\n}\r\n\r\nstruct SVGFConfig {\r\n  normalSigma: f32,\r\n  depthSigma: f32,\r\n  blueNoiseScale: f32,\r\n  spatialSigma: f32,\r\n}\r\n\r\n@group(0) @binding(0) var nearestSampler : sampler;\r\n@group(0) @binding(1) var worldPosTex : texture_2d<f32>;\r\n@group(0) @binding(2) var normalTex : texture_2d<f32>;\r\n@group(0) @binding(3) var<storage, read> lightsBuffer : array<Light>;\r\n@group(0) @binding(4) var outputTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(6) var inputTex : texture_2d<f32>;\r\n@group(0) @binding(10) var blueNoiseTex : texture_2d<f32>;\r\n@group(0) @binding(11) var<uniform> time : Time;\r\n@group(0) @binding(12) var<uniform> cameraPosition : vec3<f32>;\r\n@group(0) @binding(13) var linearSampler : sampler;\r\n\r\n@group(1) @binding(0) var<uniform> svgfConfig : SVGFConfig;\r\n@group(1) @binding(1) var reservoirTex : texture_2d<f32>;\r\n\r\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\r\n    vec2<i32>(-1, -1),\r\n    vec2<i32>(0, -1),\r\n    vec2<i32>(1, -1),\r\n    vec2<i32>(-1, 0),\r\n    vec2<i32>(1, 0),\r\n    vec2<i32>(-1, 1),\r\n    vec2<i32>(0, 1),\r\n    vec2<i32>(1, 1)\r\n);\r\n\r\n\r\nfn unpackReservoir(reservoir: vec4<f32>) -> Reservoir {\r\n    return Reservoir(\r\n        bitcast<u32>(reservoir.x),\r\n        reservoir.y,\r\n        reservoir.z,\r\n        bitcast<u32>(reservoir.w)\r\n    );\r\n}\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn composite(\r\n@builtin(global_invocation_id) id : vec3<u32>\r\n){\r\n  let pixel = id.xy;\r\n  let resolution = textureDimensions(outputTex);\r\n  let uv = vec2<f32>(pixel) / vec2<f32>(resolution);\r\n  let reservoir = unpackReservoir(textureSampleLevel(reservoirTex, nearestSampler, uv, 0));\r\n  let linearReservoir = unpackReservoir(textureSampleLevel(reservoirTex, linearSampler, uv, 0));\r\n  let diffuse = reservoir.lightWeight * lightsBuffer[reservoir.lightIndex].color;\r\n//  textureStore(outputTex, vec2<i32>(id.xy), vec4<f32>(linearReservoir.lightWeight * 200.0));\r\n  textureStore(outputTex, vec2<i32>(id.xy), vec4<f32>(diffuse, 1.0));\r\n\r\n\r\n}"}),entryPoint:"composite"},layout:m}),S=e.createComputePipeline({compute:{module:e.createShaderModule({code:`\n            const DOWN_SAMPLE_FACTOR = 3;\n            const MAX_SAMPLES = 256;\n            const RESERVOIR_DECAY = 0.5;\n            @group(0) @binding(7) var<storage, read> octreeBuffer : array<vec2<u32>>;\n            @group(0) @binding(8) var<storage> voxelObjects : array<VoxelObject>;\n            @group(0) @binding(9) var<storage> bvhNodes: array<BVHNode>;\n            \n            ${c}\n            ${h}\n            ${a}\n            ${u}\n            \n            @group(0) @binding(0) var nearestSampler : sampler;\r\n@group(0) @binding(1) var worldPosTex : texture_2d<f32>;\r\n@group(0) @binding(2) var normalTex : texture_2d<f32>;\r\n@group(0) @binding(3) var<storage, read> lightsBuffer : array<Light>;\r\n@group(0) @binding(4) var outputTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(5) var reservoirTex : texture_storage_2d<rgba32float, write>;\r\n@group(0) @binding(6) var inputTex : texture_2d<f32>;\r\n@group(0) @binding(10) var blueNoiseTex : texture_2d<f32>;\r\n@group(0) @binding(11) var<uniform> time : Time;\r\n@group(0) @binding(12) var<uniform> cameraPosition : vec3<f32>;\r\n@group(0) @binding(13) var linearSampler : sampler;\r\n\r\n\r\n@group(1) @binding(0) var inputReservoirTex : texture_2d<f32>;\r\n\r\nfn convert2DTo1D(width: u32, index2D: vec2<u32>) -> u32 {\r\n    return index2D.y * width + index2D.x;\r\n}\r\n\r\nfn convert1DTo2D(width: u32, index1D: u32) -> vec2<u32> {\r\n    return vec2<u32>(index1D % width, index1D / width);\r\n}\r\n\r\n\r\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>,\r\n  viewMatrix : mat4x4<f32>,\r\n};\r\n\r\nstruct Time {\r\n  frame: u32,\r\n  deltaTime: f32,\r\n  elapsed: f32\r\n};\r\n\r\nstruct Light {\r\n  position: vec3<f32>,\r\n  color: vec3<f32>,\r\n};\r\n\r\nstruct Reservoir {\r\n  sampleCount: u32,\r\n  weightSum: f32,\r\n  lightWeight: f32,\r\n  lightIndex: u32,\r\n}\r\n\r\nconst NEIGHBOUR_OFFSETS = array<vec2<i32>, 4>(\r\n  vec2<i32>(-1, 0),\r\n  vec2<i32>(1, 0),\r\n  vec2<i32>(0, -1),\r\n  vec2<i32>(0, 1),\r\n//  vec2<i32>(-1, -1),\r\n//  vec2<i32>(1, -1),\r\n//  vec2<i32>(-1, 1),\r\n//  vec2<i32>(1, 1)\r\n);\r\n\r\nconst SAMPLE_RADIUS = 1;\r\nconst MAX_WEIGHT = 5.0;\r\nconst WEIGHT_THRESHOLD = 50.0;\r\n\r\n\r\nfn unpackReservoir(reservoir: vec4<f32>) -> Reservoir {\r\n    return Reservoir(\r\n        bitcast<u32>(reservoir.x),\r\n        reservoir.y,\r\n        reservoir.z,\r\n        bitcast<u32>(reservoir.w)\r\n    );\r\n}\r\n\r\nfn packReservoir(reservoir: Reservoir) -> vec4<f32> {\r\n    return vec4<f32>(\r\n        bitcast<f32>(reservoir.sampleCount),\r\n        reservoir.weightSum,\r\n        reservoir.lightWeight,\r\n        bitcast<f32>(reservoir.lightIndex)\r\n    );\r\n}\r\n\r\nconst DEPTH_THRESHOLD = 16.0;\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn spatial(\r\n@builtin(global_invocation_id) id : vec3<u32>\r\n){\r\n\r\n  let resolution = textureDimensions(worldPosTex).xy;\r\n  let uv = (vec2<f32>(id.xy) + vec2(0.5)) / vec2<f32>(resolution);\r\n  let normalRef = textureSampleLevel(normalTex, nearestSampler, uv, 0).xyz;\r\n  let worldPos = textureLoad(worldPosTex, id.xy, 0);\r\n\r\n  if(worldPos.w > 10000.0){\r\n    return;\r\n  }\r\n\r\n  let reservoir = unpackReservoir(textureSampleLevel(inputReservoirTex, nearestSampler, uv, 0));\r\n  var weightSum = reservoir.weightSum;\r\n  var currentWeight = reservoir.lightWeight;\r\n  var currentSampleCount = reservoir.sampleCount;\r\n  var lightIndex = reservoir.lightIndex;\r\n\r\n  let frameOffsetX = (i32(time.frame) * 92821 + 71413) % 512;  // Large prime numbers for frame variation\r\n  let frameOffsetY = (i32(time.frame) * 13761 + 511) % 512;    // Different prime numbers\r\n\r\n  for(var i = 0u; i < 4; i = i + 1u){\r\n    let offset = NEIGHBOUR_OFFSETS[i];\r\n    let neighbor = vec2<i32>(id.xy) + offset;\r\n    let neighborUv = vec2<f32>(neighbor) / vec2<f32>(resolution);\r\n    let neighborReservoir = unpackReservoir(textureLoad(inputReservoirTex, neighbor, 0));\r\n    let linearReservoir = unpackReservoir(textureSampleLevel(inputReservoirTex, linearSampler, neighborUv, 0));\r\n    let neighborWeight = neighborReservoir.lightWeight;\r\n    let normalSample = textureSampleLevel(normalTex, nearestSampler, neighborUv, 0).xyz;\r\n    let normalSimilarity = dot(normalRef, normalSample);\r\n\r\n    weightSum += neighborWeight;\r\n    currentSampleCount += neighborReservoir.sampleCount;\r\n\r\n    let sampleR = textureLoad(blueNoiseTex, (neighbor + vec2(frameOffsetX, frameOffsetY)) % 512, 0).xy;\r\n\r\n    let depthSample = textureLoad(worldPosTex, neighbor, 0).w;\r\n    let depthDifference: f32 = abs(depthSample - worldPos.w);\r\n\r\n    if(sampleR.y < neighborWeight / weightSum && normalSimilarity > 0.5 && depthDifference < DEPTH_THRESHOLD){\r\n        lightIndex = neighborReservoir.lightIndex;\r\n        currentWeight = neighborWeight;\r\n    }\r\n\r\n  }\r\n\r\n  let newReservoir = Reservoir(currentSampleCount, weightSum, currentWeight, lightIndex);\r\n  textureStore(reservoirTex, id.xy, packReservoir(newReservoir));\r\n}\r\n`}),entryPoint:"spatial"},layout:f}),k=e.createComputePipeline({compute:{module:e.createShaderModule({code:"\n            const DOWN_SAMPLE_FACTOR = 3;\n            const MAX_SAMPLES = 256;\n            const RESERVOIR_DECAY = 0.5;\n            @group(0) @binding(0) var nearestSampler : sampler;\r\n@group(0) @binding(1) var worldPosTex : texture_2d<f32>;\r\n@group(0) @binding(2) var normalTex : texture_2d<f32>;\r\n@group(0) @binding(3) var<storage, read> lightsBuffer : array<Light>;\r\n@group(0) @binding(4) var outputTex : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(5) var reservoirTex : texture_storage_2d<rgba32float, write>;\r\n@group(0) @binding(6) var inputTex : texture_2d<f32>;\r\n@group(0) @binding(10) var blueNoiseTex : texture_2d<f32>;\r\n@group(0) @binding(11) var<uniform> time : Time;\r\n@group(0) @binding(12) var<uniform> cameraPosition : vec3<f32>;\r\n@group(0) @binding(13) var linearSampler : sampler;\r\n\r\n@group(1) @binding(0) var velocityTex : texture_2d<f32>;\r\n@group(1) @binding(1) var previousReservoirTex : texture_2d<f32>;\r\n@group(1) @binding(2) var inputReservoirTex : texture_2d<f32>;\r\n\r\nfn convert2DTo1D(width: u32, index2D: vec2<u32>) -> u32 {\r\n    return index2D.y * width + index2D.x;\r\n}\r\n\r\nfn convert1DTo2D(width: u32, index1D: u32) -> vec2<u32> {\r\n    return vec2<u32>(index1D % width, index1D / width);\r\n}\r\n\r\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>,\r\n  viewMatrix : mat4x4<f32>,\r\n};\r\n\r\nstruct Time {\r\n  frame: u32,\r\n  deltaTime: f32,\r\n  elapsed: f32\r\n};\r\n\r\nstruct Light {\r\n  position: vec3<f32>,\r\n  color: vec3<f32>,\r\n};\r\n\r\nstruct Reservoir {\r\n  sampleCount: u32,\r\n  weightSum: f32,\r\n  lightWeight: f32,\r\n  lightIndex: u32,\r\n}\r\n\r\nconst DISTANCE_THRESHOLD = 100.0;\r\nconst WEIGHT_THRESHOLD = 100.0;\r\nconst DEPTH_THRESHOLD : f32 = 64.0;\r\n\r\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\r\n    vec2<i32>(-1, -1),\r\n    vec2<i32>(0, -1),\r\n    vec2<i32>(1, -1),\r\n    vec2<i32>(-1, 0),\r\n    vec2<i32>(1, 0),\r\n    vec2<i32>(-1, 1),\r\n    vec2<i32>(0, 1),\r\n    vec2<i32>(1, 1)\r\n);\r\n\r\nfn unpackReservoir(reservoir: vec4<f32>) -> Reservoir {\r\n    return Reservoir(\r\n        bitcast<u32>(reservoir.x),\r\n        reservoir.y,\r\n        reservoir.z,\r\n        bitcast<u32>(reservoir.w)\r\n    );\r\n}\r\n\r\nfn packReservoir(reservoir: Reservoir) -> vec4<f32> {\r\n    return vec4<f32>(\r\n        bitcast<f32>(reservoir.sampleCount),\r\n        reservoir.weightSum,\r\n        reservoir.lightWeight,\r\n        bitcast<f32>(reservoir.lightIndex)\r\n    );\r\n}\r\n\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn main(\r\n@builtin(global_invocation_id) id : vec3<u32>\r\n){\r\n  let resolution = textureDimensions(inputTex);\r\n\r\n  var blueNoisePixel = vec2<i32>(id.xy);\r\n  let frameOffsetX = (i32(time.frame) * 92821 + 71413) % 512;  // Large prime numbers for frame variation\r\n  let frameOffsetY = (i32(time.frame) * 13761 + 511) % 512;    // Different prime numbers\r\n  blueNoisePixel.x += frameOffsetX;\r\n  blueNoisePixel.y += frameOffsetY;\r\n  let r = textureLoad(blueNoiseTex, blueNoisePixel % 512, 0).xy;\r\n\r\n  let uv = (vec2<f32>(id.xy) + vec2(0.5)) / vec2<f32>(resolution);\r\n  let velocity = textureLoad(velocityTex, id.xy, 0).xy;\r\n  let previousUv = uv - velocity;\r\n  let pixelVelocity = velocity * vec2<f32>(resolution);\r\n  let previousPixel = vec2<f32>(id.xy) - pixelVelocity;\r\n  let previousWorldPos = textureLoad(worldPosTex, vec2<u32>(previousPixel), 0);\r\n  var depthSample = textureLoad(worldPosTex, id.xy, 0).w;\r\n\r\n  let reservoir = unpackReservoir(textureSampleLevel(inputReservoirTex, nearestSampler, uv, 0.));\r\n  var currentWeightSum = reservoir.weightSum;\r\n  var currentWeight = reservoir.lightWeight;\r\n  var currentSampleCount = reservoir.sampleCount;\r\n  var currentLightIndex = reservoir.lightIndex;\r\n\r\n  let normalSample = textureSampleLevel(normalTex, nearestSampler, uv, 0);\r\n  let previousNormal = textureSampleLevel(normalTex, nearestSampler, previousUv, 0);\r\n  let normalSimilarity = dot(previousNormal, normalSample);\r\n\r\n  var previousReservoir = unpackReservoir(textureSampleLevel(previousReservoirTex, nearestSampler, previousUv, 0.));\r\n  let previousCount = previousReservoir.sampleCount;\r\n  let previousReservoirLinear = unpackReservoir(textureSampleLevel(previousReservoirTex, linearSampler, previousUv, 0.));\r\n\r\n  let previousWeight = previousReservoirLinear.lightWeight;\r\n  let previousWeightSum = previousReservoirLinear.weightSum;\r\n\r\n  currentSampleCount += previousCount;\r\n  currentWeightSum += previousWeight;\r\n\r\n\r\n  let depthDifference: f32 = abs(depthSample - previousWorldPos.w);\r\n\r\n  if(normalSimilarity > 0.5 && depthDifference < DEPTH_THRESHOLD){\r\n    currentLightIndex = previousReservoir.lightIndex;\r\n    currentWeight = previousWeight;\r\n  }\r\n\r\n\r\n  var newReservoir  = Reservoir(currentSampleCount, currentWeightSum, currentWeight, currentLightIndex);\r\n  textureStore(reservoirTex, id.xy, packReservoir(newReservoir));\r\n}\r\n"}),entryPoint:"main"},layout:e.createPipelineLayout({bindGroupLayouts:[t,i]})}),T=e.createSampler({magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest"}),E=e.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"});let A,P,M,C,z,I,B,O,R,N,U,D,L,F,q,j,V,G,W,$,H={constantAttenuation:.1,linearAttenuation:.2,quadraticAttenuation:.05},Y={normalSigma:.5,depthSigma:1.5,blueNoiseSCale:0,spatialSigma:6},X={spatialEnabled:!1,temporalEnabled:!1,denoiseEnabled:!1,maxDenoiseRate:4};const Z=window.debugUI.gui.addFolder("lighting");return Z.add(H,"constantAttenuation",0,1,.1),Z.add(H,"linearAttenuation",.01,1,.01),Z.add(H,"quadraticAttenuation",.005,.1,.001),Z.add(Y,"normalSigma",.1,2,.05),Z.add(Y,"depthSigma",.1,8,.05),Z.add(Y,"spatialSigma",.2,16,.1),Z.add(Y,"blueNoiseSCale",0,10,.1),Z.add(X,"spatialEnabled"),Z.add(X,"temporalEnabled"),Z.add(X,"denoiseEnabled"),Z.add(X,"maxDenoiseRate",1,16,1),{render:({commandEncoder:a,outputTextures:c,timestampWrites:u,lights:h,volumeAtlas:p,transformationMatrixBuffer:f,bvhBuffer:m,blueNoiseTextureView:g,timeBuffer:v,cameraPositionBuffer:w})=>{if(U&&U.width===c.finalTexture.width&&U.height===c.finalTexture.height||(U=e.createTexture({size:{width:c.finalTexture.width,height:c.finalTexture.height},format:c.finalTexture.format,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC}),D=U.createView()),a.copyTextureToTexture({texture:c.finalTexture.texture},{texture:U},{width:c.finalTexture.width,height:c.finalTexture.height}),q||(q=e.createBuffer({label:"svgf-config-buffer",size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),e.queue.writeBuffer(q,0,new Float32Array([Y.normalSigma,Y.depthSigma,Y.blueNoiseSCale,Y.spatialSigma])),C||(Math.ceil(c.finalTexture.width/3),Math.ceil(c.finalTexture.height/3),C=e.createTexture({size:{width:c.finalTexture.width,height:c.finalTexture.height},format:Zn,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING}),z=C.createView()),I||(I=e.createTexture({size:{width:C.width,height:C.height},format:Zn,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),B=I.createView()),O||(O=e.createTexture({size:{width:C.width,height:C.height},format:Zn,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),R=O.createView()),$||($=e.createBindGroup({layout:r,entries:[{binding:0,resource:R}]})),j||(j=e.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:q}},{binding:1,resource:R}]})),!N){const t=4;N=e.createBuffer({label:"light-config-buffer",size:5*t,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}e.queue.writeBuffer(N,0,new Float32Array([H.constantAttenuation,H.linearAttenuation,H.quadraticAttenuation])),A||(A=e.createBuffer({size:32*h.length,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})),V||(V=e.createBindGroup({layout:o,entries:[{binding:0,resource:C.createView()}]})),W||(W=e.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),G||(G=e.createBindGroup({layout:d,entries:[{binding:0,resource:c.finalTexture.view},{binding:1,resource:c.normalTexture.view},{binding:2,resource:c.worldPositionTexture.view},{binding:3,resource:D},{binding:4,resource:{buffer:W}},{binding:5,resource:E},{binding:6,resource:T}]})),P=e.createBindGroup({label:"lights-bind-group",layout:t,entries:[{binding:0,resource:T},{binding:1,resource:c.worldPositionTexture.view},{binding:2,resource:c.normalTexture.view},{binding:3,resource:{buffer:A}},{binding:4,resource:c.finalTexture.view},{binding:5,resource:z},{binding:6,resource:D},{binding:7,resource:{buffer:p.octreeBuffer}},{binding:8,resource:{buffer:f}},{binding:9,resource:{buffer:m}},{binding:10,resource:g},{binding:11,resource:{buffer:v}},{binding:12,resource:{buffer:w}},{binding:13,resource:E}]}),L||(L=e.createBindGroup({layout:i,entries:[{binding:0,resource:c.velocityTexture.view},{binding:1,resource:B},{binding:2,resource:R}]})),F||(F=e.createBindGroup({layout:s,entries:[{binding:0,resource:R}]})),M||(M=e.createBindGroup({label:"light-config-bind-group",layout:n,entries:[{binding:0,resource:{buffer:N}}]}));const Z=new ArrayBuffer(32*h.length),K=new DataView(Z);for(let e=0;e<h.length;e++){const t=h[e],n=32*e;K.setFloat32(n,t.position[0],!0),K.setFloat32(n+4,t.position[1],!0),K.setFloat32(n+8,t.position[2],!0),K.setFloat32(n+16,t.color[0],!0),K.setFloat32(n+20,t.color[1],!0),K.setFloat32(n+24,t.color[2],!0)}e.queue.writeBuffer(A,0,Z);const Q=Math.ceil(c.finalTexture.width/3),J=Math.ceil(c.finalTexture.height/3);let ee,te=0;const ne=()=>{a.copyTextureToTexture({texture:C},{texture:O},{width:C.width,height:C.height})},re=t=>{e.queue.writeBuffer(W,0,new Uint32Array([t])),ee=a.beginComputePass({label:"denoise-pass",timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+te,endOfPassWriteIndex:u.endOfPassWriteIndex+te}}),ee.setPipeline(y),ee.setBindGroup(0,G),ee.setBindGroup(1,j),ee.dispatchWorkgroups(Math.ceil(c.finalTexture.width/8),Math.ceil(c.finalTexture.height/8),1),ee.end(),te+=2,ie()},ie=()=>{a.copyTextureToTexture({texture:U},{texture:c.finalTexture.texture},{width:c.finalTexture.width,height:c.finalTexture.height})};X.temporalEnabled&&(ee=a.beginComputePass({label:"temporal",timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+te,endOfPassWriteIndex:u.endOfPassWriteIndex+te}}),ee.setBindGroup(0,P),ee.setPipeline(k),ee.setBindGroup(1,L),ee.dispatchWorkgroups(Math.ceil(C.width/8),Math.ceil(C.height/8),1),ee.end(),te+=2,ne()),ee=a.beginComputePass({label:"sample-lights",timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+te,endOfPassWriteIndex:u.endOfPassWriteIndex+te}}),ee.setBindGroup(0,P),ee.setPipeline(b),ee.setBindGroup(1,M),ee.setBindGroup(2,$),ee.dispatchWorkgroups(Math.ceil(Q/8),Math.ceil(J/8),1),ee.end(),te+=2,ne(),X.spatialEnabled&&(ee=a.beginComputePass({label:"spatial-pass",timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+te,endOfPassWriteIndex:u.endOfPassWriteIndex+te}}),ee.setBindGroup(0,P),ee.setBindGroup(1,F),ee.setPipeline(S),ee.dispatchWorkgroups(Math.ceil(C.width/8),Math.ceil(C.height/8),1),ee.end(),te+=2,ne()),ee=a.beginComputePass({label:"composite-pass",timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+te,endOfPassWriteIndex:u.endOfPassWriteIndex+te}}),ee.setPipeline(_),ee.setBindGroup(0,P),ee.setBindGroup(1,j),ee.dispatchWorkgroups(Math.ceil(c.finalTexture.width/8),Math.ceil(c.finalTexture.height/8),1),ee.end(),te+=2,X.denoiseEnabled&&(X.maxDenoiseRate>=2&&re(2),X.maxDenoiseRate>=4&&re(4),X.maxDenoiseRate>=8&&re(8),X.maxDenoiseRate>=16&&re(16)),a.copyTextureToTexture({texture:C},{texture:I},{width:C.width,height:C.height}),ee=a.beginComputePass({label:"clear-reservoir-pass",timestampWrites:{querySet:u.querySet,beginningOfPassWriteIndex:u.beginningOfPassWriteIndex+te,endOfPassWriteIndex:u.endOfPassWriteIndex+te}}),ee.setPipeline(x),ee.setBindGroup(0,V),ee.dispatchWorkgroups(Math.ceil(C.width/8),Math.ceil(C.height/8)),ee.end(),te+=2},label:"lights",timestampLabels:["restir clear","restir lights","restir temporal","restir spatial","restir composite","denoise 2","denoise 4"]}},Qn="clear",Jn=async()=>{const e=Sr.createShaderModule({code:"\n    struct VertexOutput {\n      @builtin(position) position : vec4f,\n    }\n    @vertex\n    fn vertex_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n      var output : VertexOutput;\n      return output;\n    }\n    @fragment\n    fn fragment_main(@builtin(position) position : vec4f) -> @location(0) vec4<f32> {\n        return vec4(0.0);\n    }"}),t=Sr.createRenderPipeline({label:Qn,layout:"auto",vertex:{module:e,entryPoint:"vertex_main"},fragment:{module:e,entryPoint:"fragment_main",targets:[{format:f}]}});return{render:e=>{const n=e.commandEncoder.beginRenderPass({label:Qn,timestampWrites:e.timestampWrites,colorAttachments:[{view:e.outputTextures.finalTexture.view,loadOp:"clear",clearValue:[0,0,0,0],storeOp:"store"}]});n.setPipeline(t),n.draw(6),n.end()},label:Qn}};function er(e,t){let n=0,r=1/t,i=e;for(;i>0;)n+=r*(i%t),i=Math.floor(i/t),r/=t;return n}let tr,nr=!1;class rr extends e{position;rotation;scale;#w;velocity=i.eR.create(0,0,0);constructor(e,t,n){super(),this.position=e,this.rotation=t,this.scale=n,this.#w=i.pB.identity()}get transform(){let e=i.pB.identity();return i.pB.translate(e,this.position,e),i.pB.multiply(e,i.pB.fromQuat(this.rotation),e),i.pB.scale(e,this.scale,e),e}get previousTransform(){return this.#w}set previousTransform(e){this.#w=e}get direction(){return i.eR.transformQuat(i.eR.create(0,0,1),this.rotation)}get right(){return i.eR.transformQuat(i.eR.create(1,0,0),this.rotation)}get left(){return i.eR.transformQuat(i.eR.create(-1,0,0),this.rotation)}get up(){return i.eR.transformQuat(i.eR.create(0,1,0),this.rotation)}get down(){return i.eR.transformQuat(i.eR.create(0,-1,0),this.rotation)}}class ir extends e{size;atlasLocation;paletteIndex;octreeBufferIndex;name;constructor({size:e,atlasLocation:t,paletteIndex:n,octreeBufferIndex:r,name:i}){super(),this.size=e,this.atlasLocation=t,this.paletteIndex=n,this.octreeBufferIndex=r,this.name=i}}const sr=async e=>{let t,n,r,i,s,o;const a=Sr.createComputePipeline({layout:"auto",compute:{module:Sr.createShaderModule({code:`\n        @group(0) @binding(2) var HistoryWrite : texture_storage_2d<${e.format}, write>;\n        // Helper function to compute luminance\r\nfn Luminance(color: vec3<f32>) -> f32 {\r\n    return dot(color, vec3<f32>(0.299, 0.587, 0.114));\r\n}\r\n\r\nfn rcp(x: f32) -> f32 {\r\n    return 1.0 / x;\r\n}\r\n\r\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\r\n\r\nfn calculateUvFromWorldPostion(worldPos: vec3<f32>, matrices: ViewProjectionMatrices) -> vec2<f32> {\r\n  let clipPos = matrices.viewProjection * vec4<f32>(worldPos, 1.0);\r\n  let uv = (matrices.inverseProjection * clipPos).xy;\r\n  return uv * 0.5 + 0.5;\r\n}\r\n\r\nconst NEIGHBORHOOD_SAMPLE_POSITIONS = array<vec2<i32>, 8>(\r\n    vec2<i32>(-1, -1),\r\n    vec2<i32>(0, -1),\r\n    vec2<i32>(1, -1),\r\n    vec2<i32>(-1, 0),\r\n    vec2<i32>(1, 0),\r\n    vec2<i32>(-1, 1),\r\n    vec2<i32>(0, 1),\r\n    vec2<i32>(1, 1)\r\n);\r\n\r\n@group(0) @binding(0) var CurrentColor : texture_2d<f32>;\r\n@group(0) @binding(1) var Velocity : texture_2d<f32>;\r\n@group(0) @binding(3) var HistoryRead : texture_2d<f32>;\r\n@group(0) @binding(4) var linearSampler : sampler;\r\n@group(0) @binding(5) var nearestSampler : sampler;\r\n@group(0) @binding(6) var worldPosTex : texture_2d<f32>;\r\n\r\nconst DEPTH_THRESHOLD : f32 = 4.0;\r\nconst MIN_SOURCE_BLEND = 0.1;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n    @builtin(global_invocation_id) id : vec3<u32>\r\n) {\r\n    let texSize = vec2<f32>(textureDimensions(CurrentColor));\r\n    let uv = (vec2<f32>(id.xy) + vec2(0.5)) / texSize;\r\n    let worldPosSample = textureLoad(worldPosTex, id.xy, 0);\r\n    let worldPos = worldPosSample.xyz;\r\n    let depthSample = worldPosSample.w;\r\n\r\n    // Get velocity from pixel with closest depth value in 3x3 neighborhood\r\n    var closestDepthPixel = vec2<i32>(id.xy);\r\n    var closestDepth = 999999999.0;\r\n    for (var i = 0; i < 8; i = i + 1) {\r\n        let neighbourPixel = clamp(vec2<i32>(id.xy) + NEIGHBORHOOD_SAMPLE_POSITIONS[i], vec2<i32>(0), vec2<i32>(texSize - 1));\r\n        let neighbourDepth = textureLoad(worldPosTex, neighbourPixel, 0).w;\r\n        if (abs(neighbourDepth - depthSample) < abs(closestDepth - depthSample)) {\r\n            closestDepth = neighbourDepth;\r\n            closestDepthPixel = neighbourPixel;\r\n        }\r\n    }\r\n\r\n    let velocity = textureLoad(Velocity, closestDepthPixel, 0).xy;\r\n    let previousUv = uv - velocity;\r\n    let previousPixel = vec2<i32>(previousUv * texSize);\r\n\r\n    let worldPosPrevSample = textureLoad(worldPosTex, previousPixel, 0);\r\n    let worldPosPrev = worldPosPrevSample.xyz;\r\n    var depthAtPreviousPixel = worldPosPrevSample.w;\r\n\r\n    var sourceSample: vec3<f32> = textureSampleLevel(CurrentColor, nearestSampler, uv, 0).rgb;\r\n    var historySample: vec3<f32> = textureSampleLevel(HistoryRead, linearSampler, previousUv, 0).rgb;\r\n\r\n    // Calculate depth difference between source and history samples\r\n    let depthDifference: f32 = abs(depthSample - depthAtPreviousPixel);\r\n\r\n    // Apply depth clamping\r\n    if (depthDifference > DEPTH_THRESHOLD) {\r\n        return;\r\n    }\r\n//\r\n    // Clamp the history sample to the min and max of the 3x3 neighborhood\r\n    var minCol: vec3<f32> = sourceSample;\r\n    var maxCol: vec3<f32> = sourceSample;\r\n    for (var x: i32 = -1; x <= 1; x = x + 1) {\r\n        for (var y: i32 = -1; y <= 1; y = y + 1) {\r\n            let neighbourPixel = clamp(vec2(i32(id.x) + x, i32(id.y) + y), vec2(0), vec2(i32(texSize.x - 1), i32(texSize.y - 1)));\r\n            let s: vec3<f32> = textureLoad(CurrentColor, neighbourPixel, 0).rgb;\r\n            minCol = min(minCol, s);\r\n            maxCol = max(maxCol, s);\r\n        }\r\n    }\r\n    historySample = clamp(historySample, minCol, maxCol);\r\n\r\n    var sourceWeight: f32 = clamp(length(velocity), MIN_SOURCE_BLEND, 1.0);\r\n    var historyWeight: f32 = 1.0 - sourceWeight;\r\n    let compressedSource: vec3<f32> = sourceSample * rcp(max(max(sourceSample.r, sourceSample.g), sourceSample.b) + 1.0);\r\n    let compressedHistory: vec3<f32> = historySample * rcp(max(max(historySample.r, historySample.g), historySample.b) + 1.0);\r\n    let luminanceSource: f32 = Luminance(compressedSource);\r\n    let luminanceHistory: f32 = Luminance(compressedHistory);\r\n    sourceWeight *= 1.0 / (1.0 + luminanceSource);\r\n    historyWeight *= 1.0 / (1.0 + luminanceHistory);\r\n    let result: vec3<f32> = (sourceSample * sourceWeight + historySample * historyWeight) / max(sourceWeight + historyWeight, 0.0001);\r\n\r\n    textureStore(HistoryWrite, id.xy, vec4<f32>(result, 1.0));\r\n}\r\n`}),entryPoint:"main"}});return{render:({commandEncoder:l,timestampWrites:c,outputTextures:u})=>{t||(t=Sr.createTexture({label:"TAA History Texture",size:[kr[0],kr[1],1],format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),i=t.createView()),s||(s=Sr.createTexture({size:[kr[0],kr[1],1],format:u.worldPositionTexture.format,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING}),o=s.createView()),l.copyTextureToTexture({texture:u.worldPositionTexture.texture},{texture:s},{width:s.width,height:s.height,depthOrArrayLayers:1}),n||(n=Sr.createTexture({size:[kr[0],kr[1],1],format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),r=n.createView()),l.copyTextureToTexture({texture:e.texture},{texture:n},{width:n.width,height:n.height,depthOrArrayLayers:1});const h=l.beginComputePass({timestampWrites:c});h.setPipeline(a);const d=Sr.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:r},{binding:1,resource:u.velocityTexture.view},{binding:2,resource:e.view},{binding:3,resource:i},{binding:4,resource:Sr.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})},{binding:5,resource:Sr.createSampler({magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest"})},{binding:6,resource:o}]});h.setBindGroup(0,d),h.dispatchWorkgroups(kr[0]/8,kr[1]/8),h.end(),l.copyTextureToTexture({texture:e.texture},{texture:t},{width:t.width,height:t.height,depthOrArrayLayers:1})},label:`taa-${e.label}`}},or={binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},ar={binding:1,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},lr={binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:f}},cr={binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},ur={binding:4,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"3d"}},hr={binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},dr={binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},pr={binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},fr={binding:8,visibility:GPUShaderStage.COMPUTE,sampler:{}},mr=(GPUShaderStage.COMPUTE,[or,ar,lr,cr,ur,hr,dr,pr,fr,{binding:10,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:11,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:13,visibility:GPUShaderStage.COMPUTE,sampler:{}},{binding:14,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:15,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:16,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"unfilterable-float"}},{binding:17,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:18,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float",viewDimension:"cube"}},{binding:19,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]),gr=async({shaderCode:e,entryPoint:t,label:n})=>{const r=Sr.createBindGroupLayout({entries:mr}),i=`\nstruct Time {\n  frame: u32,\n  deltaTime: f32\n};\n\n@group(0) @binding(0) var depthTex : texture_2d<f32>;\n@group(0) @binding(1) var inputTex : texture_2d<f32>;\n@group(0) @binding(2) var outputTex : texture_storage_2d<${f}, write>;\n@group(0) @binding(3) var<uniform> viewProjections : ViewProjectionMatrices;\n@group(0) @binding(4) var voxels : texture_3d<f32>;\n@group(0) @binding(5) var<uniform> cameraPosition : vec3<f32>;\n@group(0) @binding(6) var<storage> voxelObjects : array<VoxelObject>;\n@group(0) @binding(7) var<uniform> sunDirection : vec3<f32>;\n@group(0) @binding(8) var linearSampler : sampler;\n@group(0) @binding(10) var normalTex : texture_2d<f32>;\n@group(0) @binding(11) var blueNoiseTex : texture_2d<f32>;\n@group(0) @binding(12) var<uniform> time : Time;\n@group(0) @binding(13) var nearestSampler : sampler;\n@group(0) @binding(14) var velocityAndWaterTex : texture_2d<f32>;\n@group(0) @binding(15) var<storage> bvhNodes: array<BVHNode>;\n@group(0) @binding(16) var worldPosTex : texture_2d<f32>;\n@group(0) @binding(17) var albedoTex : texture_2d<f32>;\n@group(0) @binding(18) var skyCube : texture_cube<f32>;\n@group(0) @binding(19) var<storage, read> octreeBuffer : array<vec2<u32>>;\n\nstruct ViewProjectionMatrices {\r\n  viewProjection : mat4x4<f32>,\r\n  previousViewProjection : mat4x4<f32>,\r\n  inverseViewProjection : mat4x4<f32>,\r\n  previousInverseViewProjection : mat4x4<f32>,\r\n  projection : mat4x4<f32>,\r\n  inverseProjection: mat4x4<f32>\r\n};\n${a}\n${l}\n${c}\n${u}\n${h}\nconst MAX_COARSE_RAY_STEPS = 64;\r\n\r\nfn rayMarchCoarse(voxelObject: VoxelObject, objectRayDirection: vec3<f32>, objectRayOrigin: vec3<f32>) -> bool {\r\n    let atlasLocation = vec3<u32>(voxelObject.atlasLocation);\r\n    var voxelSize = vec3<f32>(1.0);\r\n    var objectPos = objectRayOrigin;\r\n    var currentIndex = vec3<i32>(round(objectPos));\r\n    var tDelta = voxelSize / abs(objectRayDirection);\r\n    var tIncrement = min(tDelta.x, min(tDelta.y, tDelta.z));\r\n\r\n    for(var i = 0; i < MAX_COARSE_RAY_STEPS; i++)\r\n    {\r\n      let samplePosition = objectPos + voxelObject.atlasLocation;\r\n      let uv = samplePosition / vec3<f32>(textureDimensions(voxels));\r\n      let mipSample0 = textureSampleLevel(voxels, nearestSampler, uv, 0.0);\r\n\r\n      if(mipSample0.a > 0.0){\r\n          return true;\r\n      }\r\n\r\n      objectPos += objectRayDirection * tIncrement;\r\n      currentIndex = vec3<i32>(round(objectPos));\r\n//      if(!isInBounds(currentIndex, vec3<i32>(voxelObject.size))){\r\n//          break;\r\n//      }\r\n    }\r\n    return false;\r\n}\r\n\r\nfn rayMarchTransformedCoarse(voxelObject: VoxelObject, rayDirection: vec3<f32>, rayOrigin: vec3<f32>) -> bool {\r\n    var objectRayOrigin = (voxelObject.inverseTransform * vec4<f32>(rayOrigin, 1.0)).xyz;\r\n    let objectRayDirection = (voxelObject.inverseTransform * vec4<f32>(rayDirection, 0.0)).xyz;\r\n    return rayMarchCoarse(voxelObject, objectRayDirection, objectRayOrigin);\r\n}\r\n\r\n// Used for shadows, return first hit\r\nfn rayMarchBVHCoarse(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxDistance: f32) -> bool {\r\n  // Create a stack to store the nodes to visit\r\n      var stack = stack_new();\r\n      stack_push(&stack, 0);\r\n\r\n      var iterations = 0;\r\n      var nodeIndex = 0;\r\n\r\n      while (stack.head > 0u && iterations < 32) {\r\n        let node = bvhNodes[nodeIndex];\r\n        if(node.objectCount == 0){\r\n          nodeIndex = stack_pop(&stack);\r\n        }\r\n        // valid leaf, raymarch it\r\n        else if(node.objectCount == 1){\r\n            // Raymarch the voxel object if it's a leaf node\r\n            let voxelObject = voxelObjects[node.leftIndex]; // left index represents the voxel object index for leaf nodes\r\n            let AABBDist = nodeRayIntersection(rayOrigin, rayDirection, node);\r\n            if(rayMarchTransformedCoarse(voxelObject, rayDirection, rayOrigin + rayDirection * AABBDist)){\r\n              return true;\r\n            }\r\n            // Pop the stack and continue\r\n            nodeIndex = stack_pop(&stack);\r\n        }\r\n        else{\r\n          let leftDist = nodeRayIntersection(rayOrigin, rayDirection, bvhNodes[node.leftIndex]);\r\n          let rightDist = nodeRayIntersection(rayOrigin, rayDirection, bvhNodes[node.rightIndex]);\r\n          let hitLeft = leftDist >= 0.0 && leftDist < maxDistance;\r\n          let hitRight = rightDist >= 0.0 && rightDist < maxDistance;\r\n          if(hitLeft){\r\n            var nearIndex = node.leftIndex;\r\n            // We hit both left and right, choose the closest one\r\n            if(hitRight){\r\n              if(leftDist < rightDist){\r\n                // left is closer, push right to stack\r\n                stack_push(&stack, node.rightIndex);\r\n              } else {\r\n                // right is closer, push left to stack\r\n                stack_push(&stack, node.leftIndex);\r\n                nearIndex = node.rightIndex;\r\n              }\r\n            }\r\n            nodeIndex = nearIndex;\r\n          }\r\n          // We only hit the right Node\r\n          else if(hitRight){\r\n            nodeIndex = node.rightIndex;\r\n          }\r\n          // We didn't hit any node, pop the stack\r\n          else{\r\n            nodeIndex = stack_pop(&stack);\r\n          }\r\n        }\r\n\r\n        iterations += 1;\r\n      }\r\n\r\n      return false;\r\n}\n${e}`,s=Sr.createComputePipeline({layout:Sr.createPipelineLayout({bindGroupLayouts:[r]}),compute:{module:Sr.createShaderModule({code:i}),entryPoint:t}});let o,d,p,m=Sr.createSampler({magFilter:"nearest",minFilter:"nearest"}),g=Sr.createSampler({magFilter:"linear",minFilter:"linear"});return{render:({commandEncoder:e,outputTextures:t,timestampWrites:n,viewProjectionMatricesBuffer:i,volumeAtlas:a,cameraPositionBuffer:l,transformationMatrixBuffer:c,sunDirectionBuffer:u,blueNoiseTextureView:h,timeBuffer:f,bvhBuffer:v})=>{if(o||(o=Sr.createTexture({size:[t.finalTexture.width,t.finalTexture.height,1],format:t.finalTexture.format,usage:t.finalTexture.usage}),d=o.createView()),e.copyTextureToTexture({texture:t.finalTexture.texture},{texture:o},{width:t.finalTexture.width,height:t.finalTexture.height,depthOrArrayLayers:1}),!p){const e=[{binding:0,resource:t.depthTexture.view},{binding:1,resource:d},{binding:2,resource:t.finalTexture.view},{binding:3,resource:{buffer:i}},{binding:4,resource:a.atlasTextureView},{binding:5,resource:{buffer:l}},{binding:6,resource:{buffer:c}},{binding:7,resource:{buffer:u}},{binding:8,resource:g},{binding:10,resource:t.normalTexture.view},{binding:11,resource:h},{binding:12,resource:{buffer:f}},{binding:13,resource:m},{binding:14,resource:t.velocityTexture.view},{binding:15,resource:{buffer:v}},{binding:16,resource:t.worldPositionTexture.view},{binding:17,resource:t.albedoTexture.view},{binding:18,resource:t.skyTexture.createView({dimension:"cube"})},{binding:19,resource:{buffer:a.octreeBuffer}}],n={layout:r,entries:e};p=Sr.createBindGroup(n)}const y=e.beginComputePass({timestampWrites:n});y.setPipeline(s),y.setBindGroup(0,p),y.dispatchWorkgroups(Math.ceil(t.finalTexture.width/8),Math.ceil(t.finalTexture.height/8)),y.end()},label:n}},vr=async()=>gr({shaderCode:"const TARGET_DELTA_TIME: f32 = 16.66;\r\nconst MAX_SAMPLES: i32 = 8;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  var velocity = textureLoad(velocityAndWaterTex, pixel, 0).xy;\r\n  let resolution = textureDimensions(inputTex);\r\n  let centerOfPixel = vec2<f32>(GlobalInvocationID.xy) + vec2<f32>(0.5);\r\n  var uv = centerOfPixel / vec2<f32>(resolution);\r\n  let blurScale = (TARGET_DELTA_TIME / time.deltaTime); // less blur when framerate is high\r\n  let scaledVelocity = velocity * blurScale;\r\n  var samples = MAX_SAMPLES;\r\n  var validSamples = 0.0;\r\n  var result = vec4<f32>(0.0);\r\n  for (var i = 0; i < samples; i++) {\r\n    var offset = scaledVelocity * (f32(i) / f32(samples - 1) - 0.5);\r\n    let offsetUv = uv + offset;\r\n    let textureSample = textureSampleLevel(inputTex, nearestSampler, offsetUv, 0.0);\r\n    result += textureSample;\r\n    validSamples += 1.0;\r\n  }\r\n  result /= validSamples;\r\n  textureStore(outputTex, pixel, result);\r\n}",entryPoint:"main",label:"motion blur"}),yr=async()=>gr({shaderCode:"fn uncharted2_tonemap_partial(x: vec3<f32>) -> vec3<f32>\r\n{\r\n    let A = 0.15f;\r\n    let B = 0.50f;\r\n    let C = 0.10f;\r\n    let D = 0.20f;\r\n    let E = 0.02f;\r\n    let F = 0.30f;\r\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\r\n}\r\n\r\nfn luminance(v: vec3<f32>) -> f32\r\n{\r\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn reverse_aces(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let a = 2.51f;\r\n    let b = 0.03f;\r\n    let c = 2.43f;\r\n    let d = 0.59f;\r\n    let e = 0.14f;\r\n    return clamp((v*(v*(c-e)-b))/(a-v*(d-e)), vec3(0.0), vec3(1.0f));\r\n}\r\n\r\nfn uncharted2_filmic(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let exposure_bias = 0.3f;\r\n    let curr = uncharted2_tonemap_partial(v * exposure_bias);\r\n    let W = vec3(11.2f);\r\n    let white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\r\n    return curr * white_scale;\r\n}\r\n\r\nfn reinhard_jodie(v: vec3<f32>) -> vec3<f32>\r\n{\r\n    let l = luminance(v);\r\n    let tv = v / (1.0f + v);\r\n    return mix(v / (1.0f + l), tv, tv);\r\n}\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  let inputSample = textureLoad(inputTex, pixel, 0);\r\n  let toneMapped = uncharted2_filmic(inputSample.rgb);\r\n//  let gammaCorrected = pow(toneMapped, vec3(1.0f / 0.3f));\r\n  textureStore(outputTex,pixel,vec4(toneMapped,1));\r\n}",entryPoint:"main",label:"tonemap"}),xr=async()=>gr({shaderCode:"const DENSITY = 0.0002;\r\nconst BLUE_FOG: vec3<f32> = vec3<f32>(16.,21.,29.);\r\nconst YELLOW_FOG: vec3<f32> = vec3<f32>(25.,24.,23.);\r\n\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(\r\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\r\n) {\r\n  let pixel = GlobalInvocationID.xy;\r\n  let worldPos = textureLoad(worldPosTex, pixel, 0).xyz;\r\n  let depth = distance(worldPos, cameraPosition);\r\n  let fogDensity = depth * DENSITY;\r\n\r\n  let rayDir = normalize(worldPos - cameraPosition);\r\n  let sunAmount = max(dot(rayDir, sunDirection), 0.0 );\r\n  let fogColor  = mix( BLUE_FOG, // blue\r\n                       YELLOW_FOG, // yellow\r\n                       pow(sunAmount,2.0));\r\n\r\n  let fogAmount = 1.0 - exp(-fogDensity);\r\n  let inputSample = textureLoad(inputTex, pixel, 0).xyz;\r\n  let result = mix(inputSample, fogColor, fogAmount);\r\n  textureStore(outputTex, pixel, vec4(result, 1));\r\n}",entryPoint:"main",label:"fog"});new class{#b;#_;#S;#k;constructor(){this.#b=new it(1),this.#_=new it(0),this.#S=new it(0),this.#k=new it(.8)}set targetScale(e){this.#b.target=e}set targetTranslateX(e){this.#_.target=e}set targetRotateY(e){this.#S.target=e}set targetSunRotateY(e){this.#k.target=e}get targetScale(){return this.#b.target}get targetTranslateX(){return this.#_.target}get targetRotateY(){return this.#S.target}get targetSunRotateY(){return this.#k.target}get sunRotateY(){return this.#k.value}get scale(){return this.#b.value}get translateX(){return this.#_.value}};let wr,br,_r,Sr,kr=i.Zc.create(4,4),Tr=0,Er=Tr,Ar=0,Pr=0;const Mr=new class{gui;timingsFolder;passesFolder;constructor(){this.gui=new D,this.timingsFolder=this.gui.addFolder("timings"),this.passesFolder=this.gui.addFolder("passes"),this.passesFolder.close()}log(e){Object.keys(e).forEach((t=>{const n=this.timingsFolder.controllers.find((e=>e.property===t));n?n.setValue(e[t].toFixed(2)):this.timingsFolder.add(e,t)}))}setupDebugControls(e){const t=e.reduce(((e,t)=>(e[t.label]=!0,e)),{});e.forEach((e=>{this.passesFolder.add(t,e.label)}))}setupOctreeLogging(e){this.gui.addFolder("octree").add(e,"octreeBufferSizeMB").listen()}setupAverageChunkGenerationTimeLogging(e){this.gui.addFolder("chunk average generation time").add(e,"time").listen()}};window.debugUI=Mr;let Cr={isPaused:!1};window.debugUI.gui.add(Cr,"isPaused");const zr=(()=>{let e={};const t=t=>{const n=e[t];return n?n.reduce(((e,t)=>e+t))/n.length:0};return{addSample:(t,n)=>{e[t]||(e[t]=[]),e[t].push(n)>25&&e[t].shift()},clearEntry:t=>{e[t]&&(e[t]=[0])},toString:()=>Object.keys(e).map((e=>`${e}: ${t(e).toFixed(2)}ms`)).join("\n"),toHTML:()=>Object.keys(e).map((e=>`<div class="debug-row">\n                    <div>\n                        ${e}\n                    </div>\n                   <div>${t(e).toFixed(2)}ms</div>\n                </div>`)).join("\n"),getAverages:()=>Object.keys(e).reduce(((e,n)=>(e[n]=t(n),e)),{})}})();zr.addSample("frame time",0);let Ir,Br,Or,Rr,Nr,Ur,Dr,Lr,Fr,qr,jr,Vr,Gr,Wr,$r,Hr,Yr,Xr,Zr,Kr,Qr,Jr=[],ei=i.pB.create(),ti={lightY:16};for(let e=0;e<=768;e+=96)for(let t=0;t<=768;t+=96)Jr.push({position:[e,16,t],size:5,color:i.eR.mulScalar(i.eR.normalize(i.eR.create(Math.random(),Math.random(),Math.random())),50)});window.debugUI.gui.add(ti,"lightY",0,64,1);const ni=async(e,t,n)=>{if(Sr=e,_r=t,!navigator.gpu)throw new Error("WebGPU not supported");ii=((e,t,n)=>{const r=new Float32Array(t),i=e.createBuffer({size:r.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"camera position"});return o(i,t),i})(Sr,[0,0,0,0]),Hr=new Xn(Sr,[]),br=document.getElementById("webgpu-canvas"),br.style.imageRendering="pixelated",kr=i.Zc.create(window.innerWidth,window.innerHeight),br.width=kr[0],br.height=kr[1],Rr=new v(Sr,kr[0],kr[1]),Or=new y(Sr,kr[0],kr[1]),Ur=new x(Sr,kr[0],kr[1]),Dr=new w(Sr,kr[0],kr[1]),Nr=new _(Sr,kr[0],kr[1]),Lr=new b(Sr,kr[0],kr[1]),Ir=Sr.createTexture({label:"sky texture",dimension:"2d",size:[640,640,6],format:"rgba16float",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),wr=br.getContext("webgpu"),wr.configure({device:Sr,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT}),ri(Sr),Br=await Promise.all([Jn(),S(),(async()=>({label:"copy albedo",render:e=>{((e,t,n)=>{if(t.width!==n.width||t.height!==n.height)throw new Error("Source and destination textures must have the same dimensions");e.copyTextureToTexture({texture:t.texture},{texture:n.texture},{width:t.texture.width,height:t.texture.height,depthOrArrayLayers:1})})(e.commandEncoder,e.outputTextures.albedoTexture,e.outputTextures.finalTexture)}}))(),sr(Or),Kn(Sr),xr(),yr(),vr(),L(Sr)]),Qr=Br.reduce(((e,t)=>t.timestampLabels?e.concat(t.timestampLabels):e.concat(t.label)),[]),Mr.setupDebugControls(Br),Mr.setupOctreeLogging(_r),Zr=Sr.createSampler({magFilter:"linear",minFilter:"linear"}),Kr=Sr.createSampler({magFilter:"nearest",minFilter:"nearest"}),Sr.features.has("timestamp-query")&&(Yr=Sr.createQuerySet({type:"timestamp",count:1e3}),Xr=Sr.createBuffer({label:"timestamp query",size:8*Yr.count,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}))},ri=async e=>{const t=await async function(e,t,n={}){return Wn(e,[t],n)}(e,"blue-noise-rg.png",{usage:GPUTextureUsage.COPY_SRC});Fr=t.createView()};let ii;setInterval((()=>{Mr.log(zr.getAverages())}),250);let si=0;const oi=(e,t,n,r,a)=>{if(!Sr||!Br||!_r||0===a.length)return;Jr=Jr.map((e=>({...e,position:[e.position[0],ti.lightY,e.position[2]]})));const l=Sr.createCommandEncoder();0===Tr&&(Tr=e),l.pushDebugGroup("frame");const c=e-Tr;Cr.isPaused||(Ar=c-Er,zr.addSample("frame time",Ar),Er=c,Pr=(Pr+1)%2048),((e,t)=>{const n=function(e,t,n,r,i,s){const o=2*Math.tan(r/2)*s,a=o*i,l=1/t,c=1/n;return[(er(e,2)-.5)*l*a,(er(e,3)-.5)*c*o]}(Pr,kr[0],kr[1],"fieldOfView"in e.config?e.config.fieldOfView:90,kr[0]/kr[1],"near"in e.config?e.config.near:.1),r=function(e,t){const n=new Float32Array(e);return n[8]+=t[0],n[9]+=t[1],n}(e.projectionMatrix,n),s=(e=>{const t=e.position;return i.pB.lookAt(t,i.eR.add(t,e.direction),e.up)})(t),o=i.pB.mul(r,s);Wr=new Float32Array([...o,...ei,...i.pB.invert(o),...i.pB.invert(ei),...r,...i.pB.invert(r),...s]),Vr||(Vr=Sr.createBuffer({size:Wr.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"view matrices buffer"})),Sr.queue.writeBuffer(Vr,0,Wr.buffer,0,Wr.length*Float32Array.BYTES_PER_ELEMENT);const a=i.pB.mul((l=r,i.pB.invert(l)),o);var l;const c=i.pB.invert(a);$r=new Float32Array(i.pB.getTranslation(c)),Sr.queue.writeBuffer(ii,0,$r.buffer,0,$r.length*Float32Array.BYTES_PER_ELEMENT),ei=o})(n,r),((e,t,n)=>{const r=76*n.length;jr&&r===jr.size||(jr=e.createBuffer({size:r*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"voxel objects buffer"})),n.forEach(((n,r)=>{const s=((e,t)=>{const n=((e,t)=>[...t.transform,...i.pB.invert(t.transform),...t.previousTransform,...i.pB.invert(t.previousTransform),...e.size,0,...e.atlasLocation,e.paletteIndex])(e,t),r=4*(n.length+1),s=new DataView(new ArrayBuffer(r));for(let e=0;e<n.length-1;e++)s.setFloat32(4*e,n[e],!0);return s.setUint32(r-4,e.octreeBufferIndex,!0),s})(t.getComponents(n).get(ir),t.getComponents(n).get(rr)).buffer;e.queue.writeBuffer(jr,76*r*Float32Array.BYTES_PER_ELEMENT,s,0,s.byteLength)}))})(Sr,t,a),qr||(qr=s([Pr,0,0],"time buffer")),Sr.queue.writeBuffer(qr,4,new Float32Array([Ar])),Sr.queue.writeBuffer(qr,0,new Uint32Array([Pr])),Sr.queue.writeBuffer(qr,8,new Float32Array([Er/1e3])),(()=>{let e=Math.cos(Er/5e3),t=Math.sin(Er/5e3);const n=i.eR.create(e,1,t);Gr?o(Gr,[n[0],n[1],n[2]]):Gr=s([n[0],n[1],n[2]],"sun buffer")})();const u=performance.now();Hr.update(a.map((e=>((e,t)=>{const n=i.eR.create(e.size[0]/2,e.size[1]/2,e.size[2]/2);return(e=>{let t=i.eR.create(1/0,1/0,1/0),n=i.eR.create(-1/0,-1/0,-1/0);for(const r of e)t=i.eR.min(t,r),n=i.eR.max(n,r);return{min:t,max:n}})([i.eR.create(-n[0],-n[1],-n[2]),i.eR.create(-n[0],-n[1],n[2]),i.eR.create(-n[0],n[1],-n[2]),i.eR.create(-n[0],n[1],n[2]),i.eR.create(n[0],-n[1],-n[2]),i.eR.create(n[0],-n[1],n[2]),i.eR.create(n[0],n[1],-n[2]),i.eR.create(n[0],n[1],n[2])].map((e=>i.eR.transformMat4(e,t.transform))))})(t.getComponents(e).get(ir),t.getComponents(e).get(rr)))));const h=performance.now();zr.addSample("bvh update",h-u),si=a.length;let d=0;Br.forEach(((e,i)=>{const{render:s,label:o}=e;if(!1===Mr.passesFolder.controllers.find((e=>e.property===o))?.getValue())return;let c;Sr.features.has("timestamp-query")&&l.clearBuffer(Xr),Sr.features.has("timestamp-query")&&(c={querySet:Yr,beginningOfPassWriteIndex:d,endOfPassWriteIndex:d+1}),o&&l.pushDebugGroup(o),s({enabled:document.getElementById(`flag-${o}`)?.checked,commandEncoder:l,timeBuffer:qr,outputTextures:{finalTexture:Nr,albedoTexture:Rr,normalTexture:Or,depthTexture:Ur,skyTexture:Ir,velocityTexture:Dr,worldPositionTexture:Lr},cameraPositionBuffer:ii,volumeAtlas:_r,transformationMatrixBuffer:jr,viewProjectionMatricesArray:Wr,viewProjectionMatricesBuffer:Vr,timestampWrites:c,sunDirectionBuffer:Gr,blueNoiseTextureView:Fr,bvhBuffer:Hr.gpuBuffer,lights:Jr,linearSampler:Zr,nearestSampler:Kr,camera:n,cameraTransform:r,renderableEntities:a,ecs:t,device:Sr}),e.timestampLabels?.length>0?d+=2*e.timestampLabels.length:d+=2,o&&l.popDebugGroup()})),l.popDebugGroup(),Sr.features.has("timestamp-query")&&(async(e,t,n)=>{const r=n.size;tr||(tr=Sr.createBuffer({size:r,label:"gpu read buffer",usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}));const i=Sr.createCommandEncoder();if(nr)return;nr=!0,i.resolveQuerySet(t,0,t.count,n,0),i.copyBufferToBuffer(n,0,tr,0,r),Sr.queue.submit([i.finish()]),await Sr.queue.onSubmittedWorkDone(),await tr.mapAsync(GPUMapMode.READ).finally((()=>{nr=!1}));const s=tr.getMappedRange(),o=new BigInt64Array(s),a=[];o.forEach((e=>{a.push(Number(e)/1e6)})),a.reduce(((e,t,n)=>(n%2==0&&e.push(a[n+1]-t),e)),[]).forEach(((t,n)=>{zr.addSample(e[n],t)})),tr.unmap()})(Qr,Yr,Xr),Sr.queue.submit([l.finish()])};class ai extends e{config;constructor(e){super(),this.config=e}get projectionMatrix(){return"size"in this.config?i.pB.ortho(-kr[0]/this.config.size,kr[0]/this.config.size,-kr[1]/this.config.size,kr[1]/this.config.size,this.config.size,-this.config.size):i.pB.perspective(this.config.fieldOfView,kr[0]/kr[1],this.config.near,this.config.far)}}new Error("timeout while waiting for mutex to become available"),new Error("mutex already locked");const li=new Error("request for lock canceled");class ci{constructor(e,t=li){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise(((n,r)=>{const i={resolve:n,reject:r,weight:e,priority:t},s=ui(this._queue,(e=>t<=e.priority));-1===s&&e<=this._value?this._dispatchItem(i):this._queue.splice(s+1,0,i)}))}runExclusive(e){return t=this,n=arguments,i=function*(e,t=1,n=0){const[r,i]=yield this.acquire(t,n);try{return yield e(r)}finally{i()}},new((r=void 0)||(r=Promise))((function(e,s){function o(e){try{l(i.next(e))}catch(e){s(e)}}function a(e){try{l(i.throw(e))}catch(e){s(e)}}function l(t){var n;t.done?e(t.value):(n=t.value,n instanceof r?n:new r((function(e){e(n)}))).then(o,a)}l((i=i.apply(t,n||[])).next())}));var t,n,r,i}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise((n=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),function(e,t){const n=ui(e,(e=>t.priority<=e.priority));e.splice(n+1,0,t)}(this._weightedWaiters[e-1],{resolve:n,priority:t})}))}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach((e=>e.reject(this._cancelError))),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(0===this._queue.length)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach((e=>e.resolve())),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const n=this._weightedWaiters[t-1];if(!n)continue;const r=n.findIndex((t=>t.priority<=e));(-1===r?n:n.splice(0,r)).forEach((e=>e.resolve()))}}}_couldLockImmediately(e,t){return(0===this._queue.length||this._queue[0].priority<t)&&e<=this._value}}function ui(e,t){for(let n=e.length-1;n>=0;n--)if(t(e[n]))return n;return-1}class hi{constructor(e){this._semaphore=new ci(1,e)}acquire(){return e=this,t=arguments,r=function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t},new((n=void 0)||(n=Promise))((function(i,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((r=r.apply(e,t||[])).next())}));var e,t,n,r}runExclusive(e,t=0){return this._semaphore.runExclusive((()=>e()),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const di={format:"r8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,dimension:"3d"},pi=Math.pow(2,3);class fi{#T={};#E;#A;#f;#P;#M;#C;#z=new hi;constructor(e){this.#f=e,this.#E=e.createTexture({size:{width:pi,height:pi,depthOrArrayLayers:pi},...di,label:"Volume atlas containing ",mipLevelCount:4}),this.#A=e.createTexture({size:{width:256,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,label:"Palette texture",mipLevelCount:1}),this.#P=this.#E.createView(),this.#M=this.#A.createView(),this.#C=e.createBuffer({size:0,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,label:"Octree buffer"})}get dictionary(){return this.#T}addVolume=async(e,t,n,r)=>{if(this.#T[e])throw new Error(`Error adding volume to atlas: volume with label ${e} already exists`);await this.#z.runExclusive((async()=>{const i=this.#f.createCommandEncoder(),[s,o,a]=t,l=this.#C.size/8,c=r||n.byteLength;this.#T[e]={location:[0,0,0],size:[s,o,a],paletteIndex:0,octreeOffset:l,octreeSizeBytes:c,textureSizeBytes:s*o*a};const u=this.#f.createBuffer({label:"Octree buffer",size:this.#C.size+c,usage:this.#C.usage});i.copyBufferToBuffer(this.#C,0,u,0,this.#C.size),this.#f.queue.submit([i.finish()]),this.#f.queue.writeBuffer(u,this.#C.size,n,0,c),await this.#f.queue.onSubmittedWorkDone(),this.#C=u,this.#C.unmap()}))};get atlasTextureView(){return this.#P}get paletteTextureView(){return this.#M}get octreeBuffer(){return this.#C}get octreeBufferSizeMB(){return(this.#C.size/1048576).toFixed(2)}}class mi extends e{device;volumeAtlas}const gi=e=>{const t=e.getEntitiesithComponent(mi).values().next().value;return e.getComponents(t).get(mi)};class vi{pressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1," ":!1,shift:!1};constructor(){window.addEventListener("keydown",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!0})),window.addEventListener("keyup",(e=>{const t=e.key.toLowerCase();this.pressed[t]=!1})),window.addEventListener("blur",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))})),window.addEventListener("contextmenu",(()=>{Object.keys(this.pressed).forEach((e=>{this.pressed[e]=!1}))}))}}class yi extends e{speed=.1;rotationSpeed=.002}class xi extends e{velocity=i.eR.create();angularVelocity=i.Yu.identity()}class wi{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new _i);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new _i);const n=this.elements,r=e.x,i=e.y,s=e.z;return t.x=n[0]*r+n[1]*i+n[2]*s,t.y=n[3]*r+n[4]*i+n[5]*s,t.z=n[6]*r+n[7]*i+n[8]*s,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new wi);const n=this.elements,r=e.elements,i=t.elements,s=n[0],o=n[1],a=n[2],l=n[3],c=n[4],u=n[5],h=n[6],d=n[7],p=n[8],f=r[0],m=r[1],g=r[2],v=r[3],y=r[4],x=r[5],w=r[6],b=r[7],_=r[8];return i[0]=s*f+o*v+a*w,i[1]=s*m+o*y+a*b,i[2]=s*g+o*x+a*_,i[3]=l*f+c*v+u*w,i[4]=l*m+c*y+u*b,i[5]=l*g+c*x+u*_,i[6]=h*f+d*v+p*w,i[7]=h*m+d*y+p*b,i[8]=h*g+d*x+p*_,t}scale(e,t){void 0===t&&(t=new wi);const n=this.elements,r=t.elements;for(let t=0;3!==t;t++)r[3*t+0]=e.x*n[3*t+0],r[3*t+1]=e.y*n[3*t+1],r[3*t+2]=e.z*n[3*t+2];return t}solve(e,t){void 0===t&&(t=new _i);const n=[];let r,i;for(r=0;r<12;r++)n.push(0);for(r=0;r<3;r++)for(i=0;i<3;i++)n[r+4*i]=this.elements[r+3*i];n[3]=e.x,n[7]=e.y,n[11]=e.z;let s=3;const o=s;let a,l;do{if(r=o-s,0===n[r+4*r])for(i=r+1;i<o;i++)if(0!==n[r+4*i]){a=4;do{l=4-a,n[l+4*r]+=n[l+4*i]}while(--a);break}if(0!==n[r+4*r])for(i=r+1;i<o;i++){const e=n[r+4*i]/n[r+4*r];a=4;do{l=4-a,n[l+4*i]=l<=r?0:n[l+4*i]-n[l+4*r]*e}while(--a)}}while(--s);if(t.z=n[11]/n[10],t.y=(n[7]-n[6]*t.z)/n[5],t.x=(n[3]-n[2]*t.z-n[1]*t.y)/n[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(void 0===n)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new wi);const t=bi;let n,r;for(n=0;n<3;n++)for(r=0;r<3;r++)t[n+6*r]=this.elements[n+3*r];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let i=3;const s=i;let o,a;do{if(n=s-i,0===t[n+6*n])for(r=n+1;r<s;r++)if(0!==t[n+6*r]){o=6;do{a=6-o,t[a+6*n]+=t[a+6*r]}while(--o);break}if(0!==t[n+6*n])for(r=n+1;r<s;r++){const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=a<=n?0:t[a+6*r]-t[a+6*n]*e}while(--o)}}while(--i);n=2;do{r=n-1;do{const e=t[n+6*r]/t[n+6*n];o=6;do{a=6-o,t[a+6*r]=t[a+6*r]-t[a+6*n]*e}while(--o)}while(r--)}while(--n);n=2;do{const e=1/t[n+6*n];o=6;do{a=6-o,t[a+6*n]=t[a+6*n]*e}while(--o)}while(n--);n=2;do{r=2;do{if(a=t[3+r+6*n],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(n,r,a)}while(r--)}while(n--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,r=e.z,i=e.w,s=t+t,o=n+n,a=r+r,l=t*s,c=t*o,u=t*a,h=n*o,d=n*a,p=r*a,f=i*s,m=i*o,g=i*a,v=this.elements;return v[0]=1-(h+p),v[1]=c-g,v[2]=u+m,v[3]=c+g,v[4]=1-(l+p),v[5]=d-f,v[6]=u-m,v[7]=d+f,v[8]=1-(l+h),this}transpose(e){void 0===e&&(e=new wi);const t=this.elements,n=e.elements;let r;return n[0]=t[0],n[4]=t[4],n[8]=t[8],r=t[1],n[1]=t[3],n[3]=r,r=t[2],n[2]=t[6],n[6]=r,r=t[5],n[5]=t[7],n[7]=r,e}}const bi=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class _i{constructor(e,t,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){void 0===t&&(t=new _i);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z;return t.x=o*i-a*r,t.y=a*n-s*i,t.z=s*r-o*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new _i(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new _i(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new wi([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,r=Math.sqrt(e*e+t*t+n*n);if(r>0){const e=1/r;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return r}unit(e){void 0===e&&(e=new _i);const t=this.x,n=this.y,r=this.z;let i=Math.sqrt(t*t+n*n+r*r);return i>0?(i=1/i,e.x=t*i,e.y=n*i,e.z=r*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return Math.sqrt((i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r))}distanceSquared(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,o=e.z;return(i-t)*(i-t)+(s-n)*(s-n)+(o-r)*(o-r)}scale(e,t){void 0===t&&(t=new _i);const n=this.x,r=this.y,i=this.z;return t.x=e*n,t.y=e*r,t.z=e*i,t}vmul(e,t){return void 0===t&&(t=new _i),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return void 0===n&&(n=new _i),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new _i),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const r=Si,i=1/n;r.set(this.x*i,this.y*i,this.z*i);const s=ki;Math.abs(r.x)<.9?(s.set(1,0,0),r.cross(s,e)):(s.set(0,1,0),r.cross(s,e)),r.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const r=this.x,i=this.y,s=this.z;n.x=r+(e.x-r)*t,n.y=i+(e.y-i)*t,n.z=s+(e.z-s)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(Ti),Ti.almostEquals(e,t)}clone(){return new _i(this.x,this.y,this.z)}}_i.ZERO=new _i(0,0,0),_i.UNIT_X=new _i(1,0,0),_i.UNIT_Y=new _i(0,1,0),_i.UNIT_Z=new _i(0,0,1);const Si=new _i,ki=new _i,Ti=new _i;class Ei{constructor(e){void 0===e&&(e={}),this.lowerBound=new _i,this.upperBound=new _i,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,r){const i=this.lowerBound,s=this.upperBound,o=n;i.copy(e[0]),o&&o.vmult(i,i),s.copy(i);for(let t=1;t<e.length;t++){let n=e[t];o&&(o.vmult(n,Ai),n=Ai),n.x>s.x&&(s.x=n.x),n.x<i.x&&(i.x=n.x),n.y>s.y&&(s.y=n.y),n.y<i.y&&(i.y=n.y),n.z>s.z&&(s.z=n.z),n.z<i.z&&(i.z=n.z)}return t&&(t.vadd(i,i),t.vadd(s,s)),r&&(i.x-=r,i.y-=r,i.z-=r,s.x+=r,s.y+=r,s.z+=r),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new Ei).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound,s=r.x<=n.x&&n.x<=i.x||t.x<=i.x&&i.x<=n.x,o=r.y<=n.y&&n.y<=i.y||t.y<=i.y&&i.y<=n.y,a=r.z<=n.z&&n.z<=i.z||t.z<=i.z&&i.z<=n.z;return s&&o&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound;return t.x<=r.x&&n.x>=i.x&&t.y<=r.y&&n.y>=i.y&&t.z<=r.z&&n.z>=i.z}getCorners(e,t,n,r,i,s,o,a){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),n.set(c.x,c.y,l.z),r.set(l.x,c.y,c.z),i.set(c.x,l.y,c.z),s.set(l.x,c.y,l.z),o.set(l.x,l.y,c.z),a.copy(c)}toLocalFrame(e,t){const n=Pi,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(r,i,s,o,a,l,c,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToLocal(r,r)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=Pi,r=n[0],i=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(r,i,s,o,a,l,c,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToWorld(r,r)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,r=1/t.x,i=1/t.y,s=1/t.z,o=(this.lowerBound.x-n.x)*r,a=(this.upperBound.x-n.x)*r,l=(this.lowerBound.y-n.y)*i,c=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*s,h=(this.upperBound.z-n.z)*s,d=Math.max(Math.max(Math.min(o,a),Math.min(l,c)),Math.min(u,h)),p=Math.min(Math.min(Math.max(o,a),Math.max(l,c)),Math.max(u,h));return!(p<0||d>p)}}const Ai=new _i,Pi=[new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i];class Mi{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:r}=t;if(r>n){const e=r;r=n,n=e}return this.matrix[(n*(n+1)>>1)+r-1]}set(e,t,n){let{index:r}=e,{index:i}=t;if(i>r){const e=i;i=r,r=e}this.matrix[(r*(r+1)>>1)+i-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class Ci{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;return void 0===n[e]&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return!(void 0===n[e]||!n[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const n=this._listeners;if(void 0===n[e])return this;const r=n[e].indexOf(t);return-1!==r&&n[e].splice(r,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let n=0,r=t.length;n<r;n++)t[n].call(this,e)}return this}}class zi{constructor(e,t,n,r){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===r&&(r=1),this.x=e,this.y=t,this.z=n,this.w=r}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(.5*t);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new _i),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=Ii,n=Bi;e.tangents(t,n),this.setFromAxisAngle(t,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new zi);const n=this.x,r=this.y,i=this.z,s=this.w,o=e.x,a=e.y,l=e.z,c=e.w;return t.x=n*c+s*o+r*l-i*a,t.y=r*c+s*a+i*o-n*l,t.z=i*c+s*l+n*a-r*o,t.w=s*c-n*o-r*a-i*l,t}inverse(e){void 0===e&&(e=new zi);const t=this.x,n=this.y,r=this.z,i=this.w;this.conjugate(e);const s=1/(t*t+n*n+r*r+i*i);return e.x*=s,e.y*=s,e.z*=s,e.w*=s,e}conjugate(e){return void 0===e&&(e=new zi),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new _i);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,a=this.z,l=this.w,c=l*n+o*i-a*r,u=l*r+a*n-s*i,h=l*i+s*r-o*n,d=-s*n-o*r-a*i;return t.x=c*l+d*-s+u*-a-h*-o,t.y=u*l+d*-o+h*-s-c*-a,t.z=h*l+d*-a+c*-o-u*-s,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let n,r,i;void 0===t&&(t="YZX");const s=this.x,o=this.y,a=this.z,l=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=s*o+a*l;if(e>.499&&(n=2*Math.atan2(s,l),r=Math.PI/2,i=0),e<-.499&&(n=-2*Math.atan2(s,l),r=-Math.PI/2,i=0),void 0===n){const t=s*s,c=o*o,u=a*a;n=Math.atan2(2*o*l-2*s*a,1-2*c-2*u),r=Math.asin(2*e),i=Math.atan2(2*s*l-2*o*a,1-2*t-2*u)}}e.y=n,e.z=r,e.x=i}setFromEuler(e,t,n,r){void 0===r&&(r="XYZ");const i=Math.cos(e/2),s=Math.cos(t/2),o=Math.cos(n/2),a=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(n/2);return"XYZ"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o-a*l*c):"YXZ"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o+a*l*c):"ZXY"===r?(this.x=a*s*o-i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o-a*l*c):"ZYX"===r?(this.x=a*s*o-i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o+a*l*c):"YZX"===r?(this.x=a*s*o+i*l*c,this.y=i*l*o+a*s*c,this.z=i*s*c-a*l*o,this.w=i*s*o-a*l*c):"XZY"===r&&(this.x=a*s*o-i*l*c,this.y=i*l*o-a*s*c,this.z=i*s*c+a*l*o,this.w=i*s*o+a*l*c),this}clone(){return new zi(this.x,this.y,this.z,this.w)}slerp(e,t,n){void 0===n&&(n=new zi);const r=this.x,i=this.y,s=this.z,o=this.w;let a,l,c,u,h,d=e.x,p=e.y,f=e.z,m=e.w;return l=r*d+i*p+s*f+o*m,l<0&&(l=-l,d=-d,p=-p,f=-f,m=-m),1-l>1e-6?(a=Math.acos(l),c=Math.sin(a),u=Math.sin((1-t)*a)/c,h=Math.sin(t*a)/c):(u=1-t,h=t),n.x=u*r+h*d,n.y=u*i+h*p,n.z=u*s+h*f,n.w=u*o+h*m,n}integrate(e,t,n,r){void 0===r&&(r=new zi);const i=e.x*n.x,s=e.y*n.y,o=e.z*n.z,a=this.x,l=this.y,c=this.z,u=this.w,h=.5*t;return r.x+=h*(i*u+s*c-o*l),r.y+=h*(s*u+o*a-i*c),r.z+=h*(o*u+i*l-s*a),r.w+=h*(-i*a-s*l-o*c),r}}const Ii=new _i,Bi=new _i;class Oi{constructor(e){void 0===e&&(e={}),this.id=Oi.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,n,r){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}Oi.idCounter=0,Oi.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class Ri{constructor(e){void 0===e&&(e={}),this.position=new _i,this.quaternion=new zi,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return Ri.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return Ri.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new _i),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,r){return void 0===r&&(r=new _i),n.vsub(e,r),t.conjugate(Ni),Ni.vmult(r,r),r}static pointToWorldFrame(e,t,n,r){return void 0===r&&(r=new _i),t.vmult(n,r),r.vadd(e,r),r}static vectorToWorldFrame(e,t,n){return void 0===n&&(n=new _i),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,r){return void 0===r&&(r=new _i),t.w*=-1,t.vmult(n,r),t.w*=-1,r}}const Ni=new zi;class Ui extends Oi{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:n=[],normals:r=[],axes:i,boundingSphereRadius:s}=e;super({type:Oi.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=r,0===this.faceNormals.length&&this.computeNormals(),s?this.boundingSphereRadius=s:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const r=new _i;for(let i=0;i!==e.length;i++){const s=e[i],o=s.length;for(let e=0;e!==o;e++){const i=(e+1)%o;t[s[e]].vsub(t[s[i]],r),r.normalize();let a=!1;for(let e=0;e!==n.length;e++)if(n[e].almostEquals(r)||n[e].almostEquals(r)){a=!0;break}a||n.push(r.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new _i;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],r=this.vertices[n[0]],i=this.vertices[n[1]],s=this.vertices[n[2]];Ui.computeNormal(r,i,s,t)}static computeNormal(e,t,n,r){const i=new _i,s=new _i;t.vsub(e,s),n.vsub(t,i),i.cross(s,r),r.isZero()||r.normalize()}clipAgainstHull(e,t,n,r,i,s,o,a,l){const c=new _i;let u=-1,h=-Number.MAX_VALUE;for(let e=0;e<n.faces.length;e++){c.copy(n.faceNormals[e]),i.vmult(c,c);const t=c.dot(s);t>h&&(h=t,u=e)}const d=[];for(let e=0;e<n.faces[u].length;e++){const t=n.vertices[n.faces[u][e]],s=new _i;s.copy(t),i.vmult(s,s),r.vadd(s,s),d.push(s)}u>=0&&this.clipFaceAgainstHull(s,e,t,d,o,a,l)}findSeparatingAxis(e,t,n,r,i,s,o,a){const l=new _i,c=new _i,u=new _i,h=new _i,d=new _i,p=new _i;let f=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let o=0;o!==m.uniqueAxes.length;o++){n.vmult(m.uniqueAxes[o],l);const a=m.testSepAxis(l,e,t,n,r,i);if(!1===a)return!1;a<f&&(f=a,s.copy(l))}else{const a=o?o.length:m.faces.length;for(let c=0;c<a;c++){const a=o?o[c]:c;l.copy(m.faceNormals[a]),n.vmult(l,l);const u=m.testSepAxis(l,e,t,n,r,i);if(!1===u)return!1;u<f&&(f=u,s.copy(l))}}if(e.uniqueAxes)for(let o=0;o!==e.uniqueAxes.length;o++){i.vmult(e.uniqueAxes[o],c);const a=m.testSepAxis(c,e,t,n,r,i);if(!1===a)return!1;a<f&&(f=a,s.copy(c))}else{const o=a?a.length:e.faces.length;for(let l=0;l<o;l++){const o=a?a[l]:l;c.copy(e.faceNormals[o]),i.vmult(c,c);const u=m.testSepAxis(c,e,t,n,r,i);if(!1===u)return!1;u<f&&(f=u,s.copy(c))}}for(let o=0;o!==m.uniqueEdges.length;o++){n.vmult(m.uniqueEdges[o],h);for(let o=0;o!==e.uniqueEdges.length;o++)if(i.vmult(e.uniqueEdges[o],d),h.cross(d,p),!p.almostZero()){p.normalize();const o=m.testSepAxis(p,e,t,n,r,i);if(!1===o)return!1;o<f&&(f=o,s.copy(p))}}return r.vsub(t,u),u.dot(s)>0&&s.negate(s),!0}testSepAxis(e,t,n,r,i,s){Ui.project(this,e,n,r,Di),Ui.project(t,e,i,s,Li);const o=Di[0],a=Di[1],l=Li[0],c=Li[1];if(o<c||l<a)return!1;const u=o-c,h=l-a;return u<h?u:h}calculateLocalInertia(e,t){const n=new _i,r=new _i;this.computeLocalAABB(r,n);const i=n.x-r.x,s=n.y-r.y,o=n.z-r.z;t.x=1/12*e*(2*s*2*s+2*o*2*o),t.y=1/12*e*(2*i*2*i+2*o*2*o),t.z=1/12*e*(2*s*2*s+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],r=this.vertices[t[0]];return-n.dot(r)}clipFaceAgainstHull(e,t,n,r,i,s,o){const a=new _i,l=new _i,c=new _i,u=new _i,h=new _i,d=new _i,p=new _i,f=new _i,m=this,g=r,v=[];let y=-1,x=Number.MAX_VALUE;for(let t=0;t<m.faces.length;t++){a.copy(m.faceNormals[t]),n.vmult(a,a);const r=a.dot(e);r<x&&(x=r,y=t)}if(y<0)return;const w=m.faces[y];w.connectedFaces=[];for(let e=0;e<m.faces.length;e++)for(let t=0;t<m.faces[e].length;t++)-1!==w.indexOf(m.faces[e][t])&&e!==y&&-1===w.connectedFaces.indexOf(e)&&w.connectedFaces.push(e);const b=w.length;for(let e=0;e<b;e++){const r=m.vertices[w[e]],i=m.vertices[w[(e+1)%b]];r.vsub(i,l),c.copy(l),n.vmult(c,c),t.vadd(c,c),u.copy(this.faceNormals[y]),n.vmult(u,u),t.vadd(u,u),c.cross(u,h),h.negate(h),d.copy(r),n.vmult(d,d),t.vadd(d,d);const s=w.connectedFaces[e];p.copy(this.faceNormals[s]);const o=this.getPlaneConstantOfFace(s);f.copy(p),n.vmult(f,f);const a=o-f.dot(t);for(this.clipFaceAgainstPlane(g,v,f,a);g.length;)g.shift();for(;v.length;)g.push(v.shift())}p.copy(this.faceNormals[y]);const _=this.getPlaneConstantOfFace(y);f.copy(p),n.vmult(f,f);const S=_-f.dot(t);for(let e=0;e<g.length;e++){let t=f.dot(g[e])+S;if(t<=i&&(console.log(`clamped: depth=${t} to minDist=${i}`),t=i),t<=s){const n=g[e];if(t<=1e-6){const e={point:n,normal:f,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,n,r){let i,s;const o=e.length;if(o<2)return t;let a=e[e.length-1],l=e[0];i=n.dot(a)+r;for(let c=0;c<o;c++){if(l=e[c],s=n.dot(l)+r,i<0)if(s<0){const e=new _i;e.copy(l),t.push(e)}else{const e=new _i;a.lerp(l,i/(i-s),e),t.push(e)}else if(s<0){const e=new _i;a.lerp(l,i/(i-s),e),t.push(e),t.push(l)}a=l,i=s}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new _i);const n=this.vertices,r=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(n[i],r[i]),e.vadd(r[i],r[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let r=0;r<this.vertices.length;r++){const i=n[r];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new _i);const n=this.faceNormals,r=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(n[i],r[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const r=t[n].lengthSquared();r>e&&(e=r)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,r){const i=this.vertices;let s,o,a,l,c,u,h=new _i;for(let n=0;n<i.length;n++){h.copy(i[n]),t.vmult(h,h),e.vadd(h,h);const r=h;(void 0===s||r.x<s)&&(s=r.x),(void 0===l||r.x>l)&&(l=r.x),(void 0===o||r.y<o)&&(o=r.y),(void 0===c||r.y>c)&&(c=r.y),(void 0===a||r.z<a)&&(a=r.z),(void 0===u||r.z>u)&&(u=r.z)}n.set(s,o,a),r.set(l,c,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new _i);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,r=this.vertices;if(t){for(let e=0;e<n;e++){const n=r[e];t.vmult(n,n)}for(let e=0;e<this.faceNormals.length;e++){const n=this.faceNormals[e];t.vmult(n,n)}}if(e)for(let t=0;t<n;t++){const n=r[t];n.vadd(e,n)}}pointIsInside(e){const t=this.vertices,n=this.faces,r=this.faceNormals,i=new _i;this.getAveragePointLocal(i);for(let s=0;s<this.faces.length;s++){let o=r[s];const a=t[n[s][0]],l=new _i;e.vsub(a,l);const c=o.dot(l),u=new _i;i.vsub(a,u);const h=o.dot(u);if(c<0&&h>0||c>0&&h<0)return!1}return-1}static project(e,t,n,r,i){const s=e.vertices.length,o=Fi;let a=0,l=0;const c=qi,u=e.vertices;c.setZero(),Ri.vectorToLocalFrame(n,r,t,o),Ri.pointToLocalFrame(n,r,c,c);const h=c.dot(o);l=a=u[0].dot(o);for(let e=1;e<s;e++){const t=u[e].dot(o);t>a&&(a=t),t<l&&(l=t)}if(l-=h,a-=h,l>a){const e=l;l=a,a=e}i[0]=a,i[1]=l}}const Di=[],Li=[],Fi=(new _i,new _i),qi=new _i;class ji extends Oi{constructor(e){super({type:Oi.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,r=_i,i=[new r(-e,-t,-n),new r(e,-t,-n),new r(e,t,-n),new r(-e,t,-n),new r(-e,-t,n),new r(e,-t,n),new r(e,t,n),new r(-e,t,n)],s=[new r(0,0,1),new r(0,1,0),new r(1,0,0)],o=new Ui({vertices:i,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:s});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new _i),ji.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const r=e;n.x=1/12*t*(2*r.y*2*r.y+2*r.z*2*r.z),n.y=1/12*t*(2*r.x*2*r.x+2*r.z*2*r.z),n.z=1/12*t*(2*r.y*2*r.y+2*r.x*2*r.x)}getSideNormals(e,t){const n=e,r=this.halfExtents;if(n[0].set(r.x,0,0),n[1].set(0,r.y,0),n[2].set(0,0,r.z),n[3].set(-r.x,0,0),n[4].set(0,-r.y,0),n[5].set(0,0,-r.z),void 0!==t)for(let e=0;e!==n.length;e++)t.vmult(n[e],n[e]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const r=this.halfExtents,i=[[r.x,r.y,r.z],[-r.x,r.y,r.z],[-r.x,-r.y,r.z],[-r.x,-r.y,-r.z],[r.x,-r.y,-r.z],[r.x,r.y,-r.z],[-r.x,r.y,-r.z],[r.x,-r.y,r.z]];for(let r=0;r<i.length;r++)Vi.set(i[r][0],i[r][1],i[r][2]),t.vmult(Vi,Vi),e.vadd(Vi,Vi),n(Vi.x,Vi.y,Vi.z)}calculateWorldAABB(e,t,n,r){const i=this.halfExtents;Gi[0].set(i.x,i.y,i.z),Gi[1].set(-i.x,i.y,i.z),Gi[2].set(-i.x,-i.y,i.z),Gi[3].set(-i.x,-i.y,-i.z),Gi[4].set(i.x,-i.y,-i.z),Gi[5].set(i.x,i.y,-i.z),Gi[6].set(-i.x,i.y,-i.z),Gi[7].set(i.x,-i.y,i.z);const s=Gi[0];t.vmult(s,s),e.vadd(s,s),r.copy(s),n.copy(s);for(let i=1;i<8;i++){const s=Gi[i];t.vmult(s,s),e.vadd(s,s);const o=s.x,a=s.y,l=s.z;o>r.x&&(r.x=o),a>r.y&&(r.y=a),l>r.z&&(r.z=l),o<n.x&&(n.x=o),a<n.y&&(n.y=a),l<n.z&&(n.z=l)}}}const Vi=new _i,Gi=[new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i];class Wi extends Ci{constructor(e){void 0===e&&(e={}),super(),this.id=Wi.idCounter++,this.index=-1,this.world=null,this.vlambda=new _i,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new _i,this.previousPosition=new _i,this.interpolatedPosition=new _i,this.initPosition=new _i,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new _i,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new _i,this.force=new _i;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Wi.STATIC:Wi.DYNAMIC,typeof e.type==typeof Wi.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Wi.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new _i,this.quaternion=new zi,this.initQuaternion=new zi,this.previousQuaternion=new zi,this.interpolatedQuaternion=new zi,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new _i,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new _i,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new _i,this.invInertia=new _i,this.invInertiaWorld=new wi,this.invMassSolve=0,this.invInertiaSolve=new _i,this.invInertiaWorldSolve=new wi,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new _i(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new _i(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new Ei,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new _i,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=Wi.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Wi.SLEEPING&&this.dispatchEvent(Wi.wakeupEvent)}sleep(){this.sleepState=Wi.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),r=this.sleepSpeedLimit**2;t===Wi.AWAKE&&n<r?(this.sleepState=Wi.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Wi.sleepyEvent)):t===Wi.SLEEPY&&n>r?this.wakeUp():t===Wi.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Wi.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Wi.SLEEPING||this.type===Wi.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new _i),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new _i),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new _i),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new _i),this.quaternion.vmult(e,t),t}addShape(e,t,n){const r=new _i,i=new zi;return t&&r.copy(t),n&&i.copy(n),this.shapes.push(e),this.shapeOffsets.push(r),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let r=0;for(let i=0;i!==n;i++){const n=e[i];n.updateBoundingSphereRadius();const s=t[i].length(),o=n.boundingSphereRadius;s+o>r&&(r=s+o)}this.boundingRadius=r}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,r=e.length,i=$i,s=Hi,o=this.quaternion,a=this.aabb,l=Yi;for(let c=0;c!==r;c++){const r=e[c];o.vmult(t[c],i),i.vadd(this.position,i),o.mult(n[c],s),r.calculateWorldAABB(i,s,l.lowerBound,l.upperBound),0===c?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=Xi,n=Zi;e.setRotationFromQuaternion(this.quaternion),e.transpose(n),e.scale(t,e),e.mmult(n,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new _i),this.type!==Wi.DYNAMIC)return;this.sleepState===Wi.SLEEPING&&this.wakeUp();const n=Ki;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new _i),this.type!==Wi.DYNAMIC)return;const n=Qi,r=Ji;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyForce(n,r)}applyTorque(e){this.type===Wi.DYNAMIC&&(this.sleepState===Wi.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new _i),this.type!==Wi.DYNAMIC)return;this.sleepState===Wi.SLEEPING&&this.wakeUp();const n=t,r=es;r.copy(e),r.scale(this.invMass,r),this.velocity.vadd(r,this.velocity);const i=ts;n.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new _i),this.type!==Wi.DYNAMIC)return;const n=ns,r=rs;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyImpulse(n,r)}updateMassProperties(){const e=is;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),ji.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new _i;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Wi.DYNAMIC&&this.type!==Wi.KINEMATIC||this.sleepState===Wi.SLEEPING)return;const r=this.velocity,i=this.angularVelocity,s=this.position,o=this.force,a=this.torque,l=this.quaternion,c=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,d=c*e;r.x+=o.x*d*h.x,r.y+=o.y*d*h.y,r.z+=o.z*d*h.z;const p=u.elements,f=this.angularFactor,m=a.x*f.x,g=a.y*f.y,v=a.z*f.z;i.x+=e*(p[0]*m+p[1]*g+p[2]*v),i.y+=e*(p[3]*m+p[4]*g+p[5]*v),i.z+=e*(p[6]*m+p[7]*g+p[8]*v),s.x+=r.x*e,s.y+=r.y*e,s.z+=r.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(n?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Wi.idCounter=0,Wi.COLLIDE_EVENT_NAME="collide",Wi.DYNAMIC=1,Wi.STATIC=2,Wi.KINEMATIC=4,Wi.AWAKE=0,Wi.SLEEPY=1,Wi.SLEEPING=2,Wi.wakeupEvent={type:"wakeup"},Wi.sleepyEvent={type:"sleepy"},Wi.sleepEvent={type:"sleep"};const $i=new _i,Hi=new zi,Yi=new Ei,Xi=new wi,Zi=new wi,Ki=(new wi,new _i),Qi=new _i,Ji=new _i,es=new _i,ts=new _i,ns=new _i,rs=new _i,is=new _i;class ss{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&Wi.STATIC)&&e.sleepState!==Wi.SLEEPING||0==(t.type&Wi.STATIC)&&t.sleepState!==Wi.SLEEPING)}intersectionTest(e,t,n,r){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,r):this.doBoundingSphereBroadphase(e,t,n,r)}doBoundingSphereBroadphase(e,t,n,r){const i=os;t.position.vsub(e.position,i);const s=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<s&&(n.push(e),r.push(t))}doBoundingBoxBroadphase(e,t,n,r){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),r.push(t))}makePairsUnique(e,t){const n=as,r=ls,i=cs,s=e.length;for(let n=0;n!==s;n++)r[n]=e[n],i[n]=t[n];e.length=0,t.length=0;for(let e=0;e!==s;e++){const t=r[e].id,s=i[e].id,o=t<s?`${t},${s}`:`${s},${t}`;n[o]=e,n.keys.push(o)}for(let s=0;s!==n.keys.length;s++){const s=n.keys.pop(),o=n[s];e.push(r[o]),t.push(i[o]),delete n[s]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new _i;e.position.vsub(t.position,n);const r=e.shapes[0],i=t.shapes[0];return Math.pow(r.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const os=new _i;new _i,new zi,new _i;const as={keys:[]},ls=[],cs=[];new _i,new _i,new _i;class us extends ss{constructor(){super()}collisionPairs(e,t,n){const r=e.bodies,i=r.length;let s,o;for(let e=0;e!==i;e++)for(let i=0;i!==e;i++)s=r[e],o=r[i],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,t,n)}aabbQuery(e,t,n){void 0===n&&(n=[]);for(let r=0;r<e.bodies.length;r++){const i=e.bodies[r];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&n.push(i)}return n}}class hs{constructor(){this.rayFromWorld=new _i,this.rayToWorld=new _i,this.hitNormalWorld=new _i,this.hitPointWorld=new _i,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,r,i,s,o){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(r),this.shape=i,this.body=s,this.distance=o}}let ds,ps,fs,ms,gs,vs,ys;ds=Oi.types.SPHERE,ps=Oi.types.PLANE,fs=Oi.types.BOX,ms=Oi.types.CYLINDER,gs=Oi.types.CONVEXPOLYHEDRON,vs=Oi.types.HEIGHTFIELD,ys=Oi.types.TRIMESH;class xs{get[ds](){return this._intersectSphere}get[ps](){return this._intersectPlane}get[fs](){return this._intersectBox}get[ms](){return this._intersectConvex}get[gs](){return this._intersectConvex}get[vs](){return this._intersectHeightfield}get[ys](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new _i),void 0===t&&(t=new _i),this.from=e.clone(),this.to=t.clone(),this.direction=new _i,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=xs.ANY,this.result=new hs,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||xs.ANY,this.result=t.result||new hs,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(ws),bs.length=0,e.broadphase.aabbQuery(e,ws,bs),this.intersectBodies(bs),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const r=ks,i=Ts;for(let t=0,s=e.shapes.length;t<s;t++){const s=e.shapes[t];if((!n||s.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],i),e.quaternion.vmult(e.shapeOffsets[t],r),r.vadd(e.position,r),this.intersectShape(s,i,r,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,n=e.length;!this.result.shouldStop&&t<n;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,r){const i=function(e,t,n){n.vsub(e,$s);const r=$s.dot(t);t.scale(r,Hs),Hs.vadd(e,Hs);return n.distanceTo(Hs)}(this.from,this.direction,n);if(i>e.boundingSphereRadius)return;const s=this[e.type];s&&s.call(this,e,t,n,r,e)}_intersectBox(e,t,n,r,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,r,i)}_intersectPlane(e,t,n,r,i){const s=this.from,o=this.to,a=this.direction,l=new _i(0,0,1);t.vmult(l,l);const c=new _i;s.vsub(n,c);const u=c.dot(l);if(o.vsub(n,c),u*c.dot(l)>0)return;if(s.distanceTo(o)<u)return;const h=l.dot(a);if(Math.abs(h)<this.precision)return;const d=new _i,p=new _i,f=new _i;s.vsub(n,d);const m=-l.dot(d)/h;a.scale(m,p),s.vadd(p,f),this.reportIntersection(l,f,i,r,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,r=this.to,i=this.from;t.x=Math.min(r.x,i.x),t.y=Math.min(r.y,i.y),t.z=Math.min(r.z,i.z),n.x=Math.max(r.x,i.x),n.y=Math.max(r.y,i.y),n.z=Math.max(r.z,i.z)}_intersectHeightfield(e,t,n,r,i){e.data,e.elementSize;const s=Is;s.from.copy(this.from),s.to.copy(this.to),Ri.pointToLocalFrame(n,t,s.from,s.from),Ri.pointToLocalFrame(n,t,s.to,s.to),s.updateDirection();const o=Bs;let a,l,c,u;a=l=0,c=u=e.data.length-1;const h=new Ei;s.getAABB(h),e.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,o,!0),a=Math.max(a,o[0]),l=Math.max(l,o[1]),e.getIndexOfPosition(h.upperBound.x,h.upperBound.y,o,!0),c=Math.min(c,o[0]+1),u=Math.min(u,o[1]+1);for(let o=a;o<c;o++)for(let a=l;a<u;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(o,a,h),h.overlapsRay(s)){if(e.getConvexTrianglePillar(o,a,!1),Ri.pointToWorldFrame(n,t,e.pillarOffset,zs),this._intersectConvex(e.pillarConvex,t,zs,r,i,Cs),this.result.shouldStop)return;e.getConvexTrianglePillar(o,a,!0),Ri.pointToWorldFrame(n,t,e.pillarOffset,zs),this._intersectConvex(e.pillarConvex,t,zs,r,i,Cs)}}}_intersectSphere(e,t,n,r,i){const s=this.from,o=this.to,a=e.radius,l=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2,c=2*((o.x-s.x)*(s.x-n.x)+(o.y-s.y)*(s.y-n.y)+(o.z-s.z)*(s.z-n.z)),u=c**2-4*l*((s.x-n.x)**2+(s.y-n.y)**2+(s.z-n.z)**2-a**2),h=Os,d=Rs;if(!(u<0))if(0===u)s.lerp(o,u,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1);else{const e=(-c-Math.sqrt(u))/(2*l),t=(-c+Math.sqrt(u))/(2*l);if(e>=0&&e<=1&&(s.lerp(o,e,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(s.lerp(o,t,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1))}}_intersectConvex(e,t,n,r,i,s){const o=Ns,a=Us,l=s&&s.faceList||null,c=e.faces,u=e.vertices,h=e.faceNormals,d=this.direction,p=this.from,f=this.to,m=p.distanceTo(f),g=l?l.length:c.length,v=this.result;for(let e=0;!v.shouldStop&&e<g;e++){const s=l?l[e]:e,f=c[s],g=h[s],y=t,x=n;a.copy(u[f[0]]),y.vmult(a,a),a.vadd(x,a),a.vsub(p,a),y.vmult(g,o);const w=d.dot(o);if(Math.abs(w)<this.precision)continue;const b=o.dot(a)/w;if(!(b<0)){d.scale(b,Es),Es.vadd(p,Es),As.copy(u[f[0]]),y.vmult(As,As),x.vadd(As,As);for(let e=1;!v.shouldStop&&e<f.length-1;e++){Ps.copy(u[f[e]]),Ms.copy(u[f[e+1]]),y.vmult(Ps,Ps),y.vmult(Ms,Ms),x.vadd(Ps,Ps),x.vadd(Ms,Ms);const t=Es.distanceTo(p);!xs.pointInTriangle(Es,As,Ps,Ms)&&!xs.pointInTriangle(Es,Ps,As,Ms)||t>m||this.reportIntersection(o,Es,i,r,s)}}}}_intersectTrimesh(e,t,n,r,i,s){const o=Ds,a=Gs,l=Ws,c=Us,u=Ls,h=Fs,d=qs,p=Vs,f=js,m=e.indices;e.vertices;const g=this.from,v=this.to,y=this.direction;l.position.copy(n),l.quaternion.copy(t),Ri.vectorToLocalFrame(n,t,y,u),Ri.pointToLocalFrame(n,t,g,h),Ri.pointToLocalFrame(n,t,v,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,d.vsub(h,u),u.normalize();const x=h.distanceSquared(d);e.tree.rayQuery(this,l,a);for(let s=0,l=a.length;!this.result.shouldStop&&s!==l;s++){const l=a[s];e.getNormal(l,o),e.getVertex(m[3*l],As),As.vsub(h,c);const d=u.dot(o),g=o.dot(c)/d;if(g<0)continue;u.scale(g,Es),Es.vadd(h,Es),e.getVertex(m[3*l+1],Ps),e.getVertex(m[3*l+2],Ms);const v=Es.distanceSquared(h);!xs.pointInTriangle(Es,Ps,As,Ms)&&!xs.pointInTriangle(Es,As,Ps,Ms)||v>x||(Ri.vectorToWorldFrame(t,o,f),Ri.pointToWorldFrame(n,t,Es,p),this.reportIntersection(f,p,i,r,l))}a.length=0}reportIntersection(e,t,n,r,i){const s=this.from,o=this.to,a=s.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==i?i:-1,this.mode){case xs.ALL:this.hasHit=!0,l.set(s,o,e,t,n,r,a),l.hasHit=!0,this.callback(l);break;case xs.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,r,a));break;case xs.ANY:this.hasHit=!0,l.hasHit=!0,l.set(s,o,e,t,n,r,a),l.shouldStop=!0}}static pointInTriangle(e,t,n,r){r.vsub(t,$s),n.vsub(t,_s),e.vsub(t,Ss);const i=$s.dot($s),s=$s.dot(_s),o=$s.dot(Ss),a=_s.dot(_s),l=_s.dot(Ss);let c,u;return(c=a*o-s*l)>=0&&(u=i*l-s*o)>=0&&c+u<i*a-s*s}}xs.CLOSEST=1,xs.ANY=2,xs.ALL=4;const ws=new Ei,bs=[],_s=new _i,Ss=new _i,ks=new _i,Ts=new zi,Es=new _i,As=new _i,Ps=new _i,Ms=new _i;new _i,new hs;const Cs={faceList:[0]},zs=new _i,Is=new xs,Bs=[],Os=new _i,Rs=new _i,Ns=new _i,Us=(new _i,new _i,new _i),Ds=new _i,Ls=new _i,Fs=new _i,qs=new _i,js=new _i,Vs=new _i;new Ei;const Gs=[],Ws=new Ri,$s=new _i,Hs=new _i;class Ys{static defaults(e,t){void 0===e&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class Xs{constructor(e,t,n){void 0===n&&(n={}),n=Ys.defaults(n,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=Xs.idCounter++,this.collideConnected=n.collideConnected,n.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}Xs.idCounter=0;class Zs{constructor(){this.spatial=new _i,this.rotational=new _i}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class Ks{constructor(e,t,n,r){void 0===n&&(n=-1e6),void 0===r&&(r=1e6),this.id=Ks.idCounter++,this.minForce=n,this.maxForce=r,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new Zs,this.jacobianElementB=new Zs,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const r=t,i=e,s=n;this.a=4/(s*(1+4*r)),this.b=4*r/(1+4*r),this.eps=4/(s*s*i*(1+4*r))}computeB(e,t,n){const r=this.computeGW();return-this.computeGq()*e-r*t-this.computeGiMf()*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.position,s=r.position;return e.spatial.dot(i)+t.spatial.dot(s)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.velocity,s=r.velocity,o=n.angularVelocity,a=r.angularVelocity;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.vlambda,s=r.vlambda,o=n.wlambda,a=r.wlambda;return e.multiplyVectors(i,o)+t.multiplyVectors(s,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.force,s=n.torque,o=r.force,a=r.torque,l=n.invMassSolve,c=r.invMassSolve;return i.scale(l,Qs),o.scale(c,Js),n.invInertiaWorldSolve.vmult(s,eo),r.invInertiaWorldSolve.vmult(a,to),e.multiplyVectors(Qs,eo)+t.multiplyVectors(Js,to)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.invMassSolve,s=r.invMassSolve,o=n.invInertiaWorldSolve,a=r.invInertiaWorldSolve;let l=i+s;return o.vmult(e.rotational,no),l+=no.dot(e.rotational),a.vmult(t.rotational,no),l+=no.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,r=this.bi,i=this.bj,s=ro;r.vlambda.addScaledVector(r.invMassSolve*e,t.spatial,r.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,n.spatial,i.vlambda),r.invInertiaWorldSolve.vmult(t.rotational,s),r.wlambda.addScaledVector(e,s,r.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,s),i.wlambda.addScaledVector(e,s,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Ks.idCounter=0;const Qs=new _i,Js=new _i,eo=new _i,to=new _i,no=new _i,ro=new _i;class io extends Ks{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new _i,this.rj=new _i,this.ni=new _i}computeB(e){const t=this.a,n=this.b,r=this.bi,i=this.bj,s=this.ri,o=this.rj,a=so,l=oo,c=r.velocity,u=r.angularVelocity;r.force,r.torque;const h=i.velocity,d=i.angularVelocity;i.force,i.torque;const p=ao,f=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;s.cross(g,a),o.cross(g,l),g.negate(f.spatial),a.negate(f.rotational),m.spatial.copy(g),m.rotational.copy(l),p.copy(i.position),p.vadd(o,p),p.vsub(r.position,p),p.vsub(s,p);const v=g.dot(p),y=this.restitution+1;return-v*t-(y*h.dot(g)-y*c.dot(g)+d.dot(l)-u.dot(a))*n-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=lo,t=co,n=uo,r=ho,i=po;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,r),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(r,t),e.vsub(t,i),this.ni.dot(i)}}const so=new _i,oo=new _i,ao=new _i,lo=new _i,co=new _i,uo=new _i,ho=new _i,po=new _i;new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i;class fo extends Ks{constructor(e,t,n){super(e,t,-n,n),this.ri=new _i,this.rj=new _i,this.t=new _i}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,r=this.rj,i=mo,s=go,o=this.t;n.cross(o,i),r.cross(o,s);const a=this.jacobianElementA,l=this.jacobianElementB;return o.negate(a.spatial),i.negate(a.rotational),l.spatial.copy(o),l.rotational.copy(s),-this.computeGW()*t-e*this.computeGiMf()}}const mo=new _i,go=new _i;class vo{constructor(e,t,n){n=Ys.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=vo.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}vo.idCounter=0;class yo{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=yo.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}yo.idCounter=0,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new xs,new _i,new _i,new _i,new _i(1,0,0),new _i(0,1,0),new _i(0,0,1),new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new Ei,new _i,new Ei,new _i,new _i,new _i,new _i,new _i,new _i,new _i,new Ei,new _i,new Ri,new Ei;class xo{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);-1!==n&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class wo extends xo{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const r=this.iterations,i=this.tolerance*this.tolerance,s=this.equations,o=s.length,a=t.bodies,l=a.length,c=e;let u,h,d,p,f,m;if(0!==o)for(let e=0;e!==l;e++)a[e].updateSolveMassProperties();const g=_o,v=So,y=bo;g.length=o,v.length=o,y.length=o;for(let e=0;e!==o;e++){const t=s[e];y[e]=0,v[e]=t.computeB(c),g[e]=1/t.computeC()}if(0!==o){for(let e=0;e!==l;e++){const t=a[e],n=t.vlambda,r=t.wlambda;n.set(0,0,0),r.set(0,0,0)}for(n=0;n!==r;n++){p=0;for(let e=0;e!==o;e++){const t=s[e];u=v[e],h=g[e],m=y[e],f=t.computeGWlambda(),d=h*(u-f-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),y[e]+=d,p+=d>0?d:-d,t.addToWlambda(d)}if(p*p<i)break}for(let e=0;e!==l;e++){const t=a[e],n=t.velocity,r=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),n.vadd(t.vlambda,n),t.wlambda.vmul(t.angularFactor,t.wlambda),r.vadd(t.wlambda,r)}let e=s.length;const t=1/c;for(;e--;)s[e].multiplier=y[e]*t}return n}}const bo=[],_o=[],So=[];Wi.STATIC;class ko{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class To extends ko{constructor(){super(...arguments),this.type=_i}constructObject(){return new _i}}const Eo=Oi.types.SPHERE,Ao=Oi.types.SPHERE|Oi.types.PLANE,Po=Oi.types.BOX|Oi.types.BOX,Mo=Oi.types.SPHERE|Oi.types.BOX,Co=Oi.types.PLANE|Oi.types.BOX,zo=Oi.types.CONVEXPOLYHEDRON,Io=Oi.types.SPHERE|Oi.types.CONVEXPOLYHEDRON,Bo=Oi.types.PLANE|Oi.types.CONVEXPOLYHEDRON,Oo=Oi.types.BOX|Oi.types.CONVEXPOLYHEDRON,Ro=Oi.types.SPHERE|Oi.types.HEIGHTFIELD,No=Oi.types.BOX|Oi.types.HEIGHTFIELD,Uo=Oi.types.CONVEXPOLYHEDRON|Oi.types.HEIGHTFIELD,Do=Oi.types.PARTICLE|Oi.types.SPHERE,Lo=Oi.types.PLANE|Oi.types.PARTICLE,Fo=Oi.types.BOX|Oi.types.PARTICLE,qo=Oi.types.PARTICLE|Oi.types.CONVEXPOLYHEDRON,jo=Oi.types.CYLINDER,Vo=Oi.types.SPHERE|Oi.types.CYLINDER,Go=Oi.types.PLANE|Oi.types.CYLINDER,Wo=Oi.types.BOX|Oi.types.CYLINDER,$o=Oi.types.CONVEXPOLYHEDRON|Oi.types.CYLINDER,Ho=Oi.types.HEIGHTFIELD|Oi.types.CYLINDER,Yo=Oi.types.PARTICLE|Oi.types.CYLINDER,Xo=Oi.types.SPHERE|Oi.types.TRIMESH,Zo=Oi.types.PLANE|Oi.types.TRIMESH;class Ko{get[Eo](){return this.sphereSphere}get[Ao](){return this.spherePlane}get[Po](){return this.boxBox}get[Mo](){return this.sphereBox}get[Co](){return this.planeBox}get[zo](){return this.convexConvex}get[Io](){return this.sphereConvex}get[Bo](){return this.planeConvex}get[Oo](){return this.boxConvex}get[Ro](){return this.sphereHeightfield}get[No](){return this.boxHeightfield}get[Uo](){return this.convexHeightfield}get[Do](){return this.sphereParticle}get[Lo](){return this.planeParticle}get[Fo](){return this.boxParticle}get[qo](){return this.convexParticle}get[jo](){return this.convexConvex}get[Vo](){return this.sphereConvex}get[Go](){return this.planeConvex}get[Wo](){return this.boxConvex}get[$o](){return this.convexConvex}get[Ho](){return this.heightfieldCylinder}get[Yo](){return this.particleCylinder}get[Xo](){return this.sphereTrimesh}get[Zo](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new To,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,r,i,s){let o;this.contactPointPool.length?(o=this.contactPointPool.pop(),o.bi=e,o.bj=t):o=new io(e,t),o.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&r.collisionResponse;const a=this.currentContactMaterial;o.restitution=a.restitution,o.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=n.material||e.material,c=r.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(o.restitution=l.restitution*c.restitution),o.si=i||n,o.sj=s||r,o}createFrictionEquationsFromContact(e,t){const n=e.bi,r=e.bj,i=e.si,s=e.sj,o=this.world,a=this.currentContactMaterial;let l=a.friction;const c=i.material||n.material,u=s.material||r.material;if(c&&u&&c.friction>=0&&u.friction>=0&&(l=c.friction*u.friction),l>0){const i=l*(o.frictionGravity||o.gravity).length();let s=n.invMass+r.invMass;s>0&&(s=1/s);const c=this.frictionEquationPool,u=c.length?c.pop():new fo(n,r,i*s),h=c.length?c.pop():new fo(n,r,i*s);return u.bi=h.bi=n,u.bj=h.bj=r,u.minForce=h.minForce=-i*s,u.maxForce=h.maxForce=i*s,u.ri.copy(e.ri),u.rj.copy(e.rj),h.ri.copy(e.ri),h.rj.copy(e.rj),e.ni.tangents(u.t,h.t),u.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,o.dt),u.enabled=h.enabled=e.enabled,t.push(u,h),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const n=this.frictionResult[this.frictionResult.length-2],r=this.frictionResult[this.frictionResult.length-1];Qo.setZero(),Jo.setZero(),ea.setZero();const i=t.bi;t.bj;for(let n=0;n!==e;n++)t=this.result[this.result.length-1-n],t.bi!==i?(Qo.vadd(t.ni,Qo),Jo.vadd(t.ri,Jo),ea.vadd(t.rj,ea)):(Qo.vsub(t.ni,Qo),Jo.vadd(t.rj,Jo),ea.vadd(t.ri,ea));const s=1/e;Jo.scale(s,n.ri),ea.scale(s,n.rj),r.ri.copy(n.ri),r.rj.copy(n.rj),Qo.normalize(),Qo.tangents(n.t,r.t)}getContacts(e,t,n,r,i,s,o){this.contactPointPool=i,this.frictionEquationPool=o,this.result=r,this.frictionResult=s;const a=ra,l=ia,c=ta,u=na;for(let r=0,i=e.length;r!==i;r++){const i=e[r],s=t[r];let o=null;i.material&&s.material&&(o=n.getContactMaterial(i.material,s.material)||null);const h=i.type&Wi.KINEMATIC&&s.type&Wi.STATIC||i.type&Wi.STATIC&&s.type&Wi.KINEMATIC||i.type&Wi.KINEMATIC&&s.type&Wi.KINEMATIC;for(let e=0;e<i.shapes.length;e++){i.quaternion.mult(i.shapeOrientations[e],a),i.quaternion.vmult(i.shapeOffsets[e],c),c.vadd(i.position,c);const t=i.shapes[e];for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],l),s.quaternion.vmult(s.shapeOffsets[e],u),u.vadd(s.position,u);const r=s.shapes[e];if(!(t.collisionFilterMask&r.collisionFilterGroup&&r.collisionFilterMask&t.collisionFilterGroup))continue;if(c.distanceTo(u)>t.boundingSphereRadius+r.boundingSphereRadius)continue;let d=null;t.material&&r.material&&(d=n.getContactMaterial(t.material,r.material)||null),this.currentContactMaterial=d||o||n.defaultContactMaterial;const p=this[t.type|r.type];if(p){let e=!1;e=t.type<r.type?p.call(this,t,r,c,u,a,l,i,s,t,r,h):p.call(this,r,t,u,c,l,a,s,i,t,r,h),e&&h&&(n.shapeOverlapKeeper.set(t.id,r.id),n.bodyOverlapKeeper.set(i.id,s.id))}}}}}sphereSphere(e,t,n,r,i,s,o,a,l,c,u){if(u)return n.distanceSquared(r)<(e.radius+t.radius)**2;const h=this.createContactEquation(o,a,e,t,l,c);r.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(o.position,h.ri),h.rj.vadd(r,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,n,r,i,s,o,a,l,c,u){const h=this.createContactEquation(o,a,e,t,l,c);if(h.ni.set(0,0,1),s.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),n.vsub(r,Sa),h.ni.scale(h.ni.dot(Sa),ka),Sa.vsub(ka,h.rj),-Sa.dot(h.ni)<=e.radius){if(u)return!0;const e=h.ri,t=h.rj;e.vadd(n,e),e.vsub(o.position,e),t.vadd(r,t),t.vsub(a.position,t),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,u)}sphereBox(e,t,n,r,i,s,o,a,l,c,u){const h=this.v3pool,d=Ba;n.vsub(r,Ma),t.getSideNormals(d,s);const p=e.radius;let f=!1;const m=Ra,g=Na,v=Ua;let y=null,x=0,w=0,b=0,_=null;for(let e=0,t=d.length;e!==t&&!1===f;e++){const t=Ca;t.copy(d[e]);const n=t.length();t.normalize();const r=Ma.dot(t);if(r<n+p&&r>0){const i=za,s=Ia;i.copy(d[(e+1)%3]),s.copy(d[(e+2)%3]);const o=i.length(),a=s.length();i.normalize(),s.normalize();const l=Ma.dot(i),c=Ma.dot(s);if(l<o&&l>-o&&c<a&&c>-a){const e=Math.abs(r-n-p);if((null===_||e<_)&&(_=e,w=l,b=c,y=n,m.copy(t),g.copy(i),v.copy(s),x++,u))return!0}}}if(x){f=!0;const i=this.createContactEquation(o,a,e,t,l,c);m.scale(-p,i.ri),i.ni.copy(m),i.ni.negate(i.ni),m.scale(y,m),g.scale(w,g),m.vadd(g,m),v.scale(b,v),m.vadd(v,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}let S=h.get();const k=Oa;for(let i=0;2!==i&&!f;i++)for(let s=0;2!==s&&!f;s++)for(let h=0;2!==h&&!f;h++)if(S.set(0,0,0),i?S.vadd(d[0],S):S.vsub(d[0],S),s?S.vadd(d[1],S):S.vsub(d[1],S),h?S.vadd(d[2],S):S.vsub(d[2],S),r.vadd(S,k),k.vsub(n,k),k.lengthSquared()<p*p){if(u)return!0;f=!0;const i=this.createContactEquation(o,a,e,t,l,c);i.ri.copy(k),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(p,i.ri),i.rj.copy(S),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}h.release(S),S=null;const T=h.get(),E=h.get(),A=h.get(),P=h.get(),M=h.get(),C=d.length;for(let i=0;i!==C&&!f;i++)for(let s=0;s!==C&&!f;s++)if(i%3!=s%3){d[s].cross(d[i],T),T.normalize(),d[i].vadd(d[s],E),A.copy(n),A.vsub(E,A),A.vsub(r,A);const h=A.dot(T);T.scale(h,P);let m=0;for(;m===i%3||m===s%3;)m++;M.copy(n),M.vsub(P,M),M.vsub(E,M),M.vsub(r,M);const g=Math.abs(h),v=M.length();if(g<d[m].length()&&v<p){if(u)return!0;f=!0;const i=this.createContactEquation(o,a,e,t,l,c);E.vadd(P,i.rj),i.rj.copy(i.rj),M.negate(i.ni),i.ni.normalize(),i.ri.copy(i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(n,i.ri),i.ri.normalize(),i.ri.scale(p,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}h.release(T,E,A,P,M)}planeBox(e,t,n,r,i,s,o,a,l,c,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,r,i,s,o,a,e,t,u)}convexConvex(e,t,n,r,i,s,o,a,l,c,u,h,d){const p=Qa;if(!(n.distanceTo(r)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,i,r,s,p,h,d)){const h=[],d=Ja;e.clipAgainstHull(n,i,t,r,s,p,-100,100,h);let f=0;for(let i=0;i!==h.length;i++){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c),m=s.ri,g=s.rj;p.negate(s.ni),h[i].normal.negate(d),d.scale(h[i].depth,d),h[i].point.vadd(d,m),g.copy(h[i].point),m.vsub(n,m),g.vsub(r,g),m.vadd(n,m),m.vsub(o.position,m),g.vadd(r,g),g.vsub(a.position,g),this.result.push(s),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}}sphereConvex(e,t,n,r,i,s,o,a,l,c,u){const h=this.v3pool;n.vsub(r,Da);const d=t.faceNormals,p=t.faces,f=t.vertices,m=e.radius;let g=!1;for(let i=0;i!==f.length;i++){const h=f[i],d=ja;s.vmult(h,d),r.vadd(d,d);const p=qa;if(d.vsub(n,p),p.lengthSquared()<m*m){if(u)return!0;g=!0;const i=this.createContactEquation(o,a,e,t,l,c);return i.ri.copy(p),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(m,i.ri),d.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),void this.createFrictionEquationsFromContact(i,this.frictionResult)}}for(let i=0,v=p.length;i!==v&&!1===g;i++){const v=d[i],y=p[i],x=Va;s.vmult(v,x);const w=Ga;s.vmult(f[y[0]],w),w.vadd(r,w);const b=Wa;x.scale(-m,b),n.vadd(b,b);const _=$a;b.vsub(w,_);const S=_.dot(x),k=Ha;if(n.vsub(w,k),S<0&&k.dot(x)>0){const i=[];for(let e=0,t=y.length;e!==t;e++){const t=h.get();s.vmult(f[y[e]],t),r.vadd(t,t),i.push(t)}if(Pa(i,x,n)){if(u)return!0;g=!0;const s=this.createContactEquation(o,a,e,t,l,c);x.scale(-m,s.ri),x.negate(s.ni);const d=h.get();x.scale(-S,d);const p=h.get();x.scale(-m,p),n.vsub(r,s.rj),s.rj.vadd(p,s.rj),s.rj.vadd(d,s.rj),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),h.release(d),h.release(p),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return}for(let d=0;d!==y.length;d++){const p=h.get(),g=h.get();s.vmult(f[y[(d+1)%y.length]],p),s.vmult(f[y[(d+2)%y.length]],g),r.vadd(p,p),r.vadd(g,g);const v=La;g.vsub(p,v);const x=Fa;v.unit(x);const w=h.get(),b=h.get();n.vsub(p,b);const _=b.dot(x);x.scale(_,w),w.vadd(p,w);const S=h.get();if(w.vsub(n,S),_>0&&_*_<v.lengthSquared()&&S.lengthSquared()<m*m){if(u)return!0;const s=this.createContactEquation(o,a,e,t,l,c);w.vsub(r,s.rj),w.vsub(n,s.ni),s.ni.normalize(),s.ni.scale(m,s.ri),s.rj.vadd(r,s.rj),s.rj.vsub(a.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(o.position,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return h.release(p),h.release(g),h.release(w),h.release(S),void h.release(b)}h.release(p),h.release(g),h.release(w),h.release(S),h.release(b)}for(let e=0,t=i.length;e!==t;e++)h.release(i[e])}}}planeConvex(e,t,n,r,i,s,o,a,l,c,u){const h=Ya,d=Xa;d.set(0,0,1),i.vmult(d,d);let p=0;const f=Za;for(let i=0;i!==t.vertices.length;i++)if(h.copy(t.vertices[i]),s.vmult(h,h),r.vadd(h,h),h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const i=this.createContactEquation(o,a,e,t,l,c),s=Ka;d.scale(d.dot(f),s),h.vsub(s,s),s.vsub(n,i.ri),i.ni.copy(d),h.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(i,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}sphereHeightfield(e,t,n,r,i,s,o,a,l,c,u){const h=t.data,d=e.radius,p=t.elementSize,f=pl,m=dl;Ri.pointToLocalFrame(r,s,n,m);let g=Math.floor((m.x-d)/p)-1,v=Math.ceil((m.x+d)/p)+1,y=Math.floor((m.y-d)/p)-1,x=Math.ceil((m.y+d)/p)+1;if(v<0||x<0||g>h.length||y>h[0].length)return;g<0&&(g=0),v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),g>=h.length&&(g=h.length-1),v>=h.length&&(v=h.length-1),x>=h[0].length&&(x=h[0].length-1),y>=h[0].length&&(y=h[0].length-1);const w=[];t.getRectMinMax(g,y,v,x,w);const b=w[0],_=w[1];if(m.z-d>_||m.z+d<b)return;const S=this.result;for(let l=g;l<v;l++)for(let c=y;c<x;c++){const h=S.length;let d=!1;if(t.getConvexTrianglePillar(l,c,!1),Ri.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,o,a,e,t,u)),u&&d)return!0;if(t.getConvexTrianglePillar(l,c,!0),Ri.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,o,a,e,t,u)),u&&d)return!0;if(S.length-h>2)return}}boxHeightfield(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}convexHeightfield(e,t,n,r,i,s,o,a,l,c,u){const h=t.data,d=t.elementSize,p=e.boundingSphereRadius,f=ul,m=hl,g=cl;Ri.pointToLocalFrame(r,s,n,g);let v=Math.floor((g.x-p)/d)-1,y=Math.ceil((g.x+p)/d)+1,x=Math.floor((g.y-p)/d)-1,w=Math.ceil((g.y+p)/d)+1;if(y<0||w<0||v>h.length||x>h[0].length)return;v<0&&(v=0),y<0&&(y=0),x<0&&(x=0),w<0&&(w=0),v>=h.length&&(v=h.length-1),y>=h.length&&(y=h.length-1),w>=h[0].length&&(w=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const b=[];t.getRectMinMax(v,x,y,w,b);const _=b[0],S=b[1];if(!(g.z-p>S||g.z+p<_))for(let l=v;l<y;l++)for(let c=x;c<w;c++){let h=!1;if(t.getConvexTrianglePillar(l,c,!1),Ri.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,i,s,o,a,null,null,u,m,null)),u&&h)return!0;if(t.getConvexTrianglePillar(l,c,!0),Ri.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,i,s,o,a,null,null,u,m,null)),u&&h)return!0}}sphereParticle(e,t,n,r,i,s,o,a,l,c,u){const h=rl;if(h.set(0,0,1),r.vsub(n,h),h.lengthSquared()<=e.radius*e.radius){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);h.normalize(),n.rj.copy(h),n.rj.scale(e.radius,n.rj),n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}planeParticle(e,t,n,r,i,s,o,a,l,c,u){const h=el;h.set(0,0,1),o.quaternion.vmult(h,h);const d=tl;if(r.vsub(o.position,d),h.dot(d)<=0){if(u)return!0;const n=this.createContactEquation(a,o,t,e,l,c);n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0);const i=nl;h.scale(h.dot(r),i),r.vsub(i,i),n.rj.copy(i),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}boxParticle(e,t,n,r,i,s,o,a,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,r,i,s,o,a,e,t,u)}convexParticle(e,t,n,r,i,s,o,a,l,c,u){let h=-1;const d=ol,p=ll;let f=null;const m=sl;if(m.copy(r),m.vsub(n,m),i.conjugate(il),il.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let t=0,n=e.faces.length;t!==n;t++){const n=[e.worldVertices[e.faces[t][0]]],i=e.worldFaceNormals[t];r.vsub(n[0],al);const s=-i.dot(al);if(null===f||Math.abs(s)<Math.abs(f)){if(u)return!0;f=s,h=t,d.copy(i)}}if(-1!==h){const i=this.createContactEquation(a,o,t,e,l,c);d.scale(f,p),p.vadd(r,p),p.vsub(n,p),i.rj.copy(p),d.negate(i.ni),i.ri.set(0,0,0);const s=i.ri,u=i.rj;s.vadd(r,s),s.vsub(a.position,s),u.vadd(n,u),u.vsub(o.position,u),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,r,i,s,o,a,l,c,u){return this.convexHeightfield(t,e,r,n,s,i,a,o,l,c,u)}particleCylinder(e,t,n,r,i,s,o,a,l,c,u){return this.convexParticle(t,e,r,n,s,i,a,o,l,c,u)}sphereTrimesh(e,t,n,r,i,s,o,a,l,c,u){const h=da,d=pa,p=fa,f=ma,m=ga,g=va,v=ba,y=ha,x=ca,w=_a;Ri.pointToLocalFrame(r,s,n,m);const b=e.radius;v.lowerBound.set(m.x-b,m.y-b,m.z-b),v.upperBound.set(m.x+b,m.y+b,m.z+b),t.getTrianglesInAABB(v,w);const _=ua,S=e.radius*e.radius;for(let i=0;i<w.length;i++)for(let h=0;h<3;h++)if(t.getVertex(t.indices[3*w[i]+h],_),_.vsub(m,x),x.lengthSquared()<=S){if(y.copy(_),Ri.pointToWorldFrame(r,s,y,_),_.vsub(n,x),u)return!0;let i=this.createContactEquation(o,a,e,t,l,c);i.ni.copy(x),i.ni.normalize(),i.ri.copy(i.ni),i.ri.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),i.rj.copy(_),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}for(let i=0;i<w.length;i++)for(let v=0;v<3;v++){t.getVertex(t.indices[3*w[i]+v],h),t.getVertex(t.indices[3*w[i]+(v+1)%3],d),d.vsub(h,p),m.vsub(d,g);const y=g.dot(p);m.vsub(h,g);let x=g.dot(p);if(x>0&&y<0&&(m.vsub(h,g),f.copy(p),f.normalize(),x=g.dot(f),f.scale(x,g),g.vadd(h,g),g.distanceTo(m)<e.radius)){if(u)return!0;const i=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),Ri.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),Ri.vectorToWorldFrame(s,i.ni,i.ni),Ri.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}const k=ya,T=xa,E=wa,A=la;for(let i=0,h=w.length;i!==h;i++){t.getTriangleVertices(w[i],k,T,E),t.getNormal(w[i],A),m.vsub(k,g);let h=g.dot(A);if(A.scale(h,g),m.vsub(g,g),h=g.distanceTo(m),xs.pointInTriangle(g,k,T,E)&&h<e.radius){if(u)return!0;let i=this.createContactEquation(o,a,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(o.position,i.ri),Ri.pointToWorldFrame(r,s,g,g),g.vsub(a.position,i.rj),Ri.vectorToWorldFrame(s,i.ni,i.ni),Ri.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}w.length=0}planeTrimesh(e,t,n,r,i,s,o,a,l,c,u){const h=new _i,d=sa;d.set(0,0,1),i.vmult(d,d);for(let i=0;i<t.vertices.length/3;i++){t.getVertex(i,h);const p=new _i;p.copy(h),Ri.pointToWorldFrame(r,s,p,h);const f=oa;if(h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const n=this.createContactEquation(o,a,e,t,l,c);n.ni.copy(d);const r=aa;d.scale(f.dot(d),r),h.vsub(r,r),n.ri.copy(r),n.ri.vsub(o.position,n.ri),n.rj.copy(h),n.rj.vsub(a.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}}const Qo=new _i,Jo=new _i,ea=new _i,ta=new _i,na=new _i,ra=new zi,ia=new zi,sa=new _i,oa=new _i,aa=new _i,la=new _i,ca=new _i;new _i;const ua=new _i,ha=new _i,da=new _i,pa=new _i,fa=new _i,ma=new _i,ga=new _i,va=new _i,ya=new _i,xa=new _i,wa=new _i,ba=new Ei,_a=[],Sa=new _i,ka=new _i,Ta=new _i,Ea=new _i,Aa=new _i;function Pa(e,t,n){let r=null;const i=e.length;for(let s=0;s!==i;s++){const o=e[s],a=Ta;e[(s+1)%i].vsub(o,a);const l=Ea;a.cross(t,l);const c=Aa;n.vsub(o,c);const u=l.dot(c);if(!(null===r||u>0&&!0===r||u<=0&&!1===r))return!1;null===r&&(r=u>0)}return!0}const Ma=new _i,Ca=new _i,za=new _i,Ia=new _i,Ba=[new _i,new _i,new _i,new _i,new _i,new _i],Oa=new _i,Ra=new _i,Na=new _i,Ua=new _i,Da=new _i,La=new _i,Fa=new _i,qa=new _i,ja=new _i,Va=new _i,Ga=new _i,Wa=new _i,$a=new _i,Ha=new _i;new _i,new _i;const Ya=new _i,Xa=new _i,Za=new _i,Ka=new _i,Qa=new _i,Ja=new _i,el=new _i,tl=new _i,nl=new _i,rl=new _i,il=new zi,sl=new _i;new _i;const ol=new _i,al=new _i,ll=new _i,cl=new _i,ul=new _i,hl=[0],dl=new _i,pl=new _i;class fl{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),r=this.current;let i=0;for(;n>r[i];)i++;if(n!==r[i]){for(let e=r.length-1;e>=i;e--)r[e+1]=r[e];r[i]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,r=this.previous,i=n.length,s=r.length;let o=0;for(let t=0;t<i;t++){let i=!1;const s=n[t];for(;s>r[o];)o++;i=s===r[o],i||ml(e,s)}o=0;for(let e=0;e<s;e++){let i=!1;const s=r[e];for(;s>n[o];)o++;i=n[o]===s,i||ml(t,s)}}}function ml(e,t){e.push((4294901760&t)>>16,65535&t)}const gl=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class vl{constructor(){this.data={keys:[]}}get(e,t){const n=gl(e,t);return this.data[n]}set(e,t,n){const r=gl(e,t);this.get(e,t)||this.data.keys.push(r),this.data[r]=n}delete(e,t){const n=gl(e,t),r=this.data.keys.indexOf(n);-1!==r&&this.data.keys.splice(r,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;)delete e[t.pop()]}}class yl extends Ci{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new _i,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new _i,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new us,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new wo,this.constraints=[],this.narrowphase=new Ko(this),this.collisionMatrix=new Mi,this.collisionMatrixPrevious=new Mi,this.bodyOverlapKeeper=new fl,this.shapeOverlapKeeper=new fl,this.contactmaterials=[],this.contactMaterialTable=new vl,this.defaultMaterial=new yo("default"),this.defaultContactMaterial=new vo(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof hs?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,r){return void 0===n&&(n={}),n.mode=xs.ALL,n.from=e,n.to=t,n.callback=r,xl.intersectWorld(this,n)}raycastAny(e,t,n,r){return void 0===n&&(n={}),n.mode=xs.ANY,n.from=e,n.to=t,n.result=r,xl.intersectWorld(this,n)}raycastClosest(e,t,n,r){return void 0===n&&(n={}),n.mode=xs.CLOSEST,n.from=e,n.to=t,n.result=r,xl.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Wi&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,r=n.indexOf(e);if(-1!==r){n.splice(r,1);for(let e=0;e!==n.length;e++)n[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const r=t[n].shapes;for(let t=0;t<r.length;t++){const n=r[t];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const n=wl.now()/1e3;if(this.lastCallTime){const r=n-this.lastCallTime;this.step(e,r,t)}else this.step(e,void 0,t);this.lastCallTime=n}step(e,t,n){if(void 0===n&&(n=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const r=wl.now();let i=0;for(;this.accumulator>=e&&i<n&&(this.internalStep(e),this.accumulator-=e,i++,!(wl.now()-r>1e3*e)););this.accumulator=this.accumulator%e;const s=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,s,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,s,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=El,r=Al,i=this.bodies.length,s=this.bodies,o=this.solver,a=this.gravity,l=this.doProfiling,c=this.profile,u=Wi.DYNAMIC;let h=-1/0;const d=this.constraints,p=Tl;a.length();const f=a.x,m=a.y,g=a.z;let v=0;for(l&&(h=wl.now()),v=0;v!==i;v++){const e=s[v];if(e.type===u){const t=e.force,n=e.mass;t.x+=n*f,t.y+=n*m,t.z+=n*g}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(h=wl.now()),n.length=0,r.length=0,this.broadphase.collisionPairs(this,n,r),l&&(c.broadphase=wl.now()-h);let y=d.length;for(v=0;v!==y;v++){const e=d[v];if(!e.collideConnected)for(let t=n.length-1;t>=0;t-=1)(e.bodyA===n[t]&&e.bodyB===r[t]||e.bodyB===n[t]&&e.bodyA===r[t])&&(n.splice(t,1),r.splice(t,1))}this.collisionMatrixTick(),l&&(h=wl.now());const x=kl,w=t.length;for(v=0;v!==w;v++)x.push(t[v]);t.length=0;const b=this.frictionEquations.length;for(v=0;v!==b;v++)p.push(this.frictionEquations[v]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,r,this,t,x,this.frictionEquations,p),l&&(c.narrowphase=wl.now()-h),l&&(h=wl.now()),v=0;v<this.frictionEquations.length;v++)o.addEquation(this.frictionEquations[v]);const _=t.length;for(let e=0;e!==_;e++){const n=t[e],r=n.bi,i=n.bj,s=n.si,a=n.sj;let l;l=r.material&&i.material&&this.getContactMaterial(r.material,i.material)||this.defaultContactMaterial,l.friction,r.material&&i.material&&(r.material.friction>=0&&i.material.friction>=0&&(r.material.friction,i.material.friction),r.material.restitution>=0&&i.material.restitution>=0&&(n.restitution=r.material.restitution*i.material.restitution)),o.addEquation(n),r.allowSleep&&r.type===Wi.DYNAMIC&&r.sleepState===Wi.SLEEPING&&i.sleepState===Wi.AWAKE&&i.type!==Wi.STATIC&&i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0),i.allowSleep&&i.type===Wi.DYNAMIC&&i.sleepState===Wi.SLEEPING&&r.sleepState===Wi.AWAKE&&r.type!==Wi.STATIC&&r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(r,i,!0),this.collisionMatrixPrevious.get(r,i)||(Sl.body=i,Sl.contact=n,r.dispatchEvent(Sl),Sl.body=r,i.dispatchEvent(Sl)),this.bodyOverlapKeeper.set(r.id,i.id),this.shapeOverlapKeeper.set(s.id,a.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=wl.now()-h,h=wl.now()),v=0;v!==i;v++){const e=s[v];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(y=d.length,v=0;v!==y;v++){const e=d[v];e.update();for(let t=0,n=e.equations.length;t!==n;t++){const n=e.equations[t];o.addEquation(n)}}o.solve(e,this),l&&(c.solve=wl.now()-h),o.removeAllEquations();const S=Math.pow;for(v=0;v!==i;v++){const t=s[v];if(t.type&u){const n=S(1-t.linearDamping,e),r=t.velocity;r.scale(n,r);const i=t.angularVelocity;if(i){const n=S(1-t.angularDamping,e);i.scale(n,i)}}}this.dispatchEvent(_l),l&&(h=wl.now());const k=this.stepnumber%(this.quatNormalizeSkip+1)==0,T=this.quatNormalizeFast;for(v=0;v!==i;v++)s[v].integrate(e,k,T);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=wl.now()-h),this.stepnumber+=1,this.dispatchEvent(bl);let E=!0;if(this.allowSleep)for(E=!1,v=0;v!==i;v++){const e=s[v];e.sleepTick(this.time),e.sleepState!==Wi.SLEEPING&&(E=!0)}this.hasActiveBodies=E}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(Pl,Ml),e){for(let e=0,t=Pl.length;e<t;e+=2)Cl.bodyA=this.getBodyById(Pl[e]),Cl.bodyB=this.getBodyById(Pl[e+1]),this.dispatchEvent(Cl);Cl.bodyA=Cl.bodyB=null}if(t){for(let e=0,t=Ml.length;e<t;e+=2)zl.bodyA=this.getBodyById(Ml[e]),zl.bodyB=this.getBodyById(Ml[e+1]),this.dispatchEvent(zl);zl.bodyA=zl.bodyB=null}Pl.length=Ml.length=0;const n=this.hasAnyEventListener("beginShapeContact"),r=this.hasAnyEventListener("endShapeContact");if((n||r)&&this.shapeOverlapKeeper.getDiff(Pl,Ml),n){for(let e=0,t=Pl.length;e<t;e+=2){const t=this.getShapeById(Pl[e]),n=this.getShapeById(Pl[e+1]);Il.shapeA=t,Il.shapeB=n,t&&(Il.bodyA=t.body),n&&(Il.bodyB=n.body),this.dispatchEvent(Il)}Il.bodyA=Il.bodyB=Il.shapeA=Il.shapeB=null}if(r){for(let e=0,t=Ml.length;e<t;e+=2){const t=this.getShapeById(Ml[e]),n=this.getShapeById(Ml[e+1]);Bl.shapeA=t,Bl.shapeB=n,t&&(Bl.bodyA=t.body),n&&(Bl.bodyB=n.body),this.dispatchEvent(Bl)}Bl.bodyA=Bl.bodyB=Bl.shapeA=Bl.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const t=e[n];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new Ei;const xl=new xs,wl=globalThis.performance||{};if(!wl.now){let e=Date.now();wl.timing&&wl.timing.navigationStart&&(e=wl.timing.navigationStart),wl.now=()=>Date.now()-e}new _i;const bl={type:"postStep"},_l={type:"preStep"},Sl={type:Wi.COLLIDE_EVENT_NAME,body:null,contact:null},kl=[],Tl=[],El=[],Al=[],Pl=[],Ml=[],Cl={type:"beginContact",bodyA:null,bodyB:null},zl={type:"endContact",bodyA:null,bodyB:null},Il={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Bl={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class Ol extends e{world=new yl({gravity:new _i(0,-150,0)});constructor(){super()}}class Rl extends e{speed=1;rotationSpeed=.025;player;constructor(e=0,t=1,n=.025){super(),this.player=e,this.speed=t,this.rotationSpeed=n}}class Nl extends e{bodyId;halfExtents;options;constructor(e,t={}){super(),this.halfExtents=new _i(e[0]/2,e[1]/2,e[2]/2),this.options=t}}class Ul extends t{componentsRequired=new Set([Nl,rr,Rl]);update(e,t,n){const r=this.ecs.getEntitiesithComponent(Ol).values().next().value,s=this.ecs.getComponents(r).get(Ol).world;for(const t of e){const e=this.ecs.getComponents(t),r=e.get(Nl),o=e.get(rr),a=e.get(Rl),l=navigator.getGamepads()[a.player];if(!l)return;const c=i.eR.mulScalar(o.right,l.axes[0]),u=i.eR.mulScalar(o.direction,-l.axes[1]),h=i.eR.add(c,u),d=i.eR.add(o.position,i.eR.mulScalar(h,a.speed)),p=s.getBodyById(r.bodyId);if(!p)continue;p.position.set(d[0],d[1],d[2]);const f=i.Yu.rotateY(o.rotation,a.rotationSpeed*l.axes[2]),m=l.buttons[0].pressed,g=l.buttons[1].pressed,v=.001*n;m&&(o.scale=i.eR.add(o.scale,i.eR.create(v,v,v))),g&&(o.scale=i.eR.sub(o.scale,i.eR.create(v,v,v))),s.getBodyById(r.bodyId).quaternion.set(f[0],f[1],f[2],f[3])}}}class Dl extends e{chunkMap=new Map}var Ll=n(491);let Fl=[],ql={time:0};window.debugUI.setupAverageChunkGenerationTimeLogging(ql);var jl=n(590),Vl=n(192);const Gl=et(Ke),Wl=128,$l=navigator.hardwareConcurrency||4,Hl=new class{lastTime=0;entities=new Map;systems=new Map;nextEntityID=0;entitiesToDestroy=new Array;addEntity(){let e=this.nextEntityID;return this.nextEntityID++,this.entities.set(e,new r),e}removeEntity(e){this.entitiesToDestroy.push(e)}addComponent(e,t){this.entities.get(e).add(t),this.checkE(e)}addComponents(e,...t){for(let n of t)this.addComponent(e,n)}getComponents(e){return this.entities.get(e)}removeComponent(e,t){this.entities.get(e).delete(t),this.checkE(e)}addSystem(e){if(0==e.componentsRequired.size)return console.warn("System not added: empty Components list."),void console.warn(e);e.ecs=this,this.systems.set(e,new Set);for(let t of this.entities.keys())this.checkES(t,e)}removeSystem(e){this.systems.delete(e)}update(e){let t=e-this.lastTime;for(let[n,r]of this.systems.entries())n.update(r,e,t);for(;this.entitiesToDestroy.length>0;)this.destroyEntity(this.entitiesToDestroy.pop());this.lastTime=e}destroyEntity(e){this.entities.delete(e);for(let t of this.systems.values())t.delete(e)}checkE(e){for(let t of this.systems.keys())this.checkES(e,t)}checkES(e,t){let n=this.entities.get(e),r=t.componentsRequired;n.hasAll(r)?this.systems.get(t).add(e):this.systems.get(t).delete(e)}getEntitiesithComponent(e){let t=new Set;for(let[n,r]of this.entities)r.has(e)&&t.add(n);return t}};Hl.addSystem(new class extends t{keyboardControls=new vi;componentsRequired=new Set([rr,yi,xi]);update(e,t,n){for(const t of e){const e=this.ecs.getComponents(t),r=e.get(rr),s=e.get(yi),o=e.get(xi);let a=i.eR.create(),l=i.Yu.identity();this.keyboardControls.pressed.a&&(a=i.eR.add(a,r.left)),this.keyboardControls.pressed.d&&(a=i.eR.add(a,r.right)),this.keyboardControls.pressed.w&&(a=i.eR.add(a,r.direction)),this.keyboardControls.pressed.s&&(a=i.eR.add(a,i.eR.negate(r.direction))),this.keyboardControls.pressed.q&&(l=i.Yu.rotateY(l,-s.rotationSpeed*n)),this.keyboardControls.pressed.e&&(l=i.Yu.rotateY(l,s.rotationSpeed*n)),this.keyboardControls.pressed[" "]&&(a=i.eR.add(a,r.up)),this.keyboardControls.pressed.shift&&(a=i.eR.add(a,i.eR.negate(r.up))),i.eR.length(a)>0?(a=i.eR.normalize(a),o.velocity=i.eR.mulScalar(a,s.speed)):o.velocity=i.eR.sub(o.velocity,i.eR.mulScalar(o.velocity,.01*n)),o.angularVelocity=l}}}),Hl.addSystem(new class extends t{componentsRequired=new Set([ir,rr]);constructor(){super(),(async()=>{const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});let t;try{t=await e.requestDevice({requiredFeatures:["timestamp-query","float32-filterable"],requiredLimits:{maxColorAttachmentBytesPerSample:64}})}catch(n){console.warn("Timestamp query or 64 byte colour attachment not supported, falling back"),t=await e.requestDevice()}return t})().then((async e=>{const t=new fi(e),n=gi(this.ecs);n.device=e,n.volumeAtlas=t,ni(e,t,this.ecs)}))}update(e,t){const n=this.ecs.getEntitiesithComponent(ai).values().next().value,r=this.ecs.getComponents(n),i=r.get(ai),s=r.get(rr);oi(t,this.ecs,i,s,Array.from(e))}}),Hl.addSystem(new Ul),Hl.addSystem(new class extends t{componentsRequired=new Set([Dl]);isInitialized=!1;update(e){gi(this.ecs).device&&0!==e.size&&(this.ecs.getComponents(e.values().next().value).get(Dl),this.isInitialized||((async e=>{const t=gi(e).volumeAtlas,r=Array.from({length:Math.floor($l)},(()=>new Worker(new URL(n.p+n.u(97),n.b)))),s=r.map((e=>(0,jl.LV)(e)));let o=[];for(let e=0;e<512;e+=Wl)for(let t=0;t<512;t+=Wl)for(let n=0;n<Vl.yq;n+=Wl)o.push([e,n,t]);const a=async([n,r,o],a)=>{const l=e.addEntity(),c=await(async(e,t,n,r,i)=>{const s=performance.now(),o=`Terrain - ${n[0]}, ${n[1]}, ${n[2]}`,a=(e=>{const t=Math.ceil(Math.log2(Math.max(...e)));let n=0;for(let e=0;e<=t;e++)n+=1<<3*e;return n})(r)*Ll.ps;let l=new SharedArrayBuffer(a);const c=await i(n,r,l);if(c<=16)return;await e.addVolume(o,r,l,c),l=null;const{size:u,location:h,paletteIndex:d,octreeOffset:p}=e.dictionary[o],f=performance.now();return Fl.push(f-s),ql.time=Fl.reduce(((e,t)=>e+t),0)/Fl.length,ql.time=Math.round(ql.time),new ir({name:o,size:u,atlasLocation:h,paletteIndex:d,octreeBufferIndex:p})})(t,0,[n,r,o],[Wl,Wl,Wl],s[a].createOctreeAndReturnBytes);if(!c)return a;e.addComponent(l,new ir(c));const u=new rr([n,r-128,o],i.Yu.fromEuler(0,0,0,"xyz"),[0,0,0]);return Ye((e=>{u.scale=[e,e,e],u.position=[n,r-128*(1-e),o]}),{duration:1,easing:Gl({damping:100})}),e.addComponent(l,u),a};let l=[];for(;o.length>0;){if(l.length<$l){const[e,t,n]=o.shift(),r=l.length;l[r]=a([e,t,n],r);continue}const e=await Promise.race(l);l[e]=a(o.shift(),e)}await Promise.all(l),r.forEach((e=>e.terminate()))})(this.ecs),this.isInitialized=!0))}}),Hl.addSystem(new class extends t{componentsRequired=new Set([rr,xi]);update(e,t,n){for(const t of e){const e=this.ecs.getComponents(t),r=e.get(rr),s=e.get(xi),o=i.eR.mulScalar(s.velocity,n);r.position=i.eR.add(r.position,o),r.rotation=i.Yu.mul(r.rotation,s.angularVelocity)}}});const Yl=Hl.addEntity();Hl.addComponent(Yl,new mi),Hl.addComponent(Yl,new Ol),Hl.addComponent(Yl,new Dl);const Xl=Hl.addEntity();Hl.addComponents(Xl,new ai({fieldOfView:Math.PI/180*70,near:.5,far:1e4}),new rr(i.eR.create(-48,64,-48),i.Yu.fromEuler(0,Math.PI/180*45,0,"xyz"),i.eR.create(1,1,1)),new yi,new Ul,new xi);const Zl=()=>{Hl.update(performance.now()),requestAnimationFrame(Zl)};Zl()})()})();